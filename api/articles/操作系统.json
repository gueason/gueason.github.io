{"title":"操作系统408（搬运）","uid":"8a3e3c56ca704c10863ee2d485165156","slug":"操作系统","date":"2024-09-01T00:00:00.000Z","updated":"2024-09-27T12:39:16.558Z","comments":true,"path":"api/articles/操作系统.json","keywords":null,"cover":[],"content":"<p>参考与转载链接</p>\n<p><a href=\"https://www.cnblogs.com/zhaoyiyang/articles/17816903.html#13-操作系统运行环境\">【王道】操作系统 知识点总结（合集）【超详细！】 - Zyyyyyyyyy - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_48024605/category_12433552.html\">王道操作系统知识点总结_住在天上的云的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43914604/article/details/104415990\">《王道操作系统》学习笔记总目录+思维导图_王道操作系统思维导图-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/cxuanBlog/p/13297199.html\">5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园 (cnblogs.com)</a></p>\n<p>OS整理+代码实例</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/520711525\">一篇就学会操作系统（最全操作系统笔记总结） - 知乎 (zhihu.com)</a></p>\n<h1 id=\"一、操作系统概论\"><a href=\"#一、操作系统概论\" class=\"headerlink\" title=\"一、操作系统概论\"></a>一、操作系统概论</h1><h2 id=\"1-1基本概念\"><a href=\"#1-1基本概念\" class=\"headerlink\" title=\"1.1基本概念\"></a>1.1基本概念</h2><p>操作系统提供了几种抽象模型</p>\n<ul>\n<li>文件：对 I/O 设备的抽象</li>\n<li>虚拟内存：对程序存储器的抽象</li>\n<li>进程：对一个正在运行程序的抽象</li>\n<li>虚拟机：对整个操作系统的抽象</li>\n</ul>\n<p>现代计算机硬件系统由<strong>一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</strong>。在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 <code>操作系统</code>。它控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；操作系统相当于是一个中间层，以提供给用户和其他软件方便的接口和环境，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</p>\n<p><img src=\"../img/1515111-20200714084605556-1013677777.png\" alt=\"img\"></p>\n<p>大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p>\n<p><strong>功能：</strong></p>\n<p><img src=\"../img/89535ad88c1a0d0d93c4918d687576fc.png\" alt=\"在这里插入图片描述\" style=\"zoom:150%;\" /></p>\n<ul>\n<li><strong>处理机管理</strong></li>\n</ul>\n<p>​        即<strong>对进程的管理</strong>，包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n<ul>\n<li><p><strong>存储器管理</strong></p>\n<p>方便程序运行、用户使用及提高内存的利用率，包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p>\n</li>\n<li><p><strong>文件管理</strong></p>\n<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为<strong>文件系统</strong>。</p>\n<p>文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>\n</li>\n<li><p><strong>设备管理</strong></p>\n<p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>命令接口</strong></p>\n<p><strong>用户</strong>利用这些操作命令来组织和控制作业的执行。</p>\n</li>\n</ul>\n<p>  <strong>联机命令接口</strong>：即交互式命令接口，适用于分时或实时系统。</p>\n<p>  “雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p>\n<p>  <strong>脱机命令接口</strong>：即批处理命令接口，适用于批处理系统</p>\n<p>  “雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p>\n<ul>\n<li><p><strong>程序接口</strong></p>\n<p>程序接口由一组<strong>系统调用</strong>（也称广义指令）组成。是为编程人员提供的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。</p>\n<p>用户通过在程序中使用<strong>系统调用命令</strong>请求OS为其提供服务。系统调用命令又称广义指令。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>GUl：图形化用户接口</strong>（Graphical User Interface）</p>\n<p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>裸机</strong>：没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础。</p>\n<p>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方         便的机器。</p>\n</li>\n</ul>\n<p>​       通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>\n<h2 id=\"1-2特征\"><a href=\"#1-2特征\" class=\"headerlink\" title=\"1.2特征\"></a>1.2特征</h2><p><strong>并发</strong></p>\n<p>并发指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生的，但微观上是交替发生</strong>的。</p>\n<p>OS的并发性是通过分时实现的。</p>\n<ul>\n<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</li>\n<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>\n</ul>\n<p><strong>并发性</strong>：两个或多个事件在同一时间间隔内发生。</p>\n<p><strong>并行性</strong>：两个或多个事件在同一时刻发生，需要硬件支持，如多流水线或多处理机硬件环境。</p>\n<p>多道程序环境下，一段时间，宏观上，多道程序同时执行某一时刻，单处理机环境下实际仅有一道程序执行，微观上程序分时交替执行</p>\n<p><strong>共享</strong></p>\n<p>共享即资源共享，是指系统中的资源可供内存中<strong>多个并发执行的进程</strong>共同使用。</p>\n<ul>\n<li><p><strong>互斥共享</strong>：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p>\n<p>临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享</p>\n<p>应用：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>同时共享</strong>：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。</p>\n<p>分时共享：宏观上“同时”，微观上交替地对该资源进行访问</p>\n<p>应用：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>\n</li>\n</ul>\n<p>​      </p>\n<p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p>\n<ul>\n<li><p>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；</p>\n</li>\n<li><p>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p>\n</li>\n</ul>\n<p><strong>虚拟</strong></p>\n<p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>\n<ul>\n<li><p><strong>虚拟处理器</strong>：通过<strong>时分复用</strong>技术，让多道程序并发执行的方法，来分时使用一个处理器的。</p>\n<p>虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。</p>\n</li>\n<li><p><strong>虚拟存储器</strong>：通过<strong>空分复用</strong>技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。</p>\n</li>\n<li><p><strong>虚拟I/O设备</strong>：采用虚拟设备技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的<strong>共享设备</strong>。</p>\n</li>\n</ul>\n<p><strong>异步</strong></p>\n<p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是<strong>进程的异步性</strong>。</p>\n<p>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</p>\n<h2 id=\"1-3分类与发展\"><a href=\"#1-3分类与发展\" class=\"headerlink\" title=\"1.3分类与发展\"></a>1.3分类与发展</h2><p><img src=\"../img/ad183ededa4700f307f802538f8278f3.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"../img/7d9e2df707bcccbf01aa641b719e58de.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>单道批处理系统</strong>：引入脱机输入输出技术</p>\n<ul>\n<li><p><strong>特征</strong>：</p>\n<p><strong>自动性</strong>。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</p>\n<p><strong>顺序性</strong>。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</p>\n<p><strong>单道性</strong>。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p>\n</li>\n<li><p><strong>优点</strong>：缓解人机速度矛盾。</p>\n</li>\n<li><p><strong>缺点</strong>：资源利用率仍低，高速CPU等待低速I/O。</p>\n</li>\n</ul>\n<p><strong>多道批处理系统</strong>：多道程序设计技术操作系统开始出现</p>\n<p><strong>多道程序设计</strong>：允许<strong>多个程序同时进入内存</strong>并允许它们<strong>在CPU中交替地运行</strong>，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>\n<ul>\n<li><p><strong>特点</strong>：</p>\n<p><strong>多道</strong>：计算机内存中同时存放多道相互独立的程序。</p>\n<p><strong>宏观上并行</strong>：同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</p>\n<p><strong>微观上串行</strong>：内存中的多道程序轮流占有CPU，交替执行。</p>\n<p><strong>间断性</strong>：由于多道程序之间需要共享和竞争系统资源，因此每个程序的执行过程不是连续的，而是有间断的。</p>\n<p><strong>共享性</strong>：多道程序之间需要共享系统的各种资源，如CPU、内存、外设等。</p>\n<p><strong>制约性</strong>：多道程序之间存在相互制约的关系，如同步、互斥、优先级等。</p>\n</li>\n<li><p><strong>优点</strong>：</p>\n<p>资源利用率高，多道程序并发执行，共享计算机资源</p>\n<p>系统吞叶量大，CPU和其他资源保持”忙碌”</p>\n</li>\n<li><p><strong>缺点</strong>：用户响应时间长、无人机交互能力</p>\n</li>\n</ul>\n<p><strong>分时操作系统</strong></p>\n<p><strong>分时技术</strong>：计算机以<strong>时间片为单位轮流</strong>为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p>\n<p>多个用户通过终端同时共享一台主机，用户可以同时与主机进行交互操作而互不干扰。</p>\n<ul>\n<li><p><strong>特点</strong></p>\n<p><strong>同时性</strong>。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</p>\n<p><strong>交互性</strong>。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</p>\n<p><strong>独立性</strong>。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</p>\n<p><strong>及时性</strong>。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</p>\n</li>\n<li><p>优点</p>\n<p>用户请求可以被即时响应，解决了人机交互问题。</p>\n<p>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>\n</li>\n<li><p>缺点：无法优先处理紧急任务</p>\n</li>\n</ul>\n<p><strong>实时操作系统</strong></p>\n<p>能在某个时间限制内完成某些紧急任务而不需要时间片排队。</p>\n<ul>\n<li><p>分类：</p>\n<p><strong>软实时系统：</strong>能够接受偶尔违反时间规定且不会引起永久性的损害。</p>\n<p>如飞机订票系统、银行管理系统。</p>\n<p><strong>硬实时系统：</strong>某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p>\n<p>如飞行器的飞行自动控制系统。</p>\n</li>\n<li><p>特点</p>\n<p>及时性</p>\n<p>可靠性</p>\n</li>\n<li><p>优点：能够优先处理紧急任务</p>\n</li>\n</ul>\n<p><strong>网络操作系统</strong></p>\n<p>把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。</p>\n<ul>\n<li><p>特点</p>\n<p>网络中各种资源的共享</p>\n<p>各台计算机之间的通信</p>\n</li>\n<li><p>分布式计算机系统：由多台计算机组成并满足下列条件的系统，主要特点是分布性和并行性。</p>\n<p>系统中任意两台计算机通过通信方式交换信息</p>\n<p>系统中的每台计算机都具有同等的地位，即没有主机也没有从机</p>\n<p>每台计算机上的资源为所有用户共享</p>\n<p>系统中的任意台计算机都可以构成一个子系统，并且还能重构</p>\n<p>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成</p>\n</li>\n<li><p>分布式操作系统与网络操作系统的本质不同：分布式操作系统中的若干计算机<strong>相互协同完成同一任务</strong>。</p>\n</li>\n</ul>\n<h2 id=\"1-4体系结构\"><a href=\"#1-4体系结构\" class=\"headerlink\" title=\"1.4体系结构\"></a>1.4体系结构</h2><p><img src=\"../img/794479e71c18cb3ff26c3c42ed61a3c2.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>宏内核</strong></p>\n<p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>\n<p>由于各模块共享信息，因此有很高的性能。</p>\n<p><strong>微内核</strong></p>\n<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>\n<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>\n<h2 id=\"1-5运行机制\"><a href=\"#1-5运行机制\" class=\"headerlink\" title=\"1.5运行机制\"></a>1.5运行机制</h2><ol>\n<li><p>CPU执行两种不同性质的程序：</p>\n<p>操作系统<strong>内核程序</strong>：是用户自编程序的管理者，“管理程序”（即内核程序）要执行一些特权指令。</p>\n<p>用户自编程序：即系统外层的应用程序，或简称“应用程序”，“被管理程序”（即用户自编程序）出于安全考虑不能执行这特权指令。</p>\n</li>\n</ol>\n<ol>\n<li><p>特权指令和非特权指令</p>\n<p><strong>特权指令</strong>：是指不允许用户直接使用的指令，如/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</p>\n<p><strong>非特权指令</strong>：是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。</p>\n</li>\n</ol>\n<ol>\n<li><p>CPU的运行模式</p>\n<p><strong>用户态（目态）</strong>：CPU处于用户态，此时CPU只能执行非特权指令。</p>\n<p><strong>核心态（又称管态、内核态）</strong>：CPU处于核心态，此时CPU可以执行特权指令，切换到用户态的指令也是特权指令。</p>\n<p>应用程序运行在用户态，操作系统内核程序运行在核心态。</p>\n</li>\n</ol>\n<p>   <strong>内核态一&gt;用户态：</strong>执行特权指令，修改PSW（程序状态字寄存器），用二进制位表示，1内核态0用户态</p>\n<p>   <strong>用户态一&gt;内核态：</strong>应用程序向操作系统请求服务时通过使用访管指令，从而产生一个中断事件将操作系统转换为核心态。</p>\n<h2 id=\"1-6中断与异常\"><a href=\"#1-6中断与异常\" class=\"headerlink\" title=\"1.6中断与异常\"></a>1.6中断与异常</h2><p><img src=\"../img/2de5d41d4f3c1927f127fe308ac574a9.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>中断作用</strong></p>\n<p>让操作系统内核强行夺回CPU的控制权；使CPU从用户态变为内核态。</p>\n<p><strong>中断和异常的分类</strong></p>\n<p><strong>异常</strong>：又称内中断，指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。</p>\n<ul>\n<li><p>故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。</p>\n</li>\n<li><p>陷入（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。</p>\n</li>\n<li><p>终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。</p>\n</li>\n</ul>\n<p><strong>中断</strong>：又称外中断，指来自CPU执行指令外部的事件，通常用于信息输入/输出，如I/O中断，时钟中断。</p>\n<ul>\n<li><p>可屏蔽中断：指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</p>\n</li>\n<li><p>不可屏蔽中断：指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。</p>\n</li>\n</ul>\n<p>故障和陷入异常属于<strong>软件中断（程序性异常）</strong>，终止异常（内中断）和外中断属于<strong>硬件中断</strong>。</p>\n<p>异常不能被屏蔽，一旦出现，就应立即处理。</p>\n<p><strong>中断和异常的处理过程</strong></p>\n<ul>\n<li><p>当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号</p>\n</li>\n<li><p>如果检查到外部中断信号，保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）</p>\n</li>\n<li><p>CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。</p>\n</li>\n<li><p>若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i+1条指令继续执行</p>\n<blockquote>\n<p>返回第i+1条指令：由自陷（Trap）引起的内中断；如系统调用。由外部设备引起的外中断，如键盘</p>\n<p>返回第i条指令：由故障（Fault）引起的内中断；如缺页等。</p>\n</blockquote>\n</li>\n<li><p>若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。</p>\n</li>\n</ul>\n<p>通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。</p>\n<h2 id=\"1-7系统调用\"><a href=\"#1-7系统调用\" class=\"headerlink\" title=\"1.7系统调用\"></a>1.7系统调用</h2><p><img src=\"../img/16f90e33adeb20e6b1908a0fa2299c96.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>系统调用和库函数的区别</strong></p>\n<p><img src=\"../img/90d13240e1f1f2ace58996bf118ec42f.png\" alt=\"在这里插入图片描述\"></p>\n<p>系统调用是操作系统提供的接口，允许用户程序请求操作系统服务，如文件操作、进程管理等，通常需要切换到内核模式</p>\n<p>库函数则是开发者在应用层编写的函数，封装了常用的功能，可以直接被程序调用，无需内核模式切换。</p>\n<p><strong>定义</strong></p>\n<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，系统调用可视为特殊的公共子程序。又称<strong>广义指令</strong>。<strong>程序接口</strong>由一组系统调用组成。目的为解决资源分配问题</p>\n<p><strong>分类</strong></p>\n<ul>\n<li><p><strong>设备管理</strong>：完成设备的请求或释放，以及设备启动等功能。</p>\n</li>\n<li><p><strong>文件管理</strong>：完成文件的读、写、创建及删除等功能。</p>\n</li>\n<li><p><strong>进程控制</strong>：完成进程的创建、撤销、阻塞及唤醒等功能。</p>\n</li>\n<li><p><strong>进程通信</strong>：完成进程之间的消息传递或信号传递等功能。</p>\n</li>\n<li><p><strong>内存管理</strong>：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</p>\n</li>\n</ul>\n<p><strong>系统调用过程</strong></p>\n<p>系统调用的处理需要由操作系统内核程序负责完成，要运行在<strong>核心态</strong>。</p>\n<p>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。</p>\n<blockquote>\n<p>访管指令不是特权指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>\n</blockquote>\n<p><strong>系统调用执行过程：</strong></p>\n<p>传递系统调用参数→执行陷入（trap）指令→执行相应的服务程序→返回用户态</p>\n<p><img src=\"https://raw.githubusercontent.com/ZzDarker/figure/main../img/image-20230907104615415.png\" alt=\"image-20230907104615415\"></p>\n<ul>\n<li><p>当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；</p>\n</li>\n<li><p>也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。</p>\n</li>\n<li><p>管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行</p>\n</li>\n</ul>\n<p><img src=\"../img/e06fda511b5f03fdf8ca1c8388237050.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>用户态转向核心态的例子：</strong></p>\n<ul>\n<li>用户程序要求操作系统的服务，即系统调用。</li>\n<li>发生一次中断。</li>\n<li>用户程序中产生了一个错误状态。</li>\n<li>用户程序中企图执行一条特权指令。</li>\n<li><p>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</p>\n</li>\n<li><p><strong>只能在核心态下执行的指令（特权指令）：</strong></p>\n<ul>\n<li>开关中断指令，用于允许或禁止中断，控制中断屏蔽位</li>\n<li>设置时钟日期指令，用于修改系统时钟</li>\n<li>改变存储映像图指令，用于修改主存保护机制</li>\n<li>启动I/O指令，用于控制I/O设备的工作状态和动作</li>\n<li>加载PSW指令，用于修改程序状态字（PSW），包括中断标志位、运算结果标志位等</li>\n<li>置特殊寄存器指令，用于存取中断寄存器、时钟寄存器等特殊寄存器</li>\n<li>停机指令，用于停止一个中央处理器的工作</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p>\n</blockquote>\n<hr>\n<h1 id=\"二、进程管理\"><a href=\"#二、进程管理\" class=\"headerlink\" title=\"二、进程管理\"></a>二、进程管理</h1><h2 id=\"2-1进程与线程\"><a href=\"#2-1进程与线程\" class=\"headerlink\" title=\"2.1进程与线程\"></a>2.1进程与线程</h2><h3 id=\"2-1-1-进程的概念和特征\"><a href=\"#2-1-1-进程的概念和特征\" class=\"headerlink\" title=\"2.1.1 进程的概念和特征\"></a>2.1.1 进程的概念和特征</h3><p>在多道程序处理的系统中，CPU 会在<strong>进程</strong>间快速切换，使每个程序运行几十或者几百毫秒。CPU 瞬间只能运行一个进程，但CPU 执行速度很快，进程间的切换也非常迅速，这样就会让我们产生<strong>并行</strong>的错觉。因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</p>\n<p>一个进程就是一个<strong>正在执行的程序的实例</strong>，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>\n<p>每道程序被抽象为拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>\n<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p>\n<p><img src=\"../img/1515111-20200714084700409-571820975.png\" alt=\"img\"></p>\n<p><strong>进程的概念</strong></p>\n<p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p>\n<blockquote>\n<p>进程实现操作系统的并发性和共享性。</p>\n</blockquote>\n<p>程序：是<strong>静态</strong>的，就是个存放在磁盘里的<strong>可执行文件</strong>，如：QQ.exe。</p>\n<p>进程：是<strong>动态</strong>的，是程序的一次<strong>执行过程</strong>，或者是一个<strong>正在运行的程序</strong>，如：可同时启动多次QQ程序。</p>\n<p>进程实体：即<strong>进程映像</strong>，是<strong>静态</strong>的，可理解为进程的一次时刻的状态。</p>\n<p>作业：用户向计算机提交的一项<strong>任务</strong>，是<strong>静态</strong>的，它通常是一个批处理程序或一个后台程序。</p>\n<p><strong>进程实体的组成</strong></p>\n<p><strong>1.程序控制块PCB(Processing Control Block)</strong></p>\n<p><strong>PCB是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p>\n<p>OS是根据PCB来对并发执行的进程进行控制和管理的， 但凡管理时所需要的信息，都会被放在 PCB 中。</p>\n<p>PCB 存于内存的内核区，注意内存的内核区和 OS 的内核态的区别，内核程序运行在内核态。</p>\n<p>PCB包含的内容：</p>\n<ul>\n<li>进程描述信息<ul>\n<li>进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—PID（Process ID，进程ID）</li>\n<li>用户标识符UID</li>\n</ul>\n</li>\n<li>进程控制和管理信息<ul>\n<li>CPU、磁盘、网络流量使用情况统计…</li>\n<li>进程当前状态：就绪态/阻塞态/运行态.…</li>\n<li>进程优先级，抢占处理机的优先级</li>\n</ul>\n</li>\n<li>资源分配清单<ul>\n<li>程序段指针</li>\n<li>数据段指针</li>\n<li>I/O设备</li>\n</ul>\n</li>\n<li>处理机相关信息（CPU现场信息）：如PSW、PC等等各种寄存器的值（用于实现进程切换）</li>\n</ul>\n<p><strong>2.程序段：</strong>程序的代码（指令序列）</p>\n<p><strong>3.数据段：</strong>运行过程中产生的各种数据（如：程序中定义的变量）</p>\n<blockquote>\n<p>PCB 是给操作系统用的，程序段和数据段是给进程自己用的。</p>\n<p>引入进程实体的概念后，可把进程定义为是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>\n</blockquote>\n<p><strong>进程的特征</strong></p>\n<ul>\n<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征。</li>\n<li>并发性：内存中有多个进程实体，各进程可<strong>并发执行</strong></li>\n<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>\n<li>异步性：各进程按<strong>各自独立的</strong>、不可预知的速度向前推进，异步性会导致并发程序执行结果的不确定性。</li>\n<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>\n</ul>\n<h3 id=\"2-1-2-进程的状态与转换\"><a href=\"#2-1-2-进程的状态与转换\" class=\"headerlink\" title=\"2.1.2 进程的状态与转换\"></a>2.1.2 进程的状态与转换</h3><p><strong>基本状态</strong></p>\n<ul>\n<li><p><strong>运行态</strong>。占有CPU，并在CPU上运行；有其他所需资源</p>\n<p>单核处理机环境每个时刻只有一个进程处于运行态</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>就绪态</strong>。已具有运行条件，但无空闲CPU，暂时不能运行；有其他所需资源</p>\n<p>系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>阻塞态</strong>，又称等待态。因等待某一事件暂时不能运行；无其他所需资源</p>\n<p>系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>创建态</strong>。进程正在被创建，尚未转到就绪态。OS为进程分配系统资源、初始化PCB</p>\n<ul>\n<li>首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息</li>\n<li>然后为该进程分配运行时所必须的资源</li>\n<li>最后把该进程转入就绪态并插入就绪队列</li>\n</ul>\n<p>但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</p>\n</li>\n</ul>\n<ul>\n<li><strong>终止态</strong>。进程正从系统中消失，进程正常结束或其他原因退出运行。OS回收进程拥有的资源，撤销PCB</li>\n</ul>\n<p><strong>进程状态的转换</strong></p>\n<p><img src=\"../img/3308e10c1180a81ae5504e93f93f4ce0.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>就绪态一&gt;运行态：进程被调度</p>\n</li>\n<li><p>运行态一&gt;就绪态：时间片到 or CPU被其他进程抢占</p>\n</li>\n<li><p>运行态一&gt;阻塞态：等待系统资源分配or等待某事件发生（主动行为）</p>\n</li>\n<li><p>阻塞态一&gt;就绪态：资源分配到位，等待的事件发生（被动行为）</p>\n</li>\n<li><p>创建态一&gt;就绪态：系统完成创建进程相关的工作</p>\n</li>\n<li><p>运行态一&gt;终止态：进程运行结束 or 运行过程中遇到不可修复的错误</p>\n</li>\n</ul>\n<h3 id=\"2-1-3进程的组织方式\"><a href=\"#2-1-3进程的组织方式\" class=\"headerlink\" title=\"2.1.3进程的组织方式\"></a>2.1.3进程的组织方式</h3><p><strong>链接方式</strong></p>\n<p>链接方式是将同一状态的进程的PCB组成一个双向链表，称为进程队列。</p>\n<ul>\n<li><p>结构：每个队列的队首和队尾都有一个指针，指向第一个和最后一个PCB。每个PCB中也有两个指针，分别指向前一个和后一个PCB。这样，就可以方便地在队列中插入或删除PCB。</p>\n</li>\n<li><p>优点：简单、灵活</p>\n</li>\n<li><p>缺点：查找效率低，需要遍历链表</p>\n<p><img src=\"../img/8c3ded9dad84f036564517dd04955a02.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p><strong>索引方式</strong></p>\n<p>索引方式是将所有的PCB存放在一张索引表中，每个表项包含一个PCB的地址和状态信息。</p>\n<ul>\n<li>结构：索引表可以是顺序表或散列表，可以按照进程号或其他关键字进行排序或散列。</li>\n<li>优点：查找效率高，可以快速定位到某个PCB</li>\n<li>缺点：需要额外的空间存储索引表，且索引表的大小受限于内存容量</li>\n</ul>\n<p><img src=\"../img/221920196b8a801c04b3dff307674478.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-1-4进程的控制\"><a href=\"#2-1-4进程的控制\" class=\"headerlink\" title=\"2.1.4进程的控制\"></a>2.1.4进程的控制</h3><p><strong>创建进程的方式</strong></p>\n<ul>\n<li>系统初始化（init）：启动操作系统时，通常会创建若干个进程。</li>\n<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>\n<li>用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</li>\n<li>初始化一个批处理工作</li>\n</ul>\n<p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p>\n<p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的<code>内存映像</code>，相同的环境字符串和相同的打开文件。</p>\n<p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。<strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p>\n<p>进程控制就是要实现进程状态的转换，通过原语实现。原语不允许被中断（原子操作）。</p>\n<p><strong>进程的创建过程</strong></p>\n<ul>\n<li><p>创建原语：操作系统创建一个进程时使用的原语，其操作如下；创建态→就绪态</p>\n<ul>\n<li>申请空白PCB</li>\n<li>为新进程分配所需资源</li>\n<li>初始化PCB</li>\n<li>将PCB插入就绪队列</li>\n</ul>\n</li>\n<li><p>引起进程创建的事件</p>\n<ul>\n<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>\n<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>\n<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>\n<li>应用请求：由用户进程主动请求创建一个子进程</li>\n</ul>\n</li>\n<li><p>父子进程</p>\n<p>允许一个进程创建另一个进程，此时创建者称为<strong>父进程</strong>，被创建的进程称为<strong>子进程</strong>。</p>\n<ul>\n<li>进程可以继承父进程所拥有的资源。</li>\n<li>当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。</li>\n<li>在撤销父进程时，通常也会同时撤销其所有的子进程。</li>\n</ul>\n</li>\n</ul>\n<p><strong>进程的终止原因</strong></p>\n<p>进程早晚会发生终止，但是通常是由于以下情况触发的</p>\n<ul>\n<li><code>正常退出(自愿的)</code> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。</li>\n<li><code>错误退出(自愿的)</code>：比如执行一条不存在的命令，于是编译器就会提醒并退出。</li>\n<li><code>严重错误(非自愿的)</code></li>\n<li><code>被其他进程杀死(非自愿的)</code> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</li>\n</ul>\n<p><strong>进程的终止过程</strong></p>\n<ul>\n<li><p>撤销原语：其操作如下；</p>\n<p>就绪态/阻塞态/运行态→终止态→无</p>\n<ul>\n<li>从PCB集合中找到终止进程的PCB</li>\n<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>\n<li>终止其所有子进程</li>\n<li>将该进程拥有的所有资源归还给父进程或操作系统</li>\n<li>删除PCB</li>\n</ul>\n</li>\n<li><p>引起进程终止的事件</p>\n<ul>\n<li>正常结束：进程自已请求终止（exit系统调用）</li>\n<li>异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉</li>\n<li>外界干预：Ctrl+Alt+delete，用户选择杀掉进程</li>\n</ul>\n</li>\n</ul>\n<p><strong>进程的阻塞</strong></p>\n<ul>\n<li><p>阻塞原语：其操作如下；</p>\n<p>运行态→阻塞态</p>\n<ul>\n<li>找到要阻塞的进程对应的PCB</li>\n<li>保护进程运行现场，将PCB状态信息设置为“阻塞态，暂时停止进程运行</li>\n<li>将PCB插入相应事件的等待队列</li>\n</ul>\n</li>\n<li><p>引起进程阻塞的事件</p>\n<ul>\n<li>需要等待系统分配某种资源</li>\n<li>需要等待相互合作的其他进程完成工作</li>\n</ul>\n</li>\n</ul>\n<p><strong>进程的唤醒</strong></p>\n<ul>\n<li><p>唤醒原语：其操作如下；</p>\n<p>阻塞态→就绪态</p>\n<ul>\n<li>在事件等待队列中找到PCB</li>\n<li>将PCB从等待队列移除，设置进程为就绪态</li>\n<li>将PCB插入就绪队列，等待被调度</li>\n</ul>\n</li>\n<li><p>引起进程唤醒的事件</p>\n<ul>\n<li>等待的事件发生：因何事阻塞，就应由何事唤醒</li>\n</ul>\n</li>\n</ul>\n<p>阻塞原语唤醒原语必须成对使用</p>\n<p><strong>进程的切换</strong></p>\n<ul>\n<li><p>切换原语：其操作如下；</p>\n<p>运行态→就绪态，就绪态→运行态</p>\n<ul>\n<li>将运行环境信息存入PCB</li>\n<li>PCB移入相应队列选择</li>\n<li>另一个进程执行，并更新其PCB</li>\n<li>根据PCB恢复新进程所需的运行环境</li>\n</ul>\n</li>\n<li><p>引起进程切换的事件</p>\n<ul>\n<li>当前进程时间片到</li>\n<li>有更高优先级的进程到达</li>\n<li>当前进程主动阻塞</li>\n<li>当前进程终止</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../img/76c7d6eeb9d69df8b3291165d129152a-172697781104022.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>调度</strong>是指决定资源分配给哪个进程的行为，是一种决策行为<br><strong>切换</strong>是指实际分配的行为，是执行行为<br>一般来说现有资源调度，后有进程切换</p>\n<h3 id=\"2-1-5进程的实现\"><a href=\"#2-1-5进程的实现\" class=\"headerlink\" title=\"2.1.5进程的实现\"></a>2.1.5进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</p>\n<p>下面展示了一个典型系统中的关键字段</p>\n<p><img src=\"../img/1515111-20200714084727554-570767453.png\" alt=\"img\"></p>\n<p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p>\n<p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p>\n<p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p>\n<ol>\n<li>硬件压入堆栈程序计数器等</li>\n<li>硬件从中断向量装入新的程序计数器</li>\n<li>汇编语言过程保存寄存器的值</li>\n<li>汇编语言过程设置新的堆栈</li>\n<li>C 中断服务器运行（典型的读和缓存写入）</li>\n<li>调度器决定下面哪个程序先运行</li>\n<li>C 过程返回至汇编代码</li>\n<li>汇编语言过程开始运行新的当前进程</li>\n</ol>\n<p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>\n<h3 id=\"2-1-6进程的通信\"><a href=\"#2-1-6进程的通信\" class=\"headerlink\" title=\"2.1.6进程的通信\"></a>2.1.6进程的通信</h3><p><strong>低级通信方式</strong>：PV操作。<strong>高级通信方式</strong>：共享存储、消息传递、管道通信。</p>\n<p><strong>1.共享存储</strong></p>\n<p>设置一个共享空间进行读/写操作实现信息交换，一次只能有一个进程进行读或写操作</p>\n<p>在对共享空间进行写/读操作时，需要使用同步互斥工具（如PV操作）。</p>\n<p><img src=\"../img/image-20240922121126235.png\" alt=\"image-20240922121126235\" style=\"zoom:67%;\" /></p>\n<p>共享存储分为两种：</p>\n<ul>\n<li><p>低级方式：基于数据结构的共享</p>\n<p>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>\n</li>\n<li><p>高级方式：基于存储区的共享</p>\n<p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。</p>\n</li>\n</ul>\n<blockquote>\n<p>进程之间共享空间需要通过特殊的系统调用实现；进程内线程共享进程空间。</p>\n</blockquote>\n<p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p>\n<ul>\n<li>创建共享内存段或者使用已创建的共享内存段<code>(shmget())</code></li>\n<li>将进程附加到已经创建的内存段中<code>(shmat())</code></li>\n<li>从已连接的共享内存段分离进程<code>(shmdt())</code></li>\n<li>对共享内存段执行控制操作<code>(shmctl())</code></li>\n</ul>\n<p><strong>2.消息传递</strong></p>\n<p>在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。</p>\n<p><img src=\"../img/c986453f10b9a1e91c762efa170fed0b.png\" alt=\"在这里插入图片描述\"></p>\n<p>进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p>\n<blockquote>\n<p>在<strong>微内核操作系统</strong>中，微内核与服务器之间的通信就采用了消息传递机制。</p>\n</blockquote>\n<p><strong>消息格式</strong>：</p>\n<ul>\n<li>消息头：发送进程ID、接受进程ID、消息长度等格式化的信息</li>\n<li>消息体</li>\n</ul>\n<p><strong>通信方式</strong>：</p>\n<ul>\n<li><p><strong>直接通信方式</strong>：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p>\n</li>\n<li><p><strong>间接通信方式</strong>：送进程通过信箱间接地通信，将消息发送到某个中间实体，接收进程从中间实体取得消息。该通信方式广泛应用于计算机网络中。</p>\n<blockquote>\n<p>注：可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱中 receive 消息。</p>\n<p>用发送原语和接收原语实现基于信箱的进程间通信</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>3.管道通信</strong></p>\n<p>管道是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。</p>\n<p>一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的<code>管线 pipelines</code> 就是用管道实现的，当 shell 发现输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort &lt;f | head</span><br></pre></td></tr></table></figure>\n<p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p>\n<p>管道实际上就是 <code>|</code>，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p>\n<p><img src=\"../img/image-20240922121513539.png\" alt=\"image-20240922121513539\"></p>\n<p>管道通信允许两个进程按生产者-消费者方式进行通信。各进程要互斥访问管道。</p>\n<ul>\n<li>写满时，不能再写，读空时，不能再读</li>\n<li>没写满时，不能读，没读空时，不能写</li>\n</ul>\n<blockquote>\n<p>一个管道只能实现半双工通信；实现<strong>双向同时通信</strong>要建立两个管道</p>\n</blockquote>\n<p>管道本质上是一种特殊的文件。相比于普通的文件通信，其区别如下：</p>\n<ul>\n<li><p><strong>限制管道的大小</strong>。管道文件是一个固定大小的缓冲区，使得它的大小不像普通文件那样不加检验地增长。</p>\n</li>\n<li><p><strong>读进程也可能工作得比写进程快</strong>。读空时再读管道会被阻塞，而不是调用返回文件结束。</p>\n</li>\n</ul>\n<p><strong>管道中的数据一旦被读出，就彻底消失。</strong>因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：</p>\n<ul>\n<li><p>一个管道允许多个写进程，一个读进程</p>\n</li>\n<li><p>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据</p>\n</li>\n</ul>\n<p>管道只能由<strong>创建进程</strong>所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进进行通信。</p>\n<h3 id=\"2-1-7线程和多线程模型\"><a href=\"#2-1-7线程和多线程模型\" class=\"headerlink\" title=\"2.1.7线程和多线程模型\"></a>2.1.7线程和多线程模型</h3><p><strong>1.线程的基本概念</strong></p>\n<p>线程可理解为轻量级进程，它是一个基本的CPU执行单元，也是程序执行流的最小单位。</p>\n<p>线程由线程ID、程序计数器、寄存器集合和堆栈组成。</p>\n<blockquote>\n<p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</p>\n<p>而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>\n</blockquote>\n<p>引入线程后，<strong>进程</strong>只作为除CPU外的系统资源的分配单位，线程则作为处理机的分配单元</p>\n<p>引入线程的原因：</p>\n<ul>\n<li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li>\n<li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li>\n<li>第三个原因是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li>\n</ul>\n<p><strong>2.进程（Process）与线程（Thread）比较</strong></p>\n<p>进程：系统进行<strong>资源分配和调度的基本单位</strong>。</p>\n<p>线程：操作系统进行<strong>运行调度的最小单位</strong>。</p>\n<p>区别与联系：</p>\n<ul>\n<li>一个进程可以有一个或多个线程</li>\n<li>线程包含在进程之中，是进程中实际运行工作的单位</li>\n<li>进程的线程共享进程资源</li>\n<li>一个进程可以并发多个线程，每个线程执行不同的任务。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">传统进程机制</th>\n<th style=\"text-align:center\"><strong>引入线程后</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">资源分配、调度</td>\n<td style=\"text-align:center\">进程是资源分配、调度基本单位</td>\n<td style=\"text-align:center\">进程是资源分配基本单位线程是资源调度基本单位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">并发性</td>\n<td style=\"text-align:center\">进程间并发</td>\n<td style=\"text-align:center\">线程间也能并发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">拥有资源</td>\n<td style=\"text-align:center\">拥有资源的基本单位</td>\n<td style=\"text-align:center\">不拥有系统资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">独立性</td>\n<td style=\"text-align:center\">进程间独立地址空间和资源</td>\n<td style=\"text-align:center\">同进程下的线程共享地址空间和资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">系统开销</td>\n<td style=\"text-align:center\">需要切换进程运行环境，开销大</td>\n<td style=\"text-align:center\">同一进程内线程，不需切换进程环境，开销小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">支持多处理机系统</td>\n<td style=\"text-align:center\">进程只能运行在一个处理机上</td>\n<td style=\"text-align:center\">进程中多个线程可以分配到多个处理机执行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p>\n<p><img src=\"../img/1515111-20200714084818042-1795260872.png\" alt=\"img\"></p>\n<p>上图左边的是同一个进程中<code>每个线程共享</code>的内容，上图右边是<code>每个线程</code>中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p>\n<p><strong>3.线程的属性</strong></p>\n<p>多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。</p>\n<ul>\n<li>线程是处理机调度的单位</li>\n<li>多CPU计算机中，各个线程可占用不同的CPU</li>\n<li>每个线程都有一个线程ID、线程控制块（TCB）</li>\n<li>线程也有就绪、阻塞、运行三种基本状态</li>\n<li>线程几乎不拥有系统资源</li>\n<li>同一进程的不同线程间共享进程的资源</li>\n<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>\n<li>同一进程中的线程切换，不会引起进程切换</li>\n<li>不同进程中的线程切换，会引起进程切换</li>\n<li>切换同进程内的线程，系统开销很小</li>\n<li>切换进程，系统开销较大</li>\n</ul>\n<blockquote>\n<p>注：线程是处理机调度的单位，这里的线程指的是 操作系统看得见的内核级线程，<strong>内核级线程是处理机分配的单位</strong> 。</p>\n<p>同进程的线程之间可以共享进程的代码段、全局变量、打开的文件，不共享线程各自的栈指针等TCB内容</p>\n</blockquote>\n<p><strong>4.线程的实现方式</strong></p>\n<p>线程的实现可以分为两类：用户级线程 和 内核级线程。内核级线程又称内核支持的线程。</p>\n<ul>\n<li><p><strong>用户级线程</strong>(User-Level Thread,UTL)</p>\n<p>在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在<strong>用户空间</strong>中完成，内核意识不到线程的存在，因此说用户级线程对操作系统透明。</p>\n<p><img src=\"../img/562c201b1824dd47bfd32acdeb5ec8f8.png\" alt=\"image-20230908111610008\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li>\n<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li>\n<li>在<strong>用户</strong>看来，是有多个线程。但是在<strong>操作系统内核</strong>看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程</li>\n</ul>\n<blockquote>\n<p>若系统中只有用户级线程，则处理机的调度对象是进程</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p><strong>内核级线程</strong>(Kernel-Level Thread, KTL)</p>\n<p>内核级线程是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。</p>\n<p><img src=\"../img/d97b878c230aad3d758d9c6a061cdce9.png\" alt=\"image-20230908112224737\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>内核级线程的管理工作由操作系统内核完成。</li>\n<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>\n<li>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块）通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">用户级线程</th>\n<th style=\"text-align:center\">内核级线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">线程的管理工作</td>\n<td style=\"text-align:center\">由 应用程序 通过线程库实现所有的线程管理工作 包括线程切换</td>\n<td style=\"text-align:center\">线程管理工作由 操作系统内核完成</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">线程切换是否需要 CPU 变态</td>\n<td style=\"text-align:center\">用户级线程切换 可以在用户态下即可完成<br />无需操作系统干预</td>\n<td style=\"text-align:center\">线程调度、切换等工作都由内核负责<br />内核级线程的切换必然需要在核心态下才能完成。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">OS 是否能意识到用户级线程的存在</td>\n<td style=\"text-align:center\">OS 内核意识不到用户级线程的存在 <br />用户级线程就是从用户视角看能看到的线程</td>\n<td style=\"text-align:center\">OS 会为每个内核级线程建立相应的 TCB（线程控制块）<br />通过TCB对线程进行管理<br />内核级线程就是从操作系统内核视角看能看到的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">优点</td>\n<td style=\"text-align:center\">用户级线程的切换在用户空间即可完成<br />不需要切换到核心态<br />线程管理的系统开销小，效率高</td>\n<td style=\"text-align:center\">当一个线程被阻塞后，其他线程还可以继续执行<br />并发能力强,多线程可在多核处理机上并行执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">缺点</td>\n<td style=\"text-align:center\">当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高<br />因为进程是处理机调度的基本单位，同一进程的多个线程不可在多核处理机上并行运行</td>\n<td style=\"text-align:center\">一个用户进程会占用多个内核级线程<br />线程切换由操作系统内核完成<br />需要切换到核心态，因此线程管理的开销大，效率低，成本高</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>组合方式</strong></p>\n<p>有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。</p>\n<p><img src=\"../img/0c57b04b7d04da89cc42d4389248f19c.png\" alt=\"image-20230908113303239\"></p>\n<ul>\n<li>一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。</li>\n<li>同一进程中的多个线程可以同时在多处理机上并行执行，</li>\n<li><p>且在阻塞一个线程时不需要将整个进程阻塞，</p>\n</li>\n<li><p>线程库</p>\n<p>线程库是为程序员提供创建和管理线程的API。实现方式有以下两种。</p>\n<ul>\n<li>在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。</li>\n<li>实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../img/c9096e19636f72626a97a3cfa3e98662.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>5.多线程模型</strong></p>\n<ul>\n<li><p>一对一模型</p>\n<p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。（内核级线程优点）</p>\n</li>\n<li><p><strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。（内核级线程缺点）</p>\n<p><img src=\"../img/image-20240922173032229.png\" alt=\"image-20240922173032229\" style=\"zoom:67%;\" /></p>\n</li>\n</ul>\n<ul>\n<li><p>多对一模型</p>\n<p>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高（用户级线程优点）</p>\n</li>\n<li><p><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行（用户级线程缺点）</p>\n</li>\n</ul>\n<ul>\n<li><p>多对多模型</p>\n<p>n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p>\n<p><img src=\"../img/4698888201d154fff87804c7c0741520.png\" alt=\"image-20230908113844187\" style=\"zoom:67%;\" /></p>\n<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。还拥有上述两种模型各自的优点。</p>\n</li>\n</ul>\n<p><img src=\"../img/81551dfda705db354604abfeda9f6392.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>6.线程的状态与转换</strong></p>\n<p><img src=\"../img/00cce15b4103d3b974177ba27a09ec8f.png\" alt=\"image-20230908114535993\"></p>\n<p><strong>7.线程的组织与控制</strong></p>\n<p><img src=\"../img/0b35fffa3ab8139eaac7cb91712e9c66.png\" alt=\"image-20230908123934054\"></p>\n<ul>\n<li><p>线程控制块</p>\n<p>与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。线程控制块通常包括</p>\n<ul>\n<li>线程标识符</li>\n<li>一组寄存器，包括程序计数器、状态寄存器和通用寄存器</li>\n<li>线程运行状态，用于描述线程正处于何种状态</li>\n<li>优先级</li>\n<li>线程专有存储区，线程切换时用于保存现场等</li>\n<li>堆栈指针，用于过程调用时保存局部变量及返回地址等。</li>\n</ul>\n<p>同一进程中的所有线程都完全共享进程的地址空间和全局变量。</p>\n<p>各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</p>\n</li>\n</ul>\n<ul>\n<li><p>线程的创建</p>\n<p>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。</p>\n<p>在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。</p>\n</li>\n</ul>\n<ul>\n<li><p>线程的终止</p>\n<p>当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。</p>\n<p>但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。</p>\n<p>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</p>\n</li>\n</ul>\n<ul>\n<li><p>线程系统调用</p>\n<p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code>）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p>\n<p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p>\n<p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p>\n</li>\n</ul>\n<h2 id=\"2-2-处理机调度\"><a href=\"#2-2-处理机调度\" class=\"headerlink\" title=\"2.2 处理机调度\"></a>2.2 处理机调度</h2><h3 id=\"2-2-1-调度的概念\"><a href=\"#2-2-1-调度的概念\" class=\"headerlink\" title=\"2.2.1 调度的概念\"></a>2.2.1 调度的概念</h3><p><strong>调度的基本概念</strong></p>\n<p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p>\n<p>处理机调度是<strong>对处理机进行分配</strong>，即从就绪队列中按照一定的算法（公平、高效的原则）去选择一个进程并将处理机分配给它运行，以实现进程<strong>并发</strong>地执行。</p>\n<p><strong>调度的层次</strong></p>\n<p>一个作业从提交开始直到完成，要经历以下三级调度，如下图所示。</p>\n<p><img src=\"../img/69dd12e755b8ecb7636515bf9e90b9fa.png\" alt=\"image-20230911135226560\"></p>\n<ul>\n<li><p><strong>高级调度（作业调度）</strong></p>\n<p>内存空间有限时，无法将用户提交的作业全部放入内存，需要按一定的原则从外存的作业 后备队列 中挑选一个作业调入内存，并创建进程。</p>\n<p>每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</p>\n<blockquote>\n<p>作业：一个具体的任务</p>\n</blockquote>\n<p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p>\n<ul>\n<li>发生频率最低 外存→内存（面向作业）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>中级调度（内存调度）</strong></p>\n<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时，按照某种策略从 挂起队列 中选择合适的进程重新调入内存。</p>\n<blockquote>\n<p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。</p>\n</blockquote>\n<ul>\n<li>外存→内存（面向进程）</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>低级调度（进程调度）</strong></p>\n<p>在内存中的按照某种策略从 就绪队列 中选取一个进程，将处理机分配给它。</p>\n<ul>\n<li>发生频率高 内存→CPU</li>\n</ul>\n</li>\n</ul>\n<p><strong>三级调度的联系</strong></p>\n<ul>\n<li><p>七状态模型</p>\n<p><img src=\"../img/bf99e066db43b35c962dd8beb4c67042.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li>三层调度对比</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\"><strong>任务</strong></th>\n<th style=\"text-align:center\">调度</th>\n<th>频率</th>\n<th style=\"text-align:center\">对进程状态影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">高级调度<br/>（作业调度）</td>\n<td style=\"text-align:center\">从后备队列中选择合适的作业<br/>将其调入内存，并为其创建进程</td>\n<td style=\"text-align:center\">外存→内存<br/>(面向作业)</td>\n<td>最低</td>\n<td style=\"text-align:center\">无→创建态→就绪态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">中级调度<br/>（内存调度）</td>\n<td style=\"text-align:center\">从挂起队列中选择合适的进程<br/>将其数据调回内存</td>\n<td style=\"text-align:center\">外存→内存<br/>（面向进程）</td>\n<td>中等</td>\n<td style=\"text-align:center\">挂起态→就绪态<br/>阻塞挂起→阻塞态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">低级调度<br/>（进程调度）</td>\n<td style=\"text-align:center\">从就绪队列中选择一个进程<br/>为其分配处理机</td>\n<td style=\"text-align:center\">内存→CPU</td>\n<td>最高</td>\n<td style=\"text-align:center\">就绪态→运行态</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-2-2-调度的目标\"><a href=\"#2-2-2-调度的目标\" class=\"headerlink\" title=\"2.2.2 调度的目标\"></a>2.2.2 调度的目标</h3><p> 不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。评价标准如下。</p>\n<ol>\n<li><p><strong>CPU利用率</strong>：指CPU“忙碌”的时间占总时间的比例。</p>\n<script type=\"math/tex; mode=display\">\n利用率=\\frac{忙碌的时间}{总时间}</script></li>\n<li><p><strong>系统吞吐率</strong>：单位时间内完成作业的数量。</p>\n<script type=\"math/tex; mode=display\">\n系统吞吐率=\\frac{总共完成了多少道作业}{总共花了多少时间}</script></li>\n<li><p><strong>周转时间</strong>：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>\n<script type=\"math/tex; mode=display\">\n周转时间=作业完成时间-作业提交时间</script><p><strong>平均周转时间</strong>：指多个作业周转时间的平均值。</p>\n<script type=\"math/tex; mode=display\">\n平均周转时间=\\frac{各个作业周转时间之和}{作业数}</script><p><strong>带权周转时间</strong>：作业周转时间与作业实际运行时间的比值。带权周转时间必然≥1</p>\n<script type=\"math/tex; mode=display\">\n带权周转时间=\\frac{作业周转时间}{作业实际运行时间}=\\frac{作业完成时间-作业提交时间}{作业实际运行时间}</script><p><strong>平均带权周转时间</strong>：多个作业带权周转时间的平均值。</p>\n<script type=\"math/tex; mode=display\">\n平均带权周转时间=\\frac{各个作业带权周转时间之和}{作业数}</script></li>\n<li><p><strong>等待时间</strong></p>\n<p>等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>\n<script type=\"math/tex; mode=display\">\n等待时间=周转时间-运行时间</script><ul>\n<li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和。</li>\n<li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li>\n</ul>\n<p><strong>平均等待时间</strong>：各个进程/作业等待时间的平均值。</p>\n<script type=\"math/tex; mode=display\">\n平均等待时间=\\frac{各个进程/作业等待时间之和}{进程/作业数}</script></li>\n<li><p><strong>响应时间</strong>：从用户提交请求到首次产生响应所用的时间。</p>\n</li>\n</ol>\n<h3 id=\"2-2-3-调度的实现\"><a href=\"#2-2-3-调度的实现\" class=\"headerlink\" title=\"2.2.3 调度的实现\"></a>2.2.3 调度的实现</h3><p><strong>1.调度程序（调度器）</strong></p>\n<p>用于调度和分派CPU 的组件称为调度程序，它通带由三部分组成</p>\n<p><img src=\"../img/ad63dd6b66f21d28bde7ba26e4a6fa42.png\" alt=\"image-20230911150133174\"></p>\n<ul>\n<li><strong>排队器</strong>：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。</li>\n<li><strong>分派器</strong>：依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。</li>\n<li><strong>上下文切换器</strong>：在对处理机进行切换时，会发生两对上下文的切换操作<ul>\n<li>第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；</li>\n<li>第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2.调度的时机</strong></p>\n<ul>\n<li>需要调度<ul>\n<li>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（比如等待IO）</li>\n<li>被动放弃：时间片用完；有更紧急的事情处理（I/O中断）；有更高优先级的进程进入就结队列</li>\n</ul>\n</li>\n<li>不能调度<ul>\n<li>处理中断的过程中</li>\n<li>进程在操作系统内核程序临界区中</li>\n<li>原子操作过程中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>临界资源：</strong>一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>\n<p><strong>临界区：</strong>访问临界资源的那段代码。</p>\n<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>\n</blockquote>\n<p><strong>3.进程调度方式</strong></p>\n<ul>\n<li><p><strong>非剥夺调度方式</strong></p>\n<p>又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，<strong>直到该进程终止或主动要求进入阻塞态。</strong></p>\n<p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>\n</li>\n<li><p><strong>剥夺调度方式</strong></p>\n<p>又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则<strong>立即暂停在执行的进程</strong>，将处理机分配给更重要紧迫的那个进程。</p>\n<p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>\n</li>\n</ul>\n<p><strong>4.进程切换</strong></p>\n<ul>\n<li><p><strong>上下文切换：</strong>切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态。</p>\n<ul>\n<li>对原来运行进程各种数据的保存</li>\n<li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一保存在进程控制块）</li>\n</ul>\n<blockquote>\n<p>上下文：某一时刻CPU寄存器和程序计数器的内容。</p>\n</blockquote>\n</li>\n</ul>\n<p>  切换流程：</p>\n<ul>\n<li><p>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</p>\n</li>\n<li><p>更新PCB信息。</p>\n</li>\n<li><p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>\n</li>\n<li><p>选择另一个进程执行，并更新其PCB。</p>\n</li>\n<li><p>跳转到新进程PCB中的程序计数器所指向的位置执行。</p>\n</li>\n<li><p>恢复处理机上下文。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>上下文切换的消耗</strong></p>\n<p>上下文切换需要消耗大量CPU时间，有些处理器有多个寄存器组，则切换只需改变指针。</p>\n<blockquote>\n<p>进程切换是有<strong>代价</strong>的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>\n</blockquote>\n</li>\n<li><p><strong>上下文切换与模式切换</strong></p>\n<ul>\n<li>模式切换是用户态和内核态之间的切换，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。</li>\n<li>上下文切换切换了进程，只能发生在内核态，它是多任务操作系统中的一个必需的特性。</li>\n</ul>\n</li>\n</ul>\n<p><strong>5.闲逛进程</strong></p>\n<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）</p>\n<p><strong>特性</strong>：</p>\n<ul>\n<li>优先级最低；</li>\n<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>\n<li>能耗低</li>\n</ul>\n<blockquote>\n<p>闲逛进程不需要CPU之外的资源，它不会被阻塞。</p>\n</blockquote>\n<p><strong>6.两种线程的调度</strong></p>\n<ul>\n<li><strong>用户级线程调度</strong>。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</li>\n<li><strong>内核级线程调度</strong>。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li>\n</ul>\n<blockquote>\n<p>用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；</p>\n<p>内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。</p>\n</blockquote>\n<h3 id=\"2-2-4-典型的调度算法\"><a href=\"#2-2-4-典型的调度算法\" class=\"headerlink\" title=\"2.2.4 典型的调度算法\"></a>2.2.4 典型的调度算法</h3><p><strong>先来先服务（FCFS，first-come,first-serverd）</strong></p>\n<ul>\n<li>算法规则：按照作业/进程到达的先后顺序进行服务，当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</li>\n<li>用于作业/进程调度：<ul>\n<li>用于作业调度时，考虑是哪作业先达后备队列；</li>\n<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>\n</ul>\n</li>\n<li>优缺点：<ul>\n<li>优点：公平、算法实现简单，一个单链表记录了所有就绪进程</li>\n<li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，FCFS算法对长作业有利，对短作业来说用户体验不好。</li>\n</ul>\n</li>\n<li>非抢占式的算法；不会导致饥饿</li>\n</ul>\n<p><img src=\"../img/d4d926ad89fdc5f44c3725fab13250b6.png\" alt=\"image-20230911164645302\"></p>\n<p><strong>短作业优先（SJF，Shortest Job First）</strong></p>\n<ul>\n<li><p>算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p>\n</li>\n<li><p>用于作业/进程调度</p>\n<ul>\n<li>即可用于作业调度，也可用于进程调度。</li>\n<li>用于进程调度时为”短进程优先”（SPF，Shortest Process First）</li>\n</ul>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li><p>优点：</p>\n<p>“最短的”平均等待时间、平均周转时间;</p>\n<ul>\n<li>在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少；</li>\n</ul>\n<blockquote>\n<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>\n</blockquote>\n</li>\n<li><p>“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”</p>\n</li>\n<li><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>\n</li>\n</ul>\n</li>\n<li><p>抢占式的算法；会导致饥饿</p>\n<blockquote>\n<p>SJF和SPF是非抢占式的算法。但是也有抢占式的版本：最剩间优先算法（SRTN，Shortest Remaining Time Next）</p>\n<p>每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"../img/d44bb8e01331619a9df5e709a030dc9c.png\" alt=\"image-20230911164811967\"></p>\n<p><strong>高响应比优先（HRRN）</strong></p>\n<ul>\n<li><p>算法思想：要综合考虑作业/进程的等待时间和要求服务的时间</p>\n</li>\n<li><p>算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p>\n<script type=\"math/tex; mode=display\">\n响应比=\\frac{等待时间+要求服务时间}{要求服务时间}</script><p><strong>高响应比优先算法</strong>：非抢占式的调度算法，只有当前运行的进程主动放CPU（常/常成，主动阻塞），需行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</p>\n</li>\n<li><p>用于作业/进程调度：即可用于作业调度，也可用于进程调度</p>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点）；</li>\n<li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li>\n<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>\n</ul>\n</li>\n<li><p>非抢占式的算法；不会导致饥饿</p>\n<blockquote>\n<p>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，计算响应比</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>时间片轮转调度算法（RR）</strong></p>\n<ul>\n<li><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>\n</li>\n<li><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p>\n</li>\n<li><p>用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li>优点：公平；响应快，适用于分时操作系统；</li>\n<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>\n</ul>\n</li>\n<li><p>抢占式的算法；不会导致饥饿</p>\n<blockquote>\n<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>优先级调度算法</strong></p>\n<ul>\n<li><p>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</p>\n</li>\n<li><p>用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中</p>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</li>\n<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>\n</ul>\n</li>\n<li><p>抢占式/非抢占式的算法；会导致饥饿</p>\n<blockquote>\n<p>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p>\n</blockquote>\n</li>\n<li><p>优先级排序</p>\n<p>系统进程优先级高于用户进程</p>\n<p>前台进程优先级高于后台进程</p>\n<p>操作系统更偏好I/O型进程（或称I/O繁忙型进程）</p>\n<blockquote>\n<p>注：与I/O型进程相对的是计算型进程（或称CPU繁忙型程）</p>\n</blockquote>\n</li>\n<li><p>优先级分类：根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p>\n<ul>\n<li>静态优先级：创建进程时确定，之后一直不变</li>\n<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>\n</ul>\n<blockquote>\n<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>多级队列调度算法</strong></p>\n<ul>\n<li>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</li>\n</ul>\n<p><img src=\"../img/6686931b29e72b51c9d75ba7d03178ec.png\" alt=\"image-20230911165310270\"></p>\n<ul>\n<li><p>队列之间可采取固定优先级，或时间片划分</p>\n<ul>\n<li>固定优先级：高优先级空时低优先级进程才能被调度</li>\n<li>时间片划分：如三个队列分配时间50%、40%、10%</li>\n</ul>\n</li>\n<li><p>各队列可采用不同的调度策略，如</p>\n<p>系统进程队列采用优先级调度、交互式队列采用RR、批处理队列采用FCFS</p>\n</li>\n</ul>\n<p><strong>多级反馈队列调度算法</strong></p>\n<p><img src=\"../img/7c9e1f4adb40af04db2aa75b1fd181d0.png\" alt=\"image-20230911165245192\"></p>\n<ul>\n<li><p>算法思想：对其他调度算法的折中权衡</p>\n</li>\n<li><p>算法规则：</p>\n<ul>\n<li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>\n<li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>\n<li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>\n</ul>\n</li>\n<li><p>用于作业/进程调度：用于进程调度</p>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li>对各类型进程相对公平（FCFS的优点）；</li>\n<li>每个新到达的进程都可以很快就得到响应（RR优点）；</li>\n<li>短进程只用较少的时间就可完成（SPF优点）；</li>\n<li>不必实现估程运时间（避用户作假）；</li>\n<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程</li>\n</ul>\n<blockquote>\n<p>拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</p>\n</blockquote>\n</li>\n<li><p>抢占式的算法；会导致饥饿</p>\n<blockquote>\n<p>在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>\n</blockquote>\n</li>\n<li><p>例：</p>\n</li>\n<li><p>(2019年408第27题)系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10ms；就绪队列Q2采用短进程优先调度算法，系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的 CPU 时间分别为 30ms 和 20ms，则进程P1、P2在系统中的平均等待时间为( 15ms )。</p>\n<p><img src=\"../img/35b66ece3d7628525afc9cbe008e64a6.png\" alt=\"img\"></p>\n</li>\n</ul>\n<ul>\n<li>P1等待时间 = P1周转时间 - P1运行时间 = 50-30 = 20ms</li>\n<li>P2等待时间 = P2周转时间 - P2运行时间 = 30-20 = 10ms</li>\n<li>P1、P2在系统中的平均等待时间 = (P1等待时间+P2等待时间)/2 = 15ms</li>\n</ul>\n<p><strong>实时系统中的调度</strong></p>\n<p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p>\n<p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p>\n<p><img src=\"../img/1515111-20200714085118891-1070593363.png\" alt=\"img\"></p>\n<p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p>\n<p><a href=\"https://blog.csdn.net/weixin_43914604/article/details/105328521\">2.2.4 操作系统之作业/进程调度算法（FCFS先来先服务、SJF短作业优先、HRRN高响应比优先）_llf算法-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_43914604/article/details/105333646\">2.2.5 操作系统之调度算法（时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法）_操作系统时间调度表-CSDN博客</a></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><strong>先来先服务</strong></th>\n<th style=\"text-align:center\"><strong>短作业优先</strong></th>\n<th style=\"text-align:center\">高响应比优先</th>\n<th style=\"text-align:center\">时间片轮转</th>\n<th style=\"text-align:center\">多级反馈队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>能否是可抢占</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">队列内算法不一定</td>\n</tr>\n<tr>\n<td>能否是非抢占</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">能</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">队列内算法不一定</td>\n</tr>\n<tr>\n<td>优点</td>\n<td style=\"text-align:center\">公平，实现简单</td>\n<td style=\"text-align:center\">平均等待时间最少，效率最高</td>\n<td style=\"text-align:center\">兼顾长短作业</td>\n<td style=\"text-align:center\">兼顾长短作业</td>\n<td style=\"text-align:center\">兼顾长短作业， 有较好的的响应时间， 可行性强</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td style=\"text-align:center\">不利于短作业</td>\n<td style=\"text-align:center\">长作业会饥饿， 估计时间不易确定</td>\n<td style=\"text-align:center\">计算响应比的开销大</td>\n<td style=\"text-align:center\">平均等待时间较长， 上下文切换浪费时间</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td>适用于</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">作业调度， 批处理系统</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">分时系统</td>\n<td style=\"text-align:center\">相当通用</td>\n</tr>\n<tr>\n<td>默认决策模式</td>\n<td style=\"text-align:center\">非抢占</td>\n<td style=\"text-align:center\">非抢占</td>\n<td style=\"text-align:center\">非抢占</td>\n<td style=\"text-align:center\">抢占</td>\n<td style=\"text-align:center\">抢占</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"2-3-同步与互斥\"><a href=\"#2-3-同步与互斥\" class=\"headerlink\" title=\"2.3 同步与互斥\"></a>2.3 同步与互斥</h2><h3 id=\"2-3-1-同步与互斥的基本概念\"><a href=\"#2-3-1-同步与互斥的基本概念\" class=\"headerlink\" title=\"2.3.1 同步与互斥的基本概念\"></a>2.3.1 同步与互斥的基本概念</h3><p>临界资源：一次仅允许一个进程使用的资源</p>\n<ul>\n<li><p>类型：物理设备，如打印机等；可被进程共享的许多变量、数据等</p>\n</li>\n<li><p>临界区：访问临界资源的那段代码。</p>\n<p>为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：</p>\n<ul>\n<li>1）进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>\n<li>2）临界区。进程中访问临界资源的那段代码，又称临界段。</li>\n<li>3）退出区。将正在访问临界区的标志清除。</li>\n<li>4）剩余区。代码中的其余部分。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">    entry section;\t\t\t<span class=\"comment\">//进入区</span></span><br><span class=\"line\">    critical section;\t\t<span class=\"comment\">//临界区</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span> section;\t\t\t<span class=\"comment\">//退出区</span></span><br><span class=\"line\">    remainder section;\t\t<span class=\"comment\">//剩余区</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>同步</strong></p>\n<ul>\n<li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li>\n<li>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。</li>\n</ul>\n<p>如何解决这种异步问题，就是“进程同步”所讨论的内容。</p>\n<p><strong>互斥</strong></p>\n<p> 互斥也称间接制约关系。当一个进程进入临界区使用临界资源，另一进程必须等待当占用临界资源的进程退出临界区后，另一进程才能访问此临界资源。</p>\n<p>遵循原则：</p>\n<ul>\n<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>\n<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他图进入临界区进必须等待</li>\n<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li>\n<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>\n</ul>\n<h3 id=\"2-3-2-实现临界区互斥的基本方法\"><a href=\"#2-3-2-实现临界区互斥的基本方法\" class=\"headerlink\" title=\"2.3.2 实现临界区互斥的基本方法\"></a>2.3.2 实现临界区互斥的基本方法</h3><p><strong>1.软件实现方法</strong></p>\n<p><strong>单标志法（违背“空闲让进”原则）</strong></p>\n<p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>\n<p>该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。</p>\n<p><img src=\"../img/67164ba2874147959a5d8c8f090ea53d.png\" alt=\"在这里插入图片描述\"></p>\n<p>若某个进程不再进入临界区，则另一个 进程也将无法进入临界区（违背”空闲让进”）。</p>\n<p><img src=\"../img/44ef61ad15a246304e7efb4ae40e6be8.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>双标志法先检查（违背“忙则等待”原则）</strong></p>\n<p>在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需等待：否则，进程才进入自己自己的临界区。</p>\n<blockquote>\n<p>设置一个布尔型数组flag[ ]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag设为true，之后开始访问临界区。</p>\n</blockquote>\n<p><img src=\"../img/d79aa05dfb0229ff30f56ced130154c9.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>优点：不用交替进入，可连续使用</li>\n<li>缺点：按序列①⑤②⑥执行时，会同时进入临界区（违背“忙则等待”），Pi进程和Pj进程可能同时进入临界区；检查和修改操作不能一次进行。</li>\n</ul>\n<p><strong>双标志法后检查</strong></p>\n<p>双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>\n<p><img src=\"../img/87ca8de55489d7e6145a7fbc95e3187d.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>缺点：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值设置为TRUE，并且同时检测对方的状态，发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。违背了“空闲让进”和“有限等待”产生饥饿</li>\n</ul>\n<p><strong>Peterson算法</strong></p>\n<p>结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>\n<p><img src=\"../img/f2394bc57abed9ec287961ab0e45506a.png\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"../img/57bc68a71ab0025e56e44ee65f71f2f7.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>为了防止两个进程为进入临界区而无限期等待，又设置了变量turn，每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</li>\n<li>进程在进入区要做的步骤： ① 主动争取 ② 主动谦让 ③ 检查对方是否也想使用，且最后一次是不是自己说了客气话</li>\n<li><strong>存在问题</strong>：Peterson 算法用软件方法解决了进程互斥问题， 遵循 “空闲让进”、“忙则等待”、“有限等待” 三个原则，但是依然 未遵循 “让权等待” 的原则。</li>\n</ul>\n<p><strong>软件方法总结</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">单标志法</th>\n<th style=\"text-align:center\">双标志先检查</th>\n<th style=\"text-align:center\">双标志后检查</th>\n<th style=\"text-align:center\">Peterson 算法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">算法</td>\n<td style=\"text-align:center\">在进入区只做“检查”，不”上锁“ 在退出区把临界区的使用权转交给另一个进程 (相当于在退出区既给另一进程”解锁”，又给自己”上锁”）</td>\n<td style=\"text-align:center\">在进入区先”检查”后”上锁”，退出区”解锁“</td>\n<td style=\"text-align:center\">在进入区先”加锁”后”检查”，退出区”解锁”</td>\n<td style=\"text-align:center\">在进入区”主动争取一主动谦让一检查对方是否想进、已方是否谦让“</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">问题</td>\n<td style=\"text-align:center\">不遵循”空闲让进”</td>\n<td style=\"text-align:center\">不遵循”忙则等待”</td>\n<td style=\"text-align:center\">不遵循”空闲让进、有限等待”，可能导致”饥饿”</td>\n<td style=\"text-align:center\">不遵循”让权等待”，会发生”忙等”</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>2.硬件实现方法</strong></p>\n<p><strong>中断屏蔽方法</strong></p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单的方法是：禁止一切中断发生，或称之为屏蔽中断、关中断。</p>\n<p><img src=\"../img/image-20240924151226164.png\" alt=\"image-20240924151226164\"></p>\n<p><strong>硬件指令法</strong></p>\n<ul>\n<li><p><strong>TestAndSet指令</strong></p>\n<p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令TSL指令是用硬件实现的。TS是原子操作，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p>\n<ul>\n<li>执行TSL指令时，它的内部运转逻辑：</li>\n<li>假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等</li>\n<li>假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。</li>\n</ul>\n<p><img src=\"../img/e65e7f830c0d877918221c25af207e67.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>  相比软件实现方法，TSL 指令把 上锁和检查操作 用硬件的方式变成了一气呵成的 原子操作 。</p>\n<ul>\n<li><strong>优点：</strong> 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞。适用于多处理机环境。</li>\n<li><strong>缺点：</strong> 不满足 “让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致 忙等。</li>\n</ul>\n<ul>\n<li><p><strong>Swap指令</strong></p>\n<p>有的地方也叫Exchange指令，或简称XCHG指令。Swp指令是用硬件实现的，是原子操作，执行的过程不允许被中断，只能一气呵成。</p>\n<ul>\n<li>old是每个进程都要进行的一步，都必须将old=true</li>\n<li>因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../img/e2112c19a7ebb37272fac3589dea3fa0.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。Swap 指令优点缺点和TSL指令相同。</p>\n</blockquote>\n<ul>\n<li>硬件方法的优点<ul>\n<li>适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。</li>\n<li>可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</li>\n</ul>\n</li>\n<li>硬件方法的缺点<ul>\n<li>进程等待进入临界区时要耗费处理时间，不能实现让权等待。</li>\n<li>从等待进程中随机选择一个进入临界区，有进程可能一直选不上，从而导致“饥饿”现象。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-3-互斥锁\"><a href=\"#2-3-3-互斥锁\" class=\"headerlink\" title=\"2.3.3 互斥锁\"></a>2.3.3 互斥锁</h3><p> 解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。acquire()和release()是原子操作，由硬件机制完成。</p>\n<p> 每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acquire()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!available);\t\t<span class=\"comment\">//忙等待</span></span><br><span class=\"line\">    avilable = <span class=\"literal\">false</span>;\t\t<span class=\"comment\">//获得锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">release()&#123;</span><br><span class=\"line\">    available = <span class=\"literal\">true</span>;\t\t<span class=\"comment\">//释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>\n<li>缺点：需忙等，进程时间片用完才下处理机，违反“让权等待”；不太适用于单处理机系统，忙等的过程中不可能解锁</li>\n</ul>\n<h3 id=\"2-3-4-信号量\"><a href=\"#2-3-4-信号量\" class=\"headerlink\" title=\"2.3.4 信号量\"></a>2.3.4 信号量</h3><p> 信号量机制是一种功能较强的机制,可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为”P操作”和”V操作”。</p>\n<p> 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>\n<p> 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>\n<p><strong>整型信号量</strong></p>\n<p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。wait(S)、signal(S)可描述为：</p>\n<p><img src=\"../img/af36fadd8e8881cf6c8e0a85ae3e3e8f.png\" alt=\"img\" style=\"zoom: 80%;\" /></p>\n<blockquote>\n<p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p>\n</blockquote>\n<p>wait(S) 原语，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。</p>\n<p><strong>存在的问题：</strong> 不满足 “让权等待” 原则，会发生 忙等。</p>\n<p><img src=\"../img/0101bca97719ab8dbc1ef9b74c7ad5ae.png\" alt=\"img\"></p>\n<p>记录型信号量</p>\n<p>整型信号量存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>\n<p>除了需要用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。</p>\n<p><img src=\"../img/5618c03127458823e294f999d218a2ee.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>wait：如果剩余资源数不够使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</li>\n<li>signal：释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</li>\n<li>S.value的初值表示系统中某种资源的数目。</li>\n<li>P操作：<ul>\n<li>对信号量S的一次P操作意味着进程请求一个单位的该资源，因此需要执行S.value-，表示资源数减1</li>\n<li>当S.value&lt;0时表示该类资源已分配完毕，因此进程应调用bock原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。</li>\n<li>可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li>\n</ul>\n</li>\n<li>V操作：<ul>\n<li>对信号量S的一次V操作意味进程释放一个单位的该资源，因此需要执行S.value.+，表示资源数加1，</li>\n<li>若加1后仍是S.value&lt;=0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/weixin_43914604/article/details/104951182\">2.3.4 操作系统之信号量机制（整型信号量、记录型信号量P、V）_llf算法-CSDN博客</a></p>\n<blockquote>\n<p>例：某计算机系统中有1台打印机，则可在初始化信号量 S 时将 S.value 的值设为 1，队列 S.L 设置为空。</p>\n<p><img src=\"../img/8b4c198b4363ce7365742e171334c4fb.png\" alt=\"img\"></p>\n<p>① CPU 为 P0 服务，S.value —，值为 0，P0开始使用打印机。<br>② CPU 为 P1 服务，S.value —，值为 -1，无资源执行 block 原语( wait原语 )。阻塞队列( P1 )，S.value = -1 说明有1个进程在等待资源。<br>③ CPU 为 P2 服务，S.value —，值为 -2，无资源执行 block 原语。阻塞队列( P1→P2 )，S.value = -2 说明有2个进程在等待资源。<br>④ CPU 为 P0 服务，S.value ++，S.value = -1 ≤ 0，说明有进程在等待该资源。因此应调用 wakeup 原语(signal原语)唤醒等待队列中的第一个进程P1，将释放资源给 P1，P1从阻塞态变为就绪态，等待被 CPU 服务(CPU顺序执行)。阻塞队列( P2 )<br>⑤ CPU 为 P1 服务，P1 使用完打印机，S.value ++，S.value = 0，调用 wakeup 原语唤醒 P2。阻塞队列()。<br>⑥ CPU 为 P2 服务， P2是用完打印机，S.value ++，S.value = 1。</p>\n</blockquote>\n<p><strong>信号量机制实现进程互斥</strong></p>\n<ul>\n<li><p>伪代码如下所示：</p>\n<p>设 S 为实现进程 P1、P2 互斥的信号量，由于只允许一个进程进入临界区，所以 S 的初值应设为 1。然后把临界区置于 P(S) 和 V(S) 之间，进入区之前申请资源（P操作），退出区之前释放资源（ V操作 ），即可实现两个进程对临界资源的互斥访问。</p>\n<p><img src=\"../img/8b25e2c254ffaddde1222b7aa93c437d.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>操作：</p>\n<ul>\n<li>1.分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>\n<li>2.设置互斥信号量mutex，初值为1</li>\n<li>3.在进入区P（mutex）一一申请资源</li>\n<li>4.在退出区V（mutex）一一释放资源</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li>对不同的临界资源需要设置不同的互斥信号量。</li>\n<li>P、V操作必须成对出现。缺少P（mutex）就不能保证临界资源的互斥访问。缺少V（mutex）会导致资源永不被释放，等待进程永不被唤醒。</li>\n</ul>\n</li>\n</ul>\n<p><strong>信号量机制实现进程同步</strong></p>\n<ul>\n<li><p>程序</p>\n<p><img src=\"../img/aeadd0a9c26ce53ffa2809ff00f49e82.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li>步骤</li>\n</ul>\n<p><img src=\"../img/02bc9b6e96624e6898cf099a58873ae7.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>信号量机制实现前驱关系</strong></p>\n<p>分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题</p>\n<ul>\n<li><p>问题：下图是一个前驱图，其中 S1, S2, S3, … ,S6 是进程 P1, P2, P3,…, P6 中的程序段，这些程序段要求按如下前驱图所示的顺序来执行：</p>\n<p><img src=\"../img/0d8e5038beee6e721849c0c02824ecea.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h3 id=\"2-3-5-管程\"><a href=\"#2-3-5-管程\" class=\"headerlink\" title=\"2.3.5 管程\"></a>2.3.5 管程</h3><p><strong>引入管程原因</strong></p>\n<p>管程的引入让程序员写程序时不需要再关注复杂的PV操作，从而避免了传统信号量机制存在的很多问题。</p>\n<p>定义：由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p>\n<p><strong>管程的组成</strong></p>\n<ul>\n<li>局部于管程的共享数据结构说明</li>\n<li>对该数据结构进行操作的一组过程（函数）</li>\n<li>对局部于管程的共享数据设置初始值的语句</li>\n<li>管程的名字</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitor Demo&#123;<span class=\"comment\">//定义一个名称为&quot;Demo&quot;的管程</span></span><br><span class=\"line\">    <span class=\"comment\">//定义共享数据结构，对应系统中的某种共享资源</span></span><br><span class=\"line\">    共享数据结构 S;</span><br><span class=\"line\">    <span class=\"comment\">//对共享数据结构初始化的语句</span></span><br><span class=\"line\">    init_code()&#123;</span><br><span class=\"line\">        S=<span class=\"number\">5</span>;\t\t<span class=\"comment\">//初始资源数等于5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//过程1：申请一个资源</span></span><br><span class=\"line\">    take_away()&#123;</span><br><span class=\"line\">        对共享数据结构x的一系列处理;</span><br><span class=\"line\">        s--;\t\t<span class=\"comment\">//可用资源-1</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//过程2：归还一个资源</span></span><br><span class=\"line\">    give_back()&#123;</span><br><span class=\"line\">        对共享数据结构x的一系列处理;</span><br><span class=\"line\">        s++;\t\t<span class=\"comment\">//可用资源+1</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>管程的基本特征</strong></p>\n<ul>\n<li>局部于管程的数据只能被局部于管程的过程所访问</li>\n<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>\n<li>每次仅允许一个进程在管程内执行某个内部过程</li>\n</ul>\n<blockquote>\n<p>注：过程其实就是函数，如下面这个 People 类，People 是管程的名字，username 和 str 是局部于管程的共享数据结构，login 方法是该数据结构进行操作的过程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String username = <span class=\"string\">&quot;admin&quot;</span>; <span class=\"comment\">// 用户名</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String str= <span class=\"string\">&quot;123456&quot;</span>; <span class=\"comment\">// 密码</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">void</span> <span class=\"title\">login</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"string\">&quot;admin&quot;</span>.<span class=\"built_in\">equals</span>(username) &amp;&amp; <span class=\"string\">&quot;123456&quot;</span>.<span class=\"built_in\">equals</span>(str))&#123;</span><br><span class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;登录成功！&quot;</span>);\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><strong>条件变量</strong></p>\n<p>条件变量condition，是表示管程阻塞原因的变量。</p>\n<p> 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。</p>\n<ul>\n<li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li>\n<li>x.signal：x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞的进程。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monitor Demo&#123;</span><br><span class=\"line\">    共享数据结构 S;</span><br><span class=\"line\">    condition x；\t\t\t\t\t<span class=\"comment\">//定义一个条件变量x</span></span><br><span class=\"line\">    init_code()&#123;...&#125;</span><br><span class=\"line\">    take_away()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S&lt;<span class=\"number\">0</span>) x.wait();\t\t\t<span class=\"comment\">//资源不够，在条件变量x上阻塞等待</span></span><br><span class=\"line\">        资源足够，分配资源，做一系列处理；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    give_back()&#123;</span><br><span class=\"line\">        归还资源，做一系列相应处理;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(有进程在等待）x.signal();\t<span class=\"comment\">//唤醒一个阻塞进程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>条件变量和信号量的比较：<ul>\n<li><strong>相似点</strong>：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒。</li>\n<li><strong>不同点</strong>：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-6-经典同步问题\"><a href=\"#2-3-6-经典同步问题\" class=\"headerlink\" title=\"2.3.6 经典同步问题\"></a>2.3.6 经典同步问题</h3><p><strong>1.生产者-消费者问题</strong></p>\n<p><strong>产生问题</strong>：当两者<strong>并发执行时</strong>可能出差错，导致预期的结果与真实的结果不相符：当执行生产者+1和消费者-1操作之后，<strong>缓冲区的值从10变为了11</strong>。</p>\n<p><img src=\"../img/6667ccb2b07470918bf62f64b9aa6571.png\" alt=\"image-20210826155457272\"></p>\n<ul>\n<li><p>问题描述</p>\n<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>\n<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>\n<ul>\n<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>\n<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>\n</ul>\n<p>缓冲区是临界资源，各进程必须互斥地访问。</p>\n<p><img src=\"../img/049704b38250bb4bc6d400521500f5c3.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>问题分析</p>\n<p><img src=\"../img/0a609ec96f01f4a878a8c49deb2982ad-172706587417788.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>1.<strong>关系分析</strong>。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>\n<p>同步关系：缓冲区没满，生产者生产；缓冲区没空，消费者消费。</p>\n<p>互斥关系：各进程互斥访问缓冲区。</p>\n</li>\n<li><p>2.<strong>整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>3.<strong>设置信号量</strong>。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>; <span class=\"comment\">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class=\"line\">semaphore empty = n; <span class=\"comment\">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class=\"line\">semaphore full = <span class=\"number\">0</span>;  <span class=\"comment\">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>进程描述</p>\n<p><img src=\"../img/055bedd5982862633ceb53c05ad1789c.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>能否改变相邻P、V操作的顺序？</p>\n<p>不能，会发生死锁</p>\n<p><img src=\"../img/2baed7d9193f65b44ea98194d0fc1b56.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>能否只设置一个同步信号量</p>\n<p>不能。原因在于：两个信号量 empty 和 full，其中 empty 用于制约生产者生产，full 用于制约消费者消费。如果只设置一个信号量，如 full，那么生产者会无限的生产，起不到制约作用。</p>\n</li>\n</ul>\n<p><strong>2.多生产者多消费者问题</strong></p>\n<ul>\n<li><p>问题描述</p>\n<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>\n</li>\n<li><p>问题分析</p>\n<ul>\n<li><p>1.<strong>关系分析</strong></p>\n<p>同步关系：① 父亲将苹果放入盘子，女儿才能取苹果；<br>     ② 母亲将句子放入盘子，儿子才能取橘子；<br>     ③ 只有盘子为空，父亲或者母亲才能放水果。<br>互斥关系：对缓冲区(盘子)的访问要互斥的进行。</p>\n</li>\n<li><p>2.<strong>整理思路</strong></p>\n<p><img src=\"../img/b242f667ca90221eaef3f7f987d88dfe-172706607178391.png\" alt=\"在这里插入图片描述\"><br>分析同步要以 <strong>事件</strong> 的角度分析，不要以 <strong>进程</strong> 的角度分析。</p>\n</li>\n<li><p>3.<strong>信号量的设置</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;  <span class=\"comment\">//实现互斥访问盘子（缓冲区）</span></span><br><span class=\"line\">semaphore apple = <span class=\"number\">0</span>;  <span class=\"comment\">//盘子中有几个苹果</span></span><br><span class=\"line\">semaphore orange = <span class=\"number\">0</span>; <span class=\"comment\">//盘子中有几个橘子</span></span><br><span class=\"line\">semaphore plate = <span class=\"number\">1</span>;  <span class=\"comment\">//盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>进程描述</p>\n<p><strong>实现方法</strong></p>\n</li>\n</ul>\n<p>  <img src=\"../img/baf12e1810928afc20fc67c899f26774.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>能否不用互斥信号量</p>\n<p>如果缓冲区大小为1，在任何时刻，apple、orange、plate 三个信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。<br>  如果缓冲区大小大于1，数据可能存在相互覆盖的情况。如：父亲在向盘子放橘子的同时，母亲也可以往盘子里放橘子，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。<br>  因此，当缓冲区大小等于1，有可能不设置互斥变量。当缓冲区大小大于1，必须设置互斥变量。是否不用设置互斥信号量主要观察，同一时刻信号量是否最多一个1，建议设置互斥信号量。</p>\n<p>但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p>\n</li>\n</ul>\n<p><img src=\"../img/ae49e4f5982e2e9ba9ce5fe9c340ce34.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>如果有两个盘子plate</strong></p>\n<p><img src=\"../img/33c4b11ea0b1cdf35d5f58f5b6cf8ea8-172708076898396.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>分析</p>\n<p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p>\n<p>如果从 单个进程的角度 来考虑的话，会有以下结论：</p>\n<ul>\n<li>① 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；</li>\n<li>② 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。</li>\n</ul>\n<p>这就意味着要 设置四个同步信号量 分别实现这 四个一前一后的关系，较为复杂。</p>\n</li>\n</ul>\n<p>  若从 事件的角度 来考虑，我们可以把上述四对进程行为的前后关系抽象为 一对事件 的前后关系，即：盘子变空事件 → 放入水果事件。</p>\n<p>  <img src=\"../img/image-20240923221835055.png\" alt=\"image-20240923221835055\"></p>\n<ul>\n<li><code>总结</code>:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，<code>这不是绝对的</code>，要具体问题具体分析。</li>\n<li><code>建议</code>:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·<code>实现互斥的P操作一定要在实现同步的P操作之后</code>·，否则可能引起·<code>“死锁”</code>·。</li>\n</ul>\n<p><strong>3.读者-写者问题</strong></p>\n<ul>\n<li><p>问题描述</p>\n<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>\n<ul>\n<li>①允许多个读者可以同时对文件执行读操作</li>\n<li>②只允许一个写者往文件中写信息</li>\n<li>③任一写者在完成写操作之前不允许其他读者或写者工作</li>\n<li>④写者执行写操作前，应让已有的读者和写者全部退出</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>问题分析</p>\n<ul>\n<li>两类进程：写进程、读进程</li>\n<li>互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../img/c4b784aee93f767197513f61979e7ec2.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>进程描述</p>\n<ul>\n<li><p>方案1</p>\n<p>方案设置 rw 和 mutex 两个信号量。rw 信号量 用于实现 读进程与写进程、写进程与写进程 对共享文件的互斥访问。mutex 信号量 用于保证对 count 变量的互斥访问。</p>\n<p><img src=\"../img/e03d4f01690276b1a239ac6c15d2ee1d.png\" alt=\"在这里插入图片描述\"></p>\n<p>加mutex原因：</p>\n<p>比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>若没有设置 mutex 信号量，两个读进程并发执行到 if 条件且都满足，都会执行 P(rw)，会造成其中一个读进程阻塞的情况。设置 mutex 信号量，使得 count 信号量的检查和赋值操作一气呵成，保证了对 count 信号量访问的互斥性。\n\n\n\n **方案 1 存在的问题：** 只要有读进程还在读，写进程就要一直阻塞等待，可能 “饿死”。因此，这种算法中，读进程是优先的。\n</code></pre><ul>\n<li><p>方案2</p>\n<p>方案 2 是对方案 1 问题的修正，添加了 w 信号量，保证了 读写公平 。如：假设对共享文件的访问顺序是：读者1→读者2→ 写者1 → 读者3 ，读者 2 执行完后，写者 1 将会进行写文件，读者 3 进程将会被阻塞。待写者1写完文件后，读者 3 进行读写者 1 访问后的文件。</p>\n<p><img src=\"../img/0a418a9fd295d3b10a75c3edb64ff369.png\" alt=\"在这里插入图片描述\"></p>\n<p>算法 核心思想 在于设置了一个 计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，还需考虑 count 变量的互斥性。</p>\n</li>\n</ul>\n<p><strong>4.哲学家进餐问题</strong></p>\n<ul>\n<li><p>问题描述</p>\n<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>\n</li>\n</ul>\n<ul>\n<li><p>问题分析</p>\n<ul>\n<li><p><strong>1.关系分析</strong></p>\n<p>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>\n</li>\n<li><p><strong>2.整理思路</strong></p>\n<p>哲学家进餐问题中 只有互斥关系，但与之前遇到的问题不同点在于，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的关键。</p>\n</li>\n<li><p><strong>3.信号量的设置</strong></p>\n<p>定义互斥信号量数组 chopstick[5]={1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。此外，还需要设置 互斥信号量mutex，用以保证哲学家进程左右两支筷子都可用。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>进程描述</p>\n<p>算法保证，一个哲学家再拿到筷子拿到一半时被阻塞，也不会有别的哲学家尝试拿筷子，即至少有一个哲学家进程不阻塞。</p>\n<p><img src=\"../img/ad3ded5b21279f6db2d9579acd1637aa.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>其他方案：<br>① 对哲学家进程施加一些限制条件，如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。<br>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>吸烟者问题</strong></p>\n<ul>\n<li><p>问题描述</p>\n<p>假设一个系统有 三个抽烟者进程 和 一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。</p>\n</li>\n</ul>\n<ul>\n<li><p>问题分析</p>\n<ul>\n<li><p><strong>1.关系分析</strong></p>\n<p>同步关系：① 桌上有组合一，第一个抽烟者取走东西<br>     ② 桌上有组合二，第二个抽烟者取走东西<br>     ③ 桌上有组合三，第三个抽烟者取走东西<br>     ④ 抽烟者抽完发出完成信号，供应者将下一个组合放到桌上<br>互斥关系：对缓冲区的访问要互斥的进行。</p>\n</li>\n<li><p><strong>2.整理思路</strong></p>\n<p><img src=\"../img/image-20240923222427002.png\" alt=\"image-20240923222427002\"></p>\n<blockquote>\n<p>注：由于缓冲区大小为1，任意时刻同步信号量和互斥信号量最多只有一个1，因此互斥信号量可以不设置。</p>\n</blockquote>\n</li>\n<li><p><strong>3.信号量的设置</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore offer1 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合一的数量</span></span><br><span class=\"line\">semaphore offer2 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合二的数量</span></span><br><span class=\"line\">semaphore offer3 = <span class=\"number\">0</span>; <span class=\"comment\">//桌上组合三的数量</span></span><br><span class=\"line\">semaphore finish = <span class=\"number\">0</span>; <span class=\"comment\">//抽烟是否完成</span></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">//用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>进程描述</p>\n<p><img src=\"../img/746bc852ae887810691f127636888fb7.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>能否从进程角度思考？</p>\n<p> 不可以。<br>    同多生产者多消费者问题，假设从进程角度思考，那么第一个抽烟者抽完后，供应者再将第一个组合放到桌上；第二个抽烟者抽完后，供应者再将第二个组合放到桌上；第三个抽烟者抽完后，供应者再将第三个组合放到桌上。这样相比于从事件考虑的一个一前一后的关系，多出了多个关系，并且较为复杂。因此要从事件的角度思考 PV 关系。</p>\n</li>\n</ul>\n<h2 id=\"2-4-死锁\"><a href=\"#2-4-死锁\" class=\"headerlink\" title=\"2.4 死锁\"></a>2.4 死锁</h2><p><img src=\"../img/5f02542d936d24a07d84704b50d6a0ef.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-4-1-死锁的概念\"><a href=\"#2-4-1-死锁的概念\" class=\"headerlink\" title=\"2.4.1 死锁的概念\"></a>2.4.1 死锁的概念</h3><p><strong>1.死锁的定义</strong></p>\n<p> 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉这些进程都将无法向前推进。</p>\n<p><strong>2.死锁、饥饿、死循环的区别</strong></p>\n<ul>\n<li><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外)</p>\n</li>\n<li><p>区别：</p>\n<ul>\n<li><p><strong>死锁</strong>：两个及以上进程间互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>\n</li>\n<li><p><strong>饥饿</strong>：可能只有单个进程由于长期得不到想要的资源，某进程无法向前推进的现象。</p>\n<p>比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</p>\n</li>\n<li><p><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。是被管理者出现的问题。</p>\n<p>有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>3.死锁产生原因</strong></p>\n<ul>\n<li><p><strong>对系统资源的竞争</strong></p>\n<p>各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p>\n</li>\n<li><p><strong>进程推进顺序非法</strong></p>\n<p>请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>\n</li>\n<li><p><strong>信号量的使用不当也会造成死锁</strong></p>\n<p>如生产者-消费者问题中，如果实现互斥的P操柞在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>\n</li>\n</ul>\n<p><strong>4.死锁产出的必要条件</strong></p>\n<p>产生死锁 必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>\n<ul>\n<li>互斥条件：只有对必须 互斥使用的资源的争抢 才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>\n<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>\n<li>请求和保持条件：进程已经 保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>\n<li>循环等待条件：存在一种进程资源的 循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>\n</ul>\n<p>注：发生死锁时一定有循环等待，但是发生循环等待时未必死锁，即 循环等待是死锁的必要不充分条件。</p>\n<p><img src=\"../img/e32888eeb05ffe64ca17ae7a531bc779.png\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁（如上图 Pn 可以同时请求 P1 或者 Pk 的资源，得到 Pk 资源后，不会发生死锁）。 但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>\n<p><strong>5.死锁处理策略</strong></p>\n<ul>\n<li><strong>死锁预防</strong>。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。</li>\n<li><strong>避免死锁</strong>。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。</li>\n<li><strong>死锁的检测及解除</strong>。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</li>\n</ul>\n<p>死锁的几种处理策略的比较见下表。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">资源分配策略</th>\n<th style=\"text-align:center\">各种可能模式</th>\n<th style=\"text-align:center\">主要优点</th>\n<th style=\"text-align:center\">主要缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>死锁预防</td>\n<td style=\"text-align:center\">保守，宁可资源闲置</td>\n<td style=\"text-align:center\">一次请求所有资源，资源剥夺，资源按序分配</td>\n<td style=\"text-align:center\">适用于突发式处理的进程，不必进行剥夺</td>\n<td style=\"text-align:center\">效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td>\n</tr>\n<tr>\n<td>死锁避免</td>\n<td style=\"text-align:center\">是“预防”和“检测”的折中（在运行时判断是否可能死锁）</td>\n<td style=\"text-align:center\">寻找可能的安全允许顺序</td>\n<td style=\"text-align:center\">不必进行剥夺</td>\n<td style=\"text-align:center\">必须知道将来的资源需求；进程不能被长时间阻塞</td>\n</tr>\n<tr>\n<td>死锁检测</td>\n<td style=\"text-align:center\">宽松，只要允许就分配资源</td>\n<td style=\"text-align:center\">定期检查死锁是否已经发生</td>\n<td style=\"text-align:center\">不延长进程初始化时间，允许对死锁进行现场处理</td>\n<td style=\"text-align:center\">通过剥夺解除死锁，造成损失</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-4-2-死锁预防\"><a href=\"#2-4-2-死锁预防\" class=\"headerlink\" title=\"2.4.2 死锁预防\"></a>2.4.2 死锁预防</h3><p>死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁不会发生。</p>\n<p><strong>1.破坏互斥条件</strong></p>\n<p>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。如: SPOOLing技术。使用 SPOOLing 技术可以把 独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>\n<p><strong>2.破坏不剥夺条件</strong></p>\n<ul>\n<li>提供两种方案：<ul>\n<li>申请资源得不到时，主动释放所占有资源，需要再申请。</li>\n<li>申请资源被其他进程占用时，由 OS 协助剥夺。</li>\n</ul>\n</li>\n<li><strong>策略的缺点：</strong><ul>\n<li>实现起来比较复杂；</li>\n<li>释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU；</li>\n<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量；</li>\n<li>方案 ① 可能导致进程饥饿。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3.破坏请求和保持条件</strong></p>\n<p>采用 静态分配方法，即进程 在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>\n<p><strong>策略的缺点：</strong> 进程在整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有 可能导致某些进程饥饿。</p>\n<p><strong>4.破坏循环等待条件</strong></p>\n<p>采用 顺序资源分配法。首先给系统中的资源编号，要求进程只能按编号递增顺序请求资源。</p>\n<p><strong>原理分析</strong>： 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象(类比拓扑排序)。</p>\n<p><strong>策略的缺点</strong>： 不方便增加新的设备，因为可能需要重新分配所有的编号；进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；必须按规定次序申请资源，用户编程麻烦。</p>\n<h3 id=\"2-4-3-死锁检测\"><a href=\"#2-4-3-死锁检测\" class=\"headerlink\" title=\"2.4.3 死锁检测\"></a>2.4.3 死锁检测</h3><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p>\n<p><strong>每种类型一个资源的死锁检测方式</strong></p>\n<p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p>\n<p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p>\n<p><img src=\"../img/1515111-20200714090038711-1507102954.png\" alt=\"img\"></p>\n<p>如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</p>\n<p><strong>每种类型多个资源的死锁检测方式</strong></p>\n<p>如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</p>\n<p>现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p>\n<p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</p>\n<p><img src=\"../img/1515111-20200714090048237-1084617453.png\" alt=\"img\"></p>\n<p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p>\n<p>死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</p>\n<p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p>\n<ul>\n<li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li>\n<li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li>\n</ul>\n<h3 id=\"2-4-4-死锁恢复\"><a href=\"#2-4-4-死锁恢复\" class=\"headerlink\" title=\"2.4.4 死锁恢复\"></a>2.4.4 死锁恢复</h3><p><strong>通过抢占进行恢复</strong></p>\n<p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>\n<p><strong>通过回滚进行恢复</strong></p>\n<p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>\n<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>\n<p><strong>杀死进程恢复</strong></p>\n<p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>\n<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>\n<h3 id=\"2-4-5-死锁避免\"><a href=\"#2-4-5-死锁避免\" class=\"headerlink\" title=\"2.4.5 死锁避免\"></a>2.4.5 死锁避免</h3><p> 死锁的避免是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p>\n<p><strong>系统安全状态</strong></p>\n<ul>\n<li>安全序列：是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</li>\n<li>安全状态：系统如果存在安全序列，则处于<strong>安全状态</strong>，安全状态一定不发生死锁。安全序列可能有多个。</li>\n<li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</li>\n</ul>\n<p><strong>安全序列的计算方法：</strong></p>\n<p>例子：假设系统中有三个进程p1 , p2 , p3 ，一共有12台磁带机。进程p1共需要10台，进程p2共需要4台，进程p3共需要9台。假设在某个时刻，进程p1 , p2 , p3已分别获得5台、2台和2台，还有3台没分配。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">进程</th>\n<th style=\"text-align:center\">最大需求</th>\n<th style=\"text-align:center\">已分配</th>\n<th style=\"text-align:center\">可用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">p1</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p2</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">p3</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统变可避免进入死锁。</p>\n<p>分配2个资源给p2，满足p 2的最大需求，待p2释放所持资源，此时空闲资源共计5个单位；</p>\n<p>分配5个资源给p1，满足p 1的最大需求，待p1释放所持资源，此时空闲资源共计10个单位；</p>\n<p>分配7个资源给p3，满足p 3的最大需求，待p3释放所持资源，此时空闲资源共计12个单位；</p>\n<p>最后得到安全序列p2 , p1 , p3这种情况下不会发生死锁。<br><img src=\"../img/06f57569c13273d32f2881beecd771bb.jpeg#pic_center\" alt=\"img\"></p>\n<p>但是如果先给p3分配一个资源，此时系统进入不安全状态。之后再将剩下的两个资源分配给p2，等待p2进程运行完毕，回收其资源，此时空闲资源共有4个单位。此时4个单元无法满足p1或者p3 ，则此时无法再找到一个安全序列，陷入僵局，最终导致死锁。</p>\n<p>并不是所有的不安全状态都是死锁状态，但是当系统进入不安全状态的时候，就有可能出现死锁情况。反之，如果系统处于安全状态，系统便可以找到安全序列，避免死锁状态。</p>\n<p><strong>银行家算法</strong></p>\n<p><strong>核心思想：</strong> 在分配资源前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否答应资源分配请求，从而使得系统避免死锁。</p>\n<ul>\n<li><p><strong>数据结构描述：</strong></p>\n<p>(1) 可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现Rj类资源K个。</p>\n</li>\n</ul>\n<p>  (2) 最大需求矩阵Max。这是一个n x m的矩阵，它定义了系统中n个进程中的每个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj 类资源的最大数目为K。</p>\n<p>  分配矩阵 Allocation。这也是一个n x m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 Allocation[i,jl = K，则表示进程i当前己分得Rj类资源的数目为K。</p>\n<p>  (4) 需求矩阵Need.这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个方能完成其任务。<br>  上述三个矩阵间存在下述关系:<br>  　　　　　　　　　　　　　　Need[i,j] = Max[i,j] - allocation[i, j]</p>\n<ul>\n<li><p><strong>银行家算法描述</strong></p>\n<p>设 Request；是进程Pi的请求向量，如果 Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査:<br>(1) 如果 Requesti[j] ≤ Need[i,j]便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p>\n</li>\n</ul>\n<p>  (2) 如果 Requesti[j] ≤ Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p>\n<p>  (3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值<br>  　　　　Available[j] = Available[j] - Requesti[j];<br>  　　　　Allocation[i,j] = Allocation[i,j] + Requesti[j];<br>  　　　　Need[i,j] = Need[i,j] - Requesti[j];</p>\n<p>  (4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p>\n<p>  注：安全性算法是银行家算法的核心。</p>\n<ul>\n<li><p><strong>安全性算法描述</strong></p>\n<p>(1) 设置两个向量:①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work = Available；② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[i] = false；当有足够资源分配给进程时，再令Finish[i] = true。</p>\n</li>\n</ul>\n<p>  (2) 从进程集合中找到一个能满足下述条件的进程<br>  　　　　① Finish[i] = false;<br>  　　　　② Need[i,j] ≤ Work[j];<br>  若找到，执行步骤(3)，否则，执行步骤(4)。</p>\n<p>  (3)当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:<br>  　　　　Work[j] = Work[j] + Allocation[i,j];<br>  　　　　Finish[i] = true;<br>  　　　　go to step 2;(goto语句不推荐使用 _ )</p>\n<p>  (4)如果所有进程的 Finish[i] =true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>\n<p>  <a href=\"https://blog.csdn.net/weixin_43914604/article/details/105437474\">2.4操作系统之死锁详解(预防、避免、检测、解除)+思维导图_llf算法-CSDN博客</a></p>\n<p><strong>王道书解法</strong>：</p>\n<p><img src=\"../img/640533d81f0c0cfaf701b08e89501cc1-172716794353618.png\" alt=\"image-20230913154241862\"></p>\n<p><img src=\"../img/18fd1ab3cd3aac0d88af624547dbf334-172716794353620.png\" alt=\"image-20230913154306033\"></p>\n<h3 id=\"2-4-6-死锁检测和解除\"><a href=\"#2-4-6-死锁检测和解除\" class=\"headerlink\" title=\"2.4.6 死锁检测和解除\"></a>2.4.6 死锁检测和解除</h3><p> 如果系统既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供死锁检测和解除的手段。</p>\n<p><strong>资源分配图</strong></p>\n<p>系统死锁可利用 资源分配图 来描述。圆代表一个进程，框代表一类资源，框中一个圆代表一类资源中的一个资源。</p>\n<p><img src=\"../img/image-20240924005505991.png\" alt=\"image-20240924005505991\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>两种结点：<ul>\n<li>进程结点：对应一个进程</li>\n<li>资源结点：对应一类资源，一类资源可能有多个</li>\n</ul>\n</li>\n<li>两种边：<ul>\n<li>请求边：表示进程想申请几个资源（每条边代表一个）</li>\n<li>分配边：表示已经为进程分配了几个资源（每条边代表一个）</li>\n</ul>\n</li>\n</ul>\n<p><strong>死锁定理</strong></p>\n<p>简化资源分配图可检测系统状态是否为死锁状态。简化方法如下：</p>\n<p>① 在资源分配图中，找出 既不阻塞又不是孤点的进程 Pi。</p>\n<ul>\n<li>不阻塞：表示进程申请的资源可以被满足，如 P1 进程。由于 R2 资源除分配给 P2 进程一个资源外，还剩有一个资源，因此 P1 进程申请的 R2 资源可以被满足。相反，P2 进程申请 R1 资源则不会被满足，由于 R1 资源全部被分配完。</li>\n<li>不是孤点：表示与该进程节点至少一个边相连。</li>\n</ul>\n<p>② 消去进程所有的请求边和分配边，使之成为孤点。</p>\n<p>重复以上步骤，若能消去图中所有的边，则称该图是可完全简化的。</p>\n<p><img src=\"../img/a61c21ffd854bf02fc931f49aa738f15.jpeg#pic_center\" alt=\"img\"></p>\n<p>注：并不是系统中所有的进程都是死锁状态，用死锁检测算法 化简资源分配图后，还连着边的那些进程就是死锁进程。</p>\n<p><img src=\"../img/25fcd4264095d44dfa34aa283bf25799.jpeg#pic_center\" alt=\"img\"></p>\n<p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p>\n<p><strong>死锁解除</strong></p>\n<p>一旦检测出死锁的发生，就应该立即解除死锁。解除死锁的主要方法有：</p>\n<ul>\n<li><p>资源剥夺法</p>\n<p>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是 应防止被挂起的进程长时间得不到资源而饥饿。</p>\n</li>\n<li><p>撤销进程法（或称终止进程法）</p>\n<p>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p>\n</li>\n<li><p>进程回退法</p>\n<p>让一个或多个死锁进程回退到足以避免死锁的地步。进程回退时，自愿释放资源而非剥夺。这就要求系统要记录进程的历史信息，设置还原点。</p>\n</li>\n</ul>\n<blockquote>\n<p>注：撤销进程法中参考的优先级，应考虑：进程优先级、已执行多长时间、还要多久能完成、进程已经使用了多少资源、进程是交互式的还是批处理式的等因素。</p>\n</blockquote>\n<hr>\n<h1 id=\"三、内存管理\"><a href=\"#三、内存管理\" class=\"headerlink\" title=\"三、内存管理\"></a>三、内存管理</h1><h2 id=\"3-1-内存管理概念\"><a href=\"#3-1-内存管理概念\" class=\"headerlink\" title=\"3.1 内存管理概念\"></a>3.1 内存管理概念</h2><h3 id=\"3-1-1-内存管理的基本原理和要求\"><a href=\"#3-1-1-内存管理的基本原理和要求\" class=\"headerlink\" title=\"3.1.1 内存管理的基本原理和要求\"></a>3.1.1 内存管理的基本原理和要求</h3><p><strong>1.内存管理的概念</strong></p>\n<p>虽然计算机技术飞速发展，内存容量也在不断扩大，但仍然不可能将所有用户进程和系统所需的全部程序与数据放入内存，因此操作系统对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。</p>\n<p>内存空间的主要功能有：</p>\n<ul>\n<li><strong>内存空间的分配与回收</strong>：OS 要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲；当进程运行结束之后，如何将进程占用的内存空间回收。</li>\n<li><strong>内存空间的扩充</strong>：OS 利用虚拟内存技术或自动覆盖技术使得系统运行很大的程序，从逻辑上扩充内存。</li>\n<li><strong>地址转换</strong>：为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而 逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，其中地址重定位有三种方式。</li>\n<li><strong>内存保护</strong>：保证各进程在各自存储空间内运行，互不干扰。</li>\n</ul>\n<p><strong>2.程序执行过程</strong></p>\n<p> 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>\n<ul>\n<li><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块，编译就是把高级语言翻译为机器语言。</li>\n<li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。</li>\n<li><strong>装入</strong>：由装入程序将装入模块装入内存运行。</li>\n</ul>\n<p><img src=\"../img/image-20240924145315187.png\" alt=\"image-20240924145315187\"></p>\n<blockquote>\n<p> 编译后，每个目标模块都是从 0 号单元开始编址，这称为该目标模块的 逻辑地址 (或相对地址)。当链接程序将各个模块连接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编制的 逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到内存的不同位置。<br>  物理地址空间 是指内存中物理单元的集合，它是地址转换的最终地址。进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址(动态重定位是地址转换推迟到程序真正要执行时才进行)，这个过程称为 地址重定位。</p>\n</blockquote>\n<p><strong>3.程序的链接</strong></p>\n<ul>\n<li><p>静态链接</p>\n<p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</p>\n<p><img src=\"../img/image-20240924145617627.png\" alt=\"image-20240924145617627\" style=\"zoom:67%;\" /></p>\n</li>\n<li><p>装入时动态链接</p>\n<p>将各 目标模块装入内存时，边装入边链接的链接方式。</p>\n<p><img src=\"../img/8c16054cc79ad9d7aa1f4272d47bd1f0.png\" alt=\"img\"></p>\n</li>\n<li><p>运行时动态链接</p>\n<p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>\n<p><img src=\"../img/92729923f21853518f365b97e015e43c.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p><strong>4.程序的装入</strong></p>\n<ul>\n<li><p>绝对装入</p>\n<p>在编译与链接后，得到的装入模块指定 直接使用了绝对地址。</p>\n<p><img src=\"../img/f861bacfb1e60f31f9660c2853cfd1c7.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<ul>\n<li><p>可重定位装入</p>\n<p>装入时对地址进行重定位，即将逻辑地址变换为物理地址，地址变换是在装入时一次完成的。</p>\n<p><img src=\"../img/26aa95967083ab795a5d6b9133a03aaa.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>静态重定位的特点：</strong> 在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p>\n</li>\n</ul>\n<ul>\n<li><p>动态运行时装入</p>\n<p>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址(装入时依然保持使用逻辑地址)，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p>\n<p><img src=\"../img/aa9297afe7e7a4476652ca71443cda23.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<p>  <img src=\"../img/image-20240924150105137.png\" alt=\"image-20240924150105137\"></p>\n<p>  <img src=\"../img/image-20240924150121567.png\" alt=\"image-20240924150121567\"></p>\n<p>  <strong>动态重定位特点：</strong> 可以将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间；采用动态重定位时允许程序在内存中发生移动。</p>\n<blockquote>\n<p>注：链接的作用是形成了完整的装入模块与逻辑地址，但逻辑地址到物理地址的转换过程是重定位，而不是装入。</p>\n</blockquote>\n<p><strong>5.内存映像</strong></p>\n<p> 不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素：</p>\n<ul>\n<li><strong>代码段</strong>：即程序的二进制代码，代码段是只读的，可以被多个进程共享。</li>\n<li><strong>数据段</strong>：即程序运行时加工处理的对象，包括全局变量和静态变量。</li>\n<li><strong>进程控制块（PCB）</strong>：存放在系统区。操作系统通过PCB来控制和管理进程。</li>\n<li><strong>堆</strong>：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。</li>\n<li><strong>栈</strong>：用来实现函数调用。从用户空间的最大地址往低地址方向增长。</li>\n</ul>\n<blockquote>\n<p>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。</p>\n<p>当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</p>\n<p>用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。</p>\n</blockquote>\n<p><img src=\"../img/9304d333e8d43db563574ee591d80468.png\" alt=\"image-20230914155418540\"></p>\n<p> 上图是一个进程在内存中的映像。</p>\n<ul>\n<li>其中，共享库用来存放进程用到的共享函数库代码，如printf函数等。</li>\n<li>在只读代码段中，.iit是程序初始化时调用的_init函数；.text是用户程序的机器代码；.rodata是只读数据。</li>\n<li>在读/写数据段中，.data是已初始化的全局变量和静态变量；.bss是未初始化及所有初始化为0的全局变量和静态变量。</li>\n</ul>\n<p><strong>6.内存保护</strong></p>\n<p>确保每个进程都有一个<strong>单独的内存空间</strong>。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p>\n<ul>\n<li><p>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</p>\n</li>\n<li><p>采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。</p>\n<p><strong>重定位寄存器</strong>含最小的物理地址值，<strong>界地址寄存器</strong>含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示。</p>\n<p><img src=\"../img/18710a746250ea764bd364450d1dd195.png\" alt=\"image-20230914160656627\"></p>\n<blockquote>\n<p>重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址；</p>\n<p>界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。</p>\n</blockquote>\n<p> 加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这<br>两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。</p>\n</li>\n</ul>\n<p><strong>7.内存共享</strong></p>\n<p>并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。</p>\n<p>可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。</p>\n<p>在实际运行时，每个进程有自己的私有数据段，可以更改自己私有的数据区数据，不可改变共享的代码。</p>\n<blockquote>\n<p>例：考虑一个可以同时容纳40个用户的多用户系统，他们同时执行一个文本编辑程序，若该程序有160KB代码区和40KB数据区，则共需8000KB的内存空间来支持40个用户。如果160KB代码是可分享的纯代码，则不论是在分页系统中还是在分段系统中，整个系统只需保留一份副本即可，此时所需的内存空间仅为40KB×40+160KB=1760KB。</p>\n<p>对于分页系统，假设页面大小为4KB，则代码区占用40个页面、数据区占用10个页面。为实现代码共享，应在每个进程的页表中都建立40个页表项，它们都指向共享代码区的物理页号。此外，每个进程还要为自己的数据区建立10个页表项，指向私有数据区的物理页号。</p>\n<p>对于分段系统，由于是以段为分配单位的，不管该段有多大，都只需为该段设置一个段表项（指向共享代码段始址，以及段长160KB）。由此可见，段的共享非常简单易行。</p>\n</blockquote>\n<p><strong>8.内存分配与回收</strong></p>\n<p>在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。</p>\n<p>为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式一一页式存储管理。</p>\n<p>引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。</p>\n<h3 id=\"3-1-2-覆盖与交换\"><a href=\"#3-1-2-覆盖与交换\" class=\"headerlink\" title=\"3.1.2 覆盖与交换\"></a>3.1.2 覆盖与交换</h3><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p>\n<p><strong>覆盖</strong></p>\n<ul>\n<li><p>基本思想：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个</p>\n<p>固定区</p>\n<p>和若干</p>\n<p>覆盖区</p>\n</li>\n</ul>\n<ul>\n<li>将经常活跃的部分放在固定区，其余部分按调用关系分段。</li>\n<li>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</li>\n</ul>\n<ul>\n<li><p>特点：</p>\n<ul>\n<li>打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行；</li>\n<li>内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存；</li>\n<li>覆盖技术对用户和程序员不透明。</li>\n</ul>\n</li>\n</ul>\n<p><strong>交换</strong></p>\n<ul>\n<li>基本思想：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。</li>\n<li>交换过程：例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</li>\n<li>问题：<ul>\n<li>交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>\n<li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li>\n<li>若换出进程，则必须确保该进程完全处于空闲状态。</li>\n<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li>\n<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>\n<li>普通的交换使用不多，但交换策略的某些变体在许多系统（如UNX）中仍发挥作用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>交换过程</strong></p>\n<p>下面是一个交换过程</p>\n<p><img src=\"../img/1515111-20200714085135718-1904010396.png\" alt=\"img\"></p>\n<p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p>\n<p><img src=\"../img/1515111-20200714085142723-2056104555.png\" alt=\"img\"></p>\n<p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为<code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</p>\n<p><strong>区别</strong></p>\n<p>交换技术主要在<strong>不同进程（或作业）之间</strong>进行，而覆盖则用于<strong>同一个程序或进程</strong>中。对于主存无法存放用户程序的矛盾，现代操作系统是通过<strong>虚拟内存技术</strong>来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>\n<h3 id=\"3-1-3-连续分配管理方式\"><a href=\"#3-1-3-连续分配管理方式\" class=\"headerlink\" title=\"3.1.3 连续分配管理方式\"></a>3.1.3 连续分配管理方式</h3><p>连续分配方式是指为一个用户程序分配一个连续的内存空间，包括单一连续分配、固定分区分配和动态分区分配。</p>\n<p><strong>单一连续分配</strong></p>\n<p>在单一连续分配方式中，内存被分为 系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>\n<p><img src=\"../img/27dbdf155f8f23e3367ee687e8f75616.png\" alt=\"img\"></p>\n<p><strong>优点：</strong> 实现简单；无外部碎片；可以采用覆盖技术扩充内存；无需采取内存保护，因为内存中永远只有一道程序。</p>\n<p><strong>缺点：</strong>只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p>\n<blockquote>\n<p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p>\n<p>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p>\n</blockquote>\n<p><strong>固定分区分配</strong></p>\n<p>固定分区分配是最简单的一种多道程序存储管理方式，它将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。当有空闲分区时，便可从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。划分分区有两种方法：</p>\n<ul>\n<li>分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。</li>\n<li>分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区，增加了灵活性。</li>\n</ul>\n<p><img src=\"../img/926581c9de988006e5e5318f2c7b6071.png\" alt=\"img\"></p>\n<p> 为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配），如下图所示。</p>\n<p><img src=\"../img/0b0e1c513e5a432db4b6715d368e5940.png\" alt=\"image-20230915143014357\"></p>\n<blockquote>\n<p>分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为“已分配”；若找不到这样的分区，则拒绝分配。</p>\n<p>回收内存时，只需将对应表项的状态置为“未分配”即可。</p>\n</blockquote>\n<p><strong>优点：</strong> 实现简单，无外部碎片。</p>\n<p><strong>缺点：</strong> 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。</p>\n<p><strong>动态分区分配</strong></p>\n<p>动态分区分配 又称为 可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统分区的大小和数目是可变的。</p>\n<blockquote>\n<p>例：如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。</p>\n<p>开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩4MB，进程4无法装入。</p>\n<p>在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。</p>\n<p>之后CPU又出现空闲，需要换入进程2，而主存无法容纳进程2，操作系统就换出进程1，换入进程2。</p>\n<p><img src=\"../img/a2f95847d9963b883e3ef7314d0bf1f0.png\" alt=\"image-20230915143834058\"></p>\n</blockquote>\n<p>紧凑技术：动态分区在开始时是很好的，但随着时间的推移，内存中会产生越来越多的外部碎片。需要通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p>\n<p> 在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>\n<ul>\n<li><p>首次适应（FirstFit）算法</p>\n<ul>\n<li><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>\n<li><strong>如何实现</strong>：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。</li>\n<li>算法简单，最好最快，回收分区后一般不需要对空闲分区队列重新排序</li>\n</ul>\n</li>\n<li><p>最佳适应（BestFit）算法</p>\n<ul>\n<li><strong>算法思想：</strong>优先使用更小的分区，以保留更多大分区。</li>\n<li><strong>如何实现：</strong>空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。</li>\n<li><strong>缺点：</strong>产生大量小的、难以利用的外部碎片</li>\n</ul>\n</li>\n<li><p>最坏适应（WorstFit）算法</p>\n<p>（最大适应算法）</p>\n<ul>\n<li><strong>算法思想：</strong>优先使用更大的分区，以防止产生太小的不可用的碎片。</li>\n<li><strong>如何实现：</strong>空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。</li>\n<li><strong>缺点：</strong>如果之后有“大进程”到达，无足够大连续内存空间分配。</li>\n</ul>\n</li>\n<li><p>邻近适应（NextFit）算法</p>\n<p>（循环首次适应算法）</p>\n<ul>\n<li><strong>算法思想：</strong>由首次适应演变而来，每次从上次查找结束位置开始查找。</li>\n<li><strong>如何实现：</strong>空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>\n<li><strong>缺点：</strong>导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">算法</th>\n<th style=\"text-align:center\">算法思想</th>\n<th style=\"text-align:center\">分区排列顺序</th>\n<th style=\"text-align:center\">优点</th>\n<th style=\"text-align:center\">缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">首次适应</td>\n<td style=\"text-align:center\">从头到尾找适合的分区</td>\n<td style=\"text-align:center\">空闲分区以地址递增次序排列</td>\n<td style=\"text-align:center\">性能最好 算法开销小</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">最佳适应</td>\n<td style=\"text-align:center\">优先使用更小的分区</td>\n<td style=\"text-align:center\">空闲分区以容量递增次序排列</td>\n<td style=\"text-align:center\">保留更大分区</td>\n<td style=\"text-align:center\">产生大量碎小的外部碎片；算法开销大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">最坏适应</td>\n<td style=\"text-align:center\">优先使用更大的分区</td>\n<td style=\"text-align:center\">空闲分区以容量递减次序排列</td>\n<td style=\"text-align:center\">减少难以利用的碎片</td>\n<td style=\"text-align:center\">大分区容易被用完；算法开销大</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">邻近适应</td>\n<td style=\"text-align:center\">每次从上次查找结束位置开始查找</td>\n<td style=\"text-align:center\">空闲分区以地址递增次序排列（可排列成循环链表)</td>\n<td style=\"text-align:center\">空闲分区有相同概率被使用，算法开销小</td>\n<td style=\"text-align:center\">使高地址大分区也被用完</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ol>\n<li><blockquote>\n<p>注：动态分区分配没有内部碎片，但是有外部碎片。</p>\n</blockquote>\n</li>\n<li><p>分区的分配与回收</p>\n<p>回收内存分区时，有可能遇到四种情况：</p>\n<ul>\n<li>回收区的后面有一个相邻的空闲分区。</li>\n<li>回收区的前面有一个相邻的空闲分区。</li>\n<li>回收区的前、后各有一个相邻的空闲分区。</li>\n<li>回收区的前、后都没有相邻的空闲分区。</li>\n</ul>\n<p>无论那种情况，都要遵循相邻的空闲分区要合并的原则。</p>\n</li>\n</ol>\n<h3 id=\"3-1-4-基本分页存储管理\"><a href=\"#3-1-4-基本分页存储管理\" class=\"headerlink\" title=\"3.1.4 基本分页存储管理\"></a>3.1.4 基本分页存储管理</h3><p> 固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。为了避免碎片的产出，引出了分页的思想。<br>​ <strong>分页的思想</strong>：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p>\n<p> 分页管理与固定分区类似，不会产生外部碎片；进程运行按块申请主存空间，只会在最后一块有内部碎片，每个进程平均只有半个块的内部碎片（页内碎片）。</p>\n<p><strong>基本概念</strong></p>\n<ul>\n<li><p>页面和页面大小</p>\n<ul>\n<li>进程中的块称为页或页面（Page)，</li>\n<li>内存中的块称为页框或页帧（Page Frame)</li>\n<li>外存也以同样的单位进行划分，直接称为块或盘块（Block)。</li>\n</ul>\n<p>进程在执行时需要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p>\n<p><img src=\"../img/749151c3d7cac9c9f1d9bda04f969778.png\" alt=\"img\"></p>\n<blockquote>\n<ul>\n<li>将内存空间分为一个个大小相等的分区，每个分区就是一个页框 。每个页框有一个编号，即 页框号，页框号 从 0 开始。</li>\n<li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 页或页面。每个页面也有一个编号，即 页号，页号也是 从 0 开始。</li>\n</ul>\n<p>页框=页帧=内存块=物理块=物理页面</p>\n</blockquote>\n<p>为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，</p>\n<ul>\n<li>页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；</li>\n<li>页面过大又会使页内碎片增多，降低内存的利用率。</li>\n</ul>\n</li>\n<li><p>地址结构</p>\n<p> 地址结构决定了虚拟内存的寻址空间有多大。</p>\n<p>分页存储管理的 逻辑地址结构 如下所示：</p>\n<p><img src=\"../img/55ce0972a2368261f981cb583b842b2c.png\" alt=\"img\"></p>\n<p> 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。</p>\n<p> 在上图所示的例子中，地址长度为 32 位，其中 0 ~ 11位 为页内偏移量(或称页内地址)，即每页大小为 4KB；12~31 位为页号，进程地址空间最多允许 220 页。</p>\n</li>\n<li><p>页表</p>\n<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张 页表。页表通常存在 PCB (进程控制块，在操作系统的内核地址空间)中。页表记录进程 页面 和实际存放的 内存块 之间的 映射关系。</p>\n<p><img src=\"../img/534ad1e965d5130557d4d1846a22fe4c.png\" alt=\"img\">  </p>\n</li>\n</ul>\n<ul>\n<li><p>一个进程对应一张页表。</p>\n</li>\n<li><p>进程的每个页面对应一个页表项。</p>\n</li>\n<li>每个页表项由页号和块号组成。</li>\n<li><p>每个页表项的长度是相同的。</p>\n<blockquote>\n<p>例：假设某系统物理内存大小为 4 GB，页面大小为 4 KB，则每个页表项至少应该为多少字节？</p>\n<ul>\n<li>内存块大小=页面大小=4KB=212B</li>\n<li>4GB的内存总共会被分为232／212=220个内存块</li>\n<li>内存块号的范围应该是0～220-1</li>\n<li>内存块号至少要用20 bit来表示</li>\n<li>至少要用3B来表示块号（3＊8=24 bit＞20bit）</li>\n</ul>\n<p>页表项在内存中是连续存放，因此页号是可以隐藏的，不占内存空间，页表项占 3 个字节。</p>\n</blockquote>\n<p>注：如果未特别强调，默认计算机按字节编址。</p>\n</li>\n</ul>\n<ul>\n<li><p>地址转换</p>\n<p><strong>分页存储特点：</strong> 虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。</p>\n<p>页号 = 逻辑地址 / 页面长度<br>页内偏移量 = 逻辑地址 % 页面长度</p>\n<p>如果要访问逻辑地址 A 的物理块，则</p>\n<ul>\n<li>确定逻辑地址 A 对应的页号 P</li>\n<li>找到 P 号页面在内存中的起始地址（需要查页表）</li>\n<li>确定逻辑地址 A 的页内偏移量 W</li>\n</ul>\n</li>\n</ul>\n<p><strong>基本地址变换机构</strong></p>\n<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。变换机构如下图所示。</p>\n<p><img src=\"../img/d4ad11f82dd93a7f3348b66ae515e1b1.png\" alt=\"image-20230915162458487\"></p>\n<p>通常会在系统中设置一个 页表寄存器(PTR)，存放 页表在内存中的起始地址 F 和页表长度 M。<br>进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>\n<ul>\n<li><p>设页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下：</p>\n<p><img src=\"../img/42f549b9449ae19addc1aaafd85f29e3.png\" alt=\"img\"></p>\n<ul>\n<li><p><strong>计算页号P和页内偏移量W</strong></p>\n<p>如果用十进制数手算，则</p>\n<script type=\"math/tex; mode=display\">\nP=A/L，W=A%L</script><p>但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</p>\n</li>\n<li><p><strong>判断页号是否越界</strong></p>\n<p>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。</p>\n<p>注意：页号是从0开始的，而页表长度至少是1，因此P=M时也会越界</p>\n</li>\n<li><p><strong>查页表，找页号对应的页表项，确定内存块号</strong></p>\n<script type=\"math/tex; mode=display\">\n页表中页号P对应的页表项地址=页表起始地址F+页号P∗页表项长度</script><p>取出该页表项内容b，即为内存块号。</p>\n<blockquote>\n<p><strong>注意区分页表项长度、页表长度、页面大小的区别。</strong></p>\n<p>页表长度指的是这个页表中总共有几个页表项，即总共有几个页；</p>\n<p>页表项长度指的是每个页表项占多大的存储空间；</p>\n<p>页面大小指的是一个页面占多大的存储空间</p>\n</blockquote>\n</li>\n<li><p><strong>用内存块号和偏移量得到物理地址</strong></p>\n<p>计算$E=b*L+W$，用得到的物理地址E去访存。</p>\n<p>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</p>\n</li>\n<li><p><strong>访问目标内存单元</strong></p>\n</li>\n</ul>\n<p>在分页存储管理（页式管理）的系统中，页是信息的物理单位，分页完全是系统行为，因此 页的大小由系统决定，逻辑地址在计算机的视角很好确定。所以，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>\n</li>\n</ul>\n<p><strong>具有快表的地址变换机构</strong></p>\n<p>快表，又称联想寄存器(TLB)，是一种 访问速度比内存快很多的高速缓存器，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/6d6a73e5f83c323fd40dc48cd8884ecb.png\" alt=\"image-20230915170102254\"></p>\n<blockquote>\n<p>注：TLB 不是内存；快表与 Cache(高速缓冲器) 的区别在于，块表中只有页表项的副本，而普通 Cache 中可能有其他各种数据的副本，可以把快表理解为一种特殊的 Cache。</p>\n</blockquote>\n<ul>\n<li><p>设某进程执行过程中要访问 (0,4) 这个逻辑地址，访问过程如下：</p>\n<p><img src=\"../img/312ec275aec5dc69fc58246d59da6475.png\" alt=\"img\"></p>\n<ul>\n<li>CPU 给出逻辑地址，由硬件进行地址转换，将页号与快表中的所有页号进行比较。</li>\n<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表命中，存取数据仅一次访存。</li>\n<li>如果没有找到匹配的页号，则需要访问内存中的页表。找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表未命中，存取数据需两次访存。</li>\n</ul>\n</li>\n</ul>\n<p>注：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定算法对旧的页表项进行替换（局部性原理）。</p>\n<p><strong>两级页表</strong></p>\n<p>两级页表的分配管理方式属于基本分页存储管理范畴，其用于解决页表项占据连续页框的问题。</p>\n<ul>\n<li><p>单级页表存在的问题</p>\n<p><strong>问题一</strong>：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p>\n<p><strong>解决</strong>：可建立两级页表，一级页表为页目录表，二级页表离散存储。</p>\n<p><strong>问题二</strong>：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p>\n<p><strong>解决</strong>：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>\n</li>\n<li><p>两级页表的原理、地址结构</p>\n<p>二级页表实际上是在原有页表结构上再加上一层页表，如下图所示。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/4d5ca09e07e16a27d6c0b93a69c9e6e0.png\" alt=\"image-20230915175632539\"></p>\n<p> 建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>\n<p><img src=\"../img/5a756645eecfa8464902de391c503f39.png\" alt=\"img\"></p>\n<blockquote>\n<p>例：某系统按字节寻址，支持 30 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B，试问逻辑地址的结构。</p>\n<p>页面大小为4KB=212B，则页内偏移量要用12位表示。</p>\n<p>30-12=18，则顷号用18位表示，即进程最多有218个页面，一共需要218个页表项来记录这些页面与物理块的映射关系，且页号范围是：0~218-1。</p>\n<p>页表项长度是4B，一个内存块（页框）最多存储4K/4=212/4=210个页表项。</p>\n<p>218个页表项则需要218/210=28个内存块才能存储。</p>\n<p>即需要专门给进程分配28=256个连续的物理块（页框）来存放它的页表。</p>\n<p>为避免连续占用内存块问题，可以设置28=256个二级页表，并用一级页表来记录这些二级页表，因此一级页号占8位。</p>\n</blockquote>\n</li>\n<li><p>地址变换</p>\n<p><strong>例：</strong> 将逻辑地址 (00000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p>\n<p><img src=\"../img/5fd2608345b21ab8084405cd4709a417.png\" alt=\"img\"></p>\n<p>首先，按照地址结构将逻辑地址拆分成三部分</p>\n<ul>\n<li>从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置。</li>\n<li>根据二级页号查二级页表，找到最终想访问的内存块号。</li>\n<li>结合页内偏移量得到物理地址。</li>\n</ul>\n<p>最终要访问的内存块号为 4，该内存块的起始地址为 4*4096 = 16384 页内偏移量为 4095。</p>\n<p>最终的物理地址为：16384 + 4095= 20479。</p>\n<blockquote>\n<p><strong>两次页表，若采用“快表”，需要3次访存。</strong></p>\n<ul>\n<li>第一次：访问页目录表。</li>\n<li>第二次：访问内存中的二级页表。</li>\n<li>第三次：访问目标内存单元。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>多级页表</p>\n<p>若分为两级页表后，页表依然很长，则可以采用更多级页表。并且，若采用多级页表机制，则各级页表的大小不能超过一个页面。</p>\n<blockquote>\n<p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用 (   ) 级页表，页内偏移量为 (   ) 位？</p>\n<p><img src=\"../img/b6e937c0771306cb37282a54cb09705c.png\" alt=\"img\"></p>\n<p>页面大小=4KB=212B，按字节编址，因此页内偏移量为12位。</p>\n<p>页号=40-12=28位</p>\n<p>页面大小=212B，页表项大小=4B，则每个页面可存放212/4=210个页表项。</p>\n<p>因此，各级页表最多包含210个页表项，需要10位二进制位才能映射到210个页表项。</p>\n<p>因此每一级的页表对应页号应为10位。总共28位的页号至少要分为3级。</p>\n</blockquote>\n<p>此外，若未用“快表”，N 级页表机制，需要 N+1 次访问内存。</p>\n</li>\n</ul>\n<h3 id=\"3-1-5-基本分段式存储管理\"><a href=\"#3-1-5-基本分段式存储管理\" class=\"headerlink\" title=\"3.1.5 基本分段式存储管理\"></a>3.1.5 基本分段式存储管理</h3><p> 分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。</p>\n<p> 分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p>\n<p><strong>分段</strong></p>\n<p>段式管理方式按照用户进程中的自然段划分逻辑空间。</p>\n<p><img src=\"../img/0726f8567702b6a2043804f8a7adecf8.png\" alt=\"img\"></p>\n<blockquote>\n<p>例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间。</p>\n</blockquote>\n<p>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</p>\n<p>其逻辑地址由段号S与段内偏移量W两部分组成，如下图所示分段系统中的逻辑地址结构。</p>\n<p><img src=\"../img/755c6500099267a6fe572021518b2ebe.png\" alt=\"image-20230918092323039\"></p>\n<p>其中，段号为16位，段内偏移量为16位，因此一个作业最多有216=65536段，最大段长为64KB。</p>\n<blockquote>\n<p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p>\n</blockquote>\n<p><strong>段表</strong></p>\n<p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称段表。</p>\n<p><img src=\"../img/f0c2c93fdedbd4f294ed9ed3bafe2e7c.png\" alt=\"img\"></p>\n<p>段表用于实现从逻辑段到物理内存区的映射。</p>\n<p>特点：</p>\n<ul>\n<li>① 每个段对应一个段表项，其中 记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li>\n<li>② 各个段表项的长度是相同的。</li>\n<li>③ 由于段表项长度相同，在内存中是连续存放，因此段号可以是隐含的，不占存储空间。</li>\n<li>④ 段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</li>\n</ul>\n<p><strong>地址变换机构</strong></p>\n<p> 分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p>\n<p><img src=\"../img/ffd845ea092224da1c75e4367a9bdd1a.png\" alt=\"img\"></p>\n<ul>\n<li><p>① <strong>根据逻辑地址得到段号，段内地址</strong></p>\n<p>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</p>\n</li>\n<li><p>② <strong>判断段号是否越界</strong></p>\n<p>比较段号S和段表长度M，若 $段号S≥段表长度M$ ，则产生越界中断，否则继续执行。</p>\n</li>\n<li><p>③ <strong>查询段表，找到对应段表项</strong></p>\n<p>段表中段号S对应的 $段表项地址=段表始址F+段号S×段表项长度$ 。</p>\n</li>\n<li><p>④ <strong>检查段内地址是否超过段长</strong></p>\n<p>取出该段表项的前几位得到段长C。若$段内偏移量W≥段长C$，则产生越界中断，否则继续执行。</p>\n</li>\n<li><p>⑤ <strong>计算得到物理地址</strong></p>\n<p>取出段表项中该段的始址b，计算 $物理地址E=段基址b+偏移量W$ ，得到物理地址E。</p>\n</li>\n<li><p>⑥ <strong>访问目标内存单元</strong></p>\n<p>用得到的物理地址E去访问内存。</p>\n</li>\n</ul>\n<p><strong>段的共享与保护</strong></p>\n<ul>\n<li><p>共享</p>\n<p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。</p>\n<p>不能修改的代码称为纯代码或可重入代码（它不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>\n</li>\n<li><p>保护</p>\n<p>分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。</p>\n<ul>\n<li><strong>存取控制保护</strong>：指在段表的每个表项中，设置“存取控制”字段，规定对该段的访问方式。</li>\n<li><strong>地址越界保护</strong>：指在进行存储访问时，要检查逻辑地址是否超出了进程的地址空间。</li>\n</ul>\n</li>\n</ul>\n<p><strong>分段、分页管理的对比</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">存储信息</th>\n<th style=\"text-align:center\">地址空间</th>\n<th style=\"text-align:center\">信息保护</th>\n<th style=\"text-align:center\">访存次数</th>\n<th style=\"text-align:center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">分页管理</td>\n<td style=\"text-align:center\">页是信息的物理单位 对用户透明 系统行为</td>\n<td style=\"text-align:center\">一维 记忆符(<A>)</td>\n<td style=\"text-align:center\">不易</td>\n<td style=\"text-align:center\">分页(单级页表)需两次访问 页表+目标内存单元</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">分段管理</td>\n<td style=\"text-align:center\">段是信息的逻辑单位 对用户可见 用户需求</td>\n<td style=\"text-align:center\">二维 段名+段内地址([D]\\</td>\n<td style=\"text-align:center\"><A>)</td>\n<td style=\"text-align:center\">容易 纯代码</td>\n<td>分段需两次访问 段表+目标内存单元</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"../img/f1eb690ea2b236695b93b0f5771a1bdd.png\" alt=\"img\"></p>\n<h3 id=\"3-1-6-段页式管理\"><a href=\"#3-1-6-段页式管理\" class=\"headerlink\" title=\"3.1.6 段页式管理\"></a>3.1.6 段页式管理</h3><p><strong>段页式管理结构</strong></p>\n<p> 分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。</p>\n<p> 段页式存储管理方式，将作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每个段分成若干大小固定的页，内存空间分为大小一个个大小相等的分区。如下图所示。</p>\n<p><img src=\"../img/2ad49fa0d18cf7013af33c2e39482820.png\" alt=\"image-20230918135016046\"></p>\n<p> 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。如下图所示。</p>\n<p><img src=\"../img/1889a034e107aa215ceea24ad729d965.png\" alt=\"image-20230918135200702\"></p>\n<p> 段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。</p>\n<p> 在一个进程中，段表只有一个，而页表可能有多个。</p>\n<blockquote>\n<p>例：如下图所示的段页式格式，</p>\n<p><img src=\"../img/509b5f62a7e6ebaafcd590aab77a7f42.png\" alt=\"img\"></p>\n<ul>\n<li>段号16位，因此进程中最多有216=64K个段。</li>\n<li>页号4位，因此每个段最多有24=16页。</li>\n<li>页内偏移量有12位，因此每个内存块大小为212=2KB</li>\n</ul>\n</blockquote>\n<p>分段对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段分页对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此，段页式管理的地址结构是二维的。</p>\n<p><strong>地址转换</strong></p>\n<p> 在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页号，最后形成物理地址。</p>\n<p><img src=\"../img/2aece5b9715e69f54d6d4e68e4d85410.png\" alt=\"image-20230918140200214\"></p>\n<p> 如下图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>\n<p><img src=\"../img/d78be82601ea4602581e533e6049351a.png\" alt=\"img\"></p>\n<ul>\n<li><p>根据逻辑地址得到段号、页号、页内偏移量</p>\n</li>\n<li><p>判断段号是否越界若S≥M，则产生越界中断，否则继续执行</p>\n</li>\n<li><p>查询段表找到对应的段表项，段表项的存放地址为</p>\n<script type=\"math/tex; mode=display\">\nF+S×段表顶长度</script></li>\n<li><p>检查页号是香越界，若页号≥页表长度，则发生越界中断，否则继续执行</p>\n</li>\n<li><p>根据页表存放块号、页号查询页表找到对应页表项</p>\n</li>\n<li><p>根据内存块号页内偏移量得到最终的物理地址</p>\n</li>\n<li><p>访问目标内存单元</p>\n</li>\n</ul>\n<h3 id=\"3-1-7-空闲内存管理\"><a href=\"#3-1-7-空闲内存管理\" class=\"headerlink\" title=\"3.1.7 空闲内存管理\"></a>3.1.7 空闲内存管理</h3><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p>\n<ul>\n<li><code>位图(bitmap)</code></li>\n<li><code>空闲列表(free lists)</code></li>\n</ul>\n<p><strong>使用位图的存储管理</strong></p>\n<p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p>\n<p><img src=\"../img/1515111-20200714085150268-572806460.png\" alt=\"img\"></p>\n<p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p>\n<p><strong>使用链表进行管理</strong></p>\n<p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p>\n<p><img src=\"../img/1515111-20200714085157166-241932461.png\" alt=\"img\"></p>\n<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 <code>首次适配(first fit)</code>。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p>\n<p>首次适配的一个小的变体是 <code>下次适配(next fit)</code>。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p>\n<p>另外一个著名的并且广泛使用的算法是 <code>最佳适配(best fit)</code>。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</p>\n<h2 id=\"3-2-虚拟内存管理\"><a href=\"#3-2-虚拟内存管理\" class=\"headerlink\" title=\"3.2 虚拟内存管理\"></a>3.2 虚拟内存管理</h2><h3 id=\"3-2-1-虚拟内存的基本概念\"><a href=\"#3-2-1-虚拟内存的基本概念\" class=\"headerlink\" title=\"3.2.1 虚拟内存的基本概念\"></a>3.2.1 虚拟内存的基本概念</h3><p><strong>传统存储管理方式的特征</strong></p>\n<ul>\n<li>传统存储管理方式<ul>\n<li>连续分配<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>非连续分配<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>基本段页式存储管理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>特征</strong>：</p>\n<ul>\n<li><p>一次性</p>\n<p>作业必须一次性全部装入内存后，才能开始运行</p>\n<p>这会导致两种情况：</p>\n<ul>\n<li>当作业很大而不能全部被装入内存时，将使该作业无法运行；</li>\n<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li>\n</ul>\n</li>\n<li><p><strong>驻留性</strong>：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待IO而被阻塞，可能处于长期等待状态。</p>\n</li>\n</ul>\n<p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p>\n<p><strong>局部性原理</strong></p>\n<p>快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。</p>\n<ul>\n<li><p><strong>时间局部性</strong>。</p>\n<p>程序中的某条指令一且执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。</p>\n</li>\n<li><p><strong>空间局部性</strong>。</p>\n<p>一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式聚存储的。</p>\n</li>\n</ul>\n<p><strong>虚拟存储器的定义和特征</strong></p>\n<p>尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：<code>管理软件的不断增大(managing bloatware)</code>。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为<code>页面(page)</code>的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>\n<p>程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p>\n<ul>\n<li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>\n<li><strong>对换性</strong>：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>\n<li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>\n</ul>\n<p><strong>虚拟内存技术的实现</strong></p>\n<p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p>\n<p>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）</p>\n<p>内存空间不够时，将内存中暂时用不到的信息换出到外存（页面置换功能）</p>\n<ul>\n<li><p>虚拟内存的实现方式</p>\n<ul>\n<li>请求分页存储管理</li>\n<li>请求分段存储管理</li>\n<li>请求段页式存储管理</li>\n</ul>\n</li>\n<li><p>所需要的</p>\n<p>硬件支持</p>\n<ul>\n<li>一定容量的内存和外存。</li>\n<li>页表机制（或段表机制），作为主要的数据结构。</li>\n<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>\n<li>地址变换机构，逻辑地址到物理地址的变换。</li>\n</ul>\n</li>\n</ul>\n<p><strong>分页</strong></p>\n<p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV REG,1000</span><br></pre></td></tr></table></figure>\n<p>这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>\n<p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成<code>虚拟地址空间(virtual address space)</code>，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。<strong>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</strong>。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元把<strong>虚拟地址映射为物理内存地址</strong>，像下图这样</p>\n<p><img src=\"../img/1515111-20200714085205876-305983549.png\" alt=\"img\"></p>\n<p>下面这幅图展示了这种映射是如何工作的</p>\n<p><img src=\"../img/1515111-20200714085219354-1718482722.png\" alt=\"img\"></p>\n<p>页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p>\n<p>在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是<code>虚拟地址</code>。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</p>\n<p><strong>页表</strong></p>\n<p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p>\n<p><img src=\"../img/1515111-20200714085228595-845668595.png\" alt=\"img\"></p>\n<p>因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p>\n<p><img src=\"../img/1515111-20200714085233808-1651600095.png\" alt=\"img\"></p>\n<p>通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</p>\n<p><strong>页表项的结构</strong></p>\n<p>下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</p>\n<p><img src=\"../img/1515111-20200714085241766-805387936.png\" alt=\"img\"></p>\n<p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是<code>页框号(Page frame number)</code>。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是<code>在/不在</code>位，如果此位上的值是 1，那么页表项是有效的并且能够被<code>使用</code>。如果此值是 0 的话，则表示该页表项对应的虚拟页面<code>不在</code>内存中，访问该页面会引起一个<code>缺页异常(page fault)</code>。</p>\n<p><code>保护位(Protection)</code> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，<strong>0 表示可读可写，1 表示的是只读</strong>。</p>\n<p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code>的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p>\n<p><code>访问位(Referenced)</code> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的<code>页面置换</code>算法中作用很大。</p>\n<p>最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</p>\n<h3 id=\"3-2-2-请求分页管理方式\"><a href=\"#3-2-2-请求分页管理方式\" class=\"headerlink\" title=\"3.2.2 请求分页管理方式\"></a>3.2.2 请求分页管理方式</h3><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</p>\n<p><strong>页表机制</strong></p>\n<p> 请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况。因此在请求页表项中增加了 4个字段，如下图所示。</p>\n<p><img src=\"../img/6e9f5235a74ce8010437f9186efb7b56.png\" alt=\"image-20230918151653087\"></p>\n<ul>\n<li><strong>状态位P</strong>：用于指示该页是否已调入内存，供程序访问时参考。</li>\n<li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</li>\n<li><strong>修改位M</strong>：标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。</li>\n<li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>\n</ul>\n<p><strong>缺页中断机构</strong></p>\n<p> 在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。</p>\n<ul>\n<li><strong>缺页中断执行过程</strong><ul>\n<li>先将缺页的进程阻塞（调页完成唤醒)，</li>\n<li>若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，</li>\n<li>若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。</li>\n</ul>\n</li>\n<li><strong>缺页中断和一般中断的区别</strong>：<ul>\n<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常。</li>\n<li>一条指令在执行期间，可能产生多次缺页中断。</li>\n</ul>\n</li>\n</ul>\n<p><strong>地址变换机构</strong></p>\n<p> 请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的，如产生和处理缺页中断，及从内存中换出一页的功能等等。</p>\n<ul>\n<li>新增步骤1：请求调页（查到页表项时进行判断）</li>\n<li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行)</li>\n<li>新增步骤3：需要修改请求页表中新增的表项</li>\n</ul>\n<p>请求分页管理的地址变换过程，如下图所示，红框部分为新增步骤：</p>\n<p><img src=\"../img/3e5e104d1b1adc0d28a4c037cb7720ba.png\" alt=\"image-20230918154105795\"></p>\n<ul>\n<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>\n<li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li>\n<li>需要用某种“页面置换算法”来决定一个换出页面（下节内容）</li>\n<li>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入换出太频繁，会有很大的开销。</li>\n<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>\n</ul>\n<h3 id=\"3-2-3-页框分配\"><a href=\"#3-2-3-页框分配\" class=\"headerlink\" title=\"3.2.3 页框分配\"></a>3.2.3 页框分配</h3><p><strong>驻留集大小</strong></p>\n<p>给一个进程分配的物理页框的集合就是这个进程的驻留集。</p>\n<ul>\n<li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率。</li>\n<li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高。</li>\n<li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。</li>\n</ul>\n<p><strong>内存分配策略</strong></p>\n<p> 在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。</p>\n<ul>\n<li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li>\n<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变</li>\n<li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</li>\n<li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li>\n</ul>\n<blockquote>\n<p>固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变</p>\n<p>局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</p>\n</blockquote>\n<p>三种组合方案：</p>\n<ul>\n<li><p><strong>固定分配局部置换</strong></p>\n<p>它为每个进程分配一定数目的物理块，在整个运行期间都不改变。</p>\n<p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p>\n</li>\n<li><p><strong>可变分配全局置换</strong></p>\n<p>为系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列。</p>\n<p>当某进程发生缺页时，系统从空闲物理块队列中取出物理块分配给该进程，井将欲调入的页装入其中。</p>\n</li>\n<li><p><strong>可变分配局部置换</strong></p>\n<p>它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出动态变换，频繁缺页，分配物理块，缺页率低，减少物理块</p>\n</li>\n</ul>\n<p><strong>物理块调入算法</strong></p>\n<p>采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法。</p>\n<ul>\n<li><strong>平均分配算法</strong>，将系统中所有可供分配的物理块平均分配给各个进程。</li>\n<li><strong>按比例分配算法</strong>，根据进程的大小按比例分配物理块。</li>\n<li><strong>优先权分配算法</strong>，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程；一部分则根据优先权分配。</li>\n</ul>\n<p><strong>调入页面的时机</strong></p>\n<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：</p>\n<ul>\n<li><strong>预调页策略：</strong>将预计在不久后便会被访问的页面预先调入内存；主要用于进程的首次调入，由程序员指出应先调入哪些页。</li>\n<li><strong>请求调页策略：</strong>进程在运行中需要访问的页面不再内存而提出请求，由系统将所需页面调入内存。每次仅调入一页，增加了磁盘I/O开销。</li>\n</ul>\n<p><strong>从何处调入页面</strong></p>\n<p> 请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。</p>\n<p> 对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘IO速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：</p>\n<ul>\n<li><p><strong>系统拥有足够的对换区空间</strong></p>\n<p>可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</p>\n</li>\n<li><p><strong>系统缺少足够的对换区空间</strong></p>\n<p>凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。</p>\n</li>\n<li><p><strong>UNIX方式</strong></p>\n<p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。</p>\n</li>\n</ul>\n<p><strong>如何调入页面</strong></p>\n<ul>\n<li><p>当进程所访问的页面不在内存中时（存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。</p>\n</li>\n<li><p>该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。</p>\n</li>\n<li><p>如果内存已满，则先按某种置换算法从内存中选出一页准备换出；</p>\n<ul>\n<li>如果该页未被修改过（修改位为0)，则无须将该页写回磁盘；</li>\n<li>如果该页已被修改（修改位为1)，则必须将该页写回磁盘，</li>\n</ul>\n<p>然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。</p>\n</li>\n<li><p>调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。</p>\n</li>\n</ul>\n<h3 id=\"3-2-4-页面置换算法\"><a href=\"#3-2-4-页面置换算法\" class=\"headerlink\" title=\"3.2.4 页面置换算法\"></a>3.2.4 页面置换算法</h3><p> 进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，选择调出页面的算法就称为页面置换算法。</p>\n<p><strong>最佳置换算法（OPT）</strong></p>\n<p> 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p>\n<p><img src=\"../img/ca56f289ef1a3a04b1a63e252ae3da3f.png\" alt=\"img\"></p>\n<p>最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</p>\n<p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p>\n<p>这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p>\n<p><strong>先进先出置换算法（FIFO，First-In,First-Out）</strong></p>\n<p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p>\n<p><img src=\"../img/a28d9927399a2733dd5df3c52afd7f75.png\" alt=\"img\"></p>\n<p>该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p>\n<ul>\n<li><p>Belady异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>\n<p>只有FIFO算法回产生Belady异常，算法性能差。</p>\n<p>该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>\n</li>\n</ul>\n<p><strong>二次机会页面置换算法</strong></p>\n<p>我们上面学到的 FIFO 链表页面有个<code>缺陷</code>，那就是出链和入链并不会进行 check <code>检查</code>，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 <code>R 位</code>，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</p>\n<p>这种算法叫做 <code>第二次机会(second chance)</code>算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</p>\n<p><img src=\"../img/1515111-20200714085312983-279241456.png\" alt=\"img\"></p>\n<p>a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</p>\n<p>假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置<code>装入时间</code>为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</p>\n<p>寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 <code>FIFO 算法</code>。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</p>\n<p><strong>最近最久未使用置换算法（LRU，Least Recently Used）</strong></p>\n<p> 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p>\n<p><img src=\"../img/0e6e764588a67518e439a707941ccf1f.png\" alt=\"img\"></p>\n<p> 该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>\n<p> 该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。</p>\n<p><strong>NFU(Not Frequently Used，最不常用)</strong></p>\n<p>算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p>\n<p>只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</p>\n<ul>\n<li>首先，在 R 位被添加进来之前先把计数器右移一位；</li>\n<li>第二步，R 位被添加到最左边的位而不是最右边的位。</li>\n</ul>\n<p>修改以后的算法称为 <code>老化(aging)</code> 算法，下图解释了老化算法是如何工作的。</p>\n<p><img src=\"../img/1515111-20200714085330342-706528504.png\" alt=\"img\"></p>\n<p>我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，<strong>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</strong>，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 <code>左侧</code> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p>\n<blockquote>\n<p>CPU正在以某个频率前进，该频率的周期称为<code>时钟滴答</code>或<code>时钟周期</code>。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。</p>\n</blockquote>\n<p>当缺页异常出现时，将<code>置换（就是移除）</code>计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</p>\n<p>这个算法与 LRU 算法有两个重要的区别：看一下上图中的 <code>e</code>，第三列和第五列</p>\n<p><img src=\"../img/1515111-20200714085337205-1208389842.png\" alt=\"img\"></p>\n<p><strong>最近未使用页面置换算法（NRU）</strong></p>\n<p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。<strong>每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</strong>，这些位包含在每个页表项中，就像下面所示</p>\n<p><img src=\"../img/1515111-20200714085304344-970286659-172734045291912.png\" alt=\"img\"></p>\n<p>因为每次访问时都会更新这些位，因此由<code>硬件</code>来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</p>\n<p>如果硬件没有这些位，那么可以使用操作系统的<code>缺页中断</code>和<code>时钟中断</code>机制来进行模拟。当启动一个进程时，将其所有的页面都标记为<code>不在内存</code>；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 <code>R 位(在它的内部表中)</code>，修改页表项使其指向正确的页面，并设置为 <code>READ ONLY</code> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 <code>READ/WRITE</code>。</p>\n<p>可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p>\n<p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p>\n<ul>\n<li>第 0 类：没有引用 R，没有修改 M</li>\n<li>第 1 类：没有引用 R，已修改 M</li>\n<li>第 2 类：引用 R ，没有修改 M</li>\n<li>第 3 类：已被访问 R，已被修改 M</li>\n</ul>\n<p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</p>\n<p><code>NRU(Not Recently Used)</code> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p>\n<p><strong>时钟置换算法（CLOCK）/最近未用算法（NRU）</strong></p>\n<p>简单的CLOCK算法实现方法：</p>\n<ul>\n<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</li>\n<li>当某页被访问时，其访问位置为1。</li>\n<li>当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，</li>\n<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li>\n</ul>\n<p><img src=\"../img/2d854077d564360483064cfd62cfd444.png\" alt=\"img\"></p>\n<p><strong>改进型的时钟置换算法</strong></p>\n<ul>\n<li><p>简单时钟问题：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>\n<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。</p>\n<p>修改位=0，表示页面没有被修改过：修改位=1，表示页面被修改过。</p>\n</li>\n<li><p>算法规则：将所有可能被置换的页面排成一个循环队列，用（访问位R，修改位M）表示各页面状态。</p>\n<blockquote>\n<p>替换帧优先级：</p>\n<ul>\n<li>1类R=0，M=0：最近未被访问且未被修改，是最佳淘汰页。</li>\n<li>2类R=0，M=1：最近未被访问，但已被修改，不是很好的淘汰页。</li>\n<li>3类R=1，M=0：最近已被访问，但未被修改，可能再被访问。</li>\n<li>4类R=1，M=1：最近已被访问且已被修改，可能再被访问。</li>\n</ul>\n</blockquote>\n<ul>\n<li><p><strong>第一轮</strong>：第一优先级——最近设访问，且没修改的页面</p>\n<p>从当前位置开始扫描到第一个(0，0)的帧用于替换。本轮扫描不修改任何标志位</p>\n</li>\n<li><p><strong>第二轮</strong>：第二优先级——最近没访问，但修改过的页面</p>\n<p>若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</p>\n</li>\n<li><p><strong>第三轮</strong>：第三优先级——最近访问过，但没修改的页面</p>\n<p>若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</p>\n</li>\n<li><p><strong>第四轮</strong>：第四优先级——最近访问过，且修改过的页面</p>\n<p>若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p>\n</li>\n</ul>\n<p>由于第二轮己将所有帧的访问位设为0，因此经过第三轮、第四轮扫描定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p>\n</li>\n<li><p>性能：算法开销较小，性能也不错</p>\n</li>\n</ul>\n<h3 id=\"3-2-5-抖动和工作集\"><a href=\"#3-2-5-抖动和工作集\" class=\"headerlink\" title=\"3.2.5 抖动和工作集\"></a>3.2.5 抖动和工作集</h3><p><strong>抖动</strong></p>\n<ul>\n<li>定义：抖动，又称颠簸，指在页面置换过程中，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存。</li>\n<li>抖动发生的原因：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。</li>\n<li>抖动的危害：<ul>\n<li>使得在系统中排队等待页面调入/调出的进程数目增加。</li>\n<li>对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入/换出，而几乎不能再去做任何有效的工作，</li>\n<li>进而导致发生处理机的利用率急剧下降并趋于零的情况。</li>\n</ul>\n</li>\n</ul>\n<p><strong>工作集</strong></p>\n<p>由于抖动的发生与系统为进程分配物理块的多少有关，于是又提出了关于进程工作集的概念。</p>\n<p>工作集是指在某段时间间隔内，进程要访问的页面集合。</p>\n<p> 基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集$W$可由时间$t$和工作集窗口大小$Δ$来确定。例如，某进程对页面的访问次序如下：</p>\n<p><img src=\"../img/204be7baf475277316bebbfd87f28f90.png\" alt=\"image-20230918174429395\"></p>\n<p> 假设系统为该进程设定的工作集窗口大小$Δ$为5，则在$t_1$时刻，进程的工作集为{2,3,5}，在$t_2$时刻，进程的工作集为{1,2,3,4}。</p>\n<p> 工作集大小一般会比窗口小很多，工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页。</p>\n<p> 一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。</p>\n<h3 id=\"3-2-6-内存映射文件\"><a href=\"#3-2-6-内存映射文件\" class=\"headerlink\" title=\"3.2.6 内存映射文件\"></a>3.2.6 内存映射文件</h3><p> 内存映射文件（Memory-MappedFiles）与虚拟内存有些相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件 I/O 操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。</p>\n<p><strong>特性</strong></p>\n<ul>\n<li>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间</li>\n<li>以访问内存的方式读写文件</li>\n<li>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</li>\n<li>多个进程可以映射同一个文件，方便共享</li>\n</ul>\n<p><img src=\"../img/c2ab516439d5e9140c4b6edc5c141680.png\" alt=\"image-20230918175326496\"></p>\n<p><strong>优点</strong></p>\n<ul>\n<li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li>\n<li>文件数据的读入/写出完全由操作系统负责，I\\O效率可以由操作系统负责优化</li>\n</ul>\n<h3 id=\"3-2-7-虚拟存储器性能影响因素\"><a href=\"#3-2-7-虚拟存储器性能影响因素\" class=\"headerlink\" title=\"3.2.7 虚拟存储器性能影响因素\"></a>3.2.7 虚拟存储器性能影响因素</h3><p><strong>页面大小</strong></p>\n<p>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。</p>\n<ul>\n<li>页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。</li>\n<li>页面较大时，虽然可以减少页表长度，但会使页内碎片增大。</li>\n</ul>\n<p><strong>分配给进程的物理块</strong></p>\n<p>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。</p>\n<p><strong>页面置换算法</strong></p>\n<p>好的页面置换算法可使进程在运行过程中具有较低的缺页率。</p>\n<p>选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。</p>\n<p><strong>写回磁盘的频率</strong></p>\n<p>换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。</p>\n<p>建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将其写回磁盘。</p>\n<p><strong>局部化程度</strong></p>\n<p>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象。</p>\n<h3 id=\"3-2-8-地址翻译\"><a href=\"#3-2-8-地址翻译\" class=\"headerlink\" title=\"3.2.8 地址翻译\"></a>3.2.8 地址翻译</h3><p>设某系统满足以下条件：</p>\n<ul>\n<li>有一个TLB与一个data Cache</li>\n<li>存储器以字节为编址单位</li>\n<li>虚拟地址14位</li>\n<li>物理地址12位</li>\n<li>页面大小为64B</li>\n<li>TLB为四路组相联，共有16个条目</li>\n<li>data Cache是物理寻址、直接映射的，行大小为4B，共有16组</li>\n</ul>\n<p>写出访问地址为0x03d4, 0x00f1和0x0229的过程。</p>\n<p><strong>写出其地址结构</strong></p>\n<p><img src=\"../img/00ce3c9594dc13aaf4da7599d24686e8.png\" alt=\"image-20230919094611325\"></p>\n<ul>\n<li><p><strong>根据页面大小求页内偏移量与页号长度</strong></p>\n<p>本系统以字节编址，页面大小为64B，则页内偏移量为$log_2(64B/1B)=6位$，所以虚拟页号为$14-6=8位$，物理页号为$12-6=6位$。</p>\n</li>\n<li><p><strong>根据TLB结构求虚拟页号地址结构</strong></p>\n<p>因为TLB为四路组相联，共有16个条目，则TLB有16/4=4组，因此虚拟页号低$log_24=2位$就为组索引，高6位为TLB标记。</p>\n</li>\n<li><p><strong>根据Cache机构求物理页号地址结构</strong></p>\n<p>因为Cache行大小为4B，因此物理地址中低$log_24=2位$为块索引，Cache共有16组，可知接下来$log_216=4位$为组索引，剩下高6位作为标记。</p>\n</li>\n</ul>\n<p><strong>根据TLB、页表寻找物理页号</strong></p>\n<p><img src=\"../img/6d377bd97d39896a6008f8cd604750b8.png\" alt=\"image-20230919094851074\"></p>\n<p>先把十六进制的虚拟地址0x03d4, 0x00f1和0x0229转化为二进制形式，如下表所示。</p>\n<p><img src=\"../img/8dc69a3ef7ba28d5dac71fa36ec737e0.png\" alt=\"image-20230919095151415\"></p>\n<p>得到每个地址的组索引和TLB标记，接下来就要找出每个地址的页面在不在主存中，若在主存中，则还要找出物理地址。</p>\n<ul>\n<li>查TLB得到物理块号<ul>\n<li>对于0x03d4，组索引为3，TLB标记为0x03。</li>\n<li>查TLB表，第3组中有标记为03的项，且有效位为1，找到物理块0D。</li>\n<li>拼接页内地址（010100），得到物理地址为0x354。</li>\n</ul>\n</li>\n<li>查TLB未得到物理块号，查页表得到物理块号<ul>\n<li>对于0x00f1，组索引为3，TLB标记为0x00。</li>\n<li>查TLB表，第3组未找到有标记为00的项。</li>\n<li>访存查页表，根据虚拟页号0x03，找到物理块号02，且有有效位为1。</li>\n<li>拼接页内地址（110001），得到物理地址为0x0b1。</li>\n</ul>\n</li>\n<li>查TLB未得到物理块号，查页表也未得到物理块号<ul>\n<li>对于0x0229，组索引为0，TLB标记为0x02。</li>\n<li>查TLB表，第0组未找到有标记为02的项。</li>\n<li>访存查页表，根据虚拟页号0x08，页表08项有效位为0，页面不在主存中，产生缺页中断。</li>\n</ul>\n</li>\n</ul>\n<p><strong>根据Cache寻找内存地址</strong></p>\n<p><img src=\"../img/07d93d7298075e9c7e5ff403a9f306d5.png\" alt=\"image-20230919094903450\"></p>\n<p> 找出在主存中的页面的物理地址后，就要通过物理地址访问数据，接下来要找该物理地址的 内容在不在Cache中，物理地址结构如下表所示。</p>\n<p><img src=\"../img/e25c0db7d8634a5a712a67553f9c1333.png\" alt=\"image-20230919101554108\">)</p>\n<ul>\n<li>Cache块命中<ul>\n<li>对于0x354，Cache索引为5，Cache标记为0x0d。</li>\n<li>查询Cache索引为5的行，标记为0d，有效位为1，则该块在Cache中。</li>\n<li>偏移为0，即块0，可得虚拟地址0x03d4的内容为36H。</li>\n</ul>\n</li>\n<li>Cache块未命中<ul>\n<li>对于0x0b1，Cache索引为C，Cache标记为0x02。</li>\n<li>查询Cache索引为C的行，标记为02，有效位为0，则该块不在Cache中。</li>\n<li>需去访问主存查找，物理页号为2、偏移为0x31的内容。</li>\n</ul>\n</li>\n</ul>\n<p><strong>虚拟地址寻址总流程</strong></p>\n<p><img src=\"../img/7414ad8ca61d0e9ca1935949ac9fe98d.jpeg\" alt=\"b0b9bc36ae3ba18efd06a04216caa7f\"></p>\n<hr>\n<h1 id=\"四、文件管理\"><a href=\"#四、文件管理\" class=\"headerlink\" title=\"四、文件管理\"></a>四、文件管理</h1><h2 id=\"4-1-文件系统基础\"><a href=\"#4-1-文件系统基础\" class=\"headerlink\" title=\"4.1 文件系统基础\"></a>4.1 文件系统基础</h2><h3 id=\"4-1-1-文件的基本概念\"><a href=\"#4-1-1-文件的基本概念\" class=\"headerlink\" title=\"4.1.1 文件的基本概念\"></a>4.1.1 文件的基本概念</h3><p><strong>定义</strong></p>\n<p>文件是以计算机硬盘为载体的存储在计算机上的信息集合，在用户进行的输入、输出中，以文件位基本单位。</p>\n<p>文件管理系统是实现的文件的访问、修改和保存，对文件维护管理的系统。</p>\n<p><strong>文件的组成</strong></p>\n<ul>\n<li>存储空间：用于存储数据</li>\n<li>标签：便于对数据的分类和索引</li>\n<li>访问权限：不同用户对数据有不同的访问权限</li>\n</ul>\n<p><strong>文件的结构</strong></p>\n<ul>\n<li>数据项：是文件系统中最低级的数据组织形式，可分为以下两种类型：<ul>\n<li>基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。</li>\n<li>组合数据项：由多个基本数据项组成。</li>\n</ul>\n</li>\n<li>记录：是一组相关的数据项的集合，用于描述一个对象在某方面的属性。</li>\n<li>文件：是指由创建者所定义的、具有文件名的一组相关元素的集合，分为有结构文件和无结构文件两种。<ul>\n<li>在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；</li>\n<li>无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。</li>\n</ul>\n</li>\n</ul>\n<p><strong>文件的访问</strong></p>\n<p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p>\n<p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p>\n<p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p>\n<p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p>\n<h3 id=\"4-1-2-文件控制块和索引结点\"><a href=\"#4-1-2-文件控制块和索引结点\" class=\"headerlink\" title=\"4.1.2 文件控制块和索引结点\"></a>4.1.2 文件控制块和索引结点</h3><p><strong>文件的属性</strong></p>\n<ul>\n<li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li>\n<li>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li>\n<li>类型：指明文件的类型</li>\n<li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li>\n<li>大小：指明文件大小</li>\n<li>保护信息：对文件进行保护的访问控制信息</li>\n<li>创建时间、最后一次修改时间和最后一次存取时间：文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用。</li>\n</ul>\n<p>文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。</p>\n<p><strong>文件控制块FCB</strong></p>\n<p>文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。</p>\n<p>操作系统通过文件控制块（FCB）来维护文件元数据。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。下图为一个典型的FCB。</p>\n<p><img src=\"../img/de502bbc119348edf131dfd98b9904ab.png\" alt=\"image-20230919110034223\"></p>\n<p>FCB包含以下信息：</p>\n<ul>\n<li><strong>基本信息</strong>：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</li>\n<li><strong>存取控制信息</strong>：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。</li>\n<li><strong>使用信息</strong>：如文件建立时间、上次修改时间等。</li>\n</ul>\n<blockquote>\n<p>一个文件目录也被视为一个文件，称为目录文件。</p>\n</blockquote>\n<p><strong>索引结点</strong></p>\n<p> 在检索目录时，只用到了文件名，因此有的系统采用文件名与文件描述分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 i 结点（inode)。</p>\n<p> 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。</p>\n<blockquote>\n<p>假设一个FCB为64B，盘块大小是1KB，则每个盘块中可以存放16个FCB（FCB必须连续存放），若一个文件目录共有640个FCB，则查找文件平均需要启动磁盘20次。</p>\n<p>而在UNIX系统中，一个目录项仅占16B，其中14B是文件名，2B是 i 结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的1/4，大大节省了系统开销。</p>\n</blockquote>\n<ul>\n<li><p>磁盘索引结点</p>\n<p>它是指存放在磁盘上的索引结点。每个文件有一个唯一的磁盘索引结点，主要包括以下内容：</p>\n<ul>\n<li><strong>文件主标识符</strong>，拥有该文件的个人或小组的标识符。</li>\n<li><strong>文件类型</strong>，包括普通文件、目录文件或特别文件。</li>\n<li><strong>文件存取权限</strong>，各类用户对该文件的存取权限。</li>\n<li><strong>文件物理地址</strong>，每个索引结点中含有13个地址项，即iaddr(0)～iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。</li>\n<li><strong>文件长度</strong>，指以字节为单位的文件长度。</li>\n<li><strong>文件链接计教</strong>，在本文件系统中所有指向该文件的文件名的指针计数。</li>\n<li><strong>文件存取时间</strong>，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。</li>\n</ul>\n</li>\n<li><p>内存索引结点</p>\n<p>它是指存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在内存索引结点中增加了以下内容：</p>\n<ul>\n<li><p><strong>索引结点编号</strong>，用于标识内存索引结点。</p>\n</li>\n<li><p><strong>状态</strong>，指示 i 结点是否上锁或被修改。</p>\n</li>\n<li><p><strong>访问计数</strong>，每当有一进程要访问此 i 结点时，计数加1；访问结束减1。</p>\n</li>\n<li><p><strong>逻辑设备号</strong>，文件所属文件系统的逻辑设备号。</p>\n</li>\n<li><p><strong>链接指针</strong>，设置分别指向空闲链表和散列队列的指针。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-3-文件的操作\"><a href=\"#4-1-3-文件的操作\" class=\"headerlink\" title=\"4.1.3 文件的操作\"></a>4.1.3 文件的操作</h3><p><strong>文件的基本操作</strong></p>\n<p> 文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。</p>\n<ul>\n<li><p><strong>创建文件（create系统调用）</strong></p>\n<ul>\n<li>为新文件分配必要的外存空间；</li>\n<li>在目录 中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息。</li>\n</ul>\n</li>\n<li><p><strong>删除文件（delete系统调用）</strong></p>\n<ul>\n<li>先从目录中检索指定文件名的目录项</li>\n<li>然后释放该文件所占的存储空间，以便可被其他文件重复使用，并删除目录条目。</li>\n</ul>\n</li>\n<li><p><strong>读文件（read系统调用）</strong></p>\n<ul>\n<li>对于给定文件名，搜索目录以查找文件位置。</li>\n<li>系统维护一个读位置的指针。</li>\n<li>每当发生读操作时，更新读指针。</li>\n</ul>\n</li>\n<li><p><strong>写文件（write系统调用）</strong></p>\n<ul>\n<li>对于给定文件名，搜索目录以查找文件位置。</li>\n<li>系统必须为该文件维护一个写位置的指针。</li>\n<li>每当发生写操作时，便更新写指针。</li>\n</ul>\n<blockquote>\n<p>一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。</p>\n<p>由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度。</p>\n</blockquote>\n</li>\n<li><p><strong>重新定位文件</strong></p>\n<p>也称文件定位。搜索目录以找到适当的条目，并将当前文件位置指针重新定位到给定值。</p>\n<p>重新定位文件不涉及读、写文件。</p>\n</li>\n<li><p><strong>截断文件</strong></p>\n<p>允许文件所有属性不变，并删除文件内容，将其长度置为0并释放其空间。</p>\n</li>\n</ul>\n<p>这6个基本操作可以组合起来执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入新文件。</p>\n<p><strong>文件的打开与关闭</strong></p>\n<ul>\n<li><p><strong>打开文件（open系统调用）</strong></p>\n<ul>\n<li>过程：调用open根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置)，从外存复制到内存打开文件表的一个表目中，并将该表目的编号（也称索引）返回给用户。</li>\n</ul>\n<blockquote>\n<p>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”。</p>\n</blockquote>\n<p>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。</p>\n<p><img src=\"../img/fa3a23be2e461fed353d6c662fac7871.png\" alt=\"image-20230919114840253\"></p>\n<p>如上图所示，在多个不同进程同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。</p>\n<ul>\n<li>整个系统的打开文件表包含FCB的副本及其他信息。</li>\n<li>每个进程的打开文件表根据它打开的所有文件，包含指向系统表中适当条目的指针。</li>\n</ul>\n<p>一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目。</p>\n</li>\n<li><p><strong>关闭文件（close系统调用）</strong></p>\n<ul>\n<li>1.将进程的打开文件表相应表项删除</li>\n<li>2.回收分配给该文件的内存空间等资源</li>\n<li>3.系统打开文件表的打开计数器count减1，若count=0，则删除对应表项。</li>\n</ul>\n</li>\n</ul>\n<p>系统打开文件表为每个文件关联一个打开计数器（OpenCount)，以记录多少进程打开了该文件。</p>\n<blockquote>\n<p>文件名不必是打开文件表的一部分，因为一且完成对FCB在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。<br>因此，只要文件未被关闭，所有文件操作就通过打开文件表来进行。</p>\n</blockquote>\n<ul>\n<li>打开文件信息<ul>\n<li><strong>文件指针</strong>。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。</li>\n<li><strong>文件打开计数</strong>。计数器跟踪当前文件打开和关闭的数量。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。</li>\n<li><strong>文件磁盘位置</strong>。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息。</li>\n<li><strong>访问权限</strong>。每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的I/O请求。</li>\n</ul>\n</li>\n</ul>\n<p><strong>以下是与文件有关的最常用的一些系统调用：</strong></p>\n<ol>\n<li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li>\n<li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li>\n<li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li>\n<li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li>\n<li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li>\n<li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li>\n<li><code>append</code>，使用 append 只能向文件末尾添加数据。</li>\n<li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li>\n<li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li>\n<li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li>\n<li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li>\n</ol>\n<h3 id=\"4-1-4-文件保护\"><a href=\"#4-1-4-文件保护\" class=\"headerlink\" title=\"4.1.4 文件保护\"></a>4.1.4 文件保护</h3><p> 文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。</p>\n<p><strong>口令保护</strong></p>\n<p>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确。</p>\n<p>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</p>\n<p><strong>加密保护</strong></p>\n<p>用一个“密码“对文件加密，用户想要访问文件时，需要提供相同的“密码“才能正确的解密</p>\n<p>安全性高，但加密解密需要耗费一定的时间（Eg：异或加密）</p>\n<p><strong>访问控制</strong></p>\n<ul>\n<li><p>访问类型</p>\n<p>对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种。</p>\n<ul>\n<li>读。从文件中读。</li>\n<li>写。向文件中写。</li>\n<li>执行。将文件装入内存并执行。</li>\n<li>添加。将新信息添加到文件结尾部分。</li>\n<li>删除。删除文件，释放空间。</li>\n<li>列表清单。列出文件名和文件属性。</li>\n</ul>\n<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。</p>\n</li>\n<li><p>访问控制</p>\n<p> 解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。</p>\n<ul>\n<li>优点：可以使用复杂的访问方法，</li>\n<li>缺点：长度无法预计并且可能导致复杂的空间管理，</li>\n</ul>\n<p>使用精简的访问列表可以解决这个问题，精简的访问列表采用拥有者、组和其他三种用户类型。</p>\n<ul>\n<li>拥有者。创建文件的用户。</li>\n<li>组。一组需要共享文件且具有类似访问的用户。</li>\n<li>其他。系统内的所有其他用户。</li>\n</ul>\n<p>文件主在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，</p>\n<ul>\n<li>若用户是文件主，按照文件主所拥有的权限访问文件；</li>\n<li>若用户和文件主在同一个用户组，则按照同组权限访问，</li>\n<li>否则只能按其他用户权限访问。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-5-文件的逻辑结构\"><a href=\"#4-1-5-文件的逻辑结构\" class=\"headerlink\" title=\"4.1.5 文件的逻辑结构\"></a>4.1.5 文件的逻辑结构</h3><p> 文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构（存储结构）是从实现观点出发看到的文件在外存上的存储组织形式。</p>\n<p> 文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。</p>\n<p><strong>无结构文件（流式文件）</strong></p>\n<p>无结构文件将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合，以字节（Byte）为单位。</p>\n<ul>\n<li>只能通过穷举搜索的方式访问记录。</li>\n<li>其管理简单，用户操作方便。</li>\n<li>对基本信息单位操作不多的文件适于采用字符流的无结构文件。例如源程序文件、目标代码文件等。</li>\n</ul>\n<p><strong>有结构文件（记录式文件）</strong></p>\n<ul>\n<li><p>顺序文件</p>\n<p>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。</p>\n<p>各个记录在物理上可以顺序存储或链式存储。</p>\n<ul>\n<li><p>链式存储：无论是定长何变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p>\n</li>\n<li><p>顺序存储：</p>\n<p>可实现随机存取，记录长度为L，则第ⅰ个记录存放的相对位置是i*L</p>\n<p>若采用串结构，记录之间的顺序与关键字无关，无法快速找到某关键字对应的记录</p>\n<p>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</p>\n</li>\n</ul>\n<blockquote>\n<p>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取：若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p>\n</blockquote>\n<p>优点：读写一大批文件时，效率最高。适用于顺序存储设备（磁带）</p>\n<p>缺点：不方便增加、删除记录</p>\n</li>\n<li><p>索引文件</p>\n<ul>\n<li><p>索引表：高效查询变长记录文件。索引表本身是定长记录的顺序文件，因此可以快速找到第ⅰ个记录对应的索引项。</p>\n<p><img src=\"../img/18d18c39f0a10398da2f433c5cd5b279.png\" alt=\"image-20230920095845915\"></p>\n</li>\n<li><p>方式：可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找</p>\n<p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p>\n</li>\n</ul>\n</li>\n<li><p>索引顺序文件</p>\n<p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p>\n<ul>\n<li>将记录分组，每组对应一个素引表项</li>\n<li>检素记录时先顺序查索引表，找到分组，再顺序查找分组</li>\n<li>当记录过多时，可建立多级素引表</li>\n</ul>\n<p><img src=\"../img/eda5d0333dc755445c2c369e7cd69794.png\" alt=\"image-20230920100345089\"></p>\n<p>如上图所示，主文件名包含姓名和其他数据项。</p>\n<ul>\n<li>姓名为关键字，索引表中为每组的第一条记录（不是每条记录）的关键字值，用指针指向主文件中该记录的起始位置。</li>\n<li>索引表只包含关键字和指针两个数据项，所有姓名关键字递增排列。</li>\n<li>主文件中记录分组排列，同一个组中的关键字可以无序，但组与组之间的关键字必须有序。</li>\n<li>查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。</li>\n</ul>\n</li>\n<li><p>直接文件或散列文件（Hash File）</p>\n<p> 给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。</p>\n<p> 散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。</p>\n</li>\n</ul>\n<h3 id=\"4-1-6-文件的物理结构（分配）\"><a href=\"#4-1-6-文件的物理结构（分配）\" class=\"headerlink\" title=\"4.1.6 文件的物理结构（分配）\"></a>4.1.6 文件的物理结构（分配）</h3><p> 文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。</p>\n<p> 文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。</p>\n<p><strong>连续分配</strong></p>\n<p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p>\n<p><img src=\"../img/1515111-20200714085528167-2116651875.png\" alt=\"img\"></p>\n<p> 使用连续空间存储文件</p>\n<p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p>\n<p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 <code>3 又 1/2</code> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p>\n<p>连续的磁盘空间分配有两个优点。</p>\n<ul>\n<li>第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</li>\n<li>第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</li>\n</ul>\n<p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p>\n<p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</p>\n<p><img src=\"../img/1515111-20200714085535510-825018719.png\" alt=\"img\"></p>\n<p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p>\n<p>连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>\n<p><img src=\"../img/c4ac6db2de8f74a6c7a999ee546ed4da.png\" alt=\"image-20230920102136534\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>物理块号=起始块号+逻辑块号</li>\n<li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快。</li>\n<li>缺点：不方便文件拓展、存储空间利用率低、会产生磁盘碎片（外部碎片）。<ul>\n<li>文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。</li>\n<li>为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度。</li>\n<li>反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似）。</li>\n<li>很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</li>\n</ul>\n</li>\n<li>访存次数：访问第n条记录需访问磁盘1次</li>\n</ul>\n<p><strong>链接分配</strong></p>\n<p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</p>\n<p><img src=\"../img/1515111-20200714085543167-1286685243.png\" alt=\"img\"></p>\n<p> 以磁盘块的链表形式存储文件</p>\n<p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p>\n<p><img src=\"../img/1515111-20200714085600966-1958543627.png\" alt=\"img\"></p>\n<p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p>\n<p>另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</p>\n<p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p>\n<p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p>\n<p>访问第n条记录需访问磁盘n次</p>\n<ul>\n<li><p>隐式链接</p>\n<p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>\n<p><img src=\"../img/85699729cdec55f84515e90034272738.png\" alt=\"image-20230920102824900\" style=\"zoom:67%;\" /></p>\n<ul>\n<li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li>\n<li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li>\n<li>结论：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>显式链接</p>\n<p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</p>\n<p><img src=\"../img/1515111-20200714085606464-1681775963.png\" alt=\"img\"></p>\n<p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table,FAT)</code>。</p>\n<p>把用于链接文件各物理块的指针显式地存放在文件分配表（FAT）中。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p>\n<p><img src=\"../img/9c66f8550939841c18f9d0a5a4cd00fc.png\" alt=\"image-20230920103203044\"></p>\n<ul>\n<li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li>\n<li>缺点：文件分配表的需要占用一定的存储空间。</li>\n<li>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问ⅰ号逻辑块时，并不需要依次访问之前的0~ｉ-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</li>\n</ul>\n</li>\n<li><p><strong>文件分配表</strong>：FAT不仅记录了文件分配信息（显示链接），还“兼职”做了空闲块管理</p>\n<p><img src=\"../img/a040781115559d02854ece51af18b5a9.png\" alt=\"image-20230920103528057\"></p>\n</li>\n</ul>\n<p><strong>索引分配</strong></p>\n<p> 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p>\n<p><img src=\"../img/image-20240925095754439.png\" alt=\"image-20240925095754439\"></p>\n<blockquote>\n<p>索引表的 逻辑块号 可以是隐含的，进一步节约空间；</p>\n</blockquote>\n<ul>\n<li><p>链接方案</p>\n<p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>\n<p><img src=\"../img/image-20240925100158713.png\" alt=\"image-20240925100158713\"></p>\n<p>缺点：需要顺序访问，当文件很大时，查我效率低下</p>\n</li>\n<li><p>多层索引</p>\n<p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p>\n<p><img src=\"../img/image-20240925100603070.png\" alt=\"image-20240925100603070\"></p>\n<p>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</p>\n<p>缺点：即使是小文件，访问数据块也需受K+1次读磁盘</p>\n</li>\n<li><p>混合索引</p>\n<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p>\n<p><img src=\"../img/image-20240925100644458.png\" alt=\"image-20240925100644458\"></p>\n<p>所允许的文件最大长度：设有N0个直接地址项；N1个一次间接地址项；N2个二次间接地址项；每个盘块大小M字节；盘块号占m个字节，公式如下：</p>\n<script type=\"math/tex; mode=display\">\n文件最大长度=(N_0 + N_1·\\frac{M}{m}+N_2·(\\frac{M}{m})^2)·M</script><p>优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）</p>\n</li>\n<li><p>总结</p>\n<p><img src=\"../img/image-20240925100810793.png\" alt=\"image-20240925100810793\"></p>\n</li>\n</ul>\n<h2 id=\"4-2-目录\"><a href=\"#4-2-目录\" class=\"headerlink\" title=\"4.2 目录\"></a>4.2 目录</h2><h3 id=\"4-2-1-目录的基本概念\"><a href=\"#4-2-1-目录的基本概念\" class=\"headerlink\" title=\"4.2.1 目录的基本概念\"></a>4.2.1 目录的基本概念</h3><p> 文件目录指FCB的有序集合，一个FCB就是一个文件的目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。</p>\n<ul>\n<li><p>目录管理的基本要求：</p>\n<ul>\n<li><p>从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；</p>\n</li>\n<li><p>目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；</p>\n</li>\n<li><p>在多用户系统中，应允许多个用户共享一个文件，因此目录还需要提供用于控制访问文件的信息。</p>\n</li>\n<li><p>此外，应允许不同用户对不同文件采用相同的名字，以便于用户按自己的习惯给文件命名，目录管理通过树形结构来解决和实现。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-2-目录结构\"><a href=\"#4-2-2-目录结构\" class=\"headerlink\" title=\"4.2.2 目录结构\"></a>4.2.2 目录结构</h3><p><strong>单级目录结构</strong></p>\n<p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，不允许文件重名，如下图所示。</p>\n<p><img src=\"../img/83cefcf1baf4519844090b1234142d68.png\" alt=\"image-20230920114101960\"></p>\n<p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。</p>\n<p>当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中。</p>\n<p><strong>两级目录结构</strong></p>\n<p> 将文件目录分成主文件目录（MFD）和用户文件目录（UFD）两级，不同用户的文件可以重名，但不能对文件分类。</p>\n<p><img src=\"../img/1e84a673804dfd96ad7d4a533e2fbd93.png\" alt=\"image-20230920114603663\"></p>\n<p>主文件目录项记录用户名及相应用户文件目录所在的存储位置。</p>\n<p>用户文件目录项记录该用户文件的FCB信息。</p>\n<p><strong>树形目录结构</strong></p>\n<p>不同目录下的文件可以重名，可以对文件进行分类，不方便共享。</p>\n<p><img src=\"../img/16a7f5fd6361193a6419f52fe433b918.png\" alt=\"image-20230920114906657\"></p>\n<p>根据“文件路径”找到目标文件。用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级日录之间用“/”隔开。从根目录出发的路径称为绝对路径(absolute path name)。</p>\n<blockquote>\n<p>例如：自拍.jpg的绝对路径是“/照片/2015-08/自拍jpg”</p>\n<p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍Jpg”的存放位置。整个过程需要3次读磁盘I/O操作。</p>\n</blockquote>\n<p>另外一种指定文件名的方法是 相对路径名(relative path name)。它常常和 工作目录(working directory) ，也称作当前目录(current directory），一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。</p>\n<p>引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。</p>\n<p>从根目录出发是绝对路径；从当前目录出发是相对路径。</p>\n<p><strong>无环图目录结构</strong></p>\n<p>在树形目录的基础上，增加一些指向同一结点的有向边，使整个目录成为一个有向无环图，实现文件的共享。</p>\n<p><img src=\"../img/209ca98c1f5f9894abcd98185c58367c.png\" alt=\"image-20230920134102332\"></p>\n<p>为共享结点设置一个共享计数器，计数器为0时才真正删除该结点。</p>\n<p>对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见。</p>\n<h3 id=\"4-2-3-目录的操作\"><a href=\"#4-2-3-目录的操作\" class=\"headerlink\" title=\"4.2.3 目录的操作\"></a>4.2.3 目录的操作</h3><ul>\n<li><strong>搜索</strong>。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。</li>\n<li><strong>创建文件</strong>。当创建一个新文件时，需要在目录中增加一个目录项。</li>\n<li><strong>删除文件</strong>。当删除一个文件时，需要在目录中删除相应的目录项。</li>\n<li><strong>创建目录</strong>。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。</li>\n<li><strong>删除目录</strong>。有两种方式：①不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。②可删除非空目录，目录中的文件和子目录同时被删除。</li>\n<li><strong>移动目录</strong>。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。</li>\n<li><strong>显示目录</strong>。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。</li>\n<li><strong>修改目录</strong>。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</li>\n</ul>\n<p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p>\n<ol>\n<li><code>Create</code>，创建目录，除了目录项 <code>.</code> 和 <code>..</code> 外，目录内容为空。</li>\n<li><code>Delete</code>，删除目录，只有空目录可以删除。只包含 <code>.</code> 和 <code>..</code> 的目录被认为是空目录，这两个目录项通常不能删除</li>\n<li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li>\n<li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li>\n<li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li>\n<li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li>\n<li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为<code>硬链接(hard link)</code>。</li>\n<li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li>\n</ol>\n<h3 id=\"4-2-4-目录实现\"><a href=\"#4-2-4-目录实现\" class=\"headerlink\" title=\"4.2.4 目录实现\"></a>4.2.4 目录实现</h3><p> 目录实现有线性列表和哈希表两种方式，线性列表实现对应线性查找，哈希表的实现对应散列查找。</p>\n<p><strong>线性列表</strong></p>\n<p>最简单的目录实现方法是，采用文件名和数据块指针的线性列表。</p>\n<ul>\n<li><p>当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。</p>\n</li>\n<li><p>当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。</p>\n</li>\n<li><p>当要</p>\n<p>重用目录项</p>\n<p>时有许多种方法：</p>\n<ul>\n<li>可以将目录项标记为不再使用，或将它加到空闲目录项的列表上，</li>\n<li>还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。</li>\n</ul>\n</li>\n</ul>\n<p>采用链表结构可以减少删除文件的时间。</p>\n<p>线性列表的优点在于实现简单，不过由于线性表的特殊性，查我比较费时。</p>\n<p><strong>哈希表</strong></p>\n<p>哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。</p>\n<ul>\n<li>优点：查找非常迅速，插入和删除也较简单，</li>\n<li><p>问题：需要一些措施来避免冲突（两个文件名称哈希到同一位置）。</p>\n<p>为了减少I/O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。</p>\n</li>\n</ul>\n<h3 id=\"4-2-5-文件共享\"><a href=\"#4-2-5-文件共享\" class=\"headerlink\" title=\"4.2.5 文件共享\"></a>4.2.5 文件共享</h3><p> 文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。</p>\n<p><strong>基于索引结点的共享方式</strong>（硬链接）</p>\n<p>各个用户的目录项指向同一个索引结点，索引结点中需要链接计数count，用于表示链接到本索引结点上的用户目录项数。</p>\n<p><img src=\"../img/d29dbf4413f0f5f0c12217b0adefaf64.png\" alt=\"image-20230920140425794\"></p>\n<p>某用户删除文件只是删除该用户的目录项，count—</p>\n<p>只有count==0才能真正删除文件数据和索引结点。</p>\n<p><strong>利用符号链实现文件共享</strong>（软链接）</p>\n<p>为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将该文件写入用户B的目录中，以实现用户B的目录与文件F的链接。</p>\n<p><img src=\"../img/8c2f5e4542e8ba69d7e2a56deb4a43ab.png\" alt=\"image-20230920140838755\"></p>\n<p>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式），操作系统根据路径一层层查找目录，最终找到共享文件。</p>\n<blockquote>\n<p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p>\n</blockquote>\n<p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）。</p>\n<p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问的速度要比硬链接更慢。</p>\n<p> 硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p>\n<h2 id=\"4-3-文件系统\"><a href=\"#4-3-文件系统\" class=\"headerlink\" title=\"4.3 文件系统\"></a>4.3 文件系统</h2><h3 id=\"4-3-1-文件系统结构\"><a href=\"#4-3-1-文件系统结构\" class=\"headerlink\" title=\"4.3.1 文件系统结构\"></a>4.3.1 文件系统结构</h3><p> 文件系统(File system)提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。</p>\n<p><img src=\"../img/4bb43743859a433ce080670671737004.png\" alt=\"img\"></p>\n<p>用一个例子来辅助记忆文件系统的层次结构：<br>假设某用户请求删除文件”D:/工作目录/学生信息.xIsx”的最后100条记录。</p>\n<ol>\n<li>用户需要通过操作系统提供的接口发出上述请求一一用户接口</li>\n<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项一一文件目录系统</li>\n<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限一一存取控制模块（存取控制验证层）</li>\n<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区</li>\n<li>知道了标记录对应的逻辑地址后，还需要转换成实际的物理地址一一物理文件系统</li>\n<li>要删除这条记录，必定要对磁盘设备发出请求一一设备管理程序模块</li>\n<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收一一辅助分配模块</li>\n</ol>\n<h3 id=\"4-3-2-文件系统布局\"><a href=\"#4-3-2-文件系统布局\" class=\"headerlink\" title=\"4.3.2 文件系统布局\"></a>4.3.2 文件系统布局</h3><p><strong>文件系统在磁盘中的结构</strong></p>\n<p>文件系统存储在磁盘中。大部分的磁盘能够划分出一到多个分区，叫做<strong>磁盘分区(disk partitioning)</strong>或者是磁盘分片(disk slicing)。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 <strong>主引导记录(Master Boot Record, MBR)</strong>，用来引导(boot)计算机。在 MBR 的结尾是<strong>分区表(partition table)</strong>。每个分区表给出每个分区由开始到结束的地址。</p>\n<p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p>\n<p>文件系统可能包括如下信息：启动存储在那里的操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。如下图所示。</p>\n<p><img src=\"../img/e7e56420c7956f01541a73700ee8c051.png\" alt=\"image-20230920143351257\"></p>\n<ul>\n<li><p><strong>主引导记录（MasterBootRecord，MBR)</strong>，位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。</p>\n</li>\n<li><p><strong>引导块（bootblock)</strong>，MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统。Windows系统称之为分区引导扇区。</p>\n<p><img src=\"../img/image-20240925102600648.png\" alt=\"image-20240925102600648\"></p>\n<p>除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有如上图所列的一些项目。</p>\n</li>\n<li><p><strong>超级块（superblock)</strong>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。</p>\n</li>\n<li><p><strong>文件系统中空闲块的信息</strong>，可以使用位示图或指针链接的形式给出。</p>\n</li>\n<li><p><strong>BitMap 位图或者 Bit vector 位向量</strong></p>\n<p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。</p>\n<p><img src=\"../img/1515111-20200714085506988-20775885.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>  <strong>使用链表进行管理</strong></p>\n<p>  在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p>\n<p>  <img src=\"../img/1515111-20200714085512657-81496852.png\" alt=\"img\"></p>\n<ul>\n<li><p><strong>碎片</strong></p>\n<p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>inode</strong></p>\n<p>然后在后面是一个 <code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</p>\n<p>有一种简单的方法可以找到它们 <code>ls -lai</code> 命令。让我们看一下根文件系统：</p>\n<p><img src=\"../img/1515111-20200714085519392-1166075175.png\" alt=\"img\"></p>\n<p>inode 节点主要包括了以下信息</p>\n<ul>\n<li>模式/权限（保护）</li>\n<li>所有者 ID</li>\n<li>组 ID</li>\n<li>文件大小</li>\n<li>文件的硬链接数</li>\n<li>上次访问时间</li>\n<li>最后修改时间</li>\n<li>inode 上次修改时间</li>\n</ul>\n<p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p>\n<p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p>\n</li>\n</ul>\n<p><strong>文件系统在内存中的结构</strong></p>\n<p> 内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构的类型可能包括：</p>\n<ul>\n<li><strong>内存中的安装表(mount table)</strong>，包含每个己安装文件系统分区的有关信息。</li>\n<li><strong>内存中的目录结构的缓存</strong>，包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。</li>\n<li><strong>整个系统的打开文件表</strong>，包含每个打开文件的FCB副本及其他信息。</li>\n<li><strong>每个进程的打开文件表</strong>，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息。</li>\n</ul>\n<p><strong>进程创建：</strong></p>\n<p> 为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式，它将为文件分配一个新的FCB。然后，系统将相应的目录读入内存，使用新的文件名和FCB进行更新，并将它写回磁盘。</p>\n<p>一旦文件被创建，它就能用于I/O，不过，首先要打开文件。系统调用open()将文件名传递给逻辑文件系统。</p>\n<p><img src=\"../img/image-20240925102818925.png\" alt=\"image-20240925102818925\"></p>\n<ul>\n<li><p>调用open()首先</p>\n<p>搜索整个系统的打开文件表，以确定这个文件是否已被其他进程使用。</p>\n<ul>\n<li>如果<strong>已被使用</strong>，则在单个进程的打开文件表中创建一个条目，让其指向现有整个系统的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。</li>\n<li>如果这个文件<strong>尚未打开</strong>，则根据给定文件名来搜索目录结构。部分目录结构通常缓存在内存中，以加快目录操作。</li>\n</ul>\n</li>\n<li><p>找到文件后，它的FCB会复制到整个系统的打开文件表中；该表不但存储FCB，而且跟踪打开该文件的进程的数量。</p>\n</li>\n<li><p>然后，在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域（如文件当前位置的指针和文件访问模式等）相连。</p>\n</li>\n<li><p>调用open()返回的是一个指向单个进程的打开文件表中的适当条自的指针。以后，所有文件操作都通过该指针执行。</p>\n</li>\n<li><p>一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符（Windows称之为文件句柄）</p>\n</li>\n</ul>\n<p><strong>进程关闭：</strong></p>\n<p> 当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除。</p>\n<h3 id=\"4-3-3-外存空闲空间管理\"><a href=\"#4-3-3-外存空闲空间管理\" class=\"headerlink\" title=\"4.3.3 外存空闲空间管理\"></a>4.3.3 外存空闲空间管理</h3><p> 一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为4个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷（volumme)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集，如图所示。</p>\n<p><img src=\"../img/0ce77849ad09f2e0dee9deaaa965235c.png\" alt=\"image-20230920152153475\"></p>\n<p> 在一个卷中，存放文件数据的空间（文件区）和FCB的空间（目录区）是分离的。</p>\n<p> 文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>\n<p><strong>空闲表法</strong></p>\n<p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。</p>\n<p><img src=\"../img/image-20240925102921132.png\" alt=\"image-20240925102921132\"></p>\n<ul>\n<li><p>盘块的分配</p>\n<p>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。</p>\n<p>同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p>\n</li>\n<li><p>盘块的回收</p>\n<p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：</p>\n<ul>\n<li>①回收区的前后都没有相邻空闲区</li>\n<li>②回收区的前后都是空闲区</li>\n<li>③回收区前面是空闲区</li>\n<li>④回收区后面是空闲区</li>\n</ul>\n<p>总之，回收时需要注意表项的合并问题</p>\n</li>\n</ul>\n<p><strong>空闲链表法</strong></p>\n<p>将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：</p>\n<ul>\n<li><p>空闲盘块链：将磁盘上的所有空闲空间以盘块为单位拉成一条链。</p>\n<p><img src=\"../img/image-20240925102941504.png\" alt=\"image-20240925102941504\"></p>\n<p>操作系统保存着链头、链尾指针。</p>\n<ul>\n<li>如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li>\n<li>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li>\n</ul>\n<p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p>\n</li>\n<li><p>空闲盘区链：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。</p>\n<p><img src=\"../img/image-20240925103013703.png\" alt=\"image-20240925103013703\"></p>\n<p>操作系统保存着链头、链尾指针。</p>\n<ul>\n<li><p>如何分配：</p>\n<p>若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。</p>\n<p>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p>\n</li>\n<li><p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>\n</li>\n</ul>\n<p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。</p>\n</li>\n</ul>\n<p><strong>位示图法</strong></p>\n<p> 位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。</p>\n<p> 这样，一个m×n位组成的位示图就可用来表示m×n个盘块的使用情况，如图所示。行为位号，列为字号</p>\n<p><img src=\"../img/175964c9d3647447448c902c2f824dbc.png\" alt=\"image-20230920153912806\"></p>\n<blockquote>\n<p>注意：盘块号、字号、位号到底是从0开始，还是从1开始。两者计算盘块号方式不同。</p>\n</blockquote>\n<ul>\n<li><p>盘块的分配</p>\n<ul>\n<li><p>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。</p>\n</li>\n<li><p>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值为“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n为每行位数）：</p>\n<p><img src=\"../img/image-20240925103417170.png\" alt=\"image-20240925103417170\"></p>\n</li>\n<li><p>修改位示图，令</p>\n<script type=\"math/tex; mode=display\">\nmap[i,j]=1</script></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>盘块的回收</p>\n<ul>\n<li><p>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为</p>\n<p><img src=\"../img/image-20240925103445261.png\" alt=\"image-20240925103445261\"></p>\n</li>\n<li><p>修改位示图，令</p>\n<script type=\"math/tex; mode=display\">\nmap[i,j]=0</script></li>\n</ul>\n</li>\n</ul>\n<p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>\n<p><strong>成组链接法</strong></p>\n<p> 在UNIX系统中采用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，它具有上述两种方法的优点，克服了两种方法均有的表太长的缺点。</p>\n<p> 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保<br>证内存与外存中的“超级块”数据一致。</p>\n<p><img src=\"../img/image-20240925103510379.png\" alt=\"image-20240925103510379\"></p>\n<p>用来存放一组空闲盘块号（空闲盘块的块号）的盘块称为成组链块。</p>\n<ul>\n<li><p><strong>成组链接思想</strong>：把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。</p>\n</li>\n<li><p>盘块的分配</p>\n<p><strong>分配1个空闲块</strong>：</p>\n<ul>\n<li>①检查第一个分组的块数是否足够。1＜100，是足够的。</li>\n<li>②分配第一个分组中的1个空闲块，并修改相应数据</li>\n</ul>\n<p><img src=\"../img/6db02c3ded4db41161eca6b541415d0c.png\" alt=\"img\"></p>\n<p><strong>分配100个空闲块</strong>：</p>\n<ul>\n<li>①检查第一个分组的块数是否足够。100=100，是足够的。</li>\n<li>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</li>\n</ul>\n<p><img src=\"../img/a84c2a3a434ec2f845de55f400e05f74.png\" alt=\"img\"></p>\n<p><img src=\"../img/6f285f9c4e6ff6873326b6245cf5120a.png\" alt=\"img\"></p>\n</li>\n<li><p>盘块的回收</p>\n<p>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p>\n<p><img src=\"../img/5232a485d9e20e41c472943edab7aec5.png\" alt=\"img\"></p>\n<p><img src=\"../img/5232a485d9e20e41c472943edab7aec5-1727231947103192.png\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"4-3-4-虚拟文件系统\"><a href=\"#4-3-4-虚拟文件系统\" class=\"headerlink\" title=\"4.3.4 虚拟文件系统\"></a>4.3.4 虚拟文件系统</h3><p> 虚拟文件系统（VFS）为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节。</p>\n<p><strong>普通文件系统</strong></p>\n<p> 下图普通的文件系统，不同的外部存储设备，它的文件系统可能是不相同的，对于同一个操作的函数方法定义也许也各不相同；</p>\n<p><img src=\"../img/image-20240925103924700.png\" alt=\"image-20240925103924700\"></p>\n<p><strong>虚拟文件系统</strong></p>\n<p> 下图为虚拟文件系统，用户程序可以通过VFS提供的统一调用函数（如open()等）来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。</p>\n<p><img src=\"../img/7143a1e868486d35819066abf7def878.png\" alt=\"image-20230920162505324\" style=\"zoom:67%;\" /></p>\n<p> 虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。</p>\n<p> 为了实现VFS，Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法（函数）表的指针。</p>\n<ul>\n<li>超级块对象：表示一个已安装（或称挂载）的特定文件系统。</li>\n<li>索引结点对象：表示一个特定的文件。</li>\n<li>目录项对象：表示一个特定的目录项。</li>\n<li>文件对象：表示一个与进程相关的已打开文件。</li>\n</ul>\n<p>进程与VFS对象之间的交互如下图所示。</p>\n<p><img src=\"../img/10f467bf6e9df1f7e5862de5373be97c.png\" alt=\"image-20230920163914222\"></p>\n<blockquote>\n<p>三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。</p>\n<p>在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引结点对象, 这个索引结点对象标识的是超级块对象及随后的普通磁盘文件。</p>\n</blockquote>\n<p> 对于不同文件系统的数据结构，VFS 在每打开一个文件，就在主存建立一个vnode，用统一的数据结构表示文件；</p>\n<p>打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</p>\n<p><img src=\"../img/0a4d0588af42cd387b01f903a68046bc.png\" alt=\"img\"></p>\n<blockquote>\n<p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p>\n</blockquote>\n<p><strong>特点：</strong></p>\n<ul>\n<li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li>\n<li>VFS要求下层的文件系统必须实现某些规定的函数功能，如：open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li>\n<li>每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li>\n</ul>\n<h3 id=\"4-3-5-日志结构文件系统\"><a href=\"#4-3-5-日志结构文件系统\" class=\"headerlink\" title=\"4.3.5 日志结构文件系统\"></a>4.3.5 日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p>\n<p>为此，<code>Berkeley</code> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 <code>日志结构文件系统(Log-structured File System, LFS)</code>。旨在解决以下问题。</p>\n<ul>\n<li>不断增长的系统内存</li>\n<li>顺序 I/O 性能胜过随机 I/O 性能</li>\n<li>现有低效率的文件系统</li>\n<li>文件系统不支持 RAID（虚拟化）</li>\n</ul>\n<p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code>的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p>\n<p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 <code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p>\n<p><img src=\"../img/1515111-20200714085626626-566608708.png\" alt=\"img\"></p>\n<p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p>\n<p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p>\n<p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p>\n<p><img src=\"../img/1515111-20200714085633269-183655433.png\" alt=\"img\"></p>\n<p><strong>日志文件系统</strong></p>\n<p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，它会记录系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、Linux 的 <code>ext3</code> 就使用了此日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code> ，这个操作在 UNIX 中需要三个步骤完成：</p>\n<ul>\n<li>在目录中删除文件</li>\n<li>释放 inode 到空闲 inode 池</li>\n<li>将所有磁盘块归还给空闲磁盘池。</li>\n</ul>\n<h3 id=\"4-3-6-分区和安装\"><a href=\"#4-3-6-分区和安装\" class=\"headerlink\" title=\"4.3.6 分区和安装\"></a>4.3.6 分区和安装</h3><p>分区</p>\n<ul>\n<li><p>物理格式化（低级格式化）：划分扇区、检测坏扇区、用备用扇区替换坏扇区；当要访问某一块坏扇区时，会使用备用扇区，默默完成替换工作；</p>\n<p><img src=\"../img/image-20240925104409063.png\" alt=\"image-20240925104409063\"></p>\n</li>\n<li><p>逻辑格式化（高级格式化）：磁盘分区；每个区的大小、地址范围等信息，会使用 分区表 来记录；</p>\n<p>在每个区里可以建立各自独立的文件系统 ，例如在C盘里建立UNIZX文件系统；</p>\n<p>分区的第一部分是引导块，里面存储着引导信息，它有自身的格式，因为在引导时系统并未 加载文件系统代码，因此不能解释文件系统的格式。下图为一个典型的Linux分区。</p>\n<p><img src=\"../img/abba422afa7a8c7d34462d83f22f2093.png\" alt=\"image-20230920164945003\">安装</p>\n</li>\n</ul>\n<p>文件系统在进程使用前必须先安装，也称挂载，任务是将一个文件系统挂载到操作系统中。</p>\n<p><strong>功能：</strong></p>\n<ul>\n<li>在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li>\n<li>新挂载的文件系统，要向VFS提供一个函数地址列表</li>\n<li>将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下</li>\n</ul>\n<blockquote>\n<p>UNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以首先要给根目录分配空间，这样才能操作这个目录树。</p>\n</blockquote>\n<h2 id=\"4-4-文件系统的管理和优化\"><a href=\"#4-4-文件系统的管理和优化\" class=\"headerlink\" title=\"4.4 文件系统的管理和优化\"></a>4.4 文件系统的管理和优化</h2><p>能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</p>\n<h3 id=\"4-4-1-磁盘空间管理\"><a href=\"#4-4-1-磁盘空间管理\" class=\"headerlink\" title=\"4.4.1 磁盘空间管理\"></a>4.4.1 磁盘空间管理</h3><p>文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：<strong>分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</strong>。在存储管理系统中，主要有<code>分段管理</code>和 <code>分页管理</code> 两种方式。</p>\n<p>正如我们所看到的，按<code>连续字节序列</code>存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p>\n<p><strong>块大小</strong></p>\n<p>一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照<strong>磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</strong>。在分页系统中，分页大小也是主要因素。</p>\n<p>拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块<code>太大</code>会浪费<code>空间</code>；分配的块<code>太小</code>会浪费<code>时间</code>。</p>\n<p><strong>记录空闲块</strong></p>\n<p>一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</p>\n<p><img src=\"../img/1515111-20200714085649026-429037597.png\" alt=\"img\"></p>\n<p>第一种方法是采用<code>磁盘块链表</code>，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</p>\n<p>另一种空闲空间管理的技术是<code>位图(bitmap)</code>，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</p>\n<h3 id=\"4-4-2-磁盘配额\"><a href=\"#4-4-2-磁盘配额\" class=\"headerlink\" title=\"4.4.2 磁盘配额\"></a>4.4.2 磁盘配额</h3><p>为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种<code>磁盘配额(enforcing disk quotas)</code>的机制。系统管理员为每个用户分配<strong>最大的文件和块分配</strong>，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</p>\n<p>在用户打开一个文件时，操作系统会找到<code>文件属性</code>和<code>磁盘地址</code>，并把它们送入内存中的打开文件表。其中一个属性告诉<code>文件所有者</code>是谁。任何有关文件的增加都会记到所有者的配额中。</p>\n<p><img src=\"../img/1515111-20200714085701057-1042245958.png\" alt=\"img\"></p>\n<p> 配额表中记录了每个用户的配额</p>\n<p>第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</p>\n<p>当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加<code>硬限制</code>和<code>软限制</code>的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</p>\n<h3 id=\"4-4-3-文件系统备份\"><a href=\"#4-4-3-文件系统备份\" class=\"headerlink\" title=\"4.4.3 文件系统备份\"></a>4.4.3 文件系统备份</h3><p>做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要<strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p>\n<p>其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种<code>增量转储(incremental dumps)</code> 的思想。最简单的增量转储的形式就是<code>周期性</code>的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</p>\n<p>稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为<strong>最近的全面转储先要全部恢复，随后按逆序进行增量转储</strong>。为了方便恢复，人们往往使用更复杂的转储模式。</p>\n<p>第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</p>\n<p>第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的<code>瞬时快照</code>，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</p>\n<p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。<code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</p>\n<p>第二个需要考虑的是<strong>坏块的转储</strong>。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些<code>坏块(bad blocks)</code>。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</p>\n<p>然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的<code>文件</code>来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。<strong>那么此文件是完全不可读的</strong>。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</p>\n<p>Windows 系统有<code>分页文件(paging files)</code> 和 <code>休眠文件(hibernation files)</code> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</p>\n<h3 id=\"4-4-4-文件系统的一致性\"><a href=\"#4-4-4-文件系统的一致性\" class=\"headerlink\" title=\"4.4.4 文件系统的一致性\"></a>4.4.4 文件系统的一致性</h3><p>影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p>\n<p>为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 <code>fsck</code>；Windows 有 <code>sfc</code>，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</p>\n<p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p>\n<h3 id=\"4-4-5文件系统性能\"><a href=\"#4-4-5文件系统性能\" class=\"headerlink\" title=\"4.4.5文件系统性能\"></a>4.4.5文件系统性能</h3><p>访问磁盘的效率要比内存满的多，是时候又祭出这张图了</p>\n<p><img src=\"../img/1515111-20200714085748222-602809625.png\" alt=\"img\"></p>\n<p>从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p>\n<p><strong>高速缓存</strong></p>\n<p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p>\n<p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p>\n<p>高速缓存的操作如下图所示</p>\n<p><img src=\"../img/1515111-20200714085753673-961783412.png\" alt=\"img\"></p>\n<p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p>\n<p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</p>\n<p><strong>块提前读</strong></p>\n<p>第二个明显提高文件系统的性能是，在需要用到块之前，试图<code>提前</code>将其写入高速缓存，从而<code>提高命中率</code>。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p>\n<p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p>\n<p><strong>减少磁盘臂运动</strong></p>\n<p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p>\n<p><strong>磁盘碎片整理</strong></p>\n<p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p>\n<p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p>\n<p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p>\n<hr>\n<h1 id=\"五、输入-输出（I-O）管理\"><a href=\"#五、输入-输出（I-O）管理\" class=\"headerlink\" title=\"五、输入/输出（I/O）管理\"></a>五、输入/输出（I/O）管理</h1><h2 id=\"5-1-I-O管理概述\"><a href=\"#5-1-I-O管理概述\" class=\"headerlink\" title=\"5.1 I/O管理概述\"></a>5.1 I/O管理概述</h2><h3 id=\"5-1-1-I-O设备\"><a href=\"#5-1-1-I-O设备\" class=\"headerlink\" title=\"5.1.1 I/O设备\"></a>5.1.1 I/O设备</h3><p> I/O设备是将数据输入到计算机中，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件；</p>\n<p><strong>设备的分类</strong></p>\n<ul>\n<li>按使用特性分类：<ul>\n<li>人机交互类外部设备：鼠标、键盘、打印机等，用于人机交互。数据传输速度慢。</li>\n<li>存储设备：移动硬盘、光盘等，用于数据存储。数据传输速度快。</li>\n<li>网络通信设备：调制解调器等，用于网络通信。数据传输速度介于上述二者之间。</li>\n</ul>\n</li>\n<li>按信息交换的单位分类：<ul>\n<li>块设备。信息交换以数据块为单位。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读/写任意一块。</li>\n<li>字符设备。信息交换以字符为单位。它属于无结构类型，如交互式终端机、打印机等。</li>\n</ul>\n</li>\n<li>按传输速率分类：<ul>\n<li>低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等。</li>\n<li>中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。</li>\n<li>高速设备。传输速率在数百千字节至千兆字节的一类设备，如磁盘机、光盘机等。</li>\n</ul>\n</li>\n</ul>\n<p><strong>I/O接口</strong></p>\n<p> I/O接口（设备控制器）位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能，主要由三部分组成，如下图所示。</p>\n<p><img src=\"../img/d9b0bdc5fe90d8338ec33b3d5e9f74e2.png\" alt=\"image-20230921092426001\"></p>\n<ul>\n<li><p>组成部分：</p>\n<ul>\n<li><p><strong>设备控制器与CPU的接口</strong>：实现控制器与CPU之间的通信</p>\n<p>该接口有三类信号线：数据线、地址线和控制线。</p>\n<p>数据线与两类寄存器相连：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制/状态寄存器（存放从CPU送来的控制信息或设备的状态信息）。</p>\n</li>\n<li><p><strong>设备控制器与设备的接口</strong>：实现控制器与设备之间的通信</p>\n<p>一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。</p>\n<p>每个接口中都存在数据、控制和状态三种类型的信号。</p>\n</li>\n<li><p><strong>I/O逻辑</strong>：负责识别CPU发出的命令，并向设备发出命令</p>\n<p>用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。</p>\n<p>CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。</p>\n</li>\n</ul>\n</li>\n<li><p>主要功能：</p>\n<ul>\n<li>接受和识别CPU发出的指令（控制寄存器）</li>\n<li>向CPU报告设备的状态（状态寄存器）</li>\n<li>数据交换（数据寄存器暂存数据）</li>\n<li>地址识别（由I/O逻辑实现）</li>\n<li>数据缓冲</li>\n<li>差错控制</li>\n</ul>\n</li>\n</ul>\n<p><strong>I/O端口</strong></p>\n<p>I/O端口是指设备控制器中可被CPU直接访问的寄存器，主要有以下三类寄存器。</p>\n<ul>\n<li><p>寄存器类型：</p>\n<ul>\n<li><strong>数据寄存器</strong>：实现CPU和外设之间的数据缓冲。</li>\n<li><strong>状态寄存器</strong>：获取执行结果和设备的状态信息，以让CPU知道是否准备好。</li>\n<li><strong>控制寄存器</strong>：由CPU写入，以便启动命令或更改设备模式。</li>\n</ul>\n</li>\n<li><p>实现I/O端口通信，有两种编址方法：</p>\n<p><img src=\"../img/9c979444f0dbecee20e3e592a028c38d.png\" alt=\"image-20230921095553061\"></p>\n<ul>\n<li><strong>独立编址</strong>。为每个端口分配一个I/O端口号，所有I/O端口形成I/O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I/O指令才能访问端口。</li>\n<li><strong>统一编址</strong>。又称内存映射I/O，每个端口被分配唯一的内存地址，且不会有内存被分配这地址，通常分配给端口的地址靠近地址空间的顶端。</li>\n</ul>\n</li>\n</ul>\n<p><strong>内存映射 I/O</strong></p>\n<p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p>\n<p>为了控制<code>寄存器</code>，许多设备都会有<code>数据缓冲区(data buffer)</code>，来供系统进行读写。</p>\n<p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code>号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IN REG,PORT</span><br></pre></td></tr></table></figure>\n<p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUT PORT,REG</span><br></pre></td></tr></table></figure>\n<p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p>\n<p>第二个方法是 PDP-11 引入的，它将<strong>所有控制寄存器映射到内存空间</strong>中。</p>\n<h3 id=\"5-1-2-I-O控制方式\"><a href=\"#5-1-2-I-O控制方式\" class=\"headerlink\" title=\"5.1.2 I/O控制方式\"></a>5.1.2 I/O控制方式</h3><p>设备管理的主要任务之一是控制设备和内存或CPU之间的数据传送。外围设备与内存之间的输入/输出控制方式有以下4种。</p>\n<p><strong>1.程序直接控制方式</strong></p>\n<p> 如下图所示，计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。</p>\n<p><img src=\"../img/dd5e14605b878bfc29ff5b8084140409.png\" alt=\"image-20230921095942792\" style=\"zoom:50%;\" /></p>\n<ul>\n<li><p>工作流程：</p>\n<p><img src=\"../img/ff2cb4979105d9fce3053be22570d861.png\" alt=\"img\"></p>\n<p><img src=\"../img/1515111-20200714085829438-728483880.png\" alt=\"img\"></p>\n</li>\n<li><p>CPU干预的频率：很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。</p>\n</li>\n<li><p>数据传送的单位：每次读/写一个字</p>\n</li>\n<li><p>数据的流向：</p>\n<ul>\n<li>读操作（数据输入）：I/O设备→CPU→内存</li>\n<li>写操作（数据输出）：内存→CPU→I/O设备</li>\n<li>每个字的读/写都需要CPU的帮助</li>\n</ul>\n</li>\n<li><p>优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可</p>\n</li>\n<li><p>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。</p>\n</li>\n</ul>\n<p><strong>2.中断驱动方式</strong></p>\n<p> 中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而”解放” CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。</p>\n<p><img src=\"../img/3c2cac4a5b95508d0756b349567eec9b.png\" alt=\"image-20230921101404684\" style=\"zoom:50%;\" /></p>\n<p><img src=\"../img/1515111-20200714085835271-1652743913.png\" alt=\"img\"></p>\n<ul>\n<li>工作流程：<ul>\n<li>引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。</li>\n<li>当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</li>\n<li>处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>①CPU会在每个指令周期的末尾检查中断：<br>②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的须率太高，也会降低系统性能。</p>\n</blockquote>\n<ul>\n<li>CPU干预的频率：每次I/O操作开始之前、完成之后需要CPU介入。等待I/O完成的过程中CPU可以切换到别的进程执行。</li>\n<li>数据传送单位：每次读/写一个字</li>\n<li>数据流向：<ul>\n<li>读操作（数据输入）：I/O设备→CPU→内存</li>\n<li>写操作（数据输出）：内存→CPU→I/O设备</li>\n</ul>\n</li>\n<li>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。CPU和I/O设备可并行工作，CPU利用率得到明显提升。</li>\n<li>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li>\n</ul>\n<p><strong>3.DMA方式</strong></p>\n<p> DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。下图为DMA工作流程。</p>\n<p><img src=\"../img/c6fc008c6d740d9c1b24addd53a8aa43.png\" alt=\"image-20230921102709807\" style=\"zoom:50%;\" /></p>\n<ul>\n<li><p>与“中断驱动方式”相比，DMA方式有这样几个改进：</p>\n<ul>\n<li>①数据的传送单位是“块”。不再是一个字、一个字的传送：</li>\n<li>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。</li>\n<li>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，数据传送通过DMA控制器完成。</li>\n</ul>\n</li>\n<li><p>DMA控制器组成：</p>\n<p>下图为DMA控制器的组成。</p>\n<p><img src=\"../img/eef38dc9a65b651fb962b48f1eeb5521.png\" alt=\"image-20230921102823702\"></p>\n<p>DMA控制器中设置如下4类寄存器：</p>\n<ul>\n<li><strong>数据寄存器（DR）</strong>。暂存从设备到内存或从内存到设备的数据。</li>\n<li><strong>内存地址寄存器（MAR）</strong>。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li>\n<li><strong>数据计数器（DC）</strong>。存放本次要传送的字（节）数，剩余要读/写的字节数。</li>\n<li><strong>命令/状态寄存器（CR）</strong>。接收从CPU发来的I/O命令、有关控制信息，或设备的状态。</li>\n</ul>\n</li>\n<li><p>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>\n</li>\n<li><p>数据传送单位：每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p>\n</li>\n<li><p>数据流向：</p>\n<ul>\n<li>读操作（数据输入）：I/O设备→内存</li>\n<li>写操作（数据输出）：内存→I/O设备</li>\n</ul>\n</li>\n<li><p>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。</p>\n</li>\n<li><p>缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要发出多条I/O指令，进行多次中断处理才能完成。</p>\n</li>\n</ul>\n<p><strong>4.通道控制方式</strong></p>\n<p>通道：I/O通道是指专门负责输入输出的处理机。是一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。</p>\n<blockquote>\n<p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>\n</blockquote>\n<ul>\n<li><p>完成一次读写流程：</p>\n<p><img src=\"../img/0155f5ab504073f232d4fcb4698ef89c.png\" alt=\"image-20230921104045623\" style=\"zoom:67%;\" /></p>\n</li>\n<li><p>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</p>\n</li>\n<li><p>数据传送的单位：每次读/写一组数据块</p>\n</li>\n<li><p>数据的流向（在通道的控制下进行）</p>\n<ul>\n<li>读操作（数据输入）：I/O设备→内存</li>\n<li>写操作（数据输出）：内存→I/O设备</li>\n</ul>\n</li>\n<li><p>缺点：实现复杂，需要专门的通道硬件支持</p>\n</li>\n<li><p>优点：CPU、通道、I/O设备可并行工作，资源利用率很高。</p>\n</li>\n</ul>\n<h3 id=\"5-1-3-IO-软件原理与目标\"><a href=\"#5-1-3-IO-软件原理与目标\" class=\"headerlink\" title=\"5.1.3 IO 软件原理与目标\"></a>5.1.3 IO 软件原理与目标</h3><p><strong>设备独立性</strong></p>\n<p>I/O 软件设计一个很重要的目标就是<code>设备独立性(device independence)</code>。这意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。</p>\n<p><img src=\"../img/1515111-20200714085842677-394938011.png\" alt=\"img\"></p>\n<p><strong>错误处理</strong></p>\n<p>除了<code>设备独立性</code>外，I/O 软件实现的第二个重要的目标就是<code>错误处理(error handling)</code>。通常情况下来说，错误应该交给<code>硬件</code>层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</p>\n<p>一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</p>\n<p>这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</p>\n<p><img src=\"../img/1515111-20200714085943299-279571663.png\" alt=\"img\"></p>\n<p>控制器能做的事情就是将备用扇区之一重新映射。</p>\n<p><img src=\"../img/1515111-20200714085954352-153585314.png\" alt=\"img\"></p>\n<p>还有一种处理方式是将所有的扇区都向上移动一个扇区</p>\n<p><img src=\"../img/1515111-20200714085958971-176105069.png\" alt=\"img\"></p>\n<p>上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</p>\n<p><strong>同步和异步传输</strong></p>\n<p>I/O 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code>传输。这里先说一下同步和异步是怎么回事吧。</p>\n<p>同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。大部分<code>物理IO(physical I/O)</code> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</p>\n<p><strong>缓冲</strong></p>\n<p>I/O 软件的最后一个问题是<code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</p>\n<p><strong>共享和独占</strong></p>\n<p>I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p>\n<p>一共有三种控制 I/O 设备的方法</p>\n<ul>\n<li>使用程序控制 I/O</li>\n<li>使用中断驱动 I/O</li>\n<li>使用 DMA 驱动 I/O</li>\n</ul>\n<h3 id=\"5-1-4-I-O软件层次结构\"><a href=\"#5-1-4-I-O软件层次结构\" class=\"headerlink\" title=\"5.1.4 I/O软件层次结构\"></a>5.1.4 I/O软件层次结构</h3><p> 为了更好地设计 I/O 软件，采用 层次式结构 的 I/O 软件；</p>\n<p> 一个比较合理的层次划分如上图所示。整个I/O软件可以视为具有4个层次的系统结构，各层次功能如下：</p>\n<p><img src=\"../img/1515111-20200714085850421-283295504.png\" alt=\"img\"></p>\n<p><strong>用户层软件</strong></p>\n<p> 实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。</p>\n<p> 用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务</p>\n<p><strong>设备独立性软件</strong></p>\n<p> 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p>\n<ul>\n<li><p>功能：</p>\n<ul>\n<li>向上层提供统一的调用接口（如read/write系统调用）</li>\n<li>设备的保护</li>\n<li>差错处理</li>\n<li>设备的分配与可收</li>\n<li>数据缓冲区管理</li>\n<li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li>\n</ul>\n</li>\n<li><p>逻辑设备</p>\n<p> 为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。</p>\n<p><strong>使用逻辑设备名好处</strong>：</p>\n<ul>\n<li>①增加设备分配的灵活性</li>\n<li><p>②易于实现I/O重定向，指用于I/O操作的设备可以更换(即重定向)，而不必改变应用程序。</p>\n<p>设备独立性软件需要通过“逻辑设备表（LUT，Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。</p>\n</li>\n</ul>\n<p><img src=\"../img/471ba638fcaac484ca38327b5a117063.png\" alt=\"image-20230921110346196\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>I/O设备被当做一种特殊的文件；不同类型的I/O设备需要有不同的驱动程序处理</p>\n</blockquote>\n<p>操作系统系统可以采用两种方式<strong>管理逻辑设备表（LUT）</strong>：</p>\n<ul>\n<li>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li>\n<li>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>设备驱动程序</strong></p>\n<p> 与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。 将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。</p>\n<p> 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p>\n<p> 为I/O内核子系统隐藏设备控制器之间的差异。</p>\n<p>设备控制器的主要功能有下面这些</p>\n<ul>\n<li>接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li>\n<li>进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li>\n<li>地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</li>\n<li>差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</li>\n</ul>\n<p>在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</p>\n<p>设备驱动程序必须是<code>可重入</code>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</p>\n<p><strong>中断处理程序</strong></p>\n<p> 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p>\n<ul>\n<li><p>中断处理程序的处理流程如下：</p>\n<p><img src=\"../img/bd3752171492b72db633d6736a11479e.png\" alt=\"image-20230901173205434\"></p>\n</li>\n<li><p>中断处理层的任务：</p>\n<ul>\n<li>进行进程上下文的切换，</li>\n<li>对处理中断信号源进行测试，</li>\n<li>读取设备状态和修改进程状态等。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。</p>\n</blockquote>\n<p><strong>总结</strong></p>\n<p>说明用户对设备的一次命令过程如下所示：</p>\n<ul>\n<li>①当用户要读取某设备的内容时，通过操作系统提供的read命令接口，这就经过了用户层。</li>\n<li>②操作系统提供给用户使用的接口，一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令，如read命令，用户发出的read命令，首先经过设备独立层进行解析，然后交往下层。</li>\n<li>③接下来，不同类型的设备对read命令的行为会有所不同，如磁盘接收read命令后的行为与打印机接收read命令后的行为是不同的。因此，需要针对不同的设备，把read命令解析成不同的指令，这就经过了设备驱动层。</li>\n<li>④命令解析完毕后，需要中断正在运行的进程，转而执行read命令，这就需要中断处理程序。</li>\n<li>⑤最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。</li>\n</ul>\n<p>直接涉及到硬件其体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；</p>\n<p>没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的。</p>\n<h3 id=\"5-1-5-应用程序I-O接口\"><a href=\"#5-1-5-应用程序I-O接口\" class=\"headerlink\" title=\"5.1.5 应用程序I/O接口\"></a>5.1.5 应用程序I/O接口</h3><p> 在I/O系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干接口。</p>\n<p><strong>字符设备接口</strong></p>\n<p> 字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入输出时通常采用中断驱动方式。</p>\n<ul>\n<li><p>字符设备的操作</p>\n<ul>\n<li><strong>get和put操作</strong>。由于字符设备不可寻址，只能采取顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。</li>\n<li><strong>in-control指令</strong>。字符设备类型繁多，差异甚大，因此在接口中提供一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。</li>\n</ul>\n<p>字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。</p>\n</li>\n</ul>\n<p><strong>块设备接口</strong></p>\n<p> 块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I/O常采用DMA方式。</p>\n<ul>\n<li><strong>隐藏了磁盘的二维结构</strong>：在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从0到n-1依次编号，这样，就将二维结构变为一种线性序列。</li>\n<li><strong>将抽象命令映射为低层操作</strong>：块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。</li>\n<li><strong>内存映射接口</strong>：内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读写一样简单，极大地方便了程序员。</li>\n</ul>\n<p><strong>网络设备接口</strong></p>\n<p> 许多操作系统提供的网络I/O接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。</p>\n<p><img src=\"../img/09ad248f1a3531d1dad793e5dcf4ef88.png\" alt=\"img\"></p>\n<p><strong>阻塞/非阻塞I/O</strong></p>\n<ul>\n<li><p><strong>阻塞I/O：</strong>当用户进程调用I/O操作时，进程就被阻塞，需要等待I/O操作完成，进程才被唤醒继续执行。</p>\n<p>eg：字符设备接口一一从键盘读一个字符get</p>\n</li>\n<li><p><strong>非阻塞I/O</strong>：用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I/O操作是否完成。</p>\n<p>eg：块设备接口一一往磁盘写数据write</p>\n</li>\n</ul>\n<h2 id=\"5-2-设备独立性软件\"><a href=\"#5-2-设备独立性软件\" class=\"headerlink\" title=\"5.2 设备独立性软件\"></a>5.2 设备独立性软件</h2><h3 id=\"5-2-1-与设备无关的软件\"><a href=\"#5-2-1-与设备无关的软件\" class=\"headerlink\" title=\"5.2.1 与设备无关的软件\"></a>5.2.1 与设备无关的软件</h3><p> 与设备无关的软件是I/O系统的最高层软件，它的下层是设备驱动程序。</p>\n<ul>\n<li>设备保护：<ul>\n<li>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）</li>\n<li>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-2-高速缓存与缓冲区\"><a href=\"#5-2-2-高速缓存与缓冲区\" class=\"headerlink\" title=\"5.2.2 高速缓存与缓冲区\"></a>5.2.2 高速缓存与缓冲区</h3><p><strong>磁盘高速缓存</strong>（Disk Cache）</p>\n<p>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对访问高速缓存要比访问原始磁盘数据更为高效。</p>\n<p> 磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p>\n<ul>\n<li><p>高速缓存在内存中分为两种形式：</p>\n<ul>\n<li>一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定</li>\n<li>另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。</li>\n</ul>\n</li>\n</ul>\n<p><strong>缓冲区</strong>（Buffer）</p>\n<ul>\n<li><p>概念：缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>\n<ul>\n<li>硬件做缓冲区：使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</li>\n<li>内存做缓冲区：一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>\n<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>\n<li>解决数据粒度不匹配的问题</li>\n<li>提高CPU与I/O设备之间的并行性</li>\n</ul>\n</li>\n<li><p><strong>单缓冲</strong></p>\n<p>若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>\n<p><img src=\"../img/2dbe1e36d8bdf88befc30d4ec2872177.png\" alt=\"image-20230921143949738\"></p>\n<p><img src=\"../img/20670607c65ee53296899767ccb5174f.png\" alt=\"image-20230921141924797\"></p>\n<blockquote>\n<p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p>\n</blockquote>\n<p>设块设备输入缓冲区时间为T，缓冲区传送至工作区时间为M，CPU处理工作区时间为C：</p>\n<ul>\n<li>若T&gt;C，从初始状态到下一个开始状态，整个过程用时为M+T</li>\n<li>若T&lt;C，从初始状态到下一个开始状态，整个过程用时为M+C</li>\n</ul>\n<p>结论：故单缓冲区处理每块数据的用时为$max(C,T)+M$。</p>\n<p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p>\n</li>\n<li><p><strong>双缓冲</strong></p>\n<p>若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p>\n<p><img src=\"../img/c06ddac52b7842bc82222e264888aef0.png\" alt=\"image-20230921143131283\"></p>\n<p><img src=\"../img/face760618e3217f19c30aa42200be8a.png\" alt=\"image-20230921144213776\"></p>\n<p>双缓冲题目中，假设初始状态为；工作区空，其中一个缓冲区满，另一个缓冲区空</p>\n<ul>\n<li>若T&gt;C+M，则处理一块数据的平均用时为T</li>\n<li>若T&lt;C+M，意味着输入数据块速度要比处理机处理数据块速度更快，处理一个数据块的平均耗时为C+M</li>\n</ul>\n<p>结论：采用双缓冲策略，处理一个数据块的平均耗时为$Max(T,C+M)$</p>\n<blockquote>\n<p><img src=\"../img/4b8b9a64f38bd9ac8d58c7bef98e4551.png\" alt=\"image-20230921144605057\"></p>\n<p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p>\n<p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</p>\n</blockquote>\n</li>\n<li><p><strong>循环缓冲</strong></p>\n<p>将多个大小相等的缓冲区链接成一个循环队列。</p>\n<p><img src=\"../img/e2d85fca53ab3a85c2093ddde173c69f.png\" alt=\"image-20230921144622956\" style=\"zoom:50%;\" /></p>\n<p>注：上图中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p>\n</li>\n<li><p><strong>缓冲池</strong></p>\n<p> 缓冲池由系统中共用的缓冲区组成。</p>\n<p>这些缓冲区按使用状况可以分为：</p>\n<ul>\n<li>空缓冲队列</li>\n<li>装满输入数据的缓冲队列（输入队列）</li>\n<li>装满输出数据的缓冲队列（输出队列）</li>\n</ul>\n<p><img src=\"../img/350784df13f2508f0e72b66380faea36.png\" alt=\"image-20230921145422899\" style=\"zoom:67%;\" /></p>\n<p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了<strong>四种工作缓冲区</strong>：</p>\n<ul>\n<li>用于收容输入数据的工作缓冲区（hin）</li>\n<li>用于提取输入数据的工作缓冲区（sin）</li>\n<li>用于收容输出教据的工作绥冲区（hout）</li>\n<li>用于提取输出数据的工作缓冲区（sout）</li>\n</ul>\n<p><strong>工作过程：</strong></p>\n<ul>\n<li><p><strong>输入进程请求输入数据</strong></p>\n<p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾</p>\n</li>\n<li><p><strong>计算进程想要取得一块输入数据</strong></p>\n<p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列</p>\n</li>\n<li><p><strong>计算进程想要将准备好的数据冲入缓冲区</strong></p>\n<p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”，数据冲满后将缓冲区挂到输出队列队尾</p>\n</li>\n<li><p><strong>输出进程请求输出数据</strong></p>\n<p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-3-设备的分配与回收\"><a href=\"#5-2-3-设备的分配与回收\" class=\"headerlink\" title=\"5.2.3 设备的分配与回收\"></a>5.2.3 设备的分配与回收</h3><p><strong>设备分配概述</strong></p>\n<p> 设备分配是指根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。</p>\n<p> 从设备特性来看，分为以下三种设备：</p>\n<ul>\n<li><strong>独占式使用设备</strong>。进程分配到独占设备后，便由其独占，直至该进程释放该设备。</li>\n<li><strong>分时式共享使用设备</strong>。对于共享设备，可同时分配给多个进程，通过分时共享使用。</li>\n<li><strong>以SPOOLing方式使用外部设备</strong>。SPOOLing技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I/O操作的批处理。</li>\n</ul>\n<p><strong>设备分配的数据结构</strong></p>\n<p> 设备分配依据的主要数据结构有<strong>设备控制表(DCT)</strong>、<strong>控制器控制表(COCT)</strong>、<strong>通道控制表 (CHCT)</strong>和<strong>系统设备表(SDT)</strong>，各数据结构功能如下。</p>\n<ul>\n<li><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>\n<p><img src=\"../img/71302c97dd28eeedb47c43bf09f9d77d.png\" alt=\"image-20230921152138973\"></p>\n</li>\n<li><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p>\n<p><img src=\"../img/7ed2ab70adcf6b7dc1562437f3be1b1c.png\" alt=\"image-20230921152213087\"></p>\n</li>\n<li><p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p>\n<p><img src=\"../img/0237318080ceb7d6f896541df15bf15d.png\" alt=\"image-20230921152241283\"></p>\n</li>\n<li><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。</p>\n<p><img src=\"../img/50de50847f827de97dec400eecb3d906.png\" alt=\"image-20230921152258475\"></p>\n</li>\n</ul>\n<p><strong>设备分配的策略</strong></p>\n<ul>\n<li><p><strong>设备分配原则</strong>。设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</p>\n</li>\n<li><p><strong>设备分配方式</strong>。设备分配方式有静态分配和动态分配两种。</p>\n<ul>\n<li><p>①静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器。</p>\n<p>静态分配方式不会出现死锁，但设备的使用效率低。</p>\n</li>\n<li><p>②动态分配：进程运行过程中动态申请设备资源。在进程执行过程中根据执行需要进行。</p>\n<p>这种方式有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>设备分配算法</strong>。常用的动态设备分配算法有先请求先分配、优先级高者优先等。</p>\n</li>\n</ul>\n<p><strong>设备分配的安全性</strong></p>\n<p>设备分配的安全性是指设备分配中应防止发生进程死锁。</p>\n<ul>\n<li><p><strong>安全分配方式</strong>。</p>\n<ul>\n<li>为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。</li>\n<li>优点：破坏了“请求和保持”条件，不会死锁</li>\n<li>缺点：对于一个进程来说，CPU和I/O设备只能串行工作</li>\n</ul>\n</li>\n<li><p><strong>不安全分配方式</strong>。</p>\n<p>进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。</p>\n<ul>\n<li>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</li>\n<li>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</li>\n</ul>\n</li>\n</ul>\n<p><strong>设备分配的步骤</strong></p>\n<ul>\n<li><p>步骤</p>\n<ul>\n<li>① 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li>\n<li>② 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li>\n<li>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>\n<li>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>\n</ul>\n<blockquote>\n<p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</p>\n</blockquote>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>\n<li>②若换了一个物理设备，则程序无法运行</li>\n<li>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>\n</ul>\n</li>\n</ul>\n<p><strong>设备分配步骤的改进</strong></p>\n<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。</p>\n<ul>\n<li><p><strong>逻辑设备表（LUT）</strong></p>\n<p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</p>\n<p><img src=\"../img/5c97584cbce271fc09632b56cafae088.png\" alt=\"image-20230921155858937\" style=\"zoom:67%;\" /></p>\n<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p>\n<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p>\n<ul>\n<li><strong>整个系统只有一张LUT</strong>：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li>\n<li><strong>每个用户一张LUT</strong>：不同用户的逻辑设备名可重复，适用于多用户操作系统</li>\n</ul>\n</li>\n<li><p>步骤</p>\n<ul>\n<li>根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li>\n<li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li>\n<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>\n<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-4-SPOOLing技术（假脱机技术）\"><a href=\"#5-2-4-SPOOLing技术（假脱机技术）\" class=\"headerlink\" title=\"5.2.4 SPOOLing技术（假脱机技术）\"></a>5.2.4 SPOOLing技术（假脱机技术）</h3><p><strong>概念</strong></p>\n<ul>\n<li><p><strong>脱机技术</strong>：脱离主机的控制进行的输入/输出操作。</p>\n<p>批处理阶段引入了脱机输入/输出技术（用磁带完成），在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。</p>\n</li>\n<li><p><strong>SPOOLing技术</strong>：“假脱机技术”，又称“SPOOLing技术”，用软件的方式模拟脱机技术。</p>\n<p><img src=\"../img/b91c63102e29125357aae907c6aad29e.png\" alt=\"image-20230921161835115\"></p>\n<p>要实现SPOOLing技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”</p>\n</li>\n</ul>\n<p><strong>原理</strong></p>\n<ul>\n<li>输入井和输出井<ul>\n<li>在磁盘上开辟出两个存储区域一一“输入井”和“输出井”</li>\n<li>”输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据</li>\n<li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li>\n</ul>\n</li>\n<li>输入进程和输出进程<ul>\n<li>“输入进程”模拟脱机输入时的外围控制机</li>\n<li>“输出进程”模拟脱机输出时的外围控制机</li>\n</ul>\n</li>\n<li>输入缓冲区和输出缓冲区<ul>\n<li>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</li>\n<li>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上</li>\n<li>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</li>\n</ul>\n</li>\n</ul>\n<p><strong>预读和滞后写</strong></p>\n<ul>\n<li><p>预读（提前读）：</p>\n<p>如果采用的顺序访问方式对文件进行访问，便可预知下一次要读的盘块。此时可采用预读策略，即在读当前块的同时，也将下一个盘块提前读入内存缓冲区，这样在访问下一个盘块时就不需要再启动磁盘，从而提升磁盘I/O速度。</p>\n</li>\n<li><p>滞后写（延迟写）</p>\n<p>滞后写是指缓冲区A中的数据本应立即写回磁盘，但考虑到其中的数据在不久之后有可能再次被访问，因此并不会立即把A中的数据写回磁盘，而是将缓冲区A挂到空闲缓冲区队列。如果有别的进程申请使用该缓冲区时，才把A中的数据写回磁盘。这样做的好处是，只要缓冲区A仍在队列中，任何访问该数据的进程，都可以直接读出其中的数据而不必访问磁盘。因而这种方式也可以减少磁盘I/O次数，改善性能。</p>\n</li>\n</ul>\n<p><strong>共享打印机的原理分析</strong></p>\n<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p>\n<p><img src=\"../img/d0282df42a8f739b365443b5532e6343.png\" alt=\"image-20230921163421824\"></p>\n<ul>\n<li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：<ul>\n<li>1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中</li>\n<li>2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li>\n</ul>\n</li>\n</ul>\n<p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p>\n<blockquote>\n<p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>\n</blockquote>\n<h3 id=\"5-2-5-设备驱动程序接口\"><a href=\"#5-2-5-设备驱动程序接口\" class=\"headerlink\" title=\"5.2.5 设备驱动程序接口\"></a>5.2.5 设备驱动程序接口</h3><p> 要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。这样会使得添加一个新设备驱动程序变得很容易，同时也便于开发人员编制设备驱动程序。</p>\n<p> 对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数。</p>\n<p> 与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。</p>\n<p> 在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I/O设备。系统管理员可以为每个设备设置适当的访问权限。</p>\n<h2 id=\"5-3-磁盘和固态硬盘\"><a href=\"#5-3-磁盘和固态硬盘\" class=\"headerlink\" title=\"5.3 磁盘和固态硬盘\"></a>5.3 磁盘和固态硬盘</h2><h3 id=\"5-3-1-磁盘\"><a href=\"#5-3-1-磁盘\" class=\"headerlink\" title=\"5.3.1 磁盘\"></a>5.3.1 磁盘</h3><p><strong>磁盘结构</strong></p>\n<p><img src=\"../img/aaecf2b97867daa17882ba0dac9b625f.png\" alt=\"image-20230921170548395\"></p>\n<ul>\n<li><p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>\n</li>\n<li><p>磁道：磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道</p>\n</li>\n<li><p>扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”各个扇区存放的数据量相同</p>\n<p>最内侧磁道上的扇区面积最小，因此数据密度最大</p>\n</li>\n<li><p>盘面：磁盘有多个盘片”摞”起来，每个盘片有两个盘面。</p>\n</li>\n<li><p>柱面：所有盘面中相对位置相同的磁道组成柱面。</p>\n</li>\n</ul>\n<p><strong>如何在磁盘中读</strong>/写数据</p>\n<p>需要把“磁头”移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。</p>\n<p><strong>磁盘的物理地址</strong>：磁盘地址用“柱面号•盘面号•扇区号”表示，可根据该地址读取一个“块”</p>\n<ul>\n<li>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</li>\n<li>②激活指定盘面对应的磁头；</li>\n<li>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>\n</ul>\n<p><strong>磁盘读写时间</strong></p>\n<ul>\n<li><p>寻找时间Ts：在读/写数据前，将磁头移动到指定磁道所花的时间。</p>\n<ul>\n<li><p>①启动磁头臂是需要时间的。假设耗时为s；</p>\n</li>\n<li><p>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间</p>\n<script type=\"math/tex; mode=display\">\nTs=s+ m*n</script></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>延迟时间TR：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p>\n<ul>\n<li><p>设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间</p>\n<script type=\"math/tex; mode=display\">\nTR=(1/2)*(1/r)= 1/2r</script></li>\n<li><p>硬盘的典型转速为5400 转/分，或7200转/分</p>\n</li>\n</ul>\n</li>\n<li><p>传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间</p>\n<ul>\n<li><p>假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。</p>\n</li>\n<li><p>则：传输时间</p>\n<script type=\"math/tex; mode=display\">\nTt=(1/r)*(b/N)= b/(rN)</script></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>平均存取时间</p>\n<ul>\n<li>总的平均存取时间<script type=\"math/tex; mode=display\">\nT=Ts + 1/2r + b/(rN)</script></li>\n</ul>\n</li>\n<li><p>延迟时间和传输时间都与磁盘转速相关，且为线性相关而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</p>\n</li>\n</ul>\n<p><strong>磁盘的分类</strong></p>\n<ul>\n<li>磁头是否移动<ul>\n<li>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道</li>\n<li>磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头</li>\n</ul>\n</li>\n<li>根据盘片是否可更换<ul>\n<li>固定盘磁盘</li>\n<li>可换盘磁盘</li>\n</ul>\n</li>\n</ul>\n<p><strong>RAID</strong></p>\n<p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p>\n<p>RAID 有不同的级别</p>\n<ul>\n<li>RAID 0 - 无容错的条带化磁盘阵列</li>\n<li>RAID 1 - 镜像和双工</li>\n<li>RAID 2 - 内存式纠错码</li>\n<li>RAID 3 - 比特交错奇偶校验</li>\n<li>RAID 4 - 块交错奇偶校验</li>\n<li>RAID 5 - 块交错分布式奇偶校验</li>\n<li>RAID 6 - P + Q冗余</li>\n</ul>\n<p><strong>磁盘格式化</strong></p>\n<p>磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，下面是一个扇区的格式</p>\n<p><img src=\"../img/1515111-20200714085914079-1275068101.png\" alt=\"img\"></p>\n<p>前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于<strong>设计者愿意牺牲多少磁盘空间来提高可靠性</strong>，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</p>\n<h3 id=\"5-3-2-磁盘管理\"><a href=\"#5-3-2-磁盘管理\" class=\"headerlink\" title=\"5.3.2 磁盘管理\"></a>5.3.2 磁盘管理</h3><p><strong>磁盘初始化</strong></p>\n<p> 一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化（或称物理格式化）。</p>\n<p> 低级格式化为每个扇区使用特殊的数据结构，填充磁盘。每个扇区的数据结构通常由头部、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息。</p>\n<p><strong>分区</strong></p>\n<p>在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步：</p>\n<ul>\n<li>第一步是，将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的C盘、D盘等形式的分区），每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li>\n<li>第二步是，对物理分区进行逻辑格式化（创建文件系统），操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。</li>\n</ul>\n<p>因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇（在Linux中称为块）。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是0字节），也要占用一簇的空间。</p>\n<p><strong>引导块</strong></p>\n<p> 计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存， 并转到起始地址，从而开始操作系统的运行。</p>\n<p> 自举程序通常存放在ROM中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。</p>\n<ul>\n<li><p>Windows允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。</p>\n</li>\n<li><p>Windows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录（MBR）。</p>\n</li>\n<li><p>引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码。</p>\n<p>除了包含引导代码，MBR还包含：一个磁盘分区表和一个标志（以指示从哪个分区引导系统）</p>\n</li>\n<li><p>当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。</p>\n</li>\n</ul>\n<p><strong>坏块</strong></p>\n<p>由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。</p>\n<ul>\n<li>对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明，因此程序不会使用它们。</li>\n<li>对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。<br>控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。</li>\n</ul>\n<p>对坏块的处理实质上就是用某种机制使系统不去使用坏块。</p>\n<p><strong>减少磁盘延迟时间的方法</strong></p>\n<ul>\n<li><p>磁盘地址结构的设计：</p>\n<ul>\n<li>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？</li>\n<li>答：读取地址连续的磁盘块时，采用这样的的地址结构可以减少磁头移动消耗的时间</li>\n</ul>\n</li>\n<li><p>方法</p>\n<ul>\n<li><p>交替编号</p>\n<ul>\n<li>具体做法：让编号相邻的扇区在物理上不相邻</li>\n<li>原理：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</li>\n</ul>\n</li>\n<li><p>错位命名</p>\n<ul>\n<li><p>具体做法：让相邻盘面的扇区编号”错位”</p>\n</li>\n<li><p>原理：与”交替编号”的原理相同。“错位命名法”可降低延迟时间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-3-3-磁盘调度算法\"><a href=\"#5-3-3-磁盘调度算法\" class=\"headerlink\" title=\"5.3.3 磁盘调度算法\"></a>5.3.3 磁盘调度算法</h3><p><strong>先来先服务（FCFS）</strong></p>\n<p>根据进程请求访问磁盘的先后顺序进行调度。</p>\n<p><img src=\"../img/7d44be1b580d4e1cc70894b9cfc49bef.png\" alt=\"image-20230922090407192\"></p>\n<ul>\n<li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li>\n<li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</li>\n</ul>\n<p><strong>最短路径优先(SSF) 算法</strong></p>\n<p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p>\n<p><img src=\"../img/1515111-20200714085921122-534748659.png\" alt=\"img\"></p>\n<p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p>\n<p><img src=\"../img/1515111-20200714085928775-114327480.png\" alt=\"img\"></p>\n<p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p>\n<p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p>\n<p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p>\n<p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN</code>时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p>\n<p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p>\n<p><img src=\"../img/1515111-20200714085936060-1574910407.png\" alt=\"img\"></p>\n<p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p>\n<p>电梯算法通常情况下不如 SSF 算法。</p>\n<p><strong>最短寻找时间优先（SSTF）</strong></p>\n<p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p>\n<p><img src=\"../img/c24b25115b642e6a68bfe8855206b4c0.png\" alt=\"image-20230922090856029\"></p>\n<ul>\n<li><p>优点：性能较好，平均寻道时间短</p>\n</li>\n<li><p>缺点：可能产生“饥饿”现象，磁头有可能在一个小区域内来回来去地移动。</p>\n<blockquote>\n<p>Eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>扫描算法（SCAN）</strong></p>\n<p>又称电梯算法，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。</p>\n<p><img src=\"../img/d8fd7547fbc40e835cf59e81a821537d.png\" alt=\"image-20230922091629172\"></p>\n<ul>\n<li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li>\n<li>缺点：<ul>\n<li>①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li>\n<li>②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li>\n</ul>\n</li>\n</ul>\n<p><strong>LOOK调度算法</strong></p>\n<p>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫 LOOK）</p>\n<p><img src=\"../img/37c004a197f6789f45bd8994f86ec5c5.png\" alt=\"image-20230922092519102\"></p>\n<ul>\n<li>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>\n</ul>\n<p><strong>循环扫描算法（C-SCAN）</strong></p>\n<p>只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>\n<p><img src=\"../img/e7c0a1c552691a257879240cd0e48804.png\" alt=\"image-20230922092744277\"></p>\n<ul>\n<li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</li>\n<li>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</li>\n</ul>\n<p><strong>C-LOOK 调度算法</strong></p>\n<p>如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>\n<p><img src=\"../img/0df5372298091ecbaf9bae91d05f0997.png\" alt=\"image-20230922092846866\"></p>\n<ul>\n<li>优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>\n</ul>\n<h3 id=\"5-3-4-固态硬盘\"><a href=\"#5-3-4-固态硬盘\" class=\"headerlink\" title=\"5.3.4 固态硬盘\"></a>5.3.4 固态硬盘</h3><p>固态硬盘的特性</p>\n<ul>\n<li><p>原理：固态硬盘(SSD)是基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM</p>\n</li>\n<li><p>组成：</p>\n<p><img src=\"../img/4a1d3bce14bd1400b99f48b6b2bcacf2.png\" alt=\"image-20230922093902941\"></p>\n<ul>\n<li>闪存翻译层：负责翻译逻辑块号，找到对应页（Page）</li>\n<li>存储介质：多个闪存芯片（Flash Chip）；每个芯片包含多个块（block）；每个块包含多个页（page）。</li>\n</ul>\n</li>\n<li><p>读写性能特性：</p>\n<ul>\n<li>数据是以页为单位读写的。相当于磁盘的“扇区”</li>\n<li>以块（bock）为单位“擦除“，擦干净的块，其中的每页都可以写一次，读无限次。</li>\n<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li>\n<li>读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</li>\n</ul>\n</li>\n<li><p>与机械硬盘对比</p>\n<ul>\n<li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机诚硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>\n<li>SSD安静无噪音、耐摔抗震、能耗低、造价更贵</li>\n<li>SSD的一个”块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li>\n</ul>\n</li>\n</ul>\n<p>磨碎均衡</p>\n<p>思想：将“擦除”平均分布在各个块上，以提升使用寿命</p>\n<ul>\n<li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。</li>\n<li>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</li>\n</ul>\n<blockquote>\n<p>例：某固态硬盘采用磨损均衡技术，大小为240B=1TB，闪存块的擦写寿命只有210=1K次。某男子平均每天会对该固态硬盘写237B=128GB数据。在最理想的情况下，这个固态硬盘可以用多久？</p>\n<p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。</p>\n<script type=\"math/tex; mode=display\">\n1T/128G=8</script><p>因此，平均8天，每个闪存块需要擦除一次。</p>\n<p>每个闪存块可以被擦除1K次，因此经过8K天，约23年，固态使用到寿命。</p>\n</blockquote>\n","feature":true,"text":"参考与转载链接 【王道】操作系统 知识点总结（合集）【超详细！】 - Zyyyyyyyyy - 博客园 (cnblogs.com) 王道操作系统知识点总结_住在...","permalink":"/post/操作系统","photos":[],"count_time":{"symbolsCount":"116k","symbolsTime":"1:46"},"categories":[{"name":"理论","slug":"理论","count":3,"path":"api/categories/理论.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA\"><span class=\"toc-text\">一、操作系统概论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.1基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">1.2特征</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8F%91%E5%B1%95\"><span class=\"toc-text\">1.3分类与发展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.4体系结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.5运行机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">1.6中断与异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">1.7系统调用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">二、进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2.1进程与线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">2.1.1 进程的概念和特征</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.1.2 进程的状态与转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-3%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.1.3进程的组织方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-4%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2.1.4进程的控制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-5%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">2.1.5进程的实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-6%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2.1.6进程的通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.1.7线程和多线程模型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">2.2 处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.2.1 调度的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E8%B0%83%E5%BA%A6%E7%9A%84%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">2.2.2 调度的目标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">2.2.3 调度的实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-4-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.2.4 典型的调度算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5\"><span class=\"toc-text\">2.3 同步与互斥</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.3.1 同步与互斥的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3.2 实现临界区互斥的基本方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-3-%E4%BA%92%E6%96%A5%E9%94%81\"><span class=\"toc-text\">2.3.3 互斥锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">2.3.4 信号量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-5-%E7%AE%A1%E7%A8%8B\"><span class=\"toc-text\">2.3.5 管程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.3.6 经典同步问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">2.4 死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2.4.1 死锁的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-2-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2\"><span class=\"toc-text\">2.4.2 死锁预防</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-3-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">2.4.3 死锁检测</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-4-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D\"><span class=\"toc-text\">2.4.4 死锁恢复</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-5-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D\"><span class=\"toc-text\">2.4.5 死锁避免</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-6-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4\"><span class=\"toc-text\">2.4.6 死锁检测和解除</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">三、内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.1 内存管理概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">3.1.1 内存管理的基本原理和要求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">3.1.2 覆盖与交换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.1.3 连续分配管理方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.1.4 基本分页存储管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.1.5 基本分段式存储管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-6-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.1.6 段页式管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-7-%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.1.7 空闲内存管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.2 虚拟内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">3.2.1 虚拟内存的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.2.2 请求分页管理方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D\"><span class=\"toc-text\">3.2.3 页框分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.2.4 页面置换算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-5-%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86\"><span class=\"toc-text\">3.2.5 抖动和工作集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.2.6 内存映射文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-7-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0\"><span class=\"toc-text\">3.2.7 虚拟存储器性能影响因素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-8-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91\"><span class=\"toc-text\">3.2.8 地址翻译</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">四、文件管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">4.1 文件系统基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1.1 文件的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-2-%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">4.1.2 文件控制块和索引结点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-3-%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4.1.3 文件的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-4-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">4.1.4 文件保护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-5-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4.1.5 文件的逻辑结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-6-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E5%88%86%E9%85%8D%EF%BC%89\"><span class=\"toc-text\">4.1.6 文件的物理结构（分配）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">4.2 目录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-1-%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.2.1 目录的基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-2-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4.2.2 目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4.2.3 目录的操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-4-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4.2.4 目录实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-5-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">4.2.5 文件共享</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">4.3 文件系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">4.3.1 文件系统结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">4.3.2 文件系统布局</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-3-%E5%A4%96%E5%AD%98%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.3.3 外存空闲空间管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-4-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">4.3.4 虚拟文件系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-5-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">4.3.5 日志结构文件系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-6-%E5%88%86%E5%8C%BA%E5%92%8C%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">4.3.6 分区和安装</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4.4 文件系统的管理和优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-1-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.4.1 磁盘空间管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-2-%E7%A3%81%E7%9B%98%E9%85%8D%E9%A2%9D\"><span class=\"toc-text\">4.4.2 磁盘配额</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD\"><span class=\"toc-text\">4.4.3 文件系统备份</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">4.4.4 文件系统的一致性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">4.4.5文件系统性能</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%EF%BC%88I-O%EF%BC%89%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">五、输入&#x2F;输出（I&#x2F;O）管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">5.1 I&#x2F;O管理概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-1-I-O%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">5.1.1 I&#x2F;O设备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-2-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">5.1.2 I&#x2F;O控制方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-3-IO-%E8%BD%AF%E4%BB%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">5.1.3 IO 软件原理与目标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">5.1.4 I&#x2F;O软件层次结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-5-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FI-O%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5.1.5 应用程序I&#x2F;O接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">5.2 设备独立性软件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-1-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">5.2.1 与设备无关的软件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">5.2.2 高速缓存与缓冲区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-3-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">5.2.3 设备的分配与回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-4-SPOOLing%E6%8A%80%E6%9C%AF%EF%BC%88%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%89\"><span class=\"toc-text\">5.2.4 SPOOLing技术（假脱机技术）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-5-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">5.2.5 设备驱动程序接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98\"><span class=\"toc-text\">5.3 磁盘和固态硬盘</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-%E7%A3%81%E7%9B%98\"><span class=\"toc-text\">5.3.1 磁盘</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-2-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">5.3.2 磁盘管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-3-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5.3.3 磁盘调度算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-4-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98\"><span class=\"toc-text\">5.3.4 固态硬盘</span></a></li></ol></li></ol></li></ol>","author":{"name":"Gueason","slug":"blog-author","avatar":"https://pic.quanjing.com/60/2a/QJ6771797507.jpg@!350h","link":"/","description":"小白，在成为“牛码”的路上","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"机器学习初级（搬运）","uid":"c8b121ec7894987ab65ba8cb5cccd987","slug":"机器学习初级","date":"2024-08-01T00:00:00.000Z","updated":"2024-09-28T07:36:04.696Z","comments":true,"path":"api/articles/机器学习初级.json","keywords":null,"cover":[],"text":"相关学习链接谷歌机器学习教育课程 线性回归 | Machine Learning | Google for Developers 动手学深度学习 https:/...","permalink":"/post/机器学习初级","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"41 mins."},"categories":[{"name":"Deep Learning","slug":"Deep-Learning","count":1,"path":"api/categories/Deep-Learning.json"}],"tags":[],"author":{"name":"Gueason","slug":"blog-author","avatar":"https://pic.quanjing.com/60/2a/QJ6771797507.jpg@!350h","link":"/","description":"小白，在成为“牛码”的路上","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}