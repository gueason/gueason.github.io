{"title":"计算机组成原理408（搬运）","uid":"85d3fedd41ce5b619a50d7691e9b44cb","slug":"计算机组成原理","date":"2024-05-31T16:00:00.000Z","updated":"2024-05-31T00:42:32.228Z","comments":true,"path":"api/articles/计算机组成原理.json","keywords":null,"cover":[],"content":"<h2 id=\"第一章-计算机系统概述\"><a href=\"#第一章-计算机系统概述\" class=\"headerlink\" title=\"第一章 计算机系统概述\"></a>第一章 计算机系统概述</h2><h3 id=\"1-1-本章大纲要求与核心考点\"><a href=\"#1-1-本章大纲要求与核心考点\" class=\"headerlink\" title=\"1.1 本章大纲要求与核心考点\"></a>1.1 本章大纲要求与核心考点</h3><h4 id=\"1-1-1-大纲内容\"><a href=\"#1-1-1-大纲内容\" class=\"headerlink\" title=\"1.1.1 大纲内容\"></a>1.1.1 大纲内容</h4><p>(一) 计算机系统层次结构</p>\n<ol>\n<li><p>计算机系统的基本组成</p>\n</li>\n<li><p>计算机硬件的基本结构</p>\n</li>\n<li><p>计算机软件和硬件的关系</p>\n</li>\n<li><p>计算机系统的工作原理</p>\n<p>“存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。</p>\n</li>\n</ol>\n<p>(二) 计算机性能指标</p>\n<p>​        吞吐量、响应时间；</p>\n<p>​        CPU时钟周期、主频、CPI、CPU执行时间；</p>\n<p>​        MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。</p>\n<h4 id=\"真题分布\"><a href=\"#真题分布\" class=\"headerlink\" title=\"真题分布\"></a>真题分布</h4>  <table style=\"text-align:center\">\n      <tr>\n          <th rowspan=\"2\">考点</th>\n          <th colspan=\"2\">考查次数</th>\n      </tr>\n      <tr>\n          <th>单项选择题</th>\n          <th>综合应用题</th>\n      </tr>\n      <tr>\n          <td>计算机系统层次结构</td>\n          <td>6</td>\n          <td>0</td>\n      </tr>\n      <tr>\n          <td>计算机性能指标</td>\n          <td>9</td>\n          <td>2</td>\n      </tr>\n  </table>\n\n\n<hr>\n<h3 id=\"1-2-计算机系统简介\"><a href=\"#1-2-计算机系统简介\" class=\"headerlink\" title=\"1.2 计算机系统简介\"></a>1.2 计算机系统简介</h3><h4 id=\"1-2-1-计算机系统的概念和分类\"><a href=\"#1-2-1-计算机系统的概念和分类\" class=\"headerlink\" title=\"1.2.1 计算机系统的概念和分类\"></a>1.2.1 计算机系统的概念和分类</h4><p>​        计算机系统由“硬件”和“软件”两大部分组成。</p>\n<ul>\n<li><p>“硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。</p>\n</li>\n<li><p>“软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。</p>\n</li>\n</ul>\n<p>​        计算机的软件通常又可以分为两大类：系统软件和应用软件。</p>\n<ul>\n<li>系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。</li>\n<li>应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。</li>\n</ul>\n<h4 id=\"1-2-2-计算机的发展\"><a href=\"#1-2-2-计算机的发展\" class=\"headerlink\" title=\"1.2.2 计算机的发展\"></a>1.2.2 计算机的发展</h4><p>硬件的发展</p>\n<p>​        1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是”用电子管组成的电子数字积分机和计算机”。</p>\n<p>​        从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。</p>\n<center>硬件技术对计算机更新换代的影响</center>\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代</th>\n<th style=\"text-align:center\">时间</th>\n<th style=\"text-align:center\">硬件技术</th>\n<th style=\"text-align:center\">速度（次/秒）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">一</td>\n<td style=\"text-align:center\">1946~1957</td>\n<td style=\"text-align:center\">电子管</td>\n<td style=\"text-align:center\">40, 000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">二</td>\n<td style=\"text-align:center\">1958~1964</td>\n<td style=\"text-align:center\">晶体管</td>\n<td style=\"text-align:center\">200, 000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">三</td>\n<td style=\"text-align:center\">1965~1971</td>\n<td style=\"text-align:center\">中、小规模集成电路</td>\n<td style=\"text-align:center\">1, 000, 000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">四</td>\n<td style=\"text-align:center\">1972~1977</td>\n<td style=\"text-align:center\">大规模集成电路</td>\n<td style=\"text-align:center\">10, 000, 000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">五</td>\n<td style=\"text-align:center\">1978~现在</td>\n<td style=\"text-align:center\">超大规模集成电路</td>\n<td style=\"text-align:center\">100, 000, 000</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>摩尔定律</strong></p>\n<p>​        集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。</p>\n<p>​        微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。</p>\n<p>​        摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。</p>\n<h3 id=\"1-3-计算机系统的层次结构\"><a href=\"#1-3-计算机系统的层次结构\" class=\"headerlink\" title=\"1.3 计算机系统的层次结构\"></a>1.3 计算机系统的层次结构</h3><h4 id=\"1-3-1-计算机系统的基本组成\"><a href=\"#1-3-1-计算机系统的基本组成\" class=\"headerlink\" title=\"1.3.1 计算机系统的基本组成\"></a>1.3.1 计算机系统的基本组成</h4><p>（一） 计算机硬件</p>\n<ol>\n<li>冯·诺依曼计算机</li>\n</ol>\n<p>​        冯·诺依曼在研究EDVAC计算机时提出了 “<strong>存储程序</strong>”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为<strong>冯•诺依曼计算机</strong>，其特点如下：</p>\n<ul>\n<li><p>采用“存储程序”的工作方式。</p>\n</li>\n<li><p>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。</p>\n</li>\n<li><p>指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。</p>\n</li>\n<li><p>指令和数据均用二进制代码表示。</p>\n</li>\n<li><p>指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。</p>\n<p><img src=\"/img/1_1_计算机基本组成.png\" alt=\"1_1_计算机基本组成\"></p>\n</li>\n</ul>\n<ol>\n<li>计算机的功能部件</li>\n</ol>\n<ul>\n<li>存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。</li>\n<li>运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。</li>\n<li>控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。</li>\n<li>输入设备：用来输入原始数据和程序，如键盘、鼠标。</li>\n<li>输岀设备：用来输出计算机的处理结果，如显示器和打印机。</li>\n</ul>\n<p>​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。</p>\n<p>（二） 计算机软件</p>\n<ol>\n<li>软件的分类</li>\n</ol>\n<p>​        软件按其功能分类，可分为系统软件和应用软件。</p>\n<ol>\n<li>三个级别的计算机语言</li>\n</ol>\n<p>（1） 机器语言</p>\n<p>​        机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。</p>\n<p>（2） 汇编语言           </p>\n<p>​        汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。</p>\n<p>（3） 高级语言</p>\n<p>​        高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。</p>\n<p>​        由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：</p>\n<ul>\n<li>汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。</li>\n<li>解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。</li>\n<li>编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。</li>\n</ul>\n<h4 id=\"1-3-2-计算机硬件的基本结构\"><a href=\"#1-3-2-计算机硬件的基本结构\" class=\"headerlink\" title=\"1.3.2 计算机硬件的基本结构\"></a>1.3.2 计算机硬件的基本结构</h4><p>​        典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。</p>\n<p><img src=\"/img/1_3_典型的冯诺依曼计算机结构框图.png\" alt=\"1_3_典型的冯诺依曼计算机结构框图\"></p>\n<p>现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。</p>\n<p><img src=\"/img/1_3_典型的冯诺依曼计算机结构框图-17170535066181.png\" alt=\"1_3_典型的冯诺依曼计算机结构框图\"></p>\n<p>图中各部件的功能是：</p>\n<ul>\n<li>运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；</li>\n<li>存储器用来存放数据和程序；</li>\n<li>控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；</li>\n<li>输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。</li>\n<li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。</li>\n</ul>\n<p>​        由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I/O设备(Input/Output equipment) 。</p>\n<p>​        这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I/O设备叫作外部设备。</p>\n<p><img src=\"/img/1_3_典型的冯诺依曼计算机结构框图-17170535144652.png\" alt=\"1_3_典型的冯诺依曼计算机结构框图\"></p>\n<ul>\n<li>主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。</li>\n<li>ALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。</li>\n<li>CU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。</li>\n</ul>\n<p>​        ALU和CU是CPU的核心部件。I/O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。</p>\n<h4 id=\"1-3-3-计算机系统的多级层次结构\"><a href=\"#1-3-3-计算机系统的多级层次结构\" class=\"headerlink\" title=\"1.3.3 计算机系统的多级层次结构\"></a>1.3.3 计算机系统的多级层次结构</h4><p>​        从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：</p>\n<p><img src=\"/img/1_3_典型的冯诺依曼计算机结构框图-17170535209243.png\" alt=\"1_3_典型的冯诺依曼计算机结构框图\"></p>\n<p>​    从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M<sub>0</sub> 与传统机器 M<sub>1</sub>，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为<strong>虚拟机器</strong>，包括操作系统机器 M<sub>2</sub>、汇编语言机器 M<sub>3</sub> 和高级语言机器 M<sub>4</sub>。简单来说，虚拟机器就是由软件实现的机器。</p>\n<p>​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。</p>\n<h4 id=\"1-3-4-计算机系统的工作原理\"><a href=\"#1-3-4-计算机系统的工作原理\" class=\"headerlink\" title=\"1.3.4 计算机系统的工作原理\"></a>1.3.4 计算机系统的工作原理</h4><h5 id=\"1-从源程序得到可执行程序\"><a href=\"#1-从源程序得到可执行程序\" class=\"headerlink\" title=\"1. 从源程序得到可执行程序\"></a>1. 从源程序得到可执行程序</h5><p>​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：</p>\n<p><img src=\"/img/1_6_计算机系统5级层次结构-17170543616504.png\" alt=\"1_6_计算机系统5级层次结构\"></p>\n<p>从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M<sub>0</sub> 与传统机器 M<sub>1</sub>，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为<strong>虚拟机器</strong>，包括操作系统机器 M<sub>2</sub>、汇编语言机器 M<sub>3</sub> 和高级语言机器 M<sub>4</sub>。简单来说，虚拟机器就是由软件实现的机器。</p>\n<p>​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。</p>\n<h4 id=\"1-3-5-计算机系统的工作原理\"><a href=\"#1-3-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.3.5 计算机系统的工作原理\"></a>1.3.5 计算机系统的工作原理</h4><h5 id=\"1-从源程序得到可执行程序-1\"><a href=\"#1-从源程序得到可执行程序-1\" class=\"headerlink\" title=\"1. 从源程序得到可执行程序\"></a>1. 从源程序得到可执行程序</h5><p>​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：</p>\n<p><img src=\"/img/1_7_源程序转换为可执行程序的过程.png\" alt=\"1_7_源程序转换为可执行程序的过程\"></p>\n<p>（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。</p>\n<p>​    （2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。</p>\n<p>​    （3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。</p>\n<p>​    （4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。</p>\n<h5 id=\"2-存储程序的基本思想\"><a href=\"#2-存储程序的基本思想\" class=\"headerlink\" title=\"2. 存储程序的基本思想\"></a>2. 存储程序的基本思想</h5><p>​        “存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。</p>\n<p><img src=\"/img/1_8_存储程序的基本思想.png\" alt=\"1_8_存储程序的基本思想\"></p>\n<ul>\n<li>程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；</li>\n<li>将PC的内容作为地址访问主存，取出指令；</li>\n<li>在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；</li>\n<li>当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。</li>\n</ul>\n<p>​        这样，计算机就可以周而复始地自动执行程序中的每一条指令了。</p>\n<h5 id=\"3-计算机硬件组成的细化说明\"><a href=\"#3-计算机硬件组成的细化说明\" class=\"headerlink\" title=\"3. 计算机硬件组成的细化说明\"></a>3. 计算机硬件组成的细化说明</h5><p><img src=\"/img/1_9_细化的计算机组成框图.png\" alt=\"1_9_细化的计算机组成框图\"></p>\n<p>​    （1）主存储器</p>\n<p>​        主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”<strong>存储字长</strong>“。</p>\n<p>​        主存中的每个存储单元有一个唯一的编号，叫做存储单元的”<strong>地址</strong>“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。</p>\n<p>​        为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。</p>\n<ul>\n<li><strong>MAR</strong>（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。</li>\n<li><strong>MDR</strong>（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。</li>\n</ul>\n<p>​    （2）运算器</p>\n<p>​        运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。</p>\n<ul>\n<li><strong>ACC</strong>： Accumulator，累加器；</li>\n<li><strong>MQ</strong>： Multiplier-Quotient Register，乘商寄存器；</li>\n<li><strong>X</strong>： 操作数寄存器</li>\n</ul>\n<p>​        这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">加法</th>\n<th style=\"text-align:center\">减法</th>\n<th style=\"text-align:center\">乘法</th>\n<th style=\"text-align:center\">除法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ACC</td>\n<td style=\"text-align:center\">被加数及和</td>\n<td style=\"text-align:center\">被减数及差</td>\n<td style=\"text-align:center\">乘积高位</td>\n<td style=\"text-align:center\">被除数及余数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MQ</td>\n<td style=\"text-align:center\">——</td>\n<td style=\"text-align:center\">——</td>\n<td style=\"text-align:center\">乘数及乘积低位</td>\n<td style=\"text-align:center\">商</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">加数</td>\n<td style=\"text-align:center\">减数</td>\n<td style=\"text-align:center\">被乘数</td>\n<td style=\"text-align:center\">除数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​        不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。</p>\n<p>​    （3）控制器</p>\n<p>​        控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。</p>\n<p>PC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。</p>\n<p>IR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。</p>\n<p>​        CU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。</p>\n<p>​    （4）I/O</p>\n<p>​        I/O 系统包括各种 I/O 设备及其相应的接口。每一种 I/O 设备都由 I/O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。</p>\n<h5 id=\"4-计算机硬件的工作过程\"><a href=\"#4-计算机硬件的工作过程\" class=\"headerlink\" title=\"4. 计算机硬件的工作过程\"></a>4. 计算机硬件的工作过程</h5><p>​        总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：</p>\n<ul>\n<li>把程序和数据装入主存储器；</li>\n<li>从程序的起始地址运行程序；</li>\n<li>按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；</li>\n<li>用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。</li>\n</ul>\n<p>​        我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：</p>\n<p>​    （1）取指令： PC → MAR → M → MDR → IR</p>\n<p>​        根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。</p>\n<p>​    （2）分析指令： OP（IR） → CU</p>\n<p>​        指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。</p>\n<p>​    （3）执行指令：Ad（IR） → MAR → M → MDR → ACC</p>\n<p>​        取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。</p>\n<p>​    （4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC</p>\n<h3 id=\"1-4-计算机性能指标\"><a href=\"#1-4-计算机性能指标\" class=\"headerlink\" title=\"1.4 计算机性能指标\"></a>1.4 计算机性能指标</h3><h4 id=\"1-4-1-主要性能指标\"><a href=\"#1-4-1-主要性能指标\" class=\"headerlink\" title=\"1.4.1 主要性能指标\"></a>1.4.1 主要性能指标</h4><ol>\n<li><strong>机器字长</strong></li>\n</ol>\n<p>​        机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。</p>\n<p>​        字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。</p>\n<ul>\n<li>指令字长：一条指令中包含的二进制代码的位数。</li>\n<li>存储字长：一个存储单元中存储的二进制代码的长度。</li>\n</ul>\n<p>​        指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。</p>\n<ol>\n<li><strong>数据通路带宽</strong></li>\n</ol>\n<p>​        数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。</p>\n<ol>\n<li><strong>存储容量</strong></li>\n</ol>\n<p>​        存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。</p>\n<p>​        主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。</p>\n<p>​                                                存储容量 = 存储单元个数 × 存储字长</p>\n<p>​        在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 2<sup>16</sup> = 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K=1024）；而如果 MDR 为32位， 那么主存的存储容量为 2<sup>16</sup> × 32 = 2<sup>21</sup> = 2Ｍ 位（1Ｍ=2<sup>20</sup>）。</p>\n<p>​        现代计算机中常以字节的个数来描述容量的大小，一个<strong>字节</strong>（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 2<sup>18 </sup>字节（Byte，简写为 B）表示，记作 2<sup>18 </sup>B 或 256KB。</p>\n<p>​        同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G = 1KM = 2<sup>30 </sup>）。</p>\n<ol>\n<li><strong>运算速度</strong></li>\n</ol>\n<p>​        计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。</p>\n<h4 id=\"1-5-2-专业术语解释\"><a href=\"#1-5-2-专业术语解释\" class=\"headerlink\" title=\"1.5.2 专业术语解释\"></a>1.5.2 专业术语解释</h4><p>​    <strong>吞吐量</strong>：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。</p>\n<p>​    <strong>响应时间</strong>：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I/O操作等的时间）。</p>\n<p>​    <strong>主频（CPU 时钟频率）</strong>：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。</p>\n<p>​    <strong>CPU 时钟周期</strong>：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。</p>\n<p>​                                                            <strong>CPU 时钟周期 = 1 / 主频</strong></p>\n<p>​    <strong>CPI</strong>：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。</p>\n<p>​    <strong>CPU 执行时间</strong>：运行一个程序所花费的时间。</p>\n<p>​                                                <strong>CPU 执行时间 = （指令数 × CPI）/ 主频</strong></p>\n<p>​        对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。</p>\n<p>​        现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。</p>\n<p>​        <strong>MIPS</strong>：Million Instructions Per Second，每秒执行百万条指令的数目。</p>\n<p>​                                                            <strong>MIPS = 主频 /（CPI × 10<sup>6</sup>）</strong></p>\n<p>​        <strong>FLOPS</strong>：FLoating-point Operations Per Second，每秒执行浮点运算的次数。</p>\n<p>​        <strong>MFLOPS</strong>：百万次浮点运算每秒。 MFLOPS = 浮点操作次数 /（执行时间 * 10<sup>6</sup>）</p>\n<p>​        <strong>GFLOPS</strong>：十亿次浮点运算每秒。 GFLOPS = 浮点操作次数 /（执行时间 * 10<sup>9</sup>）</p>\n<p>​        <strong>TFLOPS</strong>：万亿次浮点运算每秒。 TFLOPS = 浮点操作次数 /（执行时间 * 10<sup>12</sup>）</p>\n<p>​        <strong>PFLOPS</strong>：千万亿次浮点运算每秒。 PFLOPS = 浮点操作次数 /（执行时间 * 10<sup>15</sup>）</p>\n<p>​        <strong>EFLOPS</strong>：百京次浮点运算每秒。 EFLOPS = 浮点操作次数 /（执行时间 * 10<sup>18</sup>）</p>\n<p>​        <strong>ZFLOPS</strong>：十万京次浮点运算每秒。 ZFLOPS = 浮点操作次数 /（执行时间 * 10<sup>21</sup>）</p>\n<p>​        <em>需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB =  2<sup>10</sup> B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb/s = 10<sup>3</sup> b/s。</em></p>\n<h3 id=\"1-5-章节练习\"><a href=\"#1-5-章节练习\" class=\"headerlink\" title=\"1.5 章节练习\"></a>1.5 章节练习</h3><h4 id=\"一、单项选择题\"><a href=\"#一、单项选择题\" class=\"headerlink\" title=\"一、单项选择题\"></a>一、单项选择题</h4><ol>\n<li>【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。</li>\n</ol>\n<p>​        A. 指令操作码的译码结果                B. 指令和数据的寻址方式</p>\n<p>​        C. 指令周期的不同阶段                    D. 指令和数据所在的数据单元</p>\n<p>​    答案： C</p>\n<ol>\n<li>【2015真题】计算机硬件能够直接执行的是 （  ）。</li>\n</ol>\n<p>​        I. 机器语言程序    II. 汇编语言程序    III. 硬件描述语言程序</p>\n<p>​        A. 仅 I             B. 仅 I、II            C. 仅 I、III            D. I、II、III</p>\n<p>​    答案： A</p>\n<ol>\n<li>【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。</li>\n</ol>\n<p>​        A. 汇编程序            B. 链接程序            C. 编译程序            D. 解释程序</p>\n<p>​    答案： C</p>\n<ol>\n<li>【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。</li>\n</ol>\n<p>​        A. 程序的功能都通过中央处理器执行指令实现            B. 指令和数据都用二进制表示，形式上无差别</p>\n<p>​        C. 指令按地址访问，数据都在指令中直接给出            D. 程序执行前，指令和数据需预先存放在存储器中</p>\n<p>​    答案： C</p>\n<ol>\n<li>【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。</li>\n</ol>\n<p>​        I. ALU        II. 指令寄存器        III. 通用寄存器        IV. 浮点寄存器</p>\n<p>​        A. 仅 I、II            B. 仅 I、III            C. 仅 II、III            D. 仅 II、III、IV</p>\n<p>​    答案： B</p>\n<ol>\n<li>【2010真题】下列选项中，能缩短程序执行时间的是（  ）。</li>\n</ol>\n<p>​        I. 提高 CPU 时钟频率    II. 优化数据通路结构    III. 对程序进行编译优化</p>\n<p>​        A. 仅 I 和 II            B. 仅 I 和 III            C. 仅 II 和 III            D. I、II、III</p>\n<p>​    答案： D</p>\n<ol>\n<li>【2011真题】下列选项中，描述浮点数操作速度的是（  ）。</li>\n</ol>\n<p>​        A. MIPS                    B. CPI                    C. IPC                    D. MFLOPS</p>\n<p>​    答案： D</p>\n<ol>\n<li>【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I/O 时间。若 CPU 速度提高 50%，I/O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。</li>\n</ol>\n<p>​        A. 55s                B. 60s                C. 65s                D. 70s</p>\n<p>​    答案： D</p>\n<ol>\n<li>【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。</li>\n</ol>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令类型</th>\n<th style=\"text-align:center\">所占比例</th>\n<th style=\"text-align:center\">CPI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">50%</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">20%</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">10%</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">20%</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​        该机的 MIPS 是 （  ）。</p>\n<p>​        A. 100                B. 200                C. 400                D. 600</p>\n<p>​    答案： C</p>\n<ol>\n<li>【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。</li>\n</ol>\n<p>​        A. 8.4s                B. 11.7s                C. 14s                D. 16.8s</p>\n<p>​    答案： D</p>\n<ol>\n<li>【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。</li>\n</ol>\n<p>​        A. 0.4                B. 0.625                C. 1.6                D. 2.5</p>\n<p>​    答案： C</p>\n<h4 id=\"二、综合应用题\"><a href=\"#二、综合应用题\" class=\"headerlink\" title=\"二、综合应用题\"></a>二、综合应用题</h4><ol>\n<li>说明机器字长、指令字长、存储字长的区别和联系。</li>\n</ol>\n<p>​    答案：</p>\n<p>​        机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</p>\n<p>​        指令字长：一个指令字中包含二进制代码的位数。</p>\n<p>​        存储字长：一个存储单元存储二进制代码的长度。</p>\n<p>​        它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。</p>\n<ol>\n<li><p>用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 <em>I</em>）。</p>\n<p>|      指令类型      | CPI  | 指令混合比 |<br>| :————————: | :—: | :————: |<br>|     算术和逻辑     |  1   |    60%     |<br>|        转移        |  4   |    12%     |<br>| 高速缓存命中的访存 |  2   |    18%     |<br>| 高速缓存失效的访存 |  8   |    10%     |</p>\n</li>\n</ol>\n<p>​    答案：</p>\n<p>​        CPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：</p>\n<p>​                        CPI = 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% = 0.6 + 0.48 + 0.36 +0.8 = 2.24</p>\n<p>​        MIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：</p>\n<p>​                                                    MIPS = 40 × 10<sup>6</sup> /（2.24 × 10<sup>6</sup> ）≈ 17.9</p>\n<p>​        程序的执行时间 T = 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：</p>\n<p>​                        T = CPI × 时钟周期 × 指令条数 = 2.24 ×（1 / 40MHz）× <em>I</em> = 5.6 × 10<sup>-8</sup> × <em>I</em>  秒</p>\n<p>​        </p>\n<hr>\n<h2 id=\"第二章-数据的表示和运算\"><a href=\"#第二章-数据的表示和运算\" class=\"headerlink\" title=\"第二章 数据的表示和运算\"></a>第二章 数据的表示和运算</h2><h3 id=\"2-1-本章大纲要求与核心考点\"><a href=\"#2-1-本章大纲要求与核心考点\" class=\"headerlink\" title=\"2.1 本章大纲要求与核心考点\"></a>2.1 本章大纲要求与核心考点</h3><h4 id=\"2-1-1-大纲内容\"><a href=\"#2-1-1-大纲内容\" class=\"headerlink\" title=\"2.1.1 大纲内容\"></a>2.1.1 大纲内容</h4><p>（一）数制与编码</p>\n<ol>\n<li>进位计数制及其数据之间的相互转换</li>\n<li>定点数的表示和运算</li>\n</ol>\n<p>（二）运算方法和运算电路</p>\n<ol>\n<li>基本运算部件：加法器、算数逻辑部件（ALU）</li>\n<li>加/减运算：补码加/减运算器，标志位的生成</li>\n<li>乘/除运算：乘/除运算的基本原理，乘法电路和除法电路的基本结构</li>\n</ol>\n<p>（三）整数的表示和运算</p>\n<ol>\n<li>无符号整数的表示和运算</li>\n<li>有符号整数的表示和运算</li>\n</ol>\n<p>（四）浮点数的表示和运算</p>\n<ol>\n<li>浮点数的表示：IEEE 754标准</li>\n<li>浮点数的加/减运算</li>\n</ol>\n<h4 id=\"2-1-2-核心考点\"><a href=\"#2-1-2-核心考点\" class=\"headerlink\" title=\"2.1.2 核心考点\"></a>2.1.2 核心考点</h4><p>​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。</p>\n<p>​        需要重点掌握的内容包括：</p>\n<ul>\n<li>真值、机器数，定点数的表示及原理</li>\n<li>C 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换</li>\n<li>ALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法</li>\n<li>IEEE 754标准浮点数的表示和特点，浮点数的加/减运算方法</li>\n<li>C 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换</li>\n<li>数据按边界对齐方式的存储，数据按大端和小端方式存储</li>\n</ul>\n<h4 id=\"2-1-3-真题分布\"><a href=\"#2-1-3-真题分布\" class=\"headerlink\" title=\"2.1.3 真题分布\"></a>2.1.3 真题分布</h4>  <table style=\"text-align:center\">\n      <tr>\n          <th rowspan=\"2\">考点</th>\n          <th colspan=\"2\">考查次数</th>\n      </tr>\n      <tr>\n          <th>单项选择题</th>\n          <th>综合应用题</th>\n      </tr>\n      <tr>\n          <td>定点数的表示与运算</td>\n          <td>10</td>\n          <td>8</td>\n      </tr>\n      <tr>\n          <td>IEEE 754标准浮点数，浮点数的运算</td>\n          <td>10</td>\n          <td>3</td>\n      </tr>\n      <tr>\n          <td>C语言中各种数据的转换</td>\n          <td>3</td>\n          <td>2</td>\n      </tr>\n      <tr>\n          <td>数据按边界对齐方式的存储，数据按大小端方式存储</td>\n          <td>4</td>\n          <td>0</td>\n      </tr>\n  </table>\n\n\n\n\n\n<hr>\n<h3 id=\"2-2-数制与编码\"><a href=\"#2-2-数制与编码\" class=\"headerlink\" title=\"2.2 数制与编码\"></a>2.2 数制与编码</h3><h4 id=\"2-2-1-进位计数制及其相互转换\"><a href=\"#2-2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.2.1 进位计数制及其相互转换\"></a>2.2.1 进位计数制及其相互转换</h4><p><strong>（一）进位计数制</strong></p>\n<p>​        进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为<strong>基数</strong>；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。</p>\n<p>​        下表是十进制数、二进制数、十六进制数对照表。</p>\n<p>​        书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)<sub>16</sub>；八进制数后面加上“O”，如372O或(372)<sub>8</sub>；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)<sub>2</sub>。</p>\n<p>​                                        <em>十进制数、二进制数、八进制数、十六进制数对照表</em></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">十进制数</th>\n<th style=\"text-align:center\">二进制数</th>\n<th style=\"text-align:center\">八进制数</th>\n<th style=\"text-align:center\">十六进制数</th>\n<th style=\"text-align:center\">十进制数</th>\n<th style=\"text-align:center\">二进制数</th>\n<th style=\"text-align:center\">八进制数</th>\n<th style=\"text-align:center\">十六进制数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">00000</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">00001</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">10001</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">11</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">00010</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">10010</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">00011</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">10011</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">13</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">00100</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">10100</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">14</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">00101</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">10101</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">15</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">00110</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">10110</td>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">00111</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">10111</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">17</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">01000</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">11000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">18</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">01001</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">11001</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">19</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">01010</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">11010</td>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:center\">1A</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">01011</td>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">11011</td>\n<td style=\"text-align:center\">33</td>\n<td style=\"text-align:center\">1B</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">01100</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">28</td>\n<td style=\"text-align:center\">11100</td>\n<td style=\"text-align:center\">34</td>\n<td style=\"text-align:center\">1C</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">01101</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:center\">11101</td>\n<td style=\"text-align:center\">35</td>\n<td style=\"text-align:center\">1D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">01110</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">11110</td>\n<td style=\"text-align:center\">36</td>\n<td style=\"text-align:center\">1E</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">01111</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">11111</td>\n<td style=\"text-align:center\">37</td>\n<td style=\"text-align:center\">1F</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​        计算机系统为什么要采用二进制？</p>\n<ul>\n<li>使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。</li>\n<li>二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。</li>\n<li>二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li>\n</ul>\n<hr>\n<p><strong>（二）不同进制数的相互转换</strong></p>\n<p>​        任意一个数 N，可以用 r 进制表示成下面的形式：</p>\n<p>​                                            N =（d<sub>n-1</sub>d<sub>n-2</sub> … d<sub>1</sub>d<sub>0</sub>.d<sub>-1</sub>d<sub>-2</sub> … d<sub>-m</sub>）</p>\n<p>​                                                = d<sub>n-1</sub>r<sup>n-1</sup> + d<sub>n-2</sub>r<sup>n-2</sup> + … + d<sub>1</sub>r<sup>1</sup> + d<sub>0</sub>r<sup>0</sup> + d<sub>-1</sub>r<sup>-1</sup> + d<sub>-2</sub>r<sup>-2</sup> + … + d<sub>-m</sub>r<sup>-m</sup></p>\n<p>​                                                = ∑ d<sub>i</sub>r<sup>i</sup></p>\n<p>​        其中，r 为<strong>基数</strong>；d 为系数，d<sub>i</sub> 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；r<sup>i</sup> 叫做第 i 位上的<strong>权值</strong>。n、m 分别代表 N 的整数部分和小数部分的位数。</p>\n<p><strong>（1）二进制和八进制、十六进制间的转换</strong></p>\n<p>​        将二进制数1110011101.0010111转换为八进制数为：</p>\n<p>​                                                <font size=2>左侧补0                  分界点                右侧补0</font></p>\n<p>​                                                   ↓                         ↓                   ↓</p>\n<p>​                                                <u>001</u> <u>110</u> <u>011</u> <u>101</u> .  <u>001</u> <u>011</u> <u>100</u></p>\n<p>​                                                 1       6     3      5  .    1      3      4</p>\n<p>​        所以 (1110011101.0010111)<sub>2</sub> = (1635.134)<sub>8</sub> ；</p>\n<p>​        同样道理，转换为十六进制数为：</p>\n<p>​                                                <u>0011</u> <u>1001</u> <u>1101</u> .  <u>0010</u> <u>1110</u></p>\n<p>​                                                    3        9        D   .     2        E</p>\n<p>​        所以 (1110011101.0010111)<sub>2</sub> = (39D.2E)<sub>16</sub> ；</p>\n<ul>\n<li>二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。</li>\n<li>二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。</li>\n<li>八进制转换为二进制：每位都转换成对应的3位二进制数。</li>\n<li>十六进制转换为二进制：每位都转换成对应的4位二进制数。</li>\n</ul>\n<p><strong>（2）任意进制数转换为十进制数</strong></p>\n<p>​        任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 <strong>按权展开法</strong>。</p>\n<p>​        例如，将二进制数 11011.101 转换为十进制数为：</p>\n<p>​        (11011.101)<sub>2</sub>  = 1 × 2<sup>4</sup> + 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 1 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1 × 2<sup>-3</sup></p>\n<p>​                            = 27.625</p>\n<p>​        另一种方法是“<strong>按基数重复相乘/除法</strong>”，需要分整数部分和小数部分分别转换。</p>\n<p>​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：</p>\n<p>​        (11011)<sub>2</sub>  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27</p>\n<p>​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：</p>\n<p>​        (0.101)<sub>2</sub>  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625</p>\n<p><strong>（3）十进制数转换为二进制数</strong></p>\n<p>​        将十进制数转换为二进制数，一般采用 <strong>基数乘除法</strong>。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。</p>\n<ul>\n<li><p>整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）</p>\n</li>\n<li><p>小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）</p>\n</li>\n</ul>\n<p>​        例如，将十进制数 123.6875 转换为二进制数。</p>\n<p>​        <strong>整数部分：</strong></p>\n<p>​          除2得商                            余数</p>\n<p>​        2 |<u>123</u>                …                1                最低位</p>\n<p>​          2  |<u>61</u>               …                1</p>\n<p>​           2 |<u>30</u>               …                0</p>\n<p>​           2 |<u>15</u>               …                1</p>\n<p>​            2  |<u>7</u>               …                1</p>\n<p>​            2  |<u>3</u>               …                1</p>\n<p>​            2  |<u>1</u>               …                1                最高位</p>\n<p>​            2  |<u>0</u></p>\n<p>​        所以 (123)<sub>10</sub> = (1111011)<sub>2</sub></p>\n<p>​        <strong>小数部分：</strong></p>\n<p>​          乘积取小数                                乘2得积                取整数部分</p>\n<p>​            0.6875                × 2                = 1.375                        1                        最高位</p>\n<p>​            0.375                  × 2                = 0.75                           0        </p>\n<p>​            0.75                    × 2                = 1.5                             1    </p>\n<p>​            0.5                      × 2                 = 1                                1                        最低位    </p>\n<p>​        所以 (0.6875)<sub>10</sub> = (0.1011)<sub>2</sub></p>\n<p>​        综合整数和小数部分，得到 (123.6875)<sub>10</sub> = (1111011.1011)<sub>2</sub></p>\n<p>​        另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：</p>\n<p>​        十进制数                位权                转换后的结果</p>\n<p>​            123                                            2<sup>6</sup>    2<sup>5</sup>    2<sup>4</sup>    2<sup>3</sup>    2<sup>2</sup>    2<sup>1</sup>    2<sup>0</sup></p>\n<p>​        <u>➖ 64</u>                        2<sup>6</sup>                1</p>\n<p>​              59</p>\n<p>​        <u>➖ 32</u>                        2<sup>5</sup>                        1</p>\n<p>​              27</p>\n<p>​        <u>➖ 16</u>                        2<sup>4</sup>                                1</p>\n<p>​              11</p>\n<p>​        <u>➖   8</u>                        2<sup>3</sup>                                        1</p>\n<p>​                3</p>\n<p>​        <u>➖   2</u>                        2<sup>1</sup>                                                        1</p>\n<p>​                1</p>\n<p>​        <u>➖   1</u>                        2<sup>0</sup>                                                                1</p>\n<p>​                0</p>\n<p>​        所以 (123)<sub>10</sub> = (1111011)<sub>2</sub> </p>\n<p>​        这种方法一般在转换很大的十进制数时比较方便。</p>\n<h4 id=\"2-2-2-真值和机器数\"><a href=\"#2-2-2-真值和机器数\" class=\"headerlink\" title=\"2.2.2 真值和机器数\"></a>2.2.2 真值和机器数</h4><p>​        在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。</p>\n<p>​        对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。</p>\n<p>例如，一个有符号的小数：</p>\n<p>​                + 0.1011                在机器中表示为        0    1 0 1 1</p>\n<p>​                -  0.1011                在机器中表示为        1    1 0 1 1</p>\n<p>再比如，一个有符号的整数：</p>\n<p>​                + 1100                    在机器中表示为        0    1 1 0 0</p>\n<p>​                -  1100                    在机器中表示为        1    1 1 0 0</p>\n<p>​        把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。</p>\n<ul>\n<li>真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。</li>\n<li>机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。</li>\n</ul>\n<p>​        在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即<strong>定点</strong>表示和<strong>浮点</strong>表示。</p>\n<p>​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。</p>\n<p>​        在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。</p>\n<h4 id=\"2-2-3-定点数及其编码表示\"><a href=\"#2-2-3-定点数及其编码表示\" class=\"headerlink\" title=\"2.2.3 定点数及其编码表示\"></a>2.2.3 定点数及其编码表示</h4><p>​        小数点固定在某一位置的数为定点数，有以下两种格式。</p>\n<p><img src=\"/img/2_1_两种定点数的格式.png\" alt=\"2_1_两种定点数的格式\"></p>\n<p>当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。</p>\n<p>​        在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。</p>\n<h5 id=\"1-无符号整数的表示\"><a href=\"#1-无符号整数的表示\" class=\"headerlink\" title=\"1. 无符号整数的表示\"></a>1. <strong>无符号整数的表示</strong></h5><p>​        当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 2<sup>8</sup>-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。</p>\n<h5 id=\"2-带符号数的表示\"><a href=\"#2-带符号数的表示\" class=\"headerlink\" title=\"2. 带符号数的表示\"></a>2. <strong>带符号数的表示</strong></h5><p>​        最高位用来表示符号位，而不再表示数值位。</p>\n<p><strong>（1）定点整数</strong></p>\n<p>​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。</p>\n<p>​        约定小数点在有效数值部分最低位之后。数据 x = x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>…x<sub>n</sub> （其中 x<sub>0</sub> 为符号位，x<sub>1</sub> ~ x<sub>n </sub>是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：</p>\n<p><img src=\"/img/2_2_定点整数的表示.png\" alt=\"2_2_定点整数的表示\"></p>\n<p><strong>（2）定点小数</strong></p>\n<p>​        约定小数点在有效数值部分最高位之前。数据 x = x<sub>0</sub>.x<sub>1</sub>x<sub>2</sub>…x<sub>n</sub>（其中 x<sub>0 </sub>为符号位，x<sub>1</sub>~x<sub>n</sub> 是尾数，x<sub>1</sub> 是最高有效位），在计算中的表示形式如下图所示：</p>\n<p><img src=\"/img/2_3_定点小数的表示.png\" alt=\"2_3_定点小数的表示\"></p>\n<h5 id=\"3-原码、补码、反码和移码\"><a href=\"#3-原码、补码、反码和移码\" class=\"headerlink\" title=\"3. 原码、补码、反码和移码\"></a>3. <strong>原码、补码、反码和移码</strong></h5><ol>\n<li><strong>原码表示法</strong></li>\n</ol>\n<p>​        用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:</p>\n<p><img src=\"/img/2_4_定点小数的原码表示.png\" alt=\"2_4_定点小数的原码表示\"></p>\n<p>式子中 x 为真值，[ x ]<sub>原</sub> 表示原码机器数。</p>\n<p>​        类似，纯整数的原码定义如下：</p>\n<p><img src=\"/img/2_5_整数的原码表示.png\" alt=\"2_5_整数的原码表示\"></p>\n<p>​    原码的性质：</p>\n<ul>\n<li><p>由符号位与数的绝对值组成，符号位是0为正、1为负</p>\n</li>\n<li><p>0有 ±0 两个编码，即 [+0]<sub>原</sub> = 00000 和 [-0]<sub>原</sub> = 10000 </p>\n</li>\n</ul>\n<ol>\n<li><strong>补码表示法</strong></li>\n</ol>\n<p>​        纯整数的补码定义为：</p>\n<p><img src=\"/img/2_6_整数的补码表示.png\" alt=\"2_6_整数的补码表示\"></p>\n<p>​    这里 n 为整数的位数，真值 x 和补码机器数 [ x ]<sub>原</sub> 互为以 2<sup>n+1</sup> 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2<sup>n</sup> ≤ x ≤ 2<sup>n</sup> - 1，比原码多表示了一个数 -2<sup>n</sup>。</p>\n<p>​        补码的性质：</p>\n<ul>\n<li>补码和其真值的关系：[x]<sub>补</sub> = 符号位 × 2<sup>n+1</sup> + x</li>\n<li>0的编码唯一，因此整数补码比原码多1个数，表示 -2<sup>n</sup></li>\n<li>符号位参与补码加减运算，统一采用加法操作实现</li>\n<li>将 [x]<sub>补 </sub>的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能</li>\n</ul>\n<p>​        例如，当 x = + 1010 时（n = 4），</p>\n<p>​        [x]<sub>补</sub> = 0, 1010</p>\n<p>​        而当 x = - 1010 时，</p>\n<p>​        [x]<sub>补</sub> = 2<sup>n+1</sup> + x = 100000 - 1010 = 1, 0110</p>\n<p>​        补码和真值的转换：</p>\n<ul>\n<li>真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。</li>\n<li>补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。</li>\n</ul>\n<p>​        <strong>变形补码</strong>是采用双符号位的补码表示法，其定义为</p>\n<p><img src=\"/img/2_7_变形补码.png\" alt=\"2_7_变形补码\"></p>\n<p>​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。</p>\n<ol>\n<li><strong>反码表示法</strong></li>\n</ol>\n<p>​        负数的补码可采用“数值位各位取反，末位加1”的方法得到，如果数值位各位取反而末位不加1，那么就是负数的反码表示。正数的反码定义和相应的补码（或原码）表示相同。</p>\n<p>​        反码表示存在以下几个方面的不足：0的表示不唯一（即存在±0）；表示范围比补码少一个最小负 数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。</p>\n<p>​        原码、补码、反码三种编码表示总结如下：</p>\n<ul>\n<li><p>三种编码的符号位相同，正数的机器码相同。</p>\n</li>\n<li><p>原码和反码的表示在数轴上对称，二者都存在 ±0 两个零。</p>\n</li>\n<li><p>补码的表示在数轴上不对称，0的表示唯一，补码比原码和反码多表示一个数。</p>\n</li>\n<li><p>负数的反码、补码末位相差1。</p>\n</li>\n</ul>\n<ul>\n<li>原码很容易判断大小。而负数的补码和反码很难直接判断大小，可采用这条规则快速判断：对于一个负数，数值部分越大，它的绝对值就越小，所以真值就越大（更靠近0）。</li>\n</ul>\n<ol>\n<li><strong>移码表示法</strong></li>\n</ol>\n<p>​        移码是在真值 x 上加上偏置值 2<sup>n </sup>构成的，相当于 x 在数轴上向正方向偏移了若干单位。</p>\n<p><img src=\"/img/2_8_移码原理.png\" alt=\"2_8_移码原理\"></p>\n<p>​    移码定义为:</p>\n<p><img src=\"/img/2_9_整数的移码表示-17170639443845.png\" alt=\"2_9_整数的移码表示\"></p>\n<p>移码的性质：</p>\n<ul>\n<li>0的表示唯一， [+0]<sub>移</sub> =  2<sup>n</sup> + 0 = [-0]<sub>移</sub> = 2<sup>n</sup> - 0 = 100…0 </li>\n<li>符号位“1”表示正，“0”表示负，这与其他机器数正好相反。</li>\n<li>一个真值的移码和补码仅差一个符号位，[x]<sub>补</sub> 的符号位取反即得 [x]<sub>移</sub>，反之亦然。</li>\n<li>移码全0时，对应真值的最小值- 2<sup>n</sup> ；移码全1时，对应真值的最大值 2<sup>n</sup> -1。</li>\n<li>保持了数据原有的大小顺序，移码大真值就大，便于进行比较操作。</li>\n<li>移码常用来表示浮点数的阶码。它只能表示整数。</li>\n</ul>\n<h4 id=\"2-2-4-C-语言中的整型数据类型\"><a href=\"#2-2-4-C-语言中的整型数据类型\" class=\"headerlink\" title=\"2.2.4  C 语言中的整型数据类型\"></a>2.2.4  <strong>C</strong> 语言中的整型数据类型</h4><ol>\n<li>C 语言中的整型数据简介</li>\n</ol>\n<p>​        C 语言中的整型数据就是定点整数，一般用补码表示。根据位数的不同，可以分为 <strong>字符型(char)</strong>、<strong>短整型(short)</strong>、<strong>整型(int)</strong>、<strong>长整型(long)</strong>。</p>\n<p>​        C 语言中的整型数据，可以分为 <strong>无符号整型</strong> 和 <strong>有符号整型</strong> 两种类型，在定义时只要加上 <strong>signed/unsigned</strong> 就可以明确指定了。</p>\n<p>​        char 是整型数据中比较特殊的一种，其他如 short/int/long 等都默认是带符号整数，但 char 默认是无符号整数。无符号整数（unsigned short/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。</p>\n<p>​        signed/unsigned 整型数据都是按补码形式存储的，在不溢出条件下的加减运算也是相同的，只是 signed 型的最高位代表符号位，而在 unsigned 型中表示数值位，而这两者体现在输出上则分别是％d 和％u。</p>\n<ol>\n<li>有符号数和无符号数的转换</li>\n</ol>\n<p>​        C 语言允许在不同的数据类型之间做类型转换。C 语言的强制类型转换格式为“TYPE b = (TYPE) a”, 强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。</p>\n<p>​        先看由 short 型转换到 unsigned short 型的情况。考虑如下代码片段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">short</span> x = <span class=\"number\">-4321</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">short</span> y = (<span class=\"type\">unsigned</span> <span class=\"type\">short</span>)x;</span><br></pre></td></tr></table></figure>\n<p>​        执行上述代码后，x = -4321, y = 61215，得到的 y 似乎与原来的 x 没有一点关系。不过将这两个数转化为二进制表示时，我们就会发现其中的规律。</p>\n<p>​        通过本例可知：强制类型转换的结果是保持每位的值不变，仅改变了解释这些位的方式。有符号数转化为等长的无符号数时，符号位解释为数据的一部分，负数转化为无符号数时数值将发生变化。同理，无符号数转化为有符号数时，最高位解释为符号位，也可能发生数值的变化。</p>\n<ol>\n<li>不同字长整数之间的转换</li>\n</ol>\n<p>​        另一种常见的运算是在不同字长的整数之间进行数值转换。</p>\n<p>​        先看长字长变量向短字长变量转换的情况。考虑如下代码片段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">165537</span>, u = <span class=\"number\">-34991</span>;                      <span class=\"comment\">//int型占用4字节</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">short</span> y = ( <span class=\"type\">short</span> )x, v = ( <span class=\"type\">short</span> )u;            <span class=\"comment\">//short型占用2字节</span></span><br></pre></td></tr></table></figure>\n<p>​        执行上述代码后，x= 165537, y=-31071, u =-34991, v = 30545。x、y、u、v 的十六进制表示分别 是0x000286a1 0x86a1 . 0xffff7751、0x7751。由本例可知：长字长整数向短字长整数转换时，系统把多余的高位部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。</p>\n<p>​        最后来看短字长变量向长字长变量转换的情况。考虑如下代码片段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">short</span> x = <span class=\"number\">-4321</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> y = (<span class=\"type\">int</span>)x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">short</span> u = (<span class=\"type\">unsigned</span> <span class=\"type\">short</span>)x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> v = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)u;</span><br></pre></td></tr></table></figure>\n<p>​        执行上述代码后，x = -4321, y = -4321, u = 61215, v = 61215。x、y、u、v 的十六进制表示分别是0xef1f. 0xffffef1f、0xef1f、0x0000ef1f。所以，短字长整数向长字长整数转换时，仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。</p>\n<p>​        从位值与数值的角度看，前3个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换可以理解为保证数值的相等。</p>\n<hr>\n<h3 id=\"2-3-运算方法\"><a href=\"#2-3-运算方法\" class=\"headerlink\" title=\"2.3 运算方法\"></a>2.3 运算方法</h3><h4 id=\"2-3-1-定点数的移位运算\"><a href=\"#2-3-1-定点数的移位运算\" class=\"headerlink\" title=\"2.3.1 定点数的移位运算\"></a>2.3.1 定点数的移位运算</h4><p>​        移位运算根据操作对象的不同，可以分为算术移位和逻辑移位。算术移位针对的是有符号数，逻辑移位针对的是机器码，可以看作无符号数。</p>\n<h5 id=\"1-算术移位\"><a href=\"#1-算术移位\" class=\"headerlink\" title=\"1. 算术移位\"></a>1. 算术移位</h5><p>​        算术移位的对象是有符号数，有符号数在计算机中采用补码表示。算术移位的特点是，移位后符号位保持不变；空出的位置根据正负和左右移位的情况，决定补 0 还是 1。</p>\n<ul>\n<li>对于正数，由于 [ x ]<sub>原</sub> = [ x ]<sub>补</sub> = 真值，因此移位后的空位均补 0。</li>\n<li>对于负数，算术左移时，高位移出，低位补 0；算术右移时，低位移出，高位补 1。</li>\n</ul>\n<p>​        可见，不论是正数还是负数，移位后其符号位均不变。</p>\n<p>​        例如，假设机器字长为 8，[4]<sub>补</sub> = 0000 0100，[-4]<sub>补</sub> = 1111 1100；</p>\n<ul>\n<li><p>将 4 算术左移一位，就得到了 0000 1000 = [8]<sub>补</sub>；算术右移一位，就得到了 0000 0010 = [2]<sub>补</sub>；</p>\n</li>\n<li><p>将 -4 算术左移一位，就得到了 1111 1000 = [-8]<sub>补</sub>；算术右移一位，就得到了 1111 1110 = [-2]<sub>补</sub>；</p>\n</li>\n</ul>\n<p>​        对于有符号数，左移一位若不产生溢出，相当于乘以2 （与十进制数左移一位相当于乘以10类似）; 右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。</p>\n<h5 id=\"2-逻辑移位\"><a href=\"#2-逻辑移位\" class=\"headerlink\" title=\"2. 逻辑移位\"></a>2. 逻辑移位</h5><p>​        逻辑移位不考虑符号位。</p>\n<p>​        移位规则：逻辑左移时，高位移出，低位补 0；逻辑右移时，低位移岀，高位补 0 。</p>\n<h4 id=\"2-3-3-定点数的加减运算\"><a href=\"#2-3-3-定点数的加减运算\" class=\"headerlink\" title=\"2.3.3 定点数的加减运算\"></a>2.3.3 定点数的加减运算</h4><p>​        加减法运算是计算机中最基本的运算，由于减法可以看成是负值的加法，因此计算机中使用补码表示有符号数之后，可以将减法运算和加法运算合并在一起讨论。</p>\n<h5 id=\"1-补码的加减运算\"><a href=\"#1-补码的加减运算\" class=\"headerlink\" title=\"1. 补码的加减运算\"></a>1. 补码的加减运算</h5><p>​        补码加减运算的规则简单，易于实现。补码加减运算的公式如下（设机器字长为 n）：<br>​                                                                [A + B]<sub>补</sub> = [A]<sub>补</sub> + [B]<sub>补</sub>  (mod 2<sup>n</sup>)<br>​                                                                [A - B]<sub>补</sub> = [A]<sub>补</sub> + [-B]<sub>补</sub>  (mod 2<sup>n</sup>)</p>\n<p>​        补码运算的特点如下：</p>\n<ul>\n<li>按二进制运算规则运算，逢二进一。</li>\n<li>如果做加法，两数的补码直接相加；如果做减法，则将被减数加上减数的机器负数。</li>\n<li>符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。</li>\n<li>最终将运算结果的高位丢弃，保留 n 位，运算结果也是补码。</li>\n</ul>\n<p>​        例如，假设机器字长为 8 （n = 8），那么</p>\n<p>​        [5]<sub>补</sub> = 0000 0101，[4]<sub>补</sub> = 0000 0100；</p>\n<p>​        [-5]<sub>补</sub> = 1111 1011，[-4]<sub>补</sub> = 1111 1100；</p>\n<p>​        [5 + 4]<sub>补</sub> = 0000 0101 + 0000 0100 = 0000 1001 = [9]<sub>补</sub>；</p>\n<p>​        [5 - 4]<sub>补</sub> = [5 + (-4)]<sub>补</sub> = 0000 0101 + 1111 1100 = 1 0000 0001 = [1]<sub>补</sub>；</p>\n<p>​        [4 - 5]<sub>补</sub> = [4 + (-5)]<sub>补</sub> = 0000 0100 + 1111 1011 = 1111 1111 = [-1]<sub>补</sub>；</p>\n<p>​        [-5 - 4]<sub>补</sub> = [-5 + (-4)]<sub>补</sub> = 1111 1011 + 1111 1100 = 1 1111 0111 = [-9]<sub>补</sub>；</p>\n<h5 id=\"2-溢出判别方法\"><a href=\"#2-溢出判别方法\" class=\"headerlink\" title=\"2. 溢出判别方法\"></a>2. 溢出判别方法</h5><p>​        <strong>溢出</strong> 是指运算结果超出了数的表示范围。通常，大于能表示的最大正数称为正上溢，小于能表示的最小负数称为负上溢。仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。</p>\n<p>​        在之前的例子中，如果假设机器字长为 4（n = 4），能表示的有符号数范围为 -8 ~ 7，那么就有：</p>\n<p>​        [5]<sub>补</sub> = 0101，[4]<sub>补</sub> = 0100；</p>\n<p>​        [-5]<sub>补</sub> = 1011，[-4]<sub>补</sub> = 1100；</p>\n<p>​        [5 + 4]<sub>补</sub> = 0101 + 0100 = 1001 = [-7]<sub>补</sub>；        （正溢出）</p>\n<p>​        [5 - 4]<sub>补</sub> = [5 + (-4)]<sub>补</sub> = 0101 + 1100 = 1 0001 = [1]<sub>补</sub>；</p>\n<p>​        [4 - 5]<sub>补</sub> = [4 + (-5)]<sub>补</sub> = 0100 + 1011 = 1111 = [-1]<sub>补</sub>；</p>\n<p>​        [-5 - 4]<sub>补</sub> = [-5 + (-4)]<sub>补</sub> = 1011 + 1100 = 1 0111 = [7]<sub>补</sub>；        （负溢出）</p>\n<p>​        补码加减运算的溢出判断方法有以下 3 种：</p>\n<p>（1）采用一位符号位。</p>\n<p>​        参加操作的两个数符号相同，结果又与原操作数符号不同，就表示结果溢出。</p>\n<p>​        一正一负相加必然不会溢出；两正数相加得到一个负数（符号位为1），则正溢出；两负数相加得到一个正数，则负溢出。</p>\n<p>（2）采用双符号位。</p>\n<p>​        运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位就代表真正的符号。也就是说，符号位 S<sub>1</sub>S<sub>2</sub> = 00 表示结果为正数，无溢出； S<sub>1</sub>S<sub>2</sub> = 11 表示结果为负数，无溢出。 S<sub>1</sub>S<sub>2</sub>= 01 表示结果正溢出； S<sub>1</sub>S<sub>2</sub> = 10 表示结果负溢出。溢出标志 OF = S<sub>1</sub> ㊉ S<sub>2</sub>。</p>\n<p>​        比如上例中，如果采用双符号位，机器字长就应该扩展为 5，那么：</p>\n<p>​        [5]<sub>补</sub> = 00 101，[4]<sub>补</sub> = 00 100；</p>\n<p>​        [-5]<sub>补</sub> = 11 011，[-4]<sub>补</sub> = 11 100；</p>\n<p>​        [5 + 4]<sub>补</sub> = 00 101 + 00 100 = 01 001 = [1]<sub>补</sub>；        （正溢出）</p>\n<p>​        [5 - 4]<sub>补</sub> = [5 + (-4)]<sub>补</sub> = 00 101 + 11 100 = 1 00 001 = [1]<sub>补</sub>；</p>\n<p>​        [4 - 5]<sub>补</sub> = [4 + (-5)]<sub>补</sub> = 00 100 + 11 011 = 11 111 = [-1]<sub>补</sub>；</p>\n<p>​        [-5 - 4]<sub>补</sub> = [-5 + (-4)]<sub>补</sub> = 11 011 + 11 100 = 1 10 111 = [-1]<sub>补</sub>；        （负溢出）</p>\n<h4 id=\"2-2-4-定点数的乘法运算\"><a href=\"#2-2-4-定点数的乘法运算\" class=\"headerlink\" title=\"2.2.4 定点数的乘法运算\"></a>2.2.4 定点数的乘法运算</h4><h5 id=\"1-原码一位乘法\"><a href=\"#1-原码一位乘法\" class=\"headerlink\" title=\"1. 原码一位乘法\"></a>1. 原码一位乘法</h5><p>​        原码乘法运算的符号位与数值位分开计算。</p>\n<ul>\n<li>确定乘积的符号位。由两个乘数的符号进行异或运算得到。</li>\n<li>计算乘积的数值位。两个乘数的数值部分之积，可看作两个无符号数的乘积。</li>\n</ul>\n<p>​        原码一位乘法的基本思路，就是类似竖式乘法的做法，让被乘数 x 分别乘以乘数 y 的每一位，然后再做叠加。不过竖式乘法需要做连加运算，这在电路实现上会有一些困难；改进的做法是，借鉴进制转换的“重复相乘/除法”，对每一位进行迭代计算。</p>\n<p>​        回忆一下二进制数转换成十进制数的重复相乘/除法：</p>\n<p>​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：</p>\n<p>​        (11011)<sub>2</sub>  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27</p>\n<p>​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：</p>\n<p>​        (0.101)<sub>2</sub>  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625</p>\n<p>​        所以，两数相乘时，就可以把乘数 y 用这种方式按每一位拆开，并乘以 x 、再逐位叠加就可以了。由于每次乘以 2 就相当于左移一位、除以 2 就相当于右移一位，因此只需要反复迭代这样的 <strong>移位</strong> 和 <strong>加法</strong> 运算就可以很容易地实现乘法了。</p>\n<p><img src=\"/img/2_25_原码一位乘计算通式.png\" alt=\"2_25_原码一位乘计算通式\"></p>\n<p>原码一位乘法的运算规则如下：</p>\n<ul>\n<li>被乘数和乘数均取绝对值|x| 和 |y|参加运算，看作无符号数，符号位为 x<sub>0</sub> ㊉ y<sub>0</sub>。</li>\n<li>乘数的每一位 y<sub>i</sub> 乘以被乘数 |x| 得到 |x| · y<sub>i</sub>，将该结果与前面所得的结果相加，作为部分积；初始值为 0。</li>\n<li>从乘数的最低位 y<sub>n</sub> 开始判断：若 y<sub>n</sub> = 1，则部分积加上被乘数 |x|，然后右移一位；若 y<sub>n</sub> = 0，则部分积加上 0，然后右移一位。</li>\n<li>重复上一步骤，判断 n 次。</li>\n</ul>\n<p>​        由于参与运算的是两个数的绝对值，因此运算过程中的右移操作均为逻辑右移。</p>\n<hr>\n<p>​        例如，当 x = 0.1101 = (0.8125)<sub>10</sub>，y = 0.1011 = (0.6875)<sub>10</sub> 时，计算 x · y。</p>\n<p><img src=\"/img/2_26_原码一位乘法示例.png\" alt=\"2_26_原码一位乘法示例\"></p>\n<p>最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：</p>\n<p>​         x · y = 0.1101 × 0.1011 =  0.10001111 = (0.55859375)<sub>10</sub></p>\n<hr>\n<h5 id=\"2-补码一位乘法\"><a href=\"#2-补码一位乘法\" class=\"headerlink\" title=\"2. 补码一位乘法\"></a>2. 补码一位乘法</h5><p>​        带符号数的乘法，采用相加/相减的校正操作，直接计算补码数据的乘积。</p>\n<p>​        补码乘法是直接对补码进行的。对于纯整数，补码表达为：</p>\n<p><img src=\"/img/2_6_整数的补码表示-17170652109566.png\" alt=\"2_6_整数的补码表示\"></p>\n<p>而类似的，纯小数补码定义为：</p>\n<p><img src=\"/img/2_28_定点小数的补码表示.png\" alt=\"2_28_定点小数的补码表示\"></p>\n<p>所以，当取不同的正负符号时，补码表达会有所不同，继而影响到逐位相乘叠加的效果。</p>\n<p>​        已知 [ x ]<sub>补</sub> = x<sub>0</sub> . x<sub>1</sub>x<sub>2</sub>…x<sub>n</sub>，[ y ]<sub>补</sub> = y<sub>0</sub> . y<sub>1</sub>y<sub>2</sub>…y<sub>n</sub>，那么需要分不同的情况讨论：</p>\n<p>​        ① 被乘数 x 和乘数 y 符号均为正，即 x<sub>0</sub> = y<sub>0</sub> = 0 时，</p>\n<p>​        [ x ]<sub>补</sub> = x，[ y ]<sub>补</sub> = y，所以就有：</p>\n<p><img src=\"/img/2_29_正数补码一位乘法通式.png\" alt=\"2_29_正数补码一位乘法通式\"></p>\n<p>类似原码一位乘法，利用移位和加法的叠加，就可以计算出补码的乘积；这也就是最终计算结果的补码。</p>\n<p>​        ② 被乘数 x 为正，乘数 y 为负，即 x<sub>0</sub> = 0，y<sub>0</sub> = 1 时，</p>\n<p>​        [ y ]<sub>补</sub> = 1. y<sub>1</sub>y<sub>2</sub>…y<sub>n</sub> = 2 + y，所以：</p>\n<p><img src=\"/img/2_30_乘数为负时的真值表达式.png\" alt=\"2_30_乘数为负时的真值表达式\"></p>\n<p>那么两数的乘积就可以写成：</p>\n<p><img src=\"/img/2_31_乘数为负时的真值乘积表达式.png\" alt=\"2_31_乘数为负时的真值乘积表达式\"></p>\n<p>这样一个计算结果，它的补码表示为：</p>\n<p><img src=\"/img/2_32_乘数为负时的补码运算表达式.png\" alt=\"2_32_乘数为负时的补码运算表达式\"></p>\n<p>​    可以看到，当乘数为负时，可以把乘数补码 [ y ]<sub>补</sub> 直接去掉符号位，当成一个正数与 [ x ]<sub>补</sub> 相乘；得到的结果再加上 [ -x ]<sub>补</sub> 进行校正。所以这种方法也叫做“校正法”。</p>\n<hr>\n<p>​        例如，当 x = 0.1101 = (0.8125)<sub>10</sub>，y = 1.1011 = (-0.3125)<sub>10</sub> 时，计算 x · y。</p>\n<p>​        我们可以直接计算 0.1101 × 0.1011 = 0.10001111，再加上 [ -x ]<sub>补</sub> = 1. 0011，得到 ：</p>\n<p>​         0.10001111 + 1. 0011 = 1.10111111 =  ( -0.25390625 )<sub>10</sub></p>\n<hr>\n<p>​        ③ 被乘数 x 为负，乘数 y 为正，即 x<sub>0</sub> = 1，y<sub>0</sub> = 0 时，</p>\n<p>​        我们可以交换被乘数和乘数，直接按情况②来处理；也可以仔细分析，发现乘数 y 为正数，可以写成</p>\n<p>[ y ]<sub>补</sub> = 0. y<sub>1</sub>y<sub>2</sub>…y<sub>n</sub> 的形式，同样可以借鉴情况②中的分析和原码一位乘的方法。当两数的补码相乘时：</p>\n<p><img src=\"/img/2_33_乘数为正补码一位乘法.png\" alt=\"2_33_乘数为正补码一位乘法\"></p>\n<p>观察可以发现，与原码一位乘完全类似，补码相乘也可以将乘数展开，逐位进行相乘、右移和叠加。不过需要注意的是，这时由于被乘数 x 是负数，右移时就需要在左侧高位补 1，也就是做算术右移、而不是逻辑右移。</p>\n<p>​        这样一来，算术右移就实现了对真值 x 的“除以 2”操作，最终叠加之后的结果，就是 x · y 的补码了。</p>\n<p>​        例如，当 x = 1.1 = (-0.5)<sub>10</sub>，y = 0.011 = (0.375)<sub>10</sub> 时，计算 x · y。</p>\n<p><img src=\"/img/2_34_乘数为正的补码一位乘法示例.png\" alt=\"2_34_乘数为正的补码一位乘法示例\"></p>\n<p>最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：</p>\n<p>​         x · y = 1.1 × 0.011 =  1.1101 = ( - 0.1875 )<sub>10</sub>        </p>\n<p>​        ④ 被乘数 x 和乘数 y 符号均为负，即 x<sub>0</sub> = y<sub>0</sub> = 1 时，</p>\n<p>​        通过情况②和③的分析可以看出，当乘数 y 为正时，可以直接按照原码一位乘的方式进行补码乘法，注意需要进行算术右移；而当乘数 y 为负时，则可以先不考虑 y 的符号位，同样按照原码一位乘进行补码乘法，最后的结果要再加上 [ -x ]<sub>补</sub> 进行校正。</p>\n<p>​        例如，当 x = 1.1 = (-0.5)<sub>10</sub>，y = 1.011 = (-0.625)<sub>10</sub> 时，计算 x · y。</p>\n<p>​        我们可以直接计算 1.1 × 0.011 =  1.1101，再加上 [ -x ]<sub>补</sub> = 0.1，得到 ：</p>\n<p>​        1.1101 + 0.1 = 1 0.0101 =  ( 0.3125 )<sub>10</sub></p>\n<p>​        可以看出，如果使用双符号位来表示正负，会更加方便。</p>\n<p>​        ⑤  <strong>Booth算法</strong></p>\n<p>​        以上的 4 种情况需要分别讨论，根据乘数的符号来决定是否需要进行校正。</p>\n<p>​        如果不考虑操作数的符号，直接用统一的规则来处理所有情况，可以采用 <strong>Booth 算法</strong>。</p>\n<p>​        当被乘数 x 和乘数 y 符号任意时，按照之前讨论的校正法规则，可以写出一个统一的计算公式：</p>\n<p><img src=\"/img/2_35_Booth算法补码一位乘法通式.png\" alt=\"2_35_Booth算法补码一位乘法通式\"></p>\n<p>​    容易推出，对于纯小数，在 mod 2 的前提下，[ -x ]<sub>补</sub> = - [ x ]<sub>补</sub>，所以可以进一步推导得到：</p>\n<p><img src=\"/img/2_36_Booth算法的迭代公式推导.png\" alt=\"2_36_Booth算法的迭代公式推导\"></p>\n<p>​    令 y<sub>n+1</sub> = 0，那么就可以得到一个通项系数： d<sub>i</sub> = y<sub>i+1</sub> - y<sub>i</sub> ，上式可以进一步化简为：</p>\n<p><img src=\"/img/2_37_Booth算法最终计算公式.png\" alt=\"2_37_Booth算法最终计算公式\"></p>\n<p>这样一来，补码乘法的计算方式就跟原码一位乘完全一样了，只是被乘数每次乘的不再是乘数 y 的每一位 y<sub>i</sub>，而是变成了 d<sub>i</sub> = y<sub>i+1</sub> - y<sub>i</sub> 。这样就有 1、-1 和 0 三种情况，每一次计算都由 d<sub>i</sub> 来决定部分积叠加的是 [ x ]<sub>补</sub>、[ -x ]<sub>补</sub> 还是 0；然后再做一位算术右移得到新的部分积。最后一步，需要由 d<sub>0</sub> = y<sub>1</sub> - y<sub>0</sub> 决定是否有叠加项，但不再做位移。</p>\n<p>​        Booth 算法的移位规则如下表所示：</p>\n<p><img src=\"/img/2_38_Booth算法的移位规则.png\" alt=\"2_38_Booth算法的移位规则\"></p>\n<p>Booth 算法的具体运算规则如下：</p>\n<p>①    符号位参与运算，运算的数均以补码表示。</p>\n<p>②    被乘数一般取 <strong>双符号位</strong> 参与运算，部分积取 <strong>双符号位</strong>，初值为 0，乘数取单符号位。</p>\n<p>③    乘数末尾增加一个“附加位” y~n+l~，初始值为 0。</p>\n<p>④    根据（y<sub>i</sub>，y<sub>i+1</sub>）的取值来确定操作，如上表所示。</p>\n<p>⑤    移位按补码右移规则（算术右移）进行。</p>\n<p>⑥    按照上述算法进行 n + 1 步操作，但第 n + 1 步不再移位，仅根据 y<sub>0</sub> （符号位）与 y<sub>1</sub> （第一位数值位）的比较结果做相应的叠加运算。所以总共需要进行 n + 1 次累加和 n 次右移。</p>\n<hr>\n<p>​        例如，当 x = 1.1101 = (-0.1875)<sub>10</sub>，y = 1.1011 = (-0.3125)<sub>10</sub>  时，计算 x · y。</p>\n<p>​        首先得到 [x]<sub>补</sub> = 11.1101，[-x]<sub>补</sub> = 00.0011。具体计算步骤如下：</p>\n<p><img src=\"/img/2_39_补码一位乘法示例（Booth算法）.png\" alt=\"2_39_补码一位乘法示例（Booth算法）\"></p>\n<p>同样，最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：</p>\n<p>​         x · y = 1.1101 × 1.1011 =  0.00001111 = (0.05859375)<sub>10</sub></p>\n<h4 id=\"2-2-5-定点数的除法运算\"><a href=\"#2-2-5-定点数的除法运算\" class=\"headerlink\" title=\"2.2.5 定点数的除法运算\"></a>2.2.5 定点数的除法运算</h4><h5 id=\"1-原码一位除法\"><a href=\"#1-原码一位除法\" class=\"headerlink\" title=\"1. 原码一位除法\"></a>1. 原码一位除法</h5><p><strong>（1）恢复余数法</strong></p>\n<p>​        恢复余数法的特点是：当余数为负时，需要加上除数的绝对值，将其恢复成原本的余数。</p>\n<p>​        由于每次得到的是商的高位，所以每轮计算可以将余数和商同时左移一位；余数加上 [- y]<sub>补</sub> ，判断正负来决定下一位商是 1 还是 0；如果为负，还需要先加上 [y]<sub>补</sub> 恢复余数，然后再做左移。</p>\n<hr>\n<p>​        例如，当 x = (-0.1011)<sub>2</sub>  = (-0.6875)<sub>10</sub>，y = (-0.1101)<sub>2</sub> = (-0.8125)<sub>10</sub> 时，计算 x / y。</p>\n<p>​        首先看出，商的符号为正，余数的符号为负。并且得到：</p>\n<p>​        x = 0.1011，y= 0.1101，[y]<sub>补</sub> = 0.1101，[-y]<sub>补</sub> = 1.0011</p>\n<p>​        具体计算过程如下：</p>\n<p><img src=\"/img/2_43_原码一位除法示例_恢复余数法.png\" alt=\"2_43_原码一位除法示例_恢复余数法\"></p>\n<p>所以商值为 x/ y = 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2^-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：</p>\n<p>​        x / y = 0.1101（商）… - 0.00000111（余数）</p>\n<p>溢出判断：当该位为 1 时，表示当前除法溢出，不能进行；当该位为 0 时，当前除法合法，可以进行。</p>\n<p><strong>（2）不恢复余数法（加减交替法）</strong></p>\n<p>​        在恢复余数法中，每当余数为负时都需要恢复余数，这就增加了运算量，操作也不规则，电路实现会比较复杂。加减交替法就克服了这一缺点。</p>\n<p>​        <strong>加减交替法</strong> 又称 <strong>不恢复余数法</strong>，是对恢复余数法的一种改进。</p>\n<p>​        通过分析恢复余数法可以发现，如果把第 i 轮计算的余数记作 R<sub>i</sub>，那么：</p>\n<ul>\n<li>如果 R<sub>i</sub> &gt; 0，就上商 1，接下来需要将余数 R<sub>i</sub> 左移一位，再减去除数绝对值 y，即 2R<sub>i</sub> - y；</li>\n<li>如果 R<sub>i</sub> &lt; 0，就上商 0，接下来先加上 y 恢复余数，再做左移和减法，即 2 (R<sub>i</sub> + y) - y = 2R<sub>i</sub> + y。</li>\n</ul>\n<p>​        这样一来，就不需要额外恢复余数了，每轮计算的规则完全统一起来，只是左移之后再加/减 y^*^ 就可以了；所以把这种方法叫做“加减交替法”，或者“不恢复余数法”。</p>\n<hr>\n<p>​        还是上面的例子，当 x = (-0.1011)<sub>2</sub>  ，y = (-0.1101)<sub>2</sub> 时，计算 x / y。</p>\n<p>​        同样的步骤，首先看出，商的符号为正，余数的符号为负。并且得到：</p>\n<p>​        x= 0.1011，y = 0.1101，[y]<sub>补</sub> = 0.1101，[-y]<sub>补</sub> = 1.0011</p>\n<p>​        具体计算过程如下：</p>\n<p><img src=\"/img/2_44_原码一位除法示例_加减交替法.png\" alt=\"2_44_原码一位除法示例_加减交替法\"></p>\n<p>所以商值为 x / y= 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2^-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：</p>\n<p>​        x / y = 0.1101（商）… - 0.00000111（余数）</p>\n<h5 id=\"2-补码一位除法（加减交替法）\"><a href=\"#2-补码一位除法（加减交替法）\" class=\"headerlink\" title=\"2. 补码一位除法（加减交替法）\"></a>2. 补码一位除法（加减交替法）</h5><p><img src=\"/img/2_47_补码除法进一步化简.png\" alt=\"2_47_补码除法进一步化简\"></p>\n<p>补码一位除法的运算规则如下：</p>\n<ul>\n<li>符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。</li>\n<li>如被除数与除数同号，则被除数减去除数；如被除数与除数异号，则被除数加上除数。</li>\n<li>余数与除数同号，商上1，余数左移一位再减去除数；余数与除数异号， 商上 0，余数左移一位再加上除数。</li>\n<li>重复执行上一步操作，操作 n 次。</li>\n<li>如果对商的精度没有特殊要求，一般采用“末位恒置 1”法。</li>\n</ul>\n<p>​    同样的例子，当 x = (-0.1011)<sub>2</sub>  ，y = (-0.1101)<sub>2</sub> 时，计算 x / y。</p>\n<p>​        首先得到： [x]<sub>补</sub> = 1.0101，[y]<sub>补</sub> = 1.0011，[-y]<sub>补</sub> = 0.1101</p>\n<p>​        具体计算过程如下：</p>\n<p><img src=\"/img/2_48_补码一位除法示例.png\" alt=\"2_48_补码一位除法示例\"></p>\n<p>所以商值为</p>\n<p>​        x / y = 0.1101</p>\n<h3 id=\"2-4-浮点数的表示和运算\"><a href=\"#2-4-浮点数的表示和运算\" class=\"headerlink\" title=\"2.4 浮点数的表示和运算\"></a>2.4 浮点数的表示和运算</h3><h4 id=\"2-4-1-浮点数的表示\"><a href=\"#2-4-1-浮点数的表示\" class=\"headerlink\" title=\"2.4.1 浮点数的表示\"></a>2.4.1 浮点数的表示</h4><p><strong>浮点数</strong> 就是小数点的位置可以浮动的数。例如：</p>\n<p>​        365.242 = 3.65242 × 10^2^</p>\n<p>​                       = 365242.0 × 10^-3^</p>\n<p>​                       = 0.365242 × 10^3^</p>\n<h5 id=\"1-浮点数的表示格式\"><a href=\"#1-浮点数的表示格式\" class=\"headerlink\" title=\"1. 浮点数的表示格式\"></a>1. 浮点数的表示格式</h5><p>​        在计算机中，浮点数的格式如下图所示。采用这种数据格式的机器称为 <strong>浮点机</strong>。</p>\n<p><img src=\"/img/2_50_浮点数表示格式.png\" alt=\"2_50_浮点数表示格式\"></p>\n<p>​    浮点数由 <strong>阶码 j</strong> 和 <strong>尾数 S</strong> 两部分组成。</p>\n<ul>\n<li>阶码是纯整数，阶符和阶码值合起来决定了小数点的实际位置；阶码值的位数 m 再结合阶符，可以反映浮点数的表示范围。</li>\n<li>尾数是纯小数，数符 Sf代表了浮点数的正负，而尾数值则是有效数位，位数 n 反映了浮点数的精度。</li>\n</ul>\n<h5 id=\"2-浮点数的表示范围\"><a href=\"#2-浮点数的表示范围\" class=\"headerlink\" title=\"2. 浮点数的表示范围\"></a>2. 浮点数的表示范围</h5><p>​        假设浮点数 N 的阶码 j 数值部分有 m 位，尾数 S 数值部分有 n 位。</p>\n<p>​        阶码是纯整数，尾数是纯小数，它们可以各自选择编码方式。对于非规格化的浮点数，如果阶码和尾数都用原码表达，各自的取值范围如下：</p>\n<p><img src=\"/img/2_51_采用原码表示的阶码尾数范围.png\" alt=\"2_51_采用原码表示的阶码尾数范围\"></p>\n<p>​        那么阶码 j 和尾数 S 组合之后，能表示的浮点数最大范围就是：</p>\n<p><img src=\"/img/2_52_采用原码表示的浮点数取值范围.png\" alt=\"2_52_采用原码表示的浮点数取值范围\"></p>\n<p>在数轴上表示出来，如下图所示：</p>\n<p><img src=\"/img/2_53_浮点数取值范围在数轴上的表示.png\" alt=\"2_53_浮点数取值范围在数轴上的表示\"></p>\n<p>原码是关于原点对称的，所以浮点数的表示范围也是关于原点对称的。</p>\n<p>​        当运算结果大于能表示的最大正数时，称为正上溢；小于最小负数时。称为负上溢：两者统称 <strong>上溢</strong>。由于尾数的溢出可以通过移位、增加阶码来调整，因此上溢的本质就是 <strong>阶码大于最大阶码</strong>，这时机器会停止计算，进行中断溢出处理。</p>\n<p>​        当运算结果在 0 至最小正数之间时，称为正下溢；在 0 至最大负数之间时，称为负下溢，统称 <strong>下溢</strong>。同样道理，下溢的本质是 <strong>阶码小于最小阶码</strong>，这时溢出的数值绝对值非常小，通常可以将尾数各位直接强置为 0，按 ”<strong>机器零</strong>“ 来处理，机器可以继续正常运行。</p>\n<p>​        类似地，如果阶码和尾数都用补码表达，各自的取值范围如下：</p>\n<p><img src=\"/img/2_54_采用补码表示的阶码尾数范围.png\" alt=\"2_54_采用补码表示的阶码尾数范围\"></p>\n<p>​    用移码来表示阶码方便进行阶数的比较和对齐，简称 “<strong>对阶</strong>”。这在进行浮点数加减运算时非常重要，尾数只有在阶数相同的时候才能做加减，采用移码直接比较两个阶码的二进制大小关系就可以了：</p>\n<p><img src=\"/img/2_55_采用移码表示阶码的浮点数范围.png\" alt=\"2_55_采用移码表示阶码的浮点数范围\"></p>\n<h5 id=\"3-浮点数的规格化\"><a href=\"#3-浮点数的规格化\" class=\"headerlink\" title=\"3. 浮点数的规格化\"></a>3. 浮点数的规格化</h5><p>​        由于规格化数的精度最高，所以当一个非零的浮点数不是规格化数时，应该通过左右移动尾数、并同时修改阶码的方法，将它转换为规格化数。把一个非规格化数转换成规格化数的过程，叫做 <strong>规格化</strong>。</p>\n<p>​        规格化的本质类似于 “科学计数法” 的表达，通过保证尾数最高数位上是一个有效值，尽可能多地保留有效数字的尾数，从而提高精度。</p>\n<p>​        规格化可以分为 “<strong>左规</strong>” 和 “<strong>右规</strong>” 两种。以基数 r = 2 为例：</p>\n<ul>\n<li>左规：向左规格化。当运算结果尾数的最高数位不是有效位，即出现 0.0…01… 的形式时，需要向左规格化。左规时，尾数左移一位，阶码减 1；</li>\n<li>右规：向右规格化。当运算结果尾数的小数点左侧出现有效位，即整数部分不为 0 时，需要向右规格化。右规时，尾数右移一位，阶码加 1；需要右规时，只需进行一次。</li>\n</ul>\n<p>​        当基数不同时，规格化的原则会有相应的改变。比如，当基数 r = 4 时，阶码每次加/减 1，就相当于多乘/除以 4，也就是左/右移 2 位。所以左规就是尾数左移 2 位，阶码减 1；右规是尾数右移 2 位，阶码加 1。尾数的最高 2 位不全为 0 的数，就是规格化数。</p>\n<p><img src=\"/img/2_56_规格化数的尾数范围.png\" alt=\"2_56_规格化数的尾数范围\"></p>\n<h5 id=\"4-IEEE-754-标准浮点数\"><a href=\"#4-IEEE-754-标准浮点数\" class=\"headerlink\" title=\"4. IEEE 754 标准浮点数\"></a>4. IEEE 754 标准浮点数</h5><p>​        在现代计算机中，浮点数的格式一般采用 IEEE 制定的国际标准。IEEE 754 标准规定的浮点数形式为：</p>\n<p><img src=\"/img/2_58_IEEE 浮点数形式-171707522309712.png\" alt=\"2_58_IEEE 浮点数形式\"></p>\n<ul>\n<li>S 为数符，直接表示浮点数的正负，它与尾数所表示的有效数位是分开的。</li>\n<li>阶码 E 包含了阶符，用移码来表示，不过这里移码的偏移量不是 2 的整次幂，而是要再减去 1。 假设阶码 E 的位数为 m + 1，那么偏移量就是 2^m - 1。</li>\n<li>尾数 M 是原码表示的纯小数。</li>\n</ul>\n<p>​        浮点数的位数不同，可以表示不同的数值范围和精度。IEEE 标准中常用的浮点数有三种：短浮点数（单精度）、长浮点数（双精度）和临时浮点数（延伸双精度）。</p>\n<p><img src=\"/img/2_59_IEEE 三种浮点数格式-171707523089113.png\" alt=\"2_59_IEEE 三种浮点数格式\"></p>\n<p>​    以 32 位的单精度浮点数为例，所有的机器码和对应的取值范围如下：</p>\n<p><img src=\"/img/2_60_IEEE 单精度32位浮点数表示范围-171707523739914.png\" alt=\"2_60_IEEE 单精度32位浮点数表示范围\"></p>\n<hr>\n<p>​    例如，对于十进制数 178.125，把它写成 IEEE 标准的短浮点数。</p>\n<p>​        我们需要分整数部分和小数部分，首先转换成二进制数的表示；然后写成类似 “科学计数法” 的二进制浮点数表达。</p>\n<p><img src=\"/img/2_61_IEEE 浮点数示例（一）_数的二进制浮点表达-171707524581315.png\" alt=\"2_61_IEEE 浮点数示例（一）_数的二进制浮点表达\"></p>\n<p>​    这是一个正数，符号位为 0；然后从二进制浮点表达中得到阶码和尾数。将 8 位二进制阶码加上偏移量 127，尾数隐藏整数位的 1 后补成 23 位，就是最终符合 IEEE 标准的 32 位短浮点数。</p>\n<p><img src=\"/img/2_62_IEEE 浮点数示例（二）_IEEE标准短浮点数-171707525240816.png\" alt=\"2_62_IEEE 浮点数示例（二）_IEEE标准短浮点数\"></p>\n<p>​    </p>\n<h4 id=\"2-4-2-浮点数的加-减运算\"><a href=\"#2-4-2-浮点数的加-减运算\" class=\"headerlink\" title=\"2.4.2 浮点数的加/减运算\"></a>2.4.2 浮点数的加/减运算</h4><p>​    （1）对阶</p>\n<p>​        对阶的目的是使两个操作数的小数点位置对齐，使两个数的阶码相等。先求阶差，然后以 “小阶向大阶看齐” 的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。</p>\n<p>​    （2）尾数求和</p>\n<p>​        将对阶后的尾数，按定点数加/减运算规则运算。</p>\n<p>​    （3）规格化</p>\n<p>​        IEEE 754 规格化尾数的形式为 ±1.×…×，所以当计算结果为非规格化数时，需要进行规格化处理。</p>\n<ul>\n<li>左规：当结果为 ±0.0…01x…x 时，需进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1移到小数点左边。</li>\n<li>右规：当结果为 ±1x.x…x 时，出现了尾数的溢出，需进行右规。尾数右移一位，阶码加 1。当尾数右移时，<strong>最高位 1 被移到小数点前一位作为隐藏位</strong>；当最后一位移出时，要考虑舍入。</li>\n</ul>\n<p>​        左规一次相当于乘以2，右规一次相当于除以2；需要右规时，只需进行一次。</p>\n<p>​    （4）舍入</p>\n<p>​        在对阶和尾数右规时，尾数右移可能会将低位丢失，影响精度，IEEE 754有以下4种舍入方式：</p>\n<ul>\n<li>就近舍入：舍入为最近的那个数，类似于 “四舍五入”，一般被叫做 “ 0 舍 1 入” 法；如果被舍入的值恰好是 100…0 形式，选择舍入为最近的偶数；</li>\n<li>正向舍入：向 +∞ 方向舍入，即取右边那个数，也叫 “向上舍入”；</li>\n<li>负向舍入：向 -∞ 方向舍入，即取左边那个数，也叫 “向下舍入”；</li>\n<li>截断：朝 0 方向舍入，即取绝对值较小的那个数。</li>\n</ul>\n<p>​    （5）溢出判断</p>\n<p>​        浮点数的溢出，并不是以尾数溢岀来判断的；尾数溢出可以通过右规操作得到纠正。运算结果是否溢出，主要看结果的指数是否发生了溢出，因此是由阶码来判断的。</p>\n<ul>\n<li>若一个正阶码超出了最大允许值（127 或 1023），则发生上溢，产生异常；</li>\n<li>若一个负阶码超出了最小允许值（-149 或 -1074），则发生下溢，通常把结果按机器零处理。</li>\n</ul>\n<hr>\n<p>​        例如，两个数 x = 29/32 × 2^7^，y = 5/8 × 2^5^，用浮点加法计算 x + y。假设浮点数的阶码和尾数均用补码表示，且阶码为 5 位（含 2 位阶符），尾数为 7 位（含 2 位数符）。</p>\n<p>​        首先，将浮点数写成下面的规格化二进制形式：</p>\n<p>​        x = 0.11101 × 2^111^，y = 0.101 × 2^101^</p>\n<p>​        具体计算过程如下：</p>\n<p>​        （1）对阶</p>\n<p>​        阶码相减 00, 111 - 00, 101 = 00, 010，说明 x 的阶码比 y 的大 2，需要将 y 的尾数右移两位，阶码加 2：</p>\n<p>​        y = 0.00101 × 2^111^</p>\n<p>​        （2）尾数求和</p>\n<p>​        尾数相加 00.11101 + 00.00101 = 01.00010</p>\n<p>​        （3）规格化</p>\n<p>​        运算结果的尾数出现溢出，需要进行右规：尾数右移一位，阶码加 1：</p>\n<p>​        1.00010 × 2^111^ = 0.100010 × 2^1000^，即计算结果为 01, 000; 00, 10001</p>\n<p>​        （4）舍入</p>\n<p>​        结果的尾数用补码表示为：00 10001，不需要舍入。</p>\n<p>​        （5）溢出判断</p>\n<p>​        结果的阶码用补码表示为：01 000，由于阶符为 01，说明结果溢出。</p>\n<hr>\n<h3 id=\"2-5-数据的存储和排列\"><a href=\"#2-5-数据的存储和排列\" class=\"headerlink\" title=\"2.5 数据的存储和排列\"></a>2.5 数据的存储和排列</h3><h4 id=\"2-5-1-数据按“边界对齐”方式存储\"><a href=\"#2-5-1-数据按“边界对齐”方式存储\" class=\"headerlink\" title=\"2.5.1 数据按“边界对齐”方式存储\"></a>2.5.1 数据按“边界对齐”方式存储</h4><p>​        可以假设字长为 32 位，可按字节、半字、字寻址。在对准边界的 32 位计算机中，半字地址是 2 的整数 倍，字地址是 4 的整数倍，当所存数据不满足此要求时，可填充一个或多个空白字节。这种存储方式称为 “<strong>边界对齐</strong>” 。这样无论所存的数据是字节、半字还是字，均可一次访存取出。虽然浪费了一些存储空间，但可提高存取速度。</p>\n<p>​        数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能取得所需数据，从而影响系统的效率。</p>\n<p><img src=\"/img/2_63_按边界对齐方式存储示例.png\" alt=\"2_63_按边界对齐方式存储示例\"></p>\n<p><img src=\"/img/2_64_不按边界对齐方式存储示例.png\" alt=\"2_64_不按边界对齐方式存储示例\"></p>\n<p>在 C 语言的 struct 类型中，边界对齐方式存储有两个重要要求：</p>\n<p>​        （1）每个成员按其类型的方式对齐，比如 char 类型的对齐值为 1，short 为 2，int 为 4（单位为字节）。</p>\n<p>​        （2）struct 的长度必须是成员中最大对齐值的整数倍（不够就补空字节），以便在处理 struct 数组时保证每项都满足边界对齐的条件。</p>\n<p>​        例如，下面是两个成员完全一样的结构体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct A &#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tshort s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">struct B &#123;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tshort s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        但两者在内存中占据的空间却不同。这是因为结构体成员是按定义的先后顺序排列的，编译器要使它们在空间上对齐，所以应该有：</p>\n<p>​        每个成员存储的起始地址 ％ 该成员的长度 = 0</p>\n<p>​        同时，还需要让结构体的长度是最大成员长度的整数倍。</p>\n<p><img src=\"/img/2_65_结构体按边界对齐方式存储示例-171707454680110.png\" alt=\"2_65_结构体按边界对齐方式存储示例\"></p>\n<h4 id=\"2-5-2-数据的“大端方式”和“小端方式”存储\"><a href=\"#2-5-2-数据的“大端方式”和“小端方式”存储\" class=\"headerlink\" title=\"2.5.2 数据的“大端方式”和“小端方式”存储\"></a>2.5.2 数据的“大端方式”和“小端方式”存储</h4><p>​        在存储数据时，通常用 <strong>最低有效字节（LSB）</strong>和 <strong>最高有效字节（MSB）</strong>来分别表示数据的低位和高位。例如，在 32 位机器中定义了一个 int 类型的变量 i，机器数为 18 0B C5 F3H，那么它的 MSB = 18H，LSB = F3H。</p>\n<p>​        现代计算机基本都采用字节编址，也就是每个地址编号对应存放 1 个字节。不同类型的数据占用的字节数不 同，而程序中对每个数据只给定一个地址。变量 i 占据连续的四个字节，它们各有一个内存地址，而变量 i 的地址就是开始的那个字节的地址。假设 i 的地址为 6C 00H，那么 i 具体存放的四个字节的地址就是：6C 00H、6C 01H、6C 02H、6C 03H。而具体每个字节存放什么内容，可以有不同的定义方式。</p>\n<p>​        多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，分为两种排列方式：<strong>大端方式</strong>（big endian）和 <strong>小端方式</strong>（little endian）。</p>\n<p><img src=\"/img/2_66_大端和小端方式示例.png\" alt=\"2_66_大端和小端方式示例\"></p>\n<ul>\n<li>大端方式：先存储高位字节，后存储低位字节。高位字节存储在低位地址中，字中的字节顺序和原序列相同。</li>\n</ul>\n<ul>\n<li>小端方式：先存储低位字节，后存储高位字节。低位字节存储在低位地址中，字中的字节顺序和原序列相反。</li>\n</ul>\n<h3 id=\"2-6-章节练习\"><a href=\"#2-6-章节练习\" class=\"headerlink\" title=\"2.6 章节练习\"></a>2.6 章节练习</h3><h4 id=\"一、单项选择题-1\"><a href=\"#一、单项选择题-1\" class=\"headerlink\" title=\"一、单项选择题\"></a>一、单项选择题</h4><p>​    1. 【2018真题】冯·诺伊曼结构计算机中的数据采用二进制编码表示，其主要原因是（  ）。</p>\n<p>​        I. 二进制的运算规则简单                II. 制造两个稳态的物理器件较容易</p>\n<p>​        III. 便于用逻辑门电路实现算术运算</p>\n<p>​        A. 仅 I、II                B. 仅 I、III                C. 仅 II、III                D. I、II 和 III</p>\n<p>​        答案： D</p>\n<ol>\n<li>【 2015真题】由 3个“1”和 5个“0”组成的8位二进制补码，能表示的最小整数是  （   ）。</li>\n</ol>\n<p>​        A． -126                B． -125                C． -32                D． -3</p>\n<p>​        答案：B</p>\n<ol>\n<li>【2022真题】32 位补码所能表示的整数范围是    （   ）。</li>\n</ol>\n<p>​        A. -2<sup>32</sup>~2<sup>31</sup>-1         B. -2<sup>31</sup>~2<sup>31</sup>-1         C. -2<sup>32</sup>~2<sup>32</sup>-1         D. -2<sup>31</sup>~2<sup>32</sup>-1 </p>\n<p>​        答案：B</p>\n<ol>\n<li>【2021真题】已知带符号整数用补码表示，变量 x、y、z 的机器数分别为 FFFDH、FFDFH、7FFCH，下列结论中，正确的是    （   ）。</li>\n</ol>\n<p>​        A. 若x、y和z为无符号整数,则z&lt;x&lt;y        B. 若x、y和z为无符号整数,则x&lt;y&lt;z</p>\n<p>​        C. 若x、y和z为带符号整数,则x&lt;y&lt;z        D. 若x、y和z为带符号整数,则y&lt;x&lt;z</p>\n<p>​        答案：D</p>\n<p>​    5. 【2016真题】有如下 C 语言程序段 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short si = -32767;</span><br><span class=\"line\">unsigned short usi = si;</span><br></pre></td></tr></table></figure>\n<p>​        执行上述两条语句后， usi 的值为     （   ）。</p>\n<p>​        A． -32767         B． 32767         C． 32768         D． 32769 </p>\n<p>​        答案：D</p>\n<p>​    6. 【2019真题】考虑以下 C 语言代码： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned short usi = 65535;</span><br><span class=\"line\">short si = usi;</span><br></pre></td></tr></table></figure>\n<p>​        执行上述程序段后， si 的值是     （   ）。 </p>\n<p>​        A．-1         B．-32767         C．-32768         D．-65535 </p>\n<p>​        答案：A</p>\n<p>​    7. 【2012真题】假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，执行下列 C 语言语句： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsigned short x=65530;</span><br><span class=\"line\">unsigned int y=x;</span><br></pre></td></tr></table></figure>\n<p>​        得到 y 的机器数为     （   ）。</p>\n<p>​        A． 0000 7FFAH       B． 0000 FFFAH         C． FFFF 7FFAH         D． FFFF FFFAH</p>\n<p>​        答案：B</p>\n<ol>\n<li>【2009真题】一个 C 语言程序在一台 32 位机器上运行。程序中定义了三个变量 x、 y 和 z，其中 x 和 z 为 int 型， y 为 short 型。当 x=127， y=-9 时，执行赋值语句 z=x+y 后， x、 y 和 z 的值分别是 （   ）。</li>\n</ol>\n<p>​    A． x=0000007FH， y=FFF9H， z=00000076H            B． x=0000007FH， y=FFF9H， z=FFFF0076H<br>​    C． x=0000007FH， y=FFF7H， z=FFFF0076H            D． x=0000007FH， y=FFF7H， z=00000076H </p>\n<p>​    答案：D</p>\n<p>​    9. 【2018真题】整数x的机器数为1101 1000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各    是    （   ）。</p>\n<p>​    A.1110 1100、1110 1100                B. 0110 1100、1110 1100</p>\n<p>​    C.1110 1100、0110 1100                D. 0110 1100、 01101100</p>\n<p>​    答案：B</p>\n<ol>\n<li>【2013真题】某字长为 8 位的计算机中，已知整型变量 x、y的机器数分别为$[x]<em>补=1 {\\quad} 1110100，[y]</em>补=1 {\\quad}0110000$。若整型变量 $z=2*x+y/2$，则 z 的机器数为    （   ）。</li>\n</ol>\n<p>​    A.  1 1000000            B.  0 0100100            C.  1 0101010            D.  溢出</p>\n<p>​    答案：A</p>\n<ol>\n<li>【2018真题】假定带符号整数采用补码表示，若 int 型变量 x 和 y 的机器数分别是 FFFF FFDFH 和 0000 0041H，则 x、y 的值以及 x-y 的机器数分别是    （   ）。</li>\n</ol>\n<p>​    A.x=-65，y=41，x-y 的机器数溢出                                B.x=-33，y=65，x-y 的机器数为FFFF FF9DH</p>\n<p>​    C.x=-33，y=65，x-y 的机器数为FFFF FF9EH                D. x = -65，y = 41，x-y 的机器数为FFFF FF96H </p>\n<p>​    答案：C</p>\n<ol>\n<li>【2016真题】某计算机字长为 32 位，按字节编址，采用小端（Little Endian）方式存放数据。假定有一个 double 型变量，其机器数表示为 1122 3344 5566 7788H，存放在 0000 8040H 开始的连续存储单元中，则存储单元 0000 8046H 中存放的是     （   ）。</li>\n</ol>\n<p>​    A． 22H                     B． 33H                     C． 66H                     D． 77H </p>\n<p>​    答案：A</p>\n<ol>\n<li>【2018真题】某32位计算机按字节编址，采用小端(Little Endian)方式。若语句 “inti=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00 00”，则语句 “int i = -64;” 对应指令的机器代码是    （   ）。</li>\n</ol>\n<p>​    A.C7 45 FC C0 FF FF FF        B.C7 45 FC 0C FF FF FF        C.C7 45 FC FF FF FF C0        D.C7 45 FC FF FF FF 0C</p>\n<p>​    答案：A</p>\n<ol>\n<li>【2012真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 型和 short<br>型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下： </li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t<span class=\"type\">char</span> b;</span><br><span class=\"line\">\t<span class=\"type\">short</span> c;</span><br><span class=\"line\">&#125; record;</span><br><span class=\"line\">record.a=<span class=\"number\">273</span>;</span><br></pre></td></tr></table></figure>\n<p>​        若 record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址分别为     （   ）。</p>\n<p>​    A. 0x00、 0xC00D         B. 0x00、 0xC00E        C. 0x11、 0xC00D         D. 0x11、 0xC00E </p>\n<p>​    答案：D</p>\n<ol>\n<li>【2020真题】在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C语言结构型变量a分配存储空间。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Struct record&#123;</span><br><span class=\"line\">\t<span class=\"type\">short</span>   x1;</span><br><span class=\"line\">\t<span class=\"type\">int</span>   x2;</span><br><span class=\"line\">&#125; a;</span><br></pre></td></tr></table></figure>\n<p>​        若a的首地址为 2020 FE00H，a的成员变量x2的机器数为1234  0000H，则其中34H所在存储单元的地址是    （   ）。</p>\n<p>​    A. 2020 FE03H                B. 2020 FE04H                C.2020 FE05H                D. 2020 FE06H</p>\n<p>​    答案：D</p>\n<ol>\n<li>【2012真题】 float 类型（即 IEEE754 单精度浮点数格式）能表示的最大正整数是     （   ）。</li>\n</ol>\n<p>​    A． 2<sup>126</sup>-2<sup>103</sup>               B． 2<sup>127</sup>-2<sup>104</sup>               C． 2<sup>127</sup>-2<sup>103</sup>               D． 2<sup>128</sup>-2<sup>104</sup></p>\n<p>​    答案：D</p>\n<ol>\n<li>【2013真题】某数采用 IEEE 754 单精度浮点数格式表示为C640 0000H，则该数的值是    （   ）。</li>\n</ol>\n<p>​    A. $-1.5×2^{13}$                B. $-1.5 × 2^{12}$                C. $-0.5×2^{13}$                D. $-0.5×2^{12}$</p>\n<p>​    答案：A</p>\n<ol>\n<li>【2014真题】ﬂoat 型数据常用 IEEE 754 单精度浮点格式表示。 假设两个 ﬂoat 型变量 x 和 y 分别存放在32位寄存器 f<sub>1</sub> 和 f<sub>2 </sub>中，若(f<sub>1</sub>)=CC90 0000H, (f<sub>2</sub>)= B0C0 0000H, 则 x 和 y 之间的关系为    （   ）。</li>\n</ol>\n<p>​    A. x<y且符号相同           B. x<y且符号不同            C. x>y且符号相同           D. x&gt;y且符号不同</p>\n<p>​    答案：A</p>\n<ol>\n<li>【2015真题】下列有关浮点数加减运算的叙述中，正确的是    （   ）。<br>Ⅰ ．对阶操作不会引起阶码上溢或下溢<br>Ⅱ ．右规和尾数舍入都可能引起阶码上溢<br>Ⅲ．左规时可能引起阶码下溢<br>Ⅳ．尾数溢出时结果不一定溢出</li>\n</ol>\n<p>​    A．仅Ⅱ 、 Ⅲ                 B． 仅Ⅰ 、 Ⅱ 、 Ⅳ                C．仅Ⅰ 、 Ⅲ、 Ⅳ                D． Ⅰ 、 Ⅱ 、 Ⅲ、 Ⅳ </p>\n<p>​    答案： D</p>\n<ol>\n<li>【2018真题】IEEE 754 单精度浮点格式表示的数中，最小的规格化正数是    （   ）。</li>\n</ol>\n<p>​    A.1.0x2<sup>-126</sup>                    B. 1.0x2<sup>-127</sup>                    C.1.0x2<sup>-128</sup>                    D.1.0x2<sup>-149</sup></p>\n<p>​    答案：A</p>\n<ol>\n<li>【2020真题】已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只<br>可能是 int 或 float，当 x 的机器数为 C800 0000H时，x 的值可能是    （   ）。</li>\n</ol>\n<p>​    A.-7x2<sup>27</sup>                        B.-2<sup>16</sup>                        C. 2<sup>17</sup>                        D. 25x2<sup>27</sup></p>\n<p>​    答案：A</p>\n<ol>\n<li>【2021真题】下列数值中,不能用 IEEE 754 浮点格式精确表示的是    （   ）。</li>\n</ol>\n<p>​    A.1.2                                B.1.25                                C.2.0                                    D.2.5</p>\n<p>​    答案：A</p>\n<ol>\n<li>【2022真题】-0.4375 的 IEEE 754 单精度浮点数表示为（ ）。</li>\n</ol>\n<p>​    A. BEE0 0000H             B. BF60 0000H             C. BF70 0000H             D. C0E0 0000H </p>\n<p>​    答案：A</p>\n<h4 id=\"二、综合应用题-1\"><a href=\"#二、综合应用题-1\" class=\"headerlink\" title=\"二、综合应用题\"></a>二、综合应用题</h4><ol>\n<li>【2020真题】有实现 x*y 的两个 C 语言函数如下:</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"title function_\">umul</span> <span class=\"params\">(<span class=\"type\">unsigned</span> x, <span class=\"type\">unsigned</span> y)</span>&#123;<span class=\"keyword\">return</span> x*y; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">imul</span> <span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span> &#123;<span class=\"keyword\">return</span> x* y;&#125;</span><br></pre></td></tr></table></figure>\n<p>​    假定某计算机 M 中 ALU 只能进行加运算和逻辑运算。请回答下列问题。</p>\n<p>​    （1）若 M 的指令系统中没有乘法指令，但有加法、减法和位移等指令，则在 M 上也能实现上述两个函数中的乘法运算，为什么?</p>\n<p>​    （2）若 M 的指令系统中有乘法指令，则基于 ALU、位移器、寄存器以及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么?</p>\n<p>​    （3）针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令；c）有使用阵列乘法器实现的乘法指令，函数 umul() 在哪种情况下执行时间最长？哪种情况下执行的时间最短？说明理由。</p>\n<p>​    （4）n 位整数乘法指令可保存 2n 位乘积，当仅取低 n 位作为乘积时，其结果可能会发生溢出。当 n=32、x=2<sup>31</sup>-1、y=2 时，带符号整数乘法指令和无符号整数乘法指令得到的 x*y 的 2n 位乘积分别是什么（用十六进制表示）？此时函数 umul() 和 imul() 的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低 n 位作为乘法结果时，如何用 2n 位乘积进行溢出判断？</p>\n<p>​    答案：</p>\n<p>​    （1）编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法、移位等指令实现乘法运算。</p>\n<p>​    （2）控制逻辑的作用为： 控制循环次数，控制加法和移位操作。</p>\n<p>​    （3）a）最长， c）最短。</p>\n<p>​        对于 a）， 需要用循环代码段（软件）实现乘法操作，因而需反复执行很多条指令， 而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长； 对于 b）和 c）， 都只要用一条乘法指令实现乘法操作，不过， b）中的乘法指令需要多个时钟周期才能完成，而 c）中的乘法指令可以在一个时钟周期内完成， 所以 c）执行时间最短。</p>\n<p>​    （4）当 n=32、 x=2<sup>31</sup>-1、 y=2 时，带符号整数和无符号整数乘法指令得到的 64 位乘积都为 0000 0000 FFFF FFFEH。</p>\n<p>​        函数 imul 的结果溢出，而函数 umul 结果不溢出。对于无符号整数乘法，若乘积高 n 位全为 0， 则不溢出，否则溢出。</p>\n<p>【2017真题】 已知</p>\n<p><img src=\"/img/2_67_真题2-2公式.png\" alt=\"2_67_真题2-2公式\"></p>\n<p>计算 f(n) 的 C 语言函数 f1 如下： </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">f1</span><span class=\"params\">(<span class=\"type\">unsigned</span> n)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum=<span class=\"number\">1</span>, power=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">unsigned</span> i=<span class=\"number\">0</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">\t\tpower *= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\tsum += power;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​        将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位， float 采用 IEEE 754 单精度标准。请回答下列问题。</p>\n<p>​    （1）当 n=0 时， f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为什么？</p>\n<p>​    （2）f1(23) 和 f2(23) 的返回值是否相等？机器数各是什么（用十六进制表示）？</p>\n<p>​    （3）f1(24)和 f2(24)的返回值分别为 33 554 431 和 33 554 432.0， 为什么不相等？</p>\n<p>​    （4）f(31)=2^32^-1， 而 f1(31) 的返回值却为 -1，为什么？若使  f1(n) 的返回值与 f(n) 相等，则最大的 n 是多少？</p>\n<p>​    （5）f2(127) 的机器数为 7F80 0000H， 对应的值是什么？若使 f2(n) 的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？ </p>\n<p>​        答案：</p>\n<p>​    （1）由于 i 和 n 是 unsigned 型，故“i&lt;=n-1”是无符号数比较； n=0 时， n-1 的机器数为全1，值是 2<sup>32</sup>-1，为 unsigned 型可表示的最大数，条件“i&lt;=n-1”永真，因此出现死循环。</p>\n<p>​        若 i 和 n 改为 int 类型，则不会出现死循环。因为“i&lt;=n-1”是带符号整数比较， n=0 时， n-1 的值是-1，当 i=0 时条件“i&lt;=n-1”不成立，此时退出 for 循环。</p>\n<p>​    （2）f1(23)与 f2(23)的返回值相等。</p>\n<p>​        f(23) = 2<sup>23+1</sup>-1 = 2<sup>24</sup>-1，它的二进制形式是 24 个1。 int 占 32 位，没有溢出。 float 有 1 个符号位， 8 个指数（阶码）位， 23 个底数（尾数）位， 23 个底数位可以表示 24 位的底数。所以两者返回值相等。</p>\n<p>​        f1(23)的机器数是 00FF FFFFH；f2(23)的机器数是 4B7F FFFFH。显而易见前者是 24 个 1，即 0000 0000 1111 1111 1111 1111 1111 1111<sub>（2）</sub>，后者符号位是 0，指数位为 23+127<sub>(10)</sub> = 1001 0110<sub>（2）</sub>，底数位是 111 1111 1111 1111 1111 1111<sub>（2）</sub>。</p>\n<p>​    （3）当 n=24 时， f(24) = 1 1111 1111 1111 1111 1111 1111 B，而 float 型数只有 24 位有效位，舍入后数值增大，所以 f2(24) 比 f1(24) 大 1。</p>\n<p>​    （4）f(31) 已超出了 int 型数据的表示范围，用 f1(31) 实现时得到的机器数为 32 个 1，作为 int 型数解释时其值为-1，所以 f1(31) 的返回值为-1。 </p>\n<p>​        因为 int 型最大可表示数是 0 后面加 31 个 1，故使 f1(n)的返回值与 f(n)相等的最大 n 值是 30。</p>\n<p>​    （5） f2 返回值为 float 型，7F80 0000H 中数符为0，阶码全为1，尾数为0。IEEE 754 标准用“阶码全 1、尾数全 0”表示无穷大。所以机器数 7F80 0000H 对应的值是+∞。</p>\n<p>​        当 n=126 时， f(126) = 2<sup>127</sup>-1 = 1.1…1×2<sup>126</sup>，对应阶码为 127+126=253，尾数部分舍入后阶码加 1，最终阶码为 254，是 IEEE 754 单精度格式表示的最大阶码。故使 f2 结果不溢出的最大 n 值为 126。</p>\n<p>​        当 n=23 时， f(23) 为 24 位 1， float 型数有 24 位有效位，所以不需舍入，结果精确。所以使 f2 获得精确结果的最大 n 值为 23。</p>\n<h2 id=\"第三章-存储器\"><a href=\"#第三章-存储器\" class=\"headerlink\" title=\"第三章 存储器\"></a>第三章 存储器</h2><h3 id=\"3-1-本章大纲要求与核心考点\"><a href=\"#3-1-本章大纲要求与核心考点\" class=\"headerlink\" title=\"3.1 本章大纲要求与核心考点\"></a>3.1 本章大纲要求与核心考点</h3><h4 id=\"3-1-1-大纲内容\"><a href=\"#3-1-1-大纲内容\" class=\"headerlink\" title=\"3.1.1 大纲内容\"></a>3.1.1 大纲内容</h4><p>（一）存储器的分类</p>\n<p>（二）层次化存储器的基本结构</p>\n<p>（三）半导体随机存储器</p>\n<ol>\n<li>SRAM 存储器</li>\n<li>DRAM 存储器</li>\n<li>Flash 存储器</li>\n</ol>\n<p>（四）主存储器</p>\n<ol>\n<li>DRAM 芯片和内存条</li>\n<li>多模块存储器</li>\n<li>主存和CPU之间的连接</li>\n</ol>\n<p>（五）外部存储器</p>\n<ol>\n<li>磁盘存储器</li>\n<li>固态硬盘（SSD）</li>\n</ol>\n<p>（六）高速缓冲存储器（Cache）</p>\n<ol>\n<li>Cache 的基本工作原理</li>\n<li>Cache 和主存之间的映射方式</li>\n<li>Cache 中主存块的替换算法</li>\n<li>Cache 写策略</li>\n</ol>\n<p>（七）虚拟存储器</p>\n<ol>\n<li><p>虚拟存储器的基本概念</p>\n</li>\n<li><p>页式虚拟存储器</p>\n<p>基本原理，页表，地址转换，TLB（快表）</p>\n</li>\n<li><p>段式虚拟存储器</p>\n</li>\n<li><p>段页式虚拟存储器</p>\n</li>\n</ol>\n<h4 id=\"3-1-2-核心考点\"><a href=\"#3-1-2-核心考点\" class=\"headerlink\" title=\"3.1.2 核心考点\"></a>3.1.2 核心考点</h4><p>​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。</p>\n<p>​        需要重点掌握的内容包括：</p>\n<ul>\n<li>半导体存储芯片的特性、工作原理、扩展技术及与 CPU 的连接，多模块存储器的原理。</li>\n<li>磁盘存储器的原理、特点、性能指标，RAID 的原理，固态硬盘的特点和原理。</li>\n<li>程序访问的局部性原理，Cache 的工作原理及性能计算，Cache 和主存的三种映射方式的原理、 特点、地址结构、访存过程，Cache 替换算法（常考 LRU） , Cache 写策略，Cache 块中的标记项。</li>\n<li>虚拟存储器的基本原理，页表机制（二级页表结合操作系统考查），快表的原理，具有快表和 Cache 的多级页式存储系统的工作原理（综合性较强），段式和段页式虚拟存储器的基本原理。</li>\n</ul>\n<h4 id=\"3-1-3-真题分布\"><a href=\"#3-1-3-真题分布\" class=\"headerlink\" title=\"3.1.3 真题分布\"></a>3.1.3 真题分布</h4>  <table style=\"text-align:center\">\n      <tr>\n          <th rowspan=\"2\">考点</th>\n          <th colspan=\"2\">考查次数</th>\n      </tr>\n      <tr>\n          <th>单项选择题</th>\n          <th>综合应用题</th>\n      </tr>\n      <tr>\n          <td>高速缓冲存储器（Cache）</td>\n          <td>12</td>\n          <td>9</td>\n      </tr>\n      <tr>\n          <td>虚拟存储器</td>\n          <td>5</td>\n          <td>9</td>\n      </tr>\n      <tr>\n          <td>半导体存储器</td>\n          <td>6</td>\n          <td>1</td>\n      </tr>\n      <tr>\n          <td>主存的扩展及与 CPU 的连接</td>\n          <td>6</td>\n          <td>1</td>\n      </tr>\n      <tr>\n          <td>磁盘存储器</td>\n          <td>4</td>\n          <td>0</td>\n      </tr>     \n      <tr>\n          <td>低位交叉存储器</td>\n          <td>2</td>\n          <td>1</td>\n      </tr>\n  </table>\n\n\n\n\n\n\n<hr>\n<h3 id=\"3-2-存储器概述\"><a href=\"#3-2-存储器概述\" class=\"headerlink\" title=\"3.2 存储器概述\"></a>3.2 存储器概述</h3><h4 id=\"3-2-1-存储器的分类\"><a href=\"#3-2-1-存储器的分类\" class=\"headerlink\" title=\"3.2.1 存储器的分类\"></a>3.2.1 存储器的分类</h4><p>​        </p>\n<p><img src=\"/img/3_1_存储器不同角度的分类.png\" alt=\"3_1_存储器不同角度的分类\"></p>\n<h5 id=\"1-按存储介质分类\"><a href=\"#1-按存储介质分类\" class=\"headerlink\" title=\"1. 按存储介质分类\"></a>1. 按存储介质分类</h5><p>​        存储介质是指能寄存“0”、“1”两种代码并能区别两种状态的物质或元器件。存储介质主要有半导体器件、磁性材料和光盘等。</p>\n<ul>\n<li><strong>半导体存储器</strong></li>\n</ul>\n<p>​        存储元件由半导体器件组成的存储器称为半导体存储器。现代半导体存储器都用超大规模集成电路工艺制成芯片，其优点是体积小、功耗低、存取时间短。</p>\n<p>​        半导体存储器又可按其材料的不同， 分为双极型（TTL）半导体存储器和 MOS 半导体存储器两种。前者具有高速的特点；后者具有高集成度的特点，并且制造简单，成本低廉，功耗小，所以 MOS 半导体存储器被广泛用。</p>\n<ul>\n<li><strong>磁性材料存储器</strong></li>\n</ul>\n<p>​        磁性材料存储器主要依靠磁性材料作为记录的介质，是不易失的永久记忆存储器。又可以分为磁表面存储器和磁芯存储器。</p>\n<p>​        磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。按载磁体形状的不同，可分为磁盘、磁带和磁鼓。</p>\n<p>​        磁芯是由硬磁材料做成的环状元件，在磁芯中穿有驱动线(通电流)和读出线，这样便可进行读/写操作，这种存储器称为磁芯存储器。磁芯属磁性材料，故它也。不过，磁芯存储器的体积过大、工艺复杂、功耗太大，目前几乎已不被采用。</p>\n<ul>\n<li><strong>光盘存储器</strong></li>\n</ul>\n<p>​        光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器，具有非易失性的特点。光盘具有记录密度高、耐用性好、可靠性高和可互换性强等特点。</p>\n<h5 id=\"2-按存取方式分类\"><a href=\"#2-按存取方式分类\" class=\"headerlink\" title=\"2. 按存取方式分类\"></a>2. 按存取方式分类</h5><p>​        按存取方式可把存储器分为随机存储器、只读存储器、顺序存取存储器和直接存取存储器。</p>\n<ul>\n<li><strong>随机存储器</strong>（Random Access Memory， <strong>RAM</strong>）</li>\n</ul>\n<p>​        RAM是一种可读/写存储器， 其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。</p>\n<p>​        由于存储信息原理的不同， RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充放电原理寄存信息）。</p>\n<ul>\n<li><strong>只读存储器</strong>（Read Only Memory， <strong>ROM</strong>）</li>\n</ul>\n<p>​        只读存储器是能对其存储的内容读出，而不能对其重新写人的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写人新的信息去改变原始信息。</p>\n<p>​        所以 ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。</p>\n<ul>\n<li><strong>串行访问存储器</strong></li>\n</ul>\n<p>​        如果对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器，也称为顺序存取存储器。显然这种存储器由于信息所在位置不同，使得读/写时间均不相同，比如磁带存储器就是一种顺序存取存储器。</p>\n<ul>\n<li><strong>直接存取存储器</strong></li>\n</ul>\n<p>​        还有一种属于部分串行访问的存储器，比如磁盘。在对磁盘读/写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，称为直接存取存储器。</p>\n<h5 id=\"3-按在计算机中的作用分类\"><a href=\"#3-按在计算机中的作用分类\" class=\"headerlink\" title=\"3. 按在计算机中的作用分类\"></a>3. 按在计算机中的作用分类</h5><p>​        按在计算机系统中的作用不同，存储器可以分为主存储器、辅助存储器、缓冲存储器。</p>\n<ul>\n<li><p><strong>主存储器</strong>（简称<strong>主存</strong>）：用来存放程序和数据，可以和CPU直接交换信息。</p>\n</li>\n<li><p><strong>辅助存储器</strong>（简称<strong>辅存</strong>）：主存储器的后援存储器， 用来存放当前暂时不用的程序和数据， 它不能与CPU直接交换信息。两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。</p>\n</li>\n<li><p><strong>缓冲存储器</strong>（简称<strong>缓存</strong>，<strong>Cache</strong>） 用在两个速度不同的部件之中。</p>\n</li>\n</ul>\n<p><img src=\"/img/3_2_存储器按照计算机中作用的分类-171707496067111.png\" alt=\"3_2_存储器按照计算机中作用的分类\"></p>\n<h4 id=\"3-2-2-存储器的性能指标\"><a href=\"#3-2-2-存储器的性能指标\" class=\"headerlink\" title=\"3.2.2 存储器的性能指标\"></a>3.2.2 存储器的性能指标</h4><h5 id=\"1-存储速度\"><a href=\"#1-存储速度\" class=\"headerlink\" title=\"1.存储速度\"></a>1.<strong>存储速度</strong></h5><p>​    （1）<strong>存取时间</strong></p>\n<p>​        要想衡量存储速度，最直观的指标就是完成一次存储器读/写操作所需要的时间，这叫做 <strong>存取时间</strong>，又称为 <strong>访问时间</strong>（Memory Access Time）。</p>\n<p>​        存取时间又分为读出时间和写入时间。读出时间是从存储器接受到有效地址开始，到产生有效输出所需的全部时间；写入时间是从存储器接受到有效地址开始，到数据写入被选中存储单元为止的全部时间。</p>\n<p>​    （2）<strong>存储器周期</strong></p>\n<p>​        <strong>存储器周期</strong> （Memory Cycle Time）指连续进行两次独立的存储器操作（读或者写）需要的最小时间间隔，也叫 <strong>存取周期</strong>。需要注意的是，存储器周期并不等同于完成一次读写操作的时间，而是要更大；因为存储器经过一次读写操作后，并不能立即进行下一次读写，中间还需要一段时间来恢复内部状态。所以，</p>\n<p>​                                                            存储器周期 = 存取时间 + 恢复时间</p>\n<p>​    （3）<strong>存储器带宽</strong></p>\n<p>​        一般来说，存储器周期越短，存储器的速度就越快；这前提是存储器的每次读写操作处理的数据位数相同。通常情况下，存储器每次读写的位数是跟存储字长相关的，字长越长，一个存取周期处理的数据就越多。</p>\n<p>​        所以可以用 <strong>数据传输率</strong> 来表示存储速度，而 <strong>存储器带宽</strong> 就是衡量数据传输率重要指标。存储器带宽指单位时间内存储器存取的数据量。单位为位/秒（b/s），或者字节/秒（B/s）、字/秒。</p>\n<p>​                                                            存储器带宽 = 数据宽度 / 存储周期</p>\n<p>​        例如，存储器周期为 500 ns，每个存取周期可以访问 16 位，那么带宽就是：</p>\n<p>​                                                                16 bit ÷ 500 ns = 32 Mb/s</p>\n<h5 id=\"2-存储容量\"><a href=\"#2-存储容量\" class=\"headerlink\" title=\"2. 存储容量\"></a>2. 存储容量</h5><p>​        存储容量指存储器能存放的数据总量，一般用二进制代码的总位数（bit）来表示。</p>\n<p>​                                                    存储容量 = 存储字数 × 存储字长</p>\n<p>​        存储字数代表了存储器地址空间的大小，由地址线的位数决定。容量一般也可以用字节总数（Byte）来表示，也就是：</p>\n<p>​                                            存储容量（字节数） = 存储字数 × 存储字长 / 8</p>\n<p>​        例如，某机器存储字长为 8 位，地址线有 28 位，那么它的主存最大存储容量为：</p>\n<p>​                                                        2^28^ × 8 / 8 = 2^28^ B = 256 MB</p>\n<h5 id=\"3-位价\"><a href=\"#3-位价\" class=\"headerlink\" title=\"3. 位价\"></a>3. 位价</h5><p>​        每位价格也就是存储器的单位成本。</p>\n<p>​                                                    位价 = 总成本 / 总容量</p>\n<p>​        一般来说，速度越高，位价就越高；容量越大，位价就越低；而且容量越大，速度也会越低。</p>\n<h4 id=\"3-2-3-层次化存储器的基本结构\"><a href=\"#3-2-3-层次化存储器的基本结构\" class=\"headerlink\" title=\"3.2.3 层次化存储器的基本结构\"></a>3.2.3 层次化存储器的基本结构</h4><p>​        </p>\n<p><img src=\"/img/3_3_存储器层级金字塔-171707527852817.png\" alt=\"3_3_存储器层级金字塔\"></p>\n<ul>\n<li>寄存器通常都制作在 CPU 芯片内。寄存器中的数直接在 CPU 内部参与运算， CPU 内可以有十几个、几十个寄存器，它们的速度最快，位价最高，容量最小。</li>\n<li>主存用来存放将要参与运行的程序和数据，它与 CPU 速度差距较大。</li>\n<li>为了使主存和 CPU 之间速度更好地匹配， 需要在主存与 CPU 之间插入一种比主存速度更快、容量更小的高速缓冲存储器 Cache，其位价要高于主存。</li>\n</ul>\n<p><img src=\"/img/3_4_存储器层次结构.png\" alt=\"3_4_存储器层次结构\"></p>\n<ul>\n<li>缓存-主存层次</li>\n</ul>\n<p>​        这一层次主要解决 CPU 和主存速度不匹配的问题。由于缓存的速度比主存的速度高， 只要将CPU近期要用的信息调人缓存， CPU 便可以直接从缓存中获取信息， 从而提高访存速度。但由于缓存的容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换掉。主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。</p>\n<ul>\n<li>主存-辅存层次</li>\n</ul>\n<p>​        这一层次主要解决存储系统的容量问题。辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息， 但它的容量比主存大得多， 可以存放大量暂时未用到的信息。当CPU需要用到这些信息时， 再将辅存的内容调人主存， 供CPU直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的。</p>\n<h3 id=\"3-3-半导体存储器\"><a href=\"#3-3-半导体存储器\" class=\"headerlink\" title=\"3.3 半导体存储器\"></a>3.3 半导体存储器</h3><p>​        半导体存储器分为 <strong>随机存取存储器（RAM）</strong>和 <strong>只读存储器（ROM）</strong>。</p>\n<p>​        RAM 是一种可读/写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。</p>\n<p>​        RAM 按照存储信息的原理不同，又可以分为静态随机存取存储器<strong>（SRAM）</strong>和动态随机存取存储器<strong>（DRAM）</strong>，主存储器主要由 DRAM 实现，靠近处理器的那一层缓存 <strong>（Cache）</strong>则由 SRAM 实现，它们都是易失性存储器。ROM 是非易失性存储器。</p>\n<p><img src=\"/img/3_6_存储芯片基本结构.png\" alt=\"3_6_存储芯片基本结构\"></p>\n<p>主存中各个存储单元的空间位置，是由一个地址号来表示的；通过地址总线可以给定一个存储单元的地址号，从而根据地址读出或者写入一个存储字。</p>\n<ul>\n<li>译码驱动：将地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作。</li>\n<li>读/写电路：包括读出放大器和写入电路，用来完成读/写操作。</li>\n</ul>\n<p>​        存储芯片通过地址总线、数据总线和控制总线与外部连接。地址线和数据共同反映了芯片的存储容量。比如，10 根地址线，4 根数据线，表示芯片的存储容量为：2^10^ × 4 = 4 Kb。</p>\n<ul>\n<li>地址线是单向输入的，其位数与芯片存储容量有关。</li>\n<li>数据线是双向输入的，其位数与芯片每次可读出或写入的数据位数有关，从而也影响到存储容量。</li>\n<li>控制线包括了读/写控制线和片选线。读/写控制线决定芯片进行的具体操作，片选线用来选择芯片。</li>\n</ul>\n<hr>\n<p>半导体存储芯片的译码驱动，主要有两种方式：<strong>线选法</strong> 和 <strong>重合法</strong>。</p>\n<ul>\n<li>线选法：是用一根字选择线（字线），直接选中一个存储单元的各位。这种方式结构比较简单，不过只适合用于容量不大的存储芯片。</li>\n</ul>\n<p>采用线选法译码驱动的存储芯片结构示意图。这个芯片有 8 位地址线和 8 位数据线，所以有 2^8^ = 256 个存储字，需要 256 根字线来实现选中每个存储字。</p>\n<p><img src=\"/img/3_7_线选法256×1B存储芯片结构示意图.png\" alt=\"3_7_线选法256×1B存储芯片结构示意图\"></p>\n<ul>\n<li>重合法：用两个方向的地址，共同决定选中存储矩阵中的一个存储单元。相比 “一维” 的线选法，重合法就升级到了 “二维”，可以用更少的选择线实现对所有存储单元的选择。</li>\n</ul>\n<p>使用 X、Y 两个方向的地址译码器分别对 4 位地址进行译码，只需要两个方向各 16 根选择线，就可以直接选中 16 × 16 存储矩阵中的每一位。</p>\n<p><img src=\"/img/3_8_重合法16×16存储芯片结构示意图.png\" alt=\"3_8_重合法16×16存储芯片结构示意图\"></p>\n<h4 id=\"3-3-1-SRAM\"><a href=\"#3-3-1-SRAM\" class=\"headerlink\" title=\"3.3.1 SRAM\"></a>3.3.1 SRAM</h4><p>​        通常把存放一个二进制位的物理器件称为存储元，它是存储器最基本的构件。地址码相同的多个存储元构成一个存储单元。存储单元的集合构成存储体。</p>\n<p>​        <strong>静态 RAM</strong>（Static RAM，<strong>SRAM</strong>）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此信息被读出后，它仍保持其原状态而不需要刷新；这种读特性被称为“非破坏性读出”。</p>\n<p><img src=\"/img/3_9_静态RAM的基本单元电路.png\" alt=\"3_9_静态RAM的基本单元电路\"></p>\n<p>下面是 Intel 2114 RAM 芯片的存储矩阵结构示意图。2114 芯片有 10 根地址线，其中 6 根行地址线、4 根列地址线，存储矩阵由 64 × 64 个基本单元电路组成，总容量为 1K × 4 位。</p>\n<p><img src=\"/img/3_10_Intel2114矩阵存储结构.png\" alt=\"3_10_Intel2114矩阵存储结构\"></p>\n<p>SRAM 使用触发器工作原理存储信息，因此在读出信息后，它仍会保持原来的状态，不需要刷新。不过如果电源掉电，存储的信息就会丢失，所以它属于易失性半导体存储器。</p>\n<p>​        SRAM 的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于 Cache。</p>\n<h4 id=\"3-3-2-DRAM\"><a href=\"#3-3-2-DRAM\" class=\"headerlink\" title=\"3.3.2 DRAM\"></a>3.3.2 DRAM</h4><p>​        <strong>动态 RAM</strong>（Dynamic RAM，<strong>DRAM</strong>）是利用存储元电路中栅极电容上的电荷来存储信息的。若电容上存有足够多的电荷表示存 “1”，电容上无电荷则表示存 “0”。</p>\n<p>​        常见的动态 RAM 基本单元电路有三管式和单管式两种。单管式只需要一个 MOS 管和一个电容，因此可以极大地提高集成度。</p>\n<p><img src=\"/img/3_11_动态RAM的基本单元电路.png\" alt=\"3_11_动态RAM的基本单元电路\"></p>\n<p>可以看到，DRAM 的基本存储元可以只使用一个晶体管, 所以它比 SRAM 的密度要高很多。为了进一步提高集成度，DRAM 采用 <strong>地址复用技术</strong>，地址信号分行、列两次传送，这样地址线是原来的一半，地址引脚数也可以减少一半，就能够进一步减小芯片的体积。</p>\n<p>​        下面是 Intel 4116 RAM 芯片的整体结构和存储矩阵示意图。4116 芯片的存储矩阵为 128 × 128，共有 16 K 个单管 MOS 基本单元电路，容量为 16K × 1 位。本来芯片应该有 14 根地址线，不过为了减少芯片封装的引脚数，地址线只有 7 根。这就需要将完整的地址信息分成行地址、列地址两部分（各自 7 位），分两次传送。</p>\n<p><img src=\"/img/3_12_Intel4116芯片基本结构.png\" alt=\"3_12_Intel4116芯片基本结构\"></p>\n<p><img src=\"/img/3_13_Intel4116矩阵存储结构.png\" alt=\"3_13_Intel4116矩阵存储结构\"></p>\n<p>​        相对 SRAM 来说，DRAM 具有容易集成、价位低、容量大和功耗低等优点，但 DRAM 的存取速度比 SRAM慢，一般用于大容量的主存系统。</p>\n<h5 id=\"DRAM-的刷新\"><a href=\"#DRAM-的刷新\" class=\"headerlink\" title=\"DRAM 的刷新\"></a>DRAM 的刷新</h5><p>​        由于电容上的电荷一般只能维持1 ~2ms，因此即使电源不掉电，信息也会自动消失。为此，必须在 2ms 内对所有存储单元恢复一次原状态，这个过程称为 <strong>再生</strong> 或者 <strong>刷新</strong>。</p>\n<p>​        刷新的过程，实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。由于存储单元是被随机访问的，有些存储单元可能一直不会被访问，因此其存储的原信息将会慢慢消失。因此，必须进行定时刷新。一般要求在一定的时间内，对动态 RAM 的全部基本单元必须作一次刷新，这个时间称为 <strong>刷新周期</strong>，也叫 <strong>再生周期</strong>，一般取 2ms。</p>\n<p>​        通常有三种刷新方式：集中刷新、分散刷新和异步刷新。</p>\n<p>​    （1）<strong>集中刷新</strong></p>\n<p>​        在规定的一个刷新周期内，对全部存储单元集中一段时间进行逐行刷新；刷新时必须停止读/写操作。</p>\n<p>​        例如，我们有一个芯片的存储矩阵为 128 × 128，它的存取周期为 0.5 μs，刷新周期为 2 ms（4000 个存取周期），那么对它的 128 行存储单元进行集中刷新需要：</p>\n<p>​                                                                        0.5 μs × 128 = 64 μs</p>\n<p>​        那剩余的 1936 μs（3872个存取周期）就可以用来读/写或者维持信息。由于在这 64 μs 内无法进行读/写操作，所以这段刷新时间被称为 “死时间”，也叫访存 “死区”。死时间占据存取周期的比例 64 μs / 2 ms × 100% = 3.2%，称为死时间率。</p>\n<p><img src=\"/img/3_14_DRAM 集中刷新时间分布.png\" alt=\"3_14_DRAM 集中刷新时间分布\"></p>\n<p>2）<strong>分散刷新</strong></p>\n<p>​        对每行存储单元的刷新，分散到每个存取周期内完成。这样，每个存储周期 t<sub>C</sub> 就分成了两段：前半段 t<sub>M</sub>用来读/写或者维持信息，后半段 t<sub>R</sub> 用来刷新。所以：</p>\n<p>​                                                                                    t<sub>M</sub> = t<sub>M</sub> + t<sub>R</sub></p>\n<p>​        同样以 128 × 128 存储矩阵的芯片为例，读/写周期 t<sub>M</sub> = t<sub>R</sub> = 0.5 μs，那么存取周期 t<sub>C</sub> = 1 μs。逐行进行刷新，每隔 128 μs 就可以将存储芯片全部刷新一遍。</p>\n<p><img src=\"/img/3_15_DRAM 分散刷新时间分布.png\" alt=\"3_15_DRAM 分散刷新时间分布\"></p>\n<p>这样的好处是不存在停止读/写操作的死时间，而且刷新间隔比要求的刷新周期 2ms 短得多；缺点在于存取周期 t<sub>C</sub> 变长了，使得整个系统速度变慢。 </p>\n<p>​    （3）<strong>异步刷新</strong></p>\n<p>​        异步刷新是前两种方式的结合，它既可以缩短 “死时间”，又能充分利用最大的刷新间隔 2ms。</p>\n<p>​        还是之前的例子，对于 128 × 128 存储矩阵的芯片，存取周期 t<sub>C</sub> = 0.5 μs，可以让它把对 128 行的刷新平均分配到 2ms 的刷新周期内。也就是说，每隔 2ms ÷ 128 ≈ 15.6 μs 刷新一行，每次刷新的时间还是一个存取周期 t<sub>R</sub> = 0.5 μs。</p>\n<p><img src=\"/img/3_16_DRAM 异步刷新时间分布.png\" alt=\"3_16_DRAM 异步刷新时间分布\"></p>\n<p>这样一来，2ms 内用于刷新的时间仍然是 128 t<sub>R</sub> = 64 μs，而由于分散到了整个刷新周期内，每次刷新一行只停了一个存取周期；所以对于每行来说，刷新的间隔还是 2ms，而 “死时间” 缩短为 0.5 μs。</p>\n<p>​        如果将 DRAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不会访问存储器，所以这样就完全避免了 “死时间” 的问题，从根本上提高了机器效率。</p>\n<h5 id=\"DRAM-和-SRAM-的比较\"><a href=\"#DRAM-和-SRAM-的比较\" class=\"headerlink\" title=\"DRAM 和 SRAM 的比较\"></a>DRAM 和 SRAM 的比较</h5><p>​        目前，随着 DRAM 的容量不断扩大，速度不断提高，它的应用要比 SRAM 更加广泛。DRAM 主要用在计算机的主存中，而 SRAM 通常用于容量不大的高速缓存（Cache）中。</p>\n<p>​        两者的特点可以比较如下：</p>\n<p><img src=\"/img/3_17_DRAM vs SRAM.png\" alt=\"3_17_DRAM vs SRAM\"></p>\n<h4 id=\"3-3-3-ROM\"><a href=\"#3-3-3-ROM\" class=\"headerlink\" title=\"3.3.3 ROM\"></a>3.3.3 ROM</h4><p>​        ROM （Read Only Memory）最原始的定义是 “只读存储器”，一旦写入原始信息后就不能更改。所以ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。</p>\n<p>​        不过随着用户的需要和技术的发展，又出现了更多类型的 ROM，让用户拥有了修改数据的能力。</p>\n<p>​        根据制造工艺不同，ROM 可分为固定掩模型 ROM（<strong>MROM</strong>）、一次可改写 ROM （<strong>PROM</strong>）、紫外线擦除电可编程 ROM（<strong>EPROM</strong>）、电擦除电可编程 ROM （<strong>EEPROM</strong>）、快擦写<strong>（Flash）</strong>存储器。</p>\n<p>​    </p>\n<p>​        <strong>SRAM</strong>、<strong>DRAM</strong> 和 <strong>ROM</strong> 这 3 种存储器的特点可以总结如下。</p>\n<p><img src=\"/img/3_18_SRAM vs DRAM vs ROM.png\" alt=\"3_18_SRAM vs DRAM vs ROM\"></p>\n<h3 id=\"3-4-主存储器\"><a href=\"#3-4-主存储器\" class=\"headerlink\" title=\"3.4 主存储器\"></a>3.4 主存储器</h3><h4 id=\"3-4-1-主存储器的基本组成\"><a href=\"#3-4-1-主存储器的基本组成\" class=\"headerlink\" title=\"3.4.1 主存储器的基本组成\"></a>3.4.1 主存储器的基本组成</h4><p>​        主存储器简称主存或内存，是计算机中存储程序和数据的重要部件。主存内包含了存储体、各种逻辑部件以及控制电路等。</p>\n<p>​        主存是通过按地址访问的方式，对存储体内的存储单元进行读写操作的。因此主存首先需要从 MAR 中获取地址，由译码器进行地址译码、再经过驱动电路，进而通过选择线选中所需访问的单元。读出时，需要经过读出放大器才能将被选中存储单元的内容送到 MDR；写入时，MDR 中的数据也需要经过写入电路才能真正存入被选中的单元。所以主存实际结构的基本组成如下：</p>\n<p><img src=\"/img/3_19_主存基本组成实际结构.png\" alt=\"3_19_主存基本组成实际结构\"></p>\n<p>译码器、驱动器和读写电路都集成在 DRAM 存储芯片中，而 MAR 和 MDR 则集成在 CPU 芯片内。存储芯片可以通过总线与 CPU 相连。</p>\n<p><img src=\"/img/3_20_主存与CPU的联系.png\" alt=\"3_20_主存与CPU的联系\"></p>\n<p>当要从主存中读某个数据字时，首先由 CPU 将字的地址送到 MAR，通过地址总线送至主存，然后发出读命令；主存的译码器将地址总线送来的地址译码，导通对应存储单元的选择线，收到读信号后，便将该单元的内容送到数据总线上，进而交给 MDR。</p>\n<p>​        如果要向主存写入一个数据字，仍然需要 CPU 先把地址送到 MAR，并把要写的数据送到 MDR，然后发出写命令；主存译码器依然从地址总线读取地址进行译码，接到写命令后，就把数据线上的信息写入对应的存储单元。</p>\n<h5 id=\"主存中地址的分配\"><a href=\"#主存中地址的分配\" class=\"headerlink\" title=\"主存中地址的分配\"></a>主存中地址的分配</h5><p>​        主存中各存储单元的空间位置，都是由存储单元的地址号表示的；地址总线的作用就是给出要访问的存储单元的地址。每次访问存储单元，可以读出或者写入一个存储字。</p>\n<p>​        存储字长必须是字节（8位）的整数倍，不同机器的存储字长不同。计算机一般既可以按字来寻址，也可以按字节寻址。例如，一台机器的存储字长为 32 位，并且可以按字节寻址，那么它的每个存储字都包含了 4 个具有独立地址的字节，地址的分配方式如下：</p>\n<p><img src=\"/img/3_22_字节寻址的主存地址分配.png\" alt=\"3_22_字节寻址的主存地址分配\"></p>\n<p>如果这台机器的地址线为 24 位，那么按字节寻址的范围是 2^24^ = 16M，按字寻址的范围为 16M / 4 = 4 M。</p>\n<h4 id=\"3-4-2-主存和-CPU-之间的连接\"><a href=\"#3-4-2-主存和-CPU-之间的连接\" class=\"headerlink\" title=\"3.4.2 主存和 CPU 之间的连接\"></a>3.4.2 主存和 CPU 之间的连接</h4><h5 id=\"1-主存容量扩展\"><a href=\"#1-主存容量扩展\" class=\"headerlink\" title=\"1. 主存容量扩展\"></a>1. 主存容量扩展</h5><p>​        单片存储芯片的容量有限，所以主存需要将多个存储芯片连在一起扩展成更大的存储器。这称为 <strong>存储容量的扩展</strong>，主要的方法有 <strong>位扩展</strong> 和 <strong>字扩展</strong>。</p>\n<p><strong>（1）位扩展</strong></p>\n<p>​        位扩展是指对字长进行扩展，也就是增加存储字长。这种情况下，系统地址线位数等于芯片地址线位数，而系统数据线位数多于芯片数据线位数。</p>\n<p>​        位扩展的连接方式：各芯片的地址线、片选线和读写控制线与系统总线相应 <strong>并联</strong>；各芯片的 <strong>数据线单独引出</strong>，分别连接系统数据线。各芯片同时工作。</p>\n<p>​        以之前介绍过的 SRAM 芯片 2114 为例，它的存储容量为 1K × 4，那么用 2 片 2114 采用位扩展的方式可以组成 1K × 8 的存储器。如下所示：        </p>\n<p><img src=\"/img/3_24_2114位扩展.png\" alt=\"3_24_2114位扩展\"></p>\n<p><strong>（2）字扩展</strong>  </p>\n<p>​        字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。这种情况下，系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。</p>\n<p>​        字扩展的连接方式：各芯片的地址线与系统地址线的 <strong>低位对应相连</strong>，芯片的数据线和读写控制线与系统总线相应 <strong>并联</strong>；由系统地址线的 <strong>高位译码</strong> 得到各芯片的片选信号。各芯片分时工作，同一时间只能有一个芯片被选中。</p>\n<p>​        例如，用 2 片容量为 1K × 4 的 2114 芯片，采用字扩展的方式可以组成 2K × 4 的存储器。如下所示：</p>\n<p><img src=\"/img/3_25_2114字扩展.png\" alt=\"3_25_2114字扩展\"></p>\n<p>​    扩展之后的地址线为 11 位，共有 2^11^ = 2 K 个地址。其中：</p>\n<ul>\n<li>第一片 2114 的地址范围为 <strong>0</strong>00 0000 0000 ~ <strong>0</strong>11 1111 1111；</li>\n<li><p>第二片 2114 的地址范围为 <strong>1</strong>00 0000 0000 ~ <strong>1</strong>11 1111 1111。</p>\n<p>（3）字和位同时扩展</p>\n</li>\n</ul>\n<p>​        字和位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。</p>\n<p>​        字和位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展相同；由系统地址线高位译码产生若干个片选信号，分别接到各组芯片的片选信号。</p>\n<p>​        例如，用 8 片容量为 1K × 4 的 2114 芯片，字和位同时扩展之后可以组成 4K × 8 的存储器。如下所示：</p>\n<p><img src=\"/img/3_26_2114字位同时扩展.png\" alt=\"3_26_2114字位同时扩展\"></p>\n<p>扩展之后的地址线为 12 位，共有 2^12^ = 4 K 个地址。其中：</p>\n<ul>\n<li>第一、二片 2114 通过位扩展构成第一组，地址范围为 <strong>00</strong>00 0000 0000 ~ <strong>00</strong>11 1111 1111；</li>\n<li>第三、四片 2114 通过位扩展构成第二组，地址范围为 <strong>01</strong>00 0000 0000 ~ <strong>01</strong>11 1111 1111；</li>\n<li>第五、六片 2114 通过位扩展构成第三组，地址范围为 <strong>10</strong>00 0000 0000 ~ <strong>10</strong>11 1111 1111；</li>\n<li>第七、八片 2114 通过位扩展构成第四组，地址范围为 <strong>11</strong>00 0000 0000 ~ <strong>11</strong>11 1111 1111。</li>\n</ul>\n<h5 id=\"2-主存与CPU的连接\"><a href=\"#2-主存与CPU的连接\" class=\"headerlink\" title=\"2. 主存与CPU的连接\"></a>2. 主存与CPU的连接</h5><p>（1）合理选择存储芯片。通常选用 ROM 存放系统程序，选用 RAM 组成用户区。</p>\n<p>（2）地址线的连接。CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）；CPU 地址线的高位在扩充存储芯片时用，以选择存储芯片（片选）。</p>\n<p>（3）数据线的连接。比较CPU的数据线数与存储芯片的数据位数。如果相等可以直接相连；如果不等，必须对存储芯片进行扩位，使其数据位数与 CPU 的数据线数量相等。</p>\n<p>（4）读/写命令线的连接。CPU 的读/写命令线一般可以直接与存储芯片的读/写控制端相连。</p>\n<p>（5）片选线的连接。片选信号一般由系统地址线高位译码，它是主存与 CPU 连接的关键。</p>\n<h4 id=\"3-4-3-多模块存储器\"><a href=\"#3-4-3-多模块存储器\" class=\"headerlink\" title=\"3.4.3 多模块存储器\"></a>3.4.3 多模块存储器</h4><h5 id=\"1-单体多字存储器\"><a href=\"#1-单体多字存储器\" class=\"headerlink\" title=\"1. 单体多字存储器\"></a>1. 单体多字存储器</h5><p>​        在主存中，程序和数据是连续存放的，所以 CPU 访存取出的信息也是连续的。如果将存储器的存储单元进行扩展，让它能够存储更多的字，那么就可以在一个存取周期内，从同一地址取出更多的指令。将多条指令逐条送至 CPU 执行，由于 CPU 的速度远高于主存，这样就相当于增大了主存的带宽，提高了速度。</p>\n<p>​        这种方式是对单独的存储器进行了扩展，类似于位扩展的思路，不过是将一个地址对应的数据扩展到了多个存储字。所以这种结构的存储器称为 <strong>单体多字存储器</strong>。</p>\n<p>​        例如，对于一个单体四字存储器，可以在一个存取周期取出四个字的信息。假设指令字长就是一个存储字，那么原先一个存取周期拿到一条指令，现在就可以拿到 4 条；逐条传给 CPU 进行处理，就相当于每隔 1/4 周期，主存就向 CPU 传送了一条指令，带宽变成了 4 倍。</p>\n<p><img src=\"/img/3_27_单体四字结构存储器.png\" alt=\"3_27_单体四字结构存储器\"></p>\n<ul>\n<li>结构特点：存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。</li>\n<li><p>访问方式：一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。</p>\n</li>\n<li><p>优点：宽度为单体单字存储器的近 m 倍（访问的内容在同一行时）。</p>\n</li>\n<li>缺点：如果出现访问冲突（需要的内容不在同一行）或遇到转移指令，效率会显著降低。</li>\n</ul>\n<h5 id=\"2-多体并行系统\"><a href=\"#2-多体并行系统\" class=\"headerlink\" title=\"2. 多体并行系统\"></a>2. 多体并行系统</h5><p>​        另一种思路是采用多模块组成存储器，各个模块可以并行读写，这就是多体并行系统。每个模块有相同的容量和存取速度，各模块都有自己独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路和读/写电路，它们能并行工作，也能交叉工作。</p>\n<p>​        所谓的 “并行工作”，就是 CPU 可以同时访问 N 个模块，同时启动，同时读出；当然，由于总线是公共的，同时读出的 N 个字需要在总线上分时传送。</p>\n<p>​        根据对这 N 个模块中存储单元的不同编址方式，多体并行系统又可以分为 <strong>多体高位交叉存储器</strong> 和 <strong>多体低位交叉存储器</strong>。</p>\n<p><strong>（1）多体高位交叉存储器</strong></p>\n<p>​        多体高位交叉存储器中，各模块采用 <strong>高位交叉方式编址</strong>。</p>\n<p>​        高位交叉方式编址时，地址分为两部分，高位地址表示体号，低位地址为体内地址。这种编址方式下，一个模块（也就是 “体”）内的地址是连续的，程序存储时会按照体内地址的顺序存放，也就是先存一个模块，存满之后再存下一个；所以这种方式也叫 “<strong>顺序存储</strong>”。</p>\n<p><img src=\"/img/3_28_高位交叉编址多体存储器.png\" alt=\"3_28_高位交叉编址多体存储器\"></p>\n<p>只要调动合理，使不同的请求源同时去访问不同的模块，就可以实现并行工作。比如，CPU 在访问一个模块的同时，外部设备可以以直接存储器访问（DMA）的方式访问另一个模块，这样两个体就是并行工作的。</p>\n<p><strong>（2）多体低位交叉存储器</strong></p>\n<p>​        多体低位交叉存储器中，各模块采用 <strong>低位交叉方式编址</strong>。</p>\n<p>​        低位交叉编址是指用主存地址的低位来指明存储器模块，高位指明模块内的字地址。这种编址方式下，连续的地址分布在相邻的模块中，同一模块内的地址是不连续的，因此也叫做 “<strong>交叉存储</strong>”。有 M 个模块的低位交叉编址，又叫 <strong>模 M 编址</strong>。</p>\n<p><img src=\"/img/3_29_低位交叉多体存储器.png\" alt=\"3_29_低位交叉多体存储器\"></p>\n<p>​       上面是一个模 4 交叉编址的存储器，存储体模块个数为 4，所以第一个模块中所有存储单元的地址号，对 4 取模都为 0；同样道理，第二、三、四个模块的地址号，对 4 取模结果分别为 1、2、3。具体的编址地址号如下所示：</p>\n<p><img src=\"/img/3_30_模4编址地址分布.png\" alt=\"3_30_模4编址地址分布\"></p>\n<p>​        程序按照地址连续存放在相邻模块中，采用低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用 <strong>流水线</strong> 方式并行存取，提高存储器的带宽。</p>\n<p>​        在一个存取周期 T 内，m 个模块按一定的顺序分时启动；如果分时启动的时间间隔为 t = T/m，那么在一个存取周期内，CPU 交叉访问各个模块，从而使各模块的读/写操作交错重叠进行，最终向 CPU 可以传送 m 个字。这样，存储器的带宽提升为 m 倍。</p>\n<p>​        由于各个模块传送取出的字共享总线，因此假设总线传输周期为 τ，当 t 小于等于 τ 时，就可以获得最大的存储器带宽。所以：</p>\n<p>​                                                                                t = T/m ≤ τ</p>\n<p>​        所以，对于一个存取周期为 T、总线传输周期为 τ 的机器，设计多体低位交叉存储器时应该有 m ≥ T / τ。一般取最小值即可，在采用流水线方式时应该满足 </p>\n<p>​                                                                                    T = m τ</p>\n<p>​        对于四体低位交叉编址存储器 T = 4 τ，按流水线方式工作时不同模块访问字的时间顺序如下：</p>\n<p><img src=\"/img/3_31_四字低位交叉编址流水线工作时间.png\" alt=\"3_31_四字低位交叉编址流水线工作时间\"></p>\n<p>​    可以看出，对于流水线工作的低位交叉存储器，连续读取 n 个字所需的时间为：</p>\n<p>​                                                                            t<sub>1</sub> = T + ( n - 1 ) τ </p>\n<p>​        而如果是高位交叉存储器，对应的时间为：</p>\n<p>​                                                                                    t<sub>2</sub> = n T</p>\n<p>​        对于上面的四字低位交叉存储器，τ = T / 4，所以 t<sub>1</sub> = ( n + 3 ) T / 4，明显要低于 t<sub>2</sub>；当 n 非常大时，t<sub>1</sub> 趋近于 T / 4，即速度提升了 4 倍。</p>\n<h3 id=\"3-5-外部存储器\"><a href=\"#3-5-外部存储器\" class=\"headerlink\" title=\"3.5 外部存储器\"></a>3.5 外部存储器</h3><p>​        外部存储器是主存的后援设备，也叫做辅助存储器，简称 <strong>外存</strong> 或 <strong>辅存</strong>，与主存一起构成了存储器系统的主存-辅存层次。与主存相比，外存容量大、速度慢、价格低，可以脱机保存信息，属于 <strong>非易失性存储器</strong>。</p>\n<p>​        用于计算机系统的外存主要有磁盘、磁带、光盘；磁盘和磁带都属于 <strong>磁表面存储器</strong>。而目前广泛应用的 <strong>固态硬盘（SSD）</strong>主体由闪存芯片构成，属于半导体存储器。</p>\n<h4 id=\"3-5-1-磁盘存储器\"><a href=\"#3-5-1-磁盘存储器\" class=\"headerlink\" title=\"3.5.1 磁盘存储器\"></a>3.5.1 磁盘存储器</h4><p>​        磁盘是应用最为广泛的外存设备。磁盘根据结构和盘片材质的不同，可以分为 <strong>硬磁盘</strong> 和 <strong>软磁盘</strong>，如今随着存储技术的发展，软磁盘存储器已渐渐不再使用，而硬磁盘存储器依然在外存中占据着重要的比例。</p>\n<p>​        磁盘存储器具有外存设备普遍的优缺点：</p>\n<ul>\n<li>优点：存储容量大，位价低；记录介质可重复使用；记录信息可长期保存而不丢失, 甚至可脱机存档；非破坏性读出，读出时不需要再生。</li>\n<li>缺点：存取速度慢，机械结构复杂。</li>\n</ul>\n<h5 id=\"1-磁表面存储器和磁记录原理\"><a href=\"#1-磁表面存储器和磁记录原理\" class=\"headerlink\" title=\"1. 磁表面存储器和磁记录原理\"></a>1. 磁表面存储器和磁记录原理</h5><p>​        磁表面存储器在不同形状（盘状、带状）的载体上涂有磁性材料层，这磁层就是记录信息的存储介质。存储器工作时，依靠载体的机械运动，由磁头在磁层上进行读/写操作；信息就记录在磁层上，这些信息的轨迹叫做 <strong>磁道</strong>。磁盘的磁道是一个个同心圆，磁带的磁道则是一条条直线。</p>\n<p><img src=\"/img/3_32_磁盘和磁带的磁道.png\" alt=\"3_32_磁盘和磁带的磁道\"></p>\n<p>磁记录原理：磁表面存储器在磁头和磁性记录介质做相对运动时，通过电磁转换完成读/写操作。</p>\n<p>磁记录方式：又称为编码方法，就是按某种规律把一连串的二进制信息转换成磁表面相应的磁化状态。通常采用调频制<strong>（FM）</strong>和改进型调频制<strong>（MFM）</strong>的记录方式。    </p>\n<p><img src=\"/img/3_33_磁表面存储器写入原理-171708472611019.png\" alt=\"3_33_磁表面存储器写入原理\"></p>\n<p><img src=\"/img/3_33_磁表面存储器读出原理.png\" alt=\"3_33_磁表面存储器读出原理\"></p>\n<h5 id=\"2-硬磁盘的分类和基本结构\"><a href=\"#2-硬磁盘的分类和基本结构\" class=\"headerlink\" title=\"2. 硬磁盘的分类和基本结构\"></a>2. 硬磁盘的分类和基本结构</h5><p>（1）硬磁盘存储器的类型</p>\n<p>​        硬磁盘中的存储载体是盘片，它是由硬质铝合金材料制成的，其表面涂有一层硬磁特性材料，可以被磁化从而完成信息的存储。通过磁头和盘片的相对运动，就可以实现信息的读取和写入。</p>\n<ul>\n<li>根据能否更换盘片，硬磁盘可以分为 <strong>可换盘磁盘</strong> 和 <strong>固定盘磁盘</strong>。</li>\n</ul>\n<p>​        可换盘磁盘的盘片可以脱机保存，所以更换的时候可以只换单片，方便维护和扩容；固定盘磁盘的盘片则不能从驱动器中取下，更换的时候需要整体更换，可靠性更高。</p>\n<ul>\n<li>按照磁头的工作方式，硬磁盘可以分为 <strong>固定磁头磁盘</strong> 和 <strong>移动磁头磁盘</strong>。</li>\n</ul>\n<p><img src=\"/img/3_35_固定磁头和移动磁头硬磁盘结构示意图.png\" alt=\"3_35_固定磁头和移动磁头硬磁盘结构示意图\"></p>\n<ul>\n<li>固定磁头的磁盘存储器，磁头位置是固定不动的，磁盘上的每一个磁道都对应着一个磁头，盘片也不可以更换；这样省去了磁头在盘片上移动寻找磁道的时间，存取速度更快。</li>\n<li>移动磁头的磁盘存储器，存取数据时磁头需要在盘面上做径向运动；这类存储器可以只有一个盘片，也可以有多个盘片。多个盘片会装在一个同心主轴上，每个记录面各有一个磁头。所有这些磁头连成一体，固定在支架上移动；任何时刻所有磁头和主轴的距离都相等，它们位于和圆心相等距离的一组磁道上，这组磁道称为一个 <strong>柱面</strong>。</li>\n</ul>\n<p>（2）硬磁盘存储器的组成</p>\n<p>​        硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。</p>\n<p><img src=\"/img/3_36_磁盘存储器基本结构-171708478845020.png\" alt=\"3_36_磁盘存储器基本结构\"></p>\n<ul>\n<li><strong>磁盘驱动器</strong></li>\n</ul>\n<p>​        磁盘驱动器是主机之外的一个独立装置，又称作 <strong>磁盘机</strong>。驱动器主要包括主轴、定位驱动和数据控制 3 个部分。</p>\n<p><img src=\"/img/3_37_磁盘驱动器结构.png\" alt=\"3_37_磁盘驱动器结构\"></p>\n<ul>\n<li><strong>磁盘控制器</strong></li>\n</ul>\n<p>​        磁盘控制器是磁盘存储器和主机的接口，通常就是一块电路板，插在主机总线插槽中。它的作用是接收由主机发来的命令，将其转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送，并且控制驱动器的读/写操作。一个磁盘控制器可以控制多台驱动器。</p>\n<p>​        将磁盘控制器的功能全部内置在磁盘设备中，主机和设备之间就可以采用标准的通用接口了。最初这种接口就称为 <strong>IDE</strong>（Integrated Drive Electronics）接口，同时期还有更高性能的 <strong>SCSI</strong>（Small Computer System Interface）接口；之后又发展出了采用串行传输技术的接口，这就是 <strong>SATA</strong>（Serial Advanced Technology Attachment）和 <strong>SAS</strong>（Serial Attached SCSI）。目前我们的个人电脑中，大多都是采用 SATA 接口的硬盘。</p>\n<ul>\n<li><strong>盘片</strong></li>\n</ul>\n<p>​        盘片是磁盘中存储信息的载体，由驱动器控制它的转动并读/写数据；有时也会直接把盘片当作驱动器的一部分。目前硬盘的盘片正朝着小体积大容量的方向发展，记录密度越来越高。</p>\n<h5 id=\"3-磁盘的工作原理\"><a href=\"#3-磁盘的工作原理\" class=\"headerlink\" title=\"3. 磁盘的工作原理\"></a>3. 磁盘的工作原理</h5><p>（1）磁盘存储区域</p>\n<p>​        一块磁盘划分为若干个记录面，每个记录面划分为若干条 <strong>磁道</strong>，而每条磁道又划分为若干个 <strong>扇区</strong>，扇区（也称块、扇段）是磁盘读写的最小单位，即磁盘按块存取。一个具有多盘片的磁盘组，可将其 n 个面上所有同一半径的磁道看成一个圆柱面，称为 <strong>柱面</strong>；在移动磁头的组合盘中，多个磁头一次定位的磁道集合就是一个柱面。    </p>\n<p><img src=\"/img/3_38_磁道和扇区.png\" alt=\"3_38_磁道和扇区\"></p>\n<p><img src=\"/img/3_39_柱面.png\" alt=\"3_39_柱面\"></p>\n<ul>\n<li><p>磁头数：表示磁盘总共有几个磁头，一般来说一个记录面对应一个磁头，所以等于记录面数。</p>\n</li>\n<li><p>柱面数：表示磁盘中柱面的个数，等于每个记录面上的磁道数。</p>\n</li>\n<li><p>扇区数：表示每条磁道上有几个扇区。</p>\n</li>\n</ul>\n<p>（2）磁盘地址</p>\n<p>​         一个磁盘存储器可以有多台驱动器，不同的驱动器可以用一个编号（驱动器号，或者台号）来区分。当驱动器号确定后，磁盘进行寻址定位时，首先需要整体移动磁头找到对应柱面（磁道）、再选定磁头，最后转动盘片找到扇区。所以寻址所需要的磁盘地址，一般由 <strong>驱动器号</strong>、<strong>柱面（磁道）号</strong>、<strong>盘面号</strong>、<strong>扇区号</strong> 组成。</p>\n<p>​        磁盘的地址格式如下所示:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">驱动器号</th>\n<th style=\"text-align:center\">柱面（磁道）号</th>\n<th style=\"text-align:center\">盘面号</th>\n<th style=\"text-align:center\">扇区号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>​        例如，系统中有 4 个驱动器，每个驱动器带一个磁盘组，其中有 11 个盘片（最外层上下侧为保护面），每个盘面有 203 个磁道、划分为 16 个扇区。则可以算出，驱动器号需要 2 位；柱面号需要 8 位（ 2^7^ &lt; 203 &lt; 2^8^ ）；而 11 个盘片有 20 个盘面，所以盘面号需要 5 位；扇区号需要 4 位。最终每个磁盘地址要 19 位二进制代码。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">驱动器号（2位）</th>\n<th style=\"text-align:center\">柱面（磁道）号（8位）</th>\n<th style=\"text-align:center\">盘面号（5位）</th>\n<th style=\"text-align:center\">扇区号（4位）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>（3）磁盘的工作过程</p>\n<p>​        磁盘的主要操作是寻址、读盘、写盘。磁盘属于机械式部件，其读/写操作是串行的，不可能在同一 时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>\n<ol>\n<li>磁盘的性能指标</li>\n</ol>\n<p>（1）<strong>记录密度</strong></p>\n<p>​        记录密度通常是指单位长度内所存储的二进制信息量。磁盘存储器用 <strong>道密度</strong>、<strong>位密度</strong> 和 <strong>面密度</strong> 来表示。</p>\n<p>（2）<strong>存储容量</strong></p>\n<p>​        存储容量指磁盘能存储的二进制信息的总数量，一般以位或者字节为单位。磁盘存储容量 C 可以计算为：</p>\n<script type=\"math/tex; mode=display\">\nC = n \\times k \\times s</script><p>​        其中 n 为 盘面数，k 为每个盘面的磁道数，s 为每条磁道上记录的二进制代码数。</p>\n<p>（3）<strong>平均寻址时间</strong></p>\n<p>​        磁盘的存取方式是直接存取，它的寻址时间分为两个部分：磁头寻找目标磁道的时间 t~s~；和找到磁道后，磁头等待要读写的磁道区段（扇区）旋转到磁头下方的时间 t~w~ 。由于寻找相邻磁道和不相邻磁道的时间不同，磁头等待不同扇区的时间也不同，所以应该取平均值，称为 <strong>平均寻址时间</strong>；它是 <strong>平均寻道时间</strong> t~sa~ 和 <strong>平均等待时间</strong>     t~wa~ 之和。</p>\n<script type=\"math/tex; mode=display\">\nT_a = t_{sa} + t_{wa} = \\frac{t_{smax} + t_{smin}}{2} + \\frac{t_{wmax} + t_{wmin}}{2}</script><p>​        平均寻址时间再加上数据传输时间，就是磁盘的 <strong>平均访问时间</strong>。</p>\n<p>（4）<strong>数据传输率</strong></p>\n<p>​        数据传输率是指单位时间内，磁盘向主机传送数据的位数或字节数。数据传输率 D<sub>R</sub> 与记录位密度 D~b~ 和磁道运动速度 V 有关；</p>\n<script type=\"math/tex; mode=display\">\nD_r = D_b \\times V</script><p>​        对于磁盘来说，“磁道运动速度” 一般用磁盘的转速 r （单位 转/s）表示，那么</p>\n<script type=\"math/tex; mode=display\">\nD_r = D_b \\times (r \\times \\pi d_{min}) = r \\times f_t</script><p>（5）误码率</p>\n<p>​        误码率是衡量磁盘出错概率的参数，等于从磁盘读出信息时，出错信息位数和读出信息总位数之比。为了减少出错率，磁盘一般采用循环冗余校验（CRC）码来发现和纠正错误。</p>\n<h5 id=\"5-冗余磁盘阵列-RAID\"><a href=\"#5-冗余磁盘阵列-RAID\" class=\"headerlink\" title=\"5. 冗余磁盘阵列 RAID\"></a>5. 冗余磁盘阵列 RAID</h5><p>​        <strong>冗余磁盘阵列</strong>（Redundant Array of Independent Disks，<strong>RAID</strong>）是将多个独立的物理磁盘组成一个磁盘阵列，引入并行处理技术，让数据在多个物理盘上分割交叉存储、并行访问。 </p>\n<p>​        根据不同的目的，可以采用不同的 RAID 方案；在 RAID1 ~ RAID5 的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。RAID 的分级如下所示：</p>\n<ul>\n<li><p>RAID0：无冗余和无校验的磁盘阵列。</p>\n</li>\n<li><p>RAID1：镜像磁盘阵列，无校验。</p>\n</li>\n<li><p>RAID2：采用纠错的海明码的磁盘阵列。</p>\n</li>\n<li><p>RAID3：位交叉奇偶校验的磁盘阵列。</p>\n</li>\n<li><p>RAID4：块交叉奇偶校验的磁盘阵列。</p>\n</li>\n<li>RAID5：无独立校验的奇偶校验磁盘阵列。</li>\n</ul>\n<p>​        其中，RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。</p>\n<p>​        RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另 一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。</p>\n<p>​        总之，RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高吞吐量；通过镜像功能，提高了安全性、可靠性；通过数据校验，提供容错能力。</p>\n<h4 id=\"3-5-2-固态硬盘（SSD）\"><a href=\"#3-5-2-固态硬盘（SSD）\" class=\"headerlink\" title=\"3.5.2 固态硬盘（SSD）\"></a>3.5.2 固态硬盘（SSD）</h4><p>​        <strong>固态硬盘</strong>（Solid State Disk，<strong>SSD</strong>）是基于闪存（Flash）技术的半导体存储器，它与 U 盘并没有本质差别。SSD 由闪存芯片和闪存翻译层组成，闪存芯片代替了传统磁盘中的磁盘驱动器，闪存翻译层则将来自 CPU 的读写请求翻译成对芯片的读写控制信号，相当于磁盘中的磁盘控制器。    </p>\n<p><img src=\"/img/3_40_机械硬盘 vs SSD.png\" alt=\"3_40_机械硬盘 vs SSD\"></p>\n<p>固态硬盘有很多优点。它由半导体存储器构成，没有机械部件，所以随机访问速度比磁盘快很多，也没有任何机械噪声和震动。另外，SSD 还具有能耗低、抗震性好、安全性高等优点。</p>\n<p>​        当然，固态硬盘也有缺点。它最大的问题是依然基于 EEPROM 的擦除原理，随机写入比较慢。</p>\n<p>​        固态硬盘的数据都存放在闪存芯片中。一个闪存芯片内包含了多个 “块”，每个块又由若干 “页” 组成。数据以页为单位进行读写，但是需要以块为单位进行擦除；所以只有一页所属的块整个被擦除之后，才能重新写这一页。一旦一个块被擦除了，块中的每一页都可以再写一次。一般某个块进行了数千次重复写之后，就会损坏。</p>\n<p><img src=\"/img/3_41_SSD结构.png\" alt=\"3_41_SSD结构\"></p>\n","text":"第一章 计算机系统概述1.1 本章大纲要求与核心考点1.1.1 大纲内容(一) 计算机系统层次结构 计算机系统的基本组成 计算机硬件的基本结构 计算机软件和硬件...","permalink":"/post/计算机组成原理","photos":[],"count_time":{"symbolsCount":"64k","symbolsTime":"58 mins."},"categories":[],"tags":[{"name":"个人","slug":"个人","count":2,"path":"api/tags/个人.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">第一章 计算机系统概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%9C%AC%E7%AB%A0%E5%A4%A7%E7%BA%B2%E8%A6%81%E6%B1%82%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9\"><span class=\"toc-text\">1.1 本章大纲要求与核心考点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-1-%E5%A4%A7%E7%BA%B2%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">1.1.1 大纲内容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9C%9F%E9%A2%98%E5%88%86%E5%B8%83\"><span class=\"toc-text\">真题分布</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">1.2 计算机系统简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">1.2.1 计算机系统的概念和分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95\"><span class=\"toc-text\">1.2.2 计算机的发展</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.3 计算机系统的层次结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\"><span class=\"toc-text\">1.3.1 计算机系统的基本组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.3.2 计算机硬件的基本结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.3.3 计算机系统的多级层次结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.3.4 计算机系统的工作原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%BE%97%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">1. 从源程序得到可执行程序</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.3.5 计算机系统的工作原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E4%BB%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%BE%97%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F-1\"><span class=\"toc-text\">1. 从源程序得到可执行程序</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">2. 存储程序的基本思想</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%E7%9A%84%E7%BB%86%E5%8C%96%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">3. 计算机硬件组成的细化说明</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">4. 计算机硬件的工作过程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">1.4 计算机性能指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-1-%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">1.4.1 主要性能指标</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-5-2-%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">1.5.2 专业术语解释</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">1.5 章节练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98\"><span class=\"toc-text\">一、单项选择题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E9%A2%98\"><span class=\"toc-text\">二、综合应用题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">第二章 数据的表示和运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%9C%AC%E7%AB%A0%E5%A4%A7%E7%BA%B2%E8%A6%81%E6%B1%82%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9\"><span class=\"toc-text\">2.1 本章大纲要求与核心考点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-1-%E5%A4%A7%E7%BA%B2%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">2.1.1 大纲内容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-2-%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9\"><span class=\"toc-text\">2.1.2 核心考点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-3-%E7%9C%9F%E9%A2%98%E5%88%86%E5%B8%83\"><span class=\"toc-text\">2.1.3 真题分布</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">2.2 数制与编码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1-%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.2.1 进位计数制及其相互转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-2-%E7%9C%9F%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E6%95%B0\"><span class=\"toc-text\">2.2.2 真值和机器数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-3-%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">2.2.3 定点数及其编码表示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">1. 无符号整数的表示</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">2. 带符号数的表示</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81\"><span class=\"toc-text\">3. 原码、补码、反码和移码</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-4-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.2.4  C 语言中的整型数据类型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3 运算方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-1-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.3.1 定点数的移位运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D\"><span class=\"toc-text\">1. 算术移位</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D\"><span class=\"toc-text\">2. 逻辑移位</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-3-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.3.3 定点数的加减运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E8%A1%A5%E7%A0%81%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">1. 补码的加减运算</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%BA%A2%E5%87%BA%E5%88%A4%E5%88%AB%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2. 溢出判别方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-4-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.2.4 定点数的乘法运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">1. 原码一位乘法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">2. 补码一位乘法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-5-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.2.5 定点数的除法运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">1. 原码一位除法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95%EF%BC%88%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">2. 补码一位除法（加减交替法）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.4 浮点数的表示和运算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-1-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">2.4.1 浮点数的表示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">1. 浮点数的表示格式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4\"><span class=\"toc-text\">2. 浮点数的表示范围</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96\"><span class=\"toc-text\">3. 浮点数的规格化</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-IEEE-754-%E6%A0%87%E5%87%86%E6%B5%AE%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">4. IEEE 754 标准浮点数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0-%E5%87%8F%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">2.4.2 浮点数的加&#x2F;减运算</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97\"><span class=\"toc-text\">2.5 数据的存储和排列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-1-%E6%95%B0%E6%8D%AE%E6%8C%89%E2%80%9C%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E2%80%9D%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">2.5.1 数据按“边界对齐”方式存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-2-%E6%95%B0%E6%8D%AE%E7%9A%84%E2%80%9C%E5%A4%A7%E7%AB%AF%E6%96%B9%E5%BC%8F%E2%80%9D%E5%92%8C%E2%80%9C%E5%B0%8F%E7%AB%AF%E6%96%B9%E5%BC%8F%E2%80%9D%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">2.5.2 数据的“大端方式”和“小端方式”存储</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">2.6 章节练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98-1\"><span class=\"toc-text\">一、单项选择题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E9%A2%98-1\"><span class=\"toc-text\">二、综合应用题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">第三章 存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E6%9C%AC%E7%AB%A0%E5%A4%A7%E7%BA%B2%E8%A6%81%E6%B1%82%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9\"><span class=\"toc-text\">3.1 本章大纲要求与核心考点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-1-%E5%A4%A7%E7%BA%B2%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">3.1.1 大纲内容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-2-%E6%A0%B8%E5%BF%83%E8%80%83%E7%82%B9\"><span class=\"toc-text\">3.1.2 核心考点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-3-%E7%9C%9F%E9%A2%98%E5%88%86%E5%B8%83\"><span class=\"toc-text\">3.1.3 真题分布</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">3.2 存储器概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">3.2.1 存储器的分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">1. 按存储介质分类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%8C%89%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">2. 按存取方式分类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">3. 按在计算机中的作用分类</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-2-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3.2.2 存储器的性能指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%AD%98%E5%82%A8%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">1.存储速度</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F\"><span class=\"toc-text\">2. 存储容量</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BD%8D%E4%BB%B7\"><span class=\"toc-text\">3. 位价</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-3-%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.2.3 层次化存储器的基本结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">3.3 半导体存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-1-SRAM\"><span class=\"toc-text\">3.3.1 SRAM</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-2-DRAM\"><span class=\"toc-text\">3.3.2 DRAM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#DRAM-%E7%9A%84%E5%88%B7%E6%96%B0\"><span class=\"toc-text\">DRAM 的刷新</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#DRAM-%E5%92%8C-SRAM-%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">DRAM 和 SRAM 的比较</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-3-ROM\"><span class=\"toc-text\">3.3.3 ROM</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">3.4 主存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-1-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\"><span class=\"toc-text\">3.4.1 主存储器的基本组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%AD%98%E4%B8%AD%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D\"><span class=\"toc-text\">主存中地址的分配</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-2-%E4%B8%BB%E5%AD%98%E5%92%8C-CPU-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">3.4.2 主存和 CPU 之间的连接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">1. 主存容量扩展</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%B8%BB%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">2. 主存与CPU的连接</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-4-3-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">3.4.3 多模块存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">1. 单体多字存储器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">2. 多体并行系统</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">3.5 外部存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-1-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8\"><span class=\"toc-text\">3.5.1 磁盘存储器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E7%A3%81%E8%A1%A8%E9%9D%A2%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E7%A3%81%E8%AE%B0%E5%BD%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1. 磁表面存储器和磁记录原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E7%A1%AC%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. 硬磁盘的分类和基本结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E7%A3%81%E7%9B%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3. 磁盘的工作原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97-RAID\"><span class=\"toc-text\">5. 冗余磁盘阵列 RAID</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-2-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89\"><span class=\"toc-text\">3.5.2 固态硬盘（SSD）</span></a></li></ol></li></ol></li></ol>","author":{"name":"Gueason","slug":"blog-author","avatar":"https://pic.quanjing.com/60/2a/QJ6771797507.jpg@!350h","link":"/","description":"小白，在成为“牛码”的路上","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"个人搭建方法","uid":"eebf5774c100175fb47d65de16ffd14d","slug":"intro","date":"2024-05-29T09:41:59.000Z","updated":"2024-05-30T13:04:33.137Z","comments":true,"path":"api/articles/intro.json","keywords":null,"cover":[],"text":"简介主要用于知识整理与分享，希望有用 ","permalink":"/post/intro","photos":[],"count_time":{"symbolsCount":20,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"个人","slug":"个人","count":2,"path":"api/tags/个人.json"}],"author":{"name":"Gueason","slug":"blog-author","avatar":"https://pic.quanjing.com/60/2a/QJ6771797507.jpg@!350h","link":"/","description":"小白，在成为“牛码”的路上","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}