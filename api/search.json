[{"id":"8a3e3c56ca704c10863ee2d485165156","title":"操作系统408（搬运）","content":"【王道】操作系统 知识点总结（合集）【超详细！】 - Zyyyyyyyyy - 博客园 (cnblogs.com)\n王道操作系统知识点总结_住在天上的云的博客-CSDN博客\n《王道操作系统》学习笔记总目录+思维导图_王道操作系统思维导图-CSDN博客\n一、操作系统概论1.1基本概念现代计算机硬件系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统。在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 操作系统。它控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；操作系统相当于是一个中间层，以提供给用户和其他软件方便的接口和环境，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。\n\n大部分计算机有两种运行模式：内核态 和 用户态，软件中最基础的部分是操作系统，它运行在 内核态 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 用户态 下。\n功能：\n\n\n处理机管理\n\n​        即对进程的管理，包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。\n\n存储器管理\n方便程序运行、用户使用及提高内存的利用率，包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。\n\n文件管理\n计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。\n文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。\n\n设备管理\n设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。\n\n\n\n命令接口\n用户利用这些操作命令来组织和控制作业的执行。\n\n\n  联机命令接口：即交互式命令接口，适用于分时或实时系统。\n  “雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。\n  脱机命令接口：即批处理命令接口，适用于批处理系统\n  “雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。\n\n程序接口\n程序接口由一组系统调用（也称广义指令）组成。是为编程人员提供的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。\n用户通过在程序中使用系统调用命令请求OS为其提供服务。系统调用命令又称广义指令。\n\n\n\nGUl：图形化用户接口（Graphical User Interface）\n用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。\n\n\n\n裸机：没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础。\n在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方         便的机器。\n\n\n​       通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机。\n1.2特征并发\n并发指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。\nOS的并发性是通过分时实现的。\n\n单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行\n多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行\n\n并发性：两个或多个事件在同一时间间隔内发生。\n并行性：两个或多个事件在同一时刻发生，需要硬件支持，如多流水线或多处理机硬件环境。\n多道程序环境下，一段时间，宏观上，多道程序同时执行某一时刻，单处理机环境下实际仅有一道程序执行，微观上程序分时交替执行\n共享\n共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。\n\n互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。\n临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享\n应用：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。\n\n\n\n同时共享：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。\n分时共享：宏观上“同时”，微观上交替地对该资源进行访问\n应用：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。\n\n\n​      \n并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：\n\n资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；\n\n若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。\n\n\n虚拟\n虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。\n\n虚拟处理器：通过时分复用技术，让多道程序并发执行的方法，来分时使用一个处理器的。\n虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。\n\n虚拟存储器：通过空分复用技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。\n\n虚拟I/O设备：采用虚拟设备技术将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的共享设备。\n\n\n异步\n在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。\n比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进\n1.3分类与发展\n\n单道批处理系统：引入脱机输入输出技术\n\n特征：\n自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。\n顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。\n单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。\n\n优点：缓解人机速度矛盾。\n\n缺点：资源利用率仍低，高速CPU等待低速I/O。\n\n\n多道批处理系统：多道程序设计技术操作系统开始出现\n多道程序设计：允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。\n\n特点：\n多道：计算机内存中同时存放多道相互独立的程序。\n宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。\n微观上串行：内存中的多道程序轮流占有CPU，交替执行。\n间断性：由于多道程序之间需要共享和竞争系统资源，因此每个程序的执行过程不是连续的，而是有间断的。\n共享性：多道程序之间需要共享系统的各种资源，如CPU、内存、外设等。\n制约性：多道程序之间存在相互制约的关系，如同步、互斥、优先级等。\n\n优点：\n资源利用率高，多道程序并发执行，共享计算机资源\n系统吞叶量大，CPU和其他资源保持”忙碌”\n\n缺点：用户响应时间长、无人机交互能力\n\n\n分时操作系统\n分时技术：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。\n多个用户通过终端同时共享一台主机，用户可以同时与主机进行交互操作而互不干扰。\n\n特点\n同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。\n交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。\n独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。\n及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。\n\n优点\n用户请求可以被即时响应，解决了人机交互问题。\n允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。\n\n缺点：无法优先处理紧急任务\n\n\n实时操作系统\n能在某个时间限制内完成某些紧急任务而不需要时间片排队。\n\n分类：\n软实时系统：能够接受偶尔违反时间规定且不会引起永久性的损害。\n如飞机订票系统、银行管理系统。\n硬实时系统：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。\n如飞行器的飞行自动控制系统。\n\n特点\n及时性\n可靠性\n\n优点：能够优先处理紧急任务\n\n\n网络操作系统\n把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。\n\n特点\n网络中各种资源的共享\n各台计算机之间的通信\n\n分布式计算机系统：由多台计算机组成并满足下列条件的系统，主要特点是分布性和并行性。\n系统中任意两台计算机通过通信方式交换信息\n系统中的每台计算机都具有同等的地位，即没有主机也没有从机\n每台计算机上的资源为所有用户共享\n系统中的任意台计算机都可以构成一个子系统，并且还能重构\n任何工作都可以分布在几台计算机上，由它们并行工作、协同完成\n\n分布式操作系统与网络操作系统的本质不同：分布式操作系统中的若干计算机相互协同完成同一任务。\n\n\n1.4体系结构\n宏内核\n宏内核是将操作系统功能作为一个紧密结合的整体放到内核。\n由于各模块共享信息，因此有很高的性能。\n微内核\n由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。\n在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。\n1.5运行机制\nCPU执行两种不同性质的程序：\n操作系统内核程序：是用户自编程序的管理者，“管理程序”（即内核程序）要执行一些特权指令。\n用户自编程序：即系统外层的应用程序，或简称“应用程序”，“被管理程序”（即用户自编程序）出于安全考虑不能执行这特权指令。\n\n\n\n特权指令和非特权指令\n特权指令：是指不允许用户直接使用的指令，如/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。\n非特权指令：是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。\n\n\n\nCPU的运行模式\n用户态（目态）：CPU处于用户态，此时CPU只能执行非特权指令。\n核心态（又称管态、内核态）：CPU处于核心态，此时CPU可以执行特权指令，切换到用户态的指令也是特权指令。\n应用程序运行在用户态，操作系统内核程序运行在核心态。\n\n\n   内核态一&gt;用户态：执行特权指令，修改PSW（程序状态字寄存器），用二进制位表示，1内核态0用户态\n   用户态一&gt;内核态：应用程序向操作系统请求服务时通过使用访管指令，从而产生一个中断事件将操作系统转换为核心态。\n1.6中断与异常\n中断作用\n让操作系统内核强行夺回CPU的控制权；使CPU从用户态变为内核态。\n中断和异常的分类\n异常：又称内中断，指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。\n\n故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。\n\n陷入（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。\n\n终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。\n\n\n中断：又称外中断，指来自CPU执行指令外部的事件，通常用于信息输入/输出，如I/O中断，时钟中断。\n\n可屏蔽中断：指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。\n\n不可屏蔽中断：指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。\n\n\n故障和陷入异常属于软件中断（程序性异常），终止异常（内中断）和外中断属于硬件中断。\n异常不能被屏蔽，一旦出现，就应立即处理。\n中断和异常的处理过程\n\n当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号\n\n如果检查到外部中断信号，保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）\n\nCPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。\n\n若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i+1条指令继续执行\n\n返回第i+1条指令：由自陷（Trap）引起的内中断；如系统调用。由外部设备引起的外中断，如键盘\n返回第i条指令：由故障（Fault）引起的内中断；如缺页等。\n\n\n若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。\n\n\n通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。\n1.7系统调用\n系统调用和库函数的区别\n\n系统调用是操作系统提供的接口，允许用户程序请求操作系统服务，如文件操作、进程管理等，通常需要切换到内核模式\n库函数则是开发者在应用层编写的函数，封装了常用的功能，可以直接被程序调用，无需内核模式切换。\n定义\n操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，系统调用可视为特殊的公共子程序。又称广义指令。程序接口由一组系统调用组成。目的为解决资源分配问题\n分类\n\n设备管理：完成设备的请求或释放，以及设备启动等功能。\n\n文件管理：完成文件的读、写、创建及删除等功能。\n\n进程控制：完成进程的创建、撤销、阻塞及唤醒等功能。\n\n进程通信：完成进程之间的消息传递或信号传递等功能。\n\n内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。\n\n\n系统调用过程\n系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。\n用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。\n\n访管指令不是特权指令，访管指令是在用户态使用的，所以它不可能是特权指令。\n\n系统调用执行过程：\n传递系统调用参数→执行陷入（trap）指令→执行相应的服务程序→返回用户态\n\n\n当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；\n\n也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。\n\n管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行\n\n\n\n用户态转向核心态的例子：\n\n用户程序要求操作系统的服务，即系统调用。\n发生一次中断。\n用户程序中产生了一个错误状态。\n用户程序中企图执行一条特权指令。\n从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。\n\n只能在核心态下执行的指令（特权指令）：\n\n开关中断指令，用于允许或禁止中断，控制中断屏蔽位\n设置时钟日期指令，用于修改系统时钟\n改变存储映像图指令，用于修改主存保护机制\n启动I/O指令，用于控制I/O设备的工作状态和动作\n加载PSW指令，用于修改程序状态字（PSW），包括中断标志位、运算结果标志位等\n置特殊寄存器指令，用于存取中断寄存器、时钟寄存器等特殊寄存器\n停机指令，用于停止一个中央处理器的工作\n\n\n\n\n注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。\n\n二、进程管理2.1进程与线程2.1.1 进程的概念和特征在多道程序处理的系统中，CPU 会在进程间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生并行的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。\n一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。\n每道程序被抽象为拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。\n从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行。\n\n进程的概念\n进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。\n\n进程实现操作系统的并发性和共享性。\n\n程序：是静态的，就是个存放在磁盘里的可执行文件，如：QQ.exe。\n进程：是动态的，是程序的一次执行过程，或者是一个正在运行的程序，如：可同时启动多次QQ程序。\n进程实体：即进程映像，是静态的，可理解为进程的一次时刻的状态。\n作业：用户向计算机提交的一项任务，是静态的，它通常是一个批处理程序或一个后台程序。\n进程实体的组成\n1.程序控制块PCB\nPCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。\nOS是根据PCB来对并发执行的进程进行控制和管理的， 但凡管理时所需要的信息，都会被放在 PCB 中。\nPCB 存于内存的内核区，注意内存的内核区和 OS 的内核态的区别，内核程序运行在内核态。\nPCB包含的内容：\n\n进程描述信息\n进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—PID（Process ID，进程ID）\n用户标识符UID\n\n\n进程控制和管理信息\nCPU、磁盘、网络流量使用情况统计…\n进程当前状态：就绪态/阻塞态/运行态.…\n进程优先级，抢占处理机的优先级\n\n\n资源分配清单\n程序段指针\n数据段指针\nI/O设备\n\n\n处理机相关信息（CPU现场信息）：如PSW、PC等等各种寄存器的值（用于实现进程切换）\n\n2.程序段：程序的代码（指令序列）\n3.数据段：运行过程中产生的各种数据（如：程序中定义的变量）\n\nPCB 是给操作系统用的，程序段和数据段是给进程自己用的。\n引入进程实体的概念后，可把进程定义为是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。\n\n进程的特征\n\n动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征。\n并发性：内存中有多个进程实体，各进程可并发执行\n独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位\n异步性：各进程按各自独立的、不可预知的速度向前推进，异步性会导致并发程序执行结果的不确定性。\n结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成\n\n2.1.2 进程的状态与转换基本状态\n\n运行态。占有CPU，并在CPU上运行；有其他所需资源\n单核处理机环境每个时刻只有一个进程处于运行态\n\n\n\n就绪态。已具有运行条件，但无空闲CPU，暂时不能运行；有其他所需资源\n系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。\n\n\n\n阻塞态，又称等待态。因等待某一事件暂时不能运行；无其他所需资源\n系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。\n\n\n\n创建态。进程正在被创建，尚未转到就绪态。OS为进程分配系统资源、初始化PCB\n\n首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息\n然后为该进程分配运行时所必须的资源\n最后把该进程转入就绪态并插入就绪队列\n\n但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。\n\n\n\n终止态。进程正从系统中消失，进程正常结束或其他原因退出运行。OS回收进程拥有的资源，撤销PCB\n\n进程状态的转换\n\n\n就绪态一&gt;运行态：进程被调度\n\n运行态一&gt;就绪态：时间片到 or CPU被其他进程抢占\n\n运行态一&gt;阻塞态：等待系统资源分配or等待某事件发生（主动行为）\n\n阻塞态一&gt;就绪态：资源分配到位，等待的事件发生（被动行为）\n\n创建态一&gt;就绪态：系统完成创建进程相关的工作\n\n运行态一&gt;终止态：进程运行结束 or 运行过程中遇到不可修复的错误\n\n\n2.1.3 进程的组织方式链接方式\n链接方式是将同一状态的进程的PCB组成一个双向链表，称为进程队列。\n\n结构：每个队列的队首和队尾都有一个指针，指向第一个和最后一个PCB。每个PCB中也有两个指针，分别指向前一个和后一个PCB。这样，就可以方便地在队列中插入或删除PCB。\n\n优点：简单、灵活\n\n缺点：查找效率低，需要遍历链表\n\n\n\n索引方式\n索引方式是将所有的PCB存放在一张索引表中，每个表项包含一个PCB的地址和状态信息。\n\n结构：索引表可以是顺序表或散列表，可以按照进程号或其他关键字进行排序或散列。\n优点：查找效率高，可以快速定位到某个PCB\n缺点：需要额外的空间存储索引表，且索引表的大小受限于内存容量\n\n\n2.1.4 进程控制进程控制就是要实现进程状态的转换，通过原语实现。原语不允许被中断（原子操作）。\n进程的创建\n\n创建原语：操作系统创建一个进程时使用的原语，其操作如下；创建态→就绪态\n\n申请空白PCB\n为新进程分配所需资源\n初始化PCB\n将PCB插入就绪队列\n\n\n引起进程创建的事件\n\n用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程\n作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\n提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求\n应用请求：由用户进程主动请求创建一个子进程\n\n\n父子进程\n允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。\n\n进程可以继承父进程所拥有的资源。\n当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。\n在撤销父进程时，通常也会同时撤销其所有的子进程。\n\n\n\n进程的终止\n\n撤销原语：其操作如下；\n就绪态/阻塞态/运行态→终止态→无\n\n从PCB集合中找到终止进程的PCB\n若进程正在运行，立即剥夺CPU，将CPU分配给其他进程\n终止其所有子进程\n将该进程拥有的所有资源归还给父进程或操作系统\n删除PCB\n\n\n引起进程终止的事件\n\n正常结束：进程自已请求终止（exit系统调用）\n异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉\n外界干预：Ctrl+Alt+delete，用户选择杀掉进程\n\n\n\n进程的阻塞\n\n阻塞原语：其操作如下；\n运行态→阻塞态\n\n找到要阻塞的进程对应的PCB\n保护进程运行现场，将PCB状态信息设置为“阻塞态，暂时停止进程运行\n将PCB插入相应事件的等待队列\n\n\n引起进程阻塞的事件\n\n需要等待系统分配某种资源\n需要等待相互合作的其他进程完成工作\n\n\n\n进程的唤醒\n\n唤醒原语：其操作如下；\n阻塞态→就绪态\n\n在事件等待队列中找到PCB\n将PCB从等待队列移除，设置进程为就绪态\n将PCB插入就绪队列，等待被调度\n\n\n引起进程唤醒的事件\n\n等待的事件发生：因何事阻塞，就应由何事唤醒\n\n\n\n阻塞原语唤醒原语必须成对使用\n进程的切换\n\n切换原语：其操作如下；\n运行态→就绪态，就绪态→运行态\n\n将运行环境信息存入PCB\nPCB移入相应队列选择\n另一个进程执行，并更新其PCB\n根据PCB恢复新进程所需的运行环境\n\n\n引起进程切换的事件\n\n当前进程时间片到\n有更高优先级的进程到达\n当前进程主动阻塞\n当前进程终止\n\n\n\n\n调度是指决定资源分配给哪个进程的行为，是一种决策行为切换是指实际分配的行为，是执行行为一般来说现有资源调度，后有进程切换\n2.1.5 进程的通信低级通信方式：PV操作。高级通信方式：共享存储、消息传递、管道通信。\n1.共享存储\n设置一个共享空间进行读/写操作实现信息交换，一次只能有一个进程进行读或写操作\n在对共享空间进行写/读操作时，需要使用同步互斥工具（如PV操作）。\n\n共享存储分为两种：\n\n低级方式：基于数据结构的共享\n比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式\n\n高级方式：基于存储区的共享\n操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。\n\n\n\n进程之间共享空间需要通过特殊的系统调用实现；进程内线程共享进程空间。\n\n2.消息传递\n在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。\n\n进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。\n\n在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。\n\n消息格式：\n\n消息头：发送进程ID、接受进程ID、消息长度等格式化的信息\n消息体\n\n通信方式：\n\n直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。\n\n间接通信方式：送进程通过信箱间接地通信，将消息发送到某个中间实体，接收进程从中间实体取得消息。该通信方式广泛应用于计算机网络中。\n\n注：可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱中 receive 消息。\n用发送原语和接收原语实现基于信箱的进程间通信\n\n\n\n3.管道通信\n管道是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。\n\n管道通信允许两个进程按生产者-消费者方式进行通信。各进程要互斥访问管道。\n\n写满时，不能再写，读空时，不能再读\n没写满时，不能读，没读空时，不能写\n\n\n一个管道只能实现半双工通信；实现双向同时通信要建立两个管道\n\n管道本质上是一种特殊的文件。相比于普通的文件通信，其区别如下：\n\n限制管道的大小。管道文件是一个固定大小的缓冲区，使得它的大小不像普通文件那样不加检验地增长。\n\n读进程也可能工作得比写进程快。读空时再读管道会被阻塞，而不是调用返回文件结束。\n\n\n管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：\n\n一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；\n\n允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Liux的方案）。\n\n\n管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进进行通信。\n2.1.6 线程和多线程模型1.线程的基本概念\n线程可理解为轻量级进程，它是一个基本的CPU执行单元，也是程序执行流的最小单位。\n线程由线程ID、程序计数器、寄存器集合和堆栈组成。\n\n引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；\n而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。\n\n引入线程后，进程只作为除CPU外的系统资源的分配单位，线程则作为处理机的分配单元\n2.进程（Process）与线程（Thread）比较\n进程：系统进行资源分配和调度的基本单位。\n线程：操作系统进行运行调度的最小单位。\n区别与联系：\n\n一个进程可以有一个或多个线程\n线程包含在进程之中，是进程中实际运行工作的单位\n进程的线程共享进程资源\n一个进程可以并发多个线程，每个线程执行不同的任务。\n\n\n\n\n\n\n传统进程机制\n引入线程后\n\n\n\n\n资源分配、调度\n进程是资源分配、调度基本单位\n进程是资源分配基本单位线程是资源调度基本单位\n\n\n并发性\n进程间并发\n线程间也能并发\n\n\n拥有资源\n拥有资源的基本单位\n不拥有系统资源\n\n\n独立性\n进程间独立地址空间和资源\n同进程下的线程共享地址空间和资源\n\n\n系统开销\n需要切换进程运行环境，开销大\n同一进程内线程，不需切换进程环境，开销小\n\n\n支持多处理机系统\n进程只能运行在一个处理机上\n进程中多个线程可以分配到多个处理机执行\n\n\n\n\n3.线程的属性\n多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。\n\n线程是处理机调度的单位\n多CPU计算机中，各个线程可占用不同的CPU\n每个线程都有一个线程ID、线程控制块（TCB）\n线程也有就绪、阻塞、运行三种基本状态\n线程几乎不拥有系统资源\n同一进程的不同线程间共享进程的资源\n由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预\n同一进程中的线程切换，不会引起进程切换\n不同进程中的线程切换，会引起进程切换\n切换同进程内的线程，系统开销很小\n切换进程，系统开销较大\n\n\n注：线程是处理机调度的单位，这里的线程指的是 操作系统看得见的内核级线程，内核级线程是处理机分配的单位 。\n同进程的线程之间可以共享进程的代码段、全局变量、打开的文件，不共享线程各自的栈指针等TCB内容\n\n4.线程的实现方式\n线程的实现可以分为两类：用户级线程 和 内核级线程。内核级线程又称内核支持的线程。\n\n用户级线程(User-Level Thread,UTL)\n在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在用户空间中完成，内核意识不到线程的存在，因此说用户级线程对操作系统透明。\n\n\n用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）\n用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。\n在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程\n\n\n若系统中只有用户级线程，则处理机的调度对象是进程\n\n\n\n\n内核级线程(Kernel-Level Thread, KTL)\n内核级线程是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。\n\n\n内核级线程的管理工作由操作系统内核完成。\n线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。\n操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块）通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”\n\n\n\n\n\n\n\n\n用户级线程\n内核级线程\n\n\n\n\n线程的管理工作\n由 应用程序 通过线程库实现所有的线程管理工作 包括线程切换\n线程管理工作由 操作系统内核完成\n\n\n线程切换是否需要 CPU 变态\n用户级线程切换 可以在用户态下即可完成无需操作系统干预\n线程调度、切换等工作都由内核负责内核级线程的切换必然需要在核心态下才能完成。\n\n\nOS 是否能意识到用户级线程的存在\nOS 内核意识不到用户级线程的存在 用户级线程就是从用户视角看能看到的线程\nOS 会为每个内核级线程建立相应的 TCB（线程控制块）通过TCB对线程进行管理内核级线程就是从操作系统内核视角看能看到的线程\n\n\n优点\n用户级线程的切换在用户空间即可完成不需要切换到核心态线程管理的系统开销小，效率高\n当一个线程被阻塞后，其他线程还可以继续执行并发能力强,多线程可在多核处理机上并行执行\n\n\n缺点\n当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高因为进程是处理机调度的基本单位，同一进程的多个线程不可在多核处理机上并行运行\n一个用户进程会占用多个内核级线程线程切换由操作系统内核完成需要切换到核心态，因此线程管理的开销大，效率低，成本高\n\n\n\n\n组合方式\n有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。\n\n\n一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。\n同一进程中的多个线程可以同时在多处理机上并行执行，\n且在阻塞一个线程时不需要将整个进程阻塞，\n\n线程库\n线程库是为程序员提供创建和管理线程的API。实现方式有以下两种。\n\n在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。\n实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。\n\n\n\n\n5.多线程模型\n\n一对一模型\n一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。\n\n\n\n优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。（内核级线程优点）\n\n缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。（内核级线程缺点）\n\n\n\n\n多对一模型\n多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。\n\n\n\n优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高（用户级线程优点）\n\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行（用户级线程缺点）\n\n\n\n多对多模型\nn用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。\n\n克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。还拥有上述两种模型各自的优点。\n\n\n\n线程的状态与转换\n\n线程的组织与控制\n\n\n线程控制块\n与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。线程控制块通常包括\n\n①线程标识符\n②一组寄存器，包括程序计数器、状态寄存器和通用寄存器\n③线程运行状态，用于描述线程正处于何种状态\n④优先级\n⑤线程专有存储区，线程切换时用于保存现场等\n⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。\n\n同一进程中的所有线程都完全共享进程的地址空间和全局变量。\n各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。\n\n线程的创建\n用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。\n在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。\n\n线程的终止\n当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。\n但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。\n被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。\n\n\n2.2 处理机调度2.2.1 调度的概念调度的基本概念\n处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）去选择一个进程并将处理机分配给它运行，以实现进程并发地执行。\n调度的层次\n一个作业从提交开始直到完成，要经历以下三级调度，如下图所示。\n\n\n高级调度（作业调度）\n内存空间有限时，无法将用户提交的作业全部放入内存，需要按一定的原则从外存的作业 后备队列 中挑选一个作业调入内存，并创建进程。\n每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。\n\n作业：一个具体的任务\n\n多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。\n\n发生频率最低 外存→内存（面向作业）\n\n\n\n\n中级调度（内存调度）\n内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时，按照某种策略从 挂起队列 中选择合适的进程重新调入内存。\n\n暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。\n\n\n外存→内存（面向进程）\n\n\n\n\n低级调度（进程调度）\n在内存中的按照某种策略从 就绪队列 中选取一个进程，将处理机分配给它。\n\n发生频率高 内存→CPU\n\n\n\n三级调度的联系\n\n七状态模型\n\n\n\n\n三层调度对比\n\n\n\n\n\n\n任务\n调度\n频率\n对进程状态影响\n\n\n\n\n高级调度（作业调度）\n从后备队列中选择合适的作业将其调入内存，并为其创建进程\n外存→内存(面向作业)\n最低\n无→创建态→就绪态\n\n\n中级调度（内存调度）\n从挂起队列中选择合适的进程将其数据调回内存\n外存→内存（面向进程）\n中等\n挂起态→就绪态阻塞挂起→阻塞态\n\n\n低级调度（进程调度）\n从就绪队列中选择一个进程为其分配处理机\n内存→CPU\n最高\n就绪态→运行态\n\n\n\n\n2.2.2 调度的目标 不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。评价标准如下。\n\nCPU利用率：指CPU“忙碌”的时间占总时间的比例。\n\n利用率=\\frac{忙碌的时间}{总时间}\n系统吞吐率：单位时间内完成作业的数量。\n\n系统吞吐率=\\frac{总共完成了多少道作业}{总共花了多少时间}\n周转时间：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。\n\n周转时间=作业完成时间-作业提交时间平均周转时间：指多个作业周转时间的平均值。\n\n平均周转时间=\\frac{各个作业周转时间之和}{作业数}带权周转时间：作业周转时间与作业实际运行时间的比值。带权周转时间必然≥1\n\n带权周转时间=\\frac{作业周转时间}{作业实际运行时间}=\\frac{作业完成时间-作业提交时间}{作业实际运行时间}平均带权周转时间：多个作业带权周转时间的平均值。\n\n平均带权周转时间=\\frac{各个作业带权周转时间之和}{作业数}\n等待时间\n等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。\n\n等待时间=周转时间-运行时间\n对于进程来说，等待时间就是指进程建立后等待被服务的时间之和。\n对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。\n\n平均等待时间：各个进程/作业等待时间的平均值。\n\n平均等待时间=\\frac{各个进程/作业等待时间之和}{进程/作业数}\n响应时间：从用户提交请求到首次产生响应所用的时间。\n\n\n2.2.3 调度的实现1.调度程序（调度器）\n用于调度和分派CPU 的组件称为调度程序，它通带由三部分组成\n\n\n排队器：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。\n分派器：依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。\n上下文切换器：在对处理机进行切换时，会发生两对上下文的切换操作\n第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；\n第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。\n\n\n\n2.调度的时机\n\n需要调度\n主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（比如等待IO）\n被动放弃：时间片用完；有更紧急的事情处理（I/O中断）；有更高优先级的进程进入就结队列\n\n\n不能调度\n处理中断的过程中\n进程在操作系统内核程序临界区中\n原子操作过程中\n\n\n\n\n临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。\n临界区：访问临界资源的那段代码。\n内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）\n\n3.进程调度方式\n\n非剥夺调度方式\n又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。\n实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统\n\n剥夺调度方式\n又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停在执行的进程，将处理机分配给更重要紧迫的那个进程。\n可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统\n\n\n4.进程切换\n\n上下文切换：切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态。\n\n对原来运行进程各种数据的保存\n对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一保存在进程控制块）\n\n\n上下文：某一时刻CPU寄存器和程序计数器的内容。\n\n\n\n  切换流程：\n\n挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。\n\n更新PCB信息。\n\n把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。\n\n选择另一个进程执行，并更新其PCB。\n\n跳转到新进程PCB中的程序计数器所指向的位置执行。\n\n恢复处理机上下文。\n\n\n\n上下文切换的消耗\n上下文切换需要消耗大量CPU时间，有些处理器有多个寄存器组，则切换只需改变指针。\n\n进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。\n\n\n上下文切换与模式切换\n\n模式切换是用户态和内核态之间的切换，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。\n上下文切换切换了进程，只能发生在内核态，它是多任务操作系统中的一个必需的特性。\n\n\n\n5.闲逛进程\n调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）\n特性：\n\n优先级最低；\n可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）\n能耗低\n\n\n闲逛进程不需要CPU之外的资源，它不会被阻塞。\n\n6.两种线程的调度\n\n用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。\n内核级线程调度。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。\n\n\n用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；\n内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。\n\n2.2.4 典型的调度算法先来先服务（FCFS）\n\n算法思想：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）\n算法规则：按照作业/进程到达的先后顺序进行服务\n用于作业/进程调度：\n用于作业调度时，考虑是哪作业先达后备队列；\n用于进程调度时，考虑的是哪个进程先到达就绪队列\n\n\n优缺点：\n优点：公平、算法实现简单\n缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对作（Eg：排队。）\n\n\n非抢占式的算法；不会导致饥饿\n\n\n短作业优先（SJF）\n\n算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间\n\n算法规则：最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）\n\n用于作业/进程调度\n\n即可用于作业调度，也可用于进程调度。\n用于进程调度时为”短进程优先”（SPF，Shortest Process First）\n\n\n优缺点\n\n优点：\n“最短的”平均等待时间、平均周转时间;\n\n在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少；\n\n\n“抢占式的短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”\n\n缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。\n\n\n\n抢占式的算法；会导致饥饿\n\nSJF和SPF是非抢占式的算法。但是也有抢占式的版本：最剩间优先算法（SRTN，Shortest Remaining Time Next）\n每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度\n\n\n\n\n高响应比优先（HRRN）\n\n算法思想：要综合考虑作业/进程的等待时间和要求服务的时间\n\n算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务\n\n响应比=\\frac{等待时间+要求服务时间}{要求服务时间}高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放CPU（常/常成，主动阻塞），需行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。\n\n用于作业/进程调度：即可用于作业调度，也可用于进程调度\n\n优缺点\n\n综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点）；\n要求服务时间相同时，等待时间长的优先（FCFS的优点）\n对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题\n\n\n非抢占式的算法；不会导致饥饿\n\n非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，计算响应比\n\n\n\n时间片轮转调度算法（RR）\n\n算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应\n\n算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。\n\n用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）\n\n优缺点\n\n优点：公平；响应快，适用于分时操作系统；\n缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。\n\n\n抢占式的算法；不会导致饥饿\n\n若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到\n\n\n\n优先级调度算法\n\n算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序\n\n算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程\n\n用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中\n\n优缺点\n\n优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度\n缺点：若源源不断地有高优先级进程到来，则可能导致饥饿\n\n\n抢占式/非抢占式的算法；会导致饥饿\n\n抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。\n\n\n优先级排序\n系统进程优先级高于用户进程\n前台进程优先级高于后台进程\n操作系统更偏好I/O型进程（或称I/O繁忙型进程）\n\n注：与I/O型进程相对的是计算型进程（或称CPU繁忙型程）\n\n\n优先级分类：根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。\n\n静态优先级：创建进程时确定，之后一直不变\n动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。\n\n\n就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置\n\n\n\n多级队列调度算法\n\n系统中按进程类型设置多个队列，进程创建成功后插入某个队列\n\n\n\n队列之间可采取固定优先级，或时间片划分\n\n固定优先级：高优先级空时低优先级进程才能被调度\n时间片划分：如三个队列分配时间50%、40%、10%\n\n\n各队列可采用不同的调度策略，如\n系统进程队列采用优先级调度、交互式队列采用RR、批处理队列采用FCFS\n\n\n多级反馈队列调度算法\n\n\n算法思想：对其他调度算法的折中权衡\n\n算法规则：\n\n1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大\n2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾\n3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片\n\n\n用于作业/进程调度：用于进程调度\n\n优缺点\n\n对各类型进程相对公平（FCFS的优点）；\n每个新到达的进程都可以很快就得到响应（RR优点）；\n短进程只用较少的时间就可完成（SPF优点）；\n不必实现估程运时间（避用户作假）；\n可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程\n\n\n拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级\n\n\n抢占式的算法；会导致饥饿\n\n在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。\n\n\n例：\n\n(2019年408第27题)系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10ms；就绪队列Q2采用短进程优先调度算法，系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的 CPU 时间分别为 30ms 和 20ms，则进程P1、P2在系统中的平均等待时间为( 15ms )。\n\n\n\n\nP1等待时间 = P1周转时间 - P1运行时间 = 50-30 = 20ms\nP2等待时间 = P2周转时间 - P2运行时间 = 30-20 = 10ms\nP1、P2在系统中的平均等待时间 = (P1等待时间+P2等待时间)/2 = 15ms\n\n2.2.4 操作系统之作业/进程调度算法（FCFS先来先服务、SJF短作业优先、HRRN高响应比优先）_llf算法-CSDN博客\n2.2.5 操作系统之调度算法（时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法）_操作系统时间调度表-CSDN博客\n\n\n\n\n\n先来先服务\n短作业优先\n高响应比优先\n时间片轮转\n多级反馈队列\n\n\n\n\n能否是可抢占\n否\n能\n能\n能\n队列内算法不一定\n\n\n能否是非抢占\n能\n能\n能\n否\n队列内算法不一定\n\n\n优点\n公平，实现简单\n平均等待时间最少，效率最高\n兼顾长短作业\n兼顾长短作业\n兼顾长短作业， 有较好的的响应时间， 可行性强\n\n\n缺点\n不利于短作业\n长作业会饥饿， 估计时间不易确定\n计算响应比的开销大\n平均等待时间较长， 上下文切换浪费时间\n无\n\n\n适用于\n无\n作业调度， 批处理系统\n无\n分时系统\n相当通用\n\n\n默认决策模式\n非抢占\n非抢占\n非抢占\n抢占\n抢占\n\n\n\n\n2.3 同步与互斥2.3.1 同步与互斥的基本概念临界资源：一次仅允许一个进程使用的资源\n\n类型：物理设备，如打印机等；可被进程共享的许多变量、数据等\n\n临界区：访问临界资源的那段代码。\n为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：\n\n1）进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。\n2）临界区。进程中访问临界资源的那段代码，又称临界段。\n3）退出区。将正在访问临界区的标志清除。\n4）剩余区。代码中的其余部分。\n\n123456do&#123;    entry section;\t\t\t//进入区    critical section;\t\t//临界区    exit section;\t\t\t//退出区    remainder section;\t\t//剩余区&#125;while(true)\n\n\n同步\n\n同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。\n读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。\n\n如何解决这种异步问题，就是“进程同步”所讨论的内容。\n互斥\n 互斥也称间接制约关系。当一个进程进入临界区使用临界资源，另一进程必须等待当占用临界资源的进程退出临界区后，另一进程才能访问此临界资源。\n遵循原则：\n\n空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；\n忙则等待。当已有进程进入临界区时，其他图进入临界区进必须等待\n有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）\n让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。\n\n2.3.2 实现临界区互斥的基本方法1.软件实现方法\n单标志法（违背“空闲让进”原则）\n两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。\n该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。\n\n若某个进程不再进入临界区，则另一个 进程也将无法进入临界区（违背”空闲让进”）。\n\n双标志法先检查（违背“忙则等待”原则）\n在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需等待：否则，进程才进入自己自己的临界区。\n\n设置一个布尔型数组flag[ ]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag设为true，之后开始访问临界区。\n\n\n\n优点：不用交替进入，可连续使用\n缺点：按序列①⑤②⑥执行时，会同时进入临界区（违背“忙则等待”），Pi进程和Pj进程可能同时进入临界区；检查和修改操作不能一次进行。\n\n双标志法后检查\n双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。\n\n\n缺点：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值设置为TRUE，并且同时检测对方的状态，发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。违背了“空闲让进”和“有限等待”产生饥饿\n\nPeterson算法\n结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。\n\n\n\n为了防止两个进程为进入临界区而无限期等待，又设置了变量turn，每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。\n进程在进入区要做的步骤： ① 主动争取 ② 主动谦让 ③ 检查对方是否也想使用，且最后一次是不是自己说了客气话\n存在问题：Peterson 算法用软件方法解决了进程互斥问题， 遵循 “空闲让进”、“忙则等待”、“有限等待” 三个原则，但是依然 未遵循 “让权等待” 的原则。\n\n软件方法总结\n\n\n\n\n\n单标志法\n双标志先检查\n双标志后检查\nPeterson 算法\n\n\n\n\n算法\n在进入区只做“检查”，不”上锁“ 在退出区把临界区的使用权转交给另一个进程 (相当于在退出区既给另一进程”解锁”，又给自己”上锁”）\n在进入区先”检查”后”上锁”，退出区”解锁“\n在进入区先”加锁”后”检查”，退出区”解锁”\n在进入区”主动争取一主动谦让一检查对方是否想进、已方是否谦让“\n\n\n问题\n不遵循”空闲让进”\n不遵循”忙则等待”\n不遵循”空闲让进、有限等待”，可能导致”饥饿”\n不遵循”让权等待”，会发生”忙等”\n\n\n\n\n2.硬件实现方法\n中断屏蔽方法\n当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单的方法是：禁止一切中断发生，或称之为屏蔽中断、关中断。\n\n硬件指令法\n\nTestAndSet指令\n简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令TSL指令是用硬件实现的。TS是原子操作，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。\n\n执行TSL指令时，它的内部运转逻辑：\n假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等\n假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。\n\n\n\n\n  相比软件实现方法，TSL 指令把 上锁和检查操作 用硬件的方式变成了一气呵成的 原子操作 。\n\n优点： 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞。适用于多处理机环境。\n缺点： 不满足 “让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致 忙等。\n\n\nSwap指令\n有的地方也叫Exchange指令，或简称XCHG指令。Swp指令是用硬件实现的，是原子操作，执行的过程不允许被中断，只能一气呵成。\n\nold是每个进程都要进行的一步，都必须将old=true\n因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。\n\n\n\n\n\n逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。Swap 指令优点缺点和TSL指令相同。\n\n\n硬件方法的优点\n适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。\n可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。\n\n\n硬件方法的缺点\n进程等待进入临界区时要耗费处理时间，不能实现让权等待。\n从等待进程中随机选择一个进入临界区，有进程可能一直选不上，从而导致“饥饿”现象。\n\n\n\n2.3.3 互斥锁 解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。acquire()和release()是原子操作，由硬件机制完成。\n 每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。\n1234567acquire()&#123;    while(!available);\t\t//忙等待    avilable = false;\t\t//获得锁&#125;release()&#123;    available = true;\t\t//释放锁&#125;\n\n优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低\n缺点：需忙等，进程时间片用完才下处理机，违反“让权等待”；不太适用于单处理机系统，忙等的过程中不可能解锁\n\n2.3.4 信号量 信号量机制是一种功能较强的机制,可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为”P操作”和”V操作”。\n 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。\n 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。\n整型信号量\n用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。wait(S)、signal(S)可描述为：\n\n\n与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作\n\nwait(S) 原语，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。\n存在的问题： 不满足 “让权等待” 原则，会发生 忙等。\n\n记录型信号量\n整型信号量存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。\n除了需要用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。\n\n\nwait：如果剩余资源数不够使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。\nsignal：释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。\nS.value的初值表示系统中某种资源的数目。\nP操作：\n对信号量S的一次P操作意味着进程请求一个单位的该资源，因此需要执行S.value-，表示资源数减1\n当S.value&lt;0时表示该类资源已分配完毕，因此进程应调用bock原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。\n可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。\n\n\nV操作：\n对信号量S的一次V操作意味进程释放一个单位的该资源，因此需要执行S.value.+，表示资源数加1，\n若加1后仍是S.value&lt;=0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）\n\n\n\n2.3.4 操作系统之信号量机制（整型信号量、记录型信号量P、V）_llf算法-CSDN博客\n\n例：某计算机系统中有1台打印机，则可在初始化信号量 S 时将 S.value 的值设为 1，队列 S.L 设置为空。\n\n① CPU 为 P0 服务，S.value —，值为 0，P0开始使用打印机。② CPU 为 P1 服务，S.value —，值为 -1，无资源执行 block 原语( wait原语 )。阻塞队列( P1 )，S.value = -1 说明有1个进程在等待资源。③ CPU 为 P2 服务，S.value —，值为 -2，无资源执行 block 原语。阻塞队列( P1→P2 )，S.value = -2 说明有2个进程在等待资源。④ CPU 为 P0 服务，S.value ++，S.value = -1 ≤ 0，说明有进程在等待该资源。因此应调用 wakeup 原语(signal原语)唤醒等待队列中的第一个进程P1，将释放资源给 P1，P1从阻塞态变为就绪态，等待被 CPU 服务(CPU顺序执行)。阻塞队列( P2 )⑤ CPU 为 P1 服务，P1 使用完打印机，S.value ++，S.value = 0，调用 wakeup 原语唤醒 P2。阻塞队列()。⑥ CPU 为 P2 服务， P2是用完打印机，S.value ++，S.value = 1。\n\n信号量机制实现进程互斥\n\n伪代码如下所示：\n设 S 为实现进程 P1、P2 互斥的信号量，由于只允许一个进程进入临界区，所以 S 的初值应设为 1。然后把临界区置于 P(S) 和 V(S) 之间，进入区之前申请资源（P操作），退出区之前释放资源（ V操作 ），即可实现两个进程对临界资源的互斥访问。\n\n\n操作：\n\n1.分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）\n2.设置互斥信号量mutex，初值为1\n3.在进入区P（mutex）一一申请资源\n4.在退出区V（mutex）一一释放资源\n\n\n注意\n\n对不同的临界资源需要设置不同的互斥信号量。\nP、V操作必须成对出现。缺少P（mutex）就不能保证临界资源的互斥访问。缺少V（mutex）会导致资源永不被释放，等待进程永不被唤醒。\n\n\n\n信号量机制实现进程同步\n\n程序\n\n\n\n\n步骤\n\n\n信号量机制实现前驱关系\n分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题\n\n问题：下图是一个前驱图，其中 S1, S2, S3, … ,S6 是进程 P1, P2, P3,…, P6 中的程序段，这些程序段要求按如下前驱图所示的顺序来执行：\n\n\n\n2.3.5 管程引入管程原因\n管程的引入让程序员写程序时不需要再关注复杂的PV操作，从而避免了传统信号量机制存在的很多问题。\n定义：由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。\n管程的组成\n\n局部于管程的共享数据结构说明\n对该数据结构进行操作的一组过程（函数）\n对局部于管程的共享数据设置初始值的语句\n管程的名字\n\n1234567891011121314151617181920monitor Demo&#123;//定义一个名称为&quot;Demo&quot;的管程    //定义共享数据结构，对应系统中的某种共享资源    共享数据结构 S;    //对共享数据结构初始化的语句    init_code()&#123;        S=5;\t\t//初始资源数等于5    &#125;    //过程1：申请一个资源    take_away()&#123;        对共享数据结构x的一系列处理;        s--;\t\t//可用资源-1        ...    &#125;    //过程2：归还一个资源    give_back()&#123;        对共享数据结构x的一系列处理;        s++;\t\t//可用资源+1        ...    &#125;&#125;\n管程的基本特征\n\n局部于管程的数据只能被局部于管程的过程所访问\n一个进程只有通过调用管程内的过程才能进入管程访问共享数据\n每次仅允许一个进程在管程内执行某个内部过程\n\n\n注：过程其实就是函数，如下面这个 People 类，People 是管程的名字，username 和 str 是局部于管程的共享数据结构，login 方法是该数据结构进行操作的过程。\n12345678910public class People&#123;\tprivate String username = &quot;admin&quot;; // 用户名\tprivate String str= &quot;123456&quot;; // 密码\t\tpublic void login()&#123;\t\tif(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(str))&#123;\t\t\tSystem.out.println(&quot;登录成功！&quot;);\t\t\t&#125;\t&#125;&#125;\n\n条件变量\n条件变量condition，是表示管程阻塞原因的变量。\n 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。\n\nx.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。\nx.signal：x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞的进程。\n\n12345678910111213monitor Demo&#123;    共享数据结构 S;    condition x；\t\t\t\t\t//定义一个条件变量x    init_code()&#123;...&#125;    take_away()&#123;        if(S&lt;0) x.wait();\t\t\t//资源不够，在条件变量x上阻塞等待        资源足够，分配资源，做一系列处理；    &#125;    give_back()&#123;        归还资源，做一系列相应处理;\t\tif(有进程在等待）x.signal();\t//唤醒一个阻塞进程    &#125;&#125;\n\n条件变量和信号量的比较：\n相似点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒。\n不同点：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。\n\n\n\n2.3.6 经典同步问题1.生产者-消费者问题\n\n问题描述\n系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）\n生产者、消费者共享一个初始为空、大小为n的缓冲区。\n\n只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。\n只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。\n\n缓冲区是临界资源，各进程必须互斥地访问。\n\n\n问题分析\n\n\n1.关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。\n同步关系：缓冲区没满，生产者生产；缓冲区没空，消费者消费。\n互斥关系：各进程互斥访问缓冲区。\n\n2.整理思路。根据各进程的操作流程确定P、V操作的大致顺序。\n\n\n\n\n\n3.设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）\n123semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问semaphore empty = n; //同步信号量，表示空闲缓冲区的数量semaphore full = 0;  //同步信号量，表示产品的数量，也即非空缓冲区的数量\n\n\n\n进程描述\n\n\n能否改变相邻P、V操作的顺序？\n不能，会发生死锁\n\n\n\n\n能否只设置一个同步信号量\n不能。原因在于：两个信号量 empty 和 full，其中 empty 用于制约生产者生产，full 用于制约消费者消费。如果只设置一个信号量，如 full，那么生产者会无限的生产，起不到制约作用。\n\n\n2.多生产者多消费者问题\n\n问题描述\n桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。\n\n问题分析\n\n1.关系分析\n同步关系：① 父亲将苹果放入盘子，女儿才能取苹果；     ② 母亲将句子放入盘子，儿子才能取橘子；     ③ 只有盘子为空，父亲或者母亲才能放水果。互斥关系：对缓冲区(盘子)的访问要互斥的进行。\n\n2.整理思路\n分析同步要以 事件 的角度分析，不要以 进程 的角度分析。\n\n3.信号量的设置\n1234semaphore mutex = 1;  //实现互斥访问盘子（缓冲区）semaphore apple = 0;  //盘子中有几个苹果semaphore orange = 0; //盘子中有几个橘子semaphore plate = 1;  //盘子中还可以放多少个水果\n\n\n\n进程描述\n实现方法\n\n\n  \n\n能否不用互斥信号量\n如果缓冲区大小为1，在任何时刻，apple、orange、plate 三个信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。  如果缓冲区大小大于1，数据可能存在相互覆盖的情况。如：父亲在向盘子放橘子的同时，母亲也可以往盘子里放橘子，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。  因此，当缓冲区大小等于1，有可能不设置互斥变量。当缓冲区大小大于1，必须设置互斥变量。是否不用设置互斥信号量主要观察，同一时刻信号量是否最多一个1，建议设置互斥信号量。\n但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。\n\n\n\n如果有两个盘子plate\n\n\n分析\n在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。\n如果从 单个进程的角度 来考虑的话，会有以下结论：\n\n① 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；\n② 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。\n\n这就意味着要 设置四个同步信号量 分别实现这 四个一前一后的关系，较为复杂。\n\n\n  若从 事件的角度 来考虑，我们可以把上述四对进程行为的前后关系抽象为 一对事件 的前后关系，即：盘子变空事件 → 放入水果事件。\n  \n\n总结:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。\n建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·实现互斥的P操作一定要在实现同步的P操作之后·，否则可能引起·“死锁”·。\n\n3.读者-写者问题\n\n问题描述\n有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：\n\n①允许多个读者可以同时对文件执行读操作\n②只允许一个写者往文件中写信息\n③任一写者在完成写操作之前不允许其他读者或写者工作\n④写者执行写操作前，应让已有的读者和写者全部退出\n\n\n\n\n问题分析\n\n两类进程：写进程、读进程\n互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题\n\n\n\n\n\n进程描述\n\n方案1\n方案设置 rw 和 mutex 两个信号量。rw 信号量 用于实现 读进程与写进程、写进程与写进程 对共享文件的互斥访问。mutex 信号量 用于保证对 count 变量的互斥访问。\n\n加mutex原因：\n比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。\n\n\n\n\n若没有设置 mutex 信号量，两个读进程并发执行到 if 条件且都满足，都会执行 P(rw)，会造成其中一个读进程阻塞的情况。设置 mutex 信号量，使得 count 信号量的检查和赋值操作一气呵成，保证了对 count 信号量访问的互斥性。\n\n\n\n **方案 1 存在的问题：** 只要有读进程还在读，写进程就要一直阻塞等待，可能 “饿死”。因此，这种算法中，读进程是优先的。\n\n方案2\n方案 2 是对方案 1 问题的修正，添加了 w 信号量，保证了 读写公平 。如：假设对共享文件的访问顺序是：读者1→读者2→ 写者1 → 读者3 ，读者 2 执行完后，写者 1 将会进行写文件，读者 3 进程将会被阻塞。待写者1写完文件后，读者 3 进行读写者 1 访问后的文件。\n\n算法 核心思想 在于设置了一个 计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，还需考虑 count 变量的互斥性。\n\n\n4.哲学家进餐问题\n\n问题描述\n一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。\n\n\n\n问题分析\n\n1.关系分析\n系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。\n\n2.整理思路\n哲学家进餐问题中 只有互斥关系，但与之前遇到的问题不同点在于，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的关键。\n\n3.信号量的设置\n定义互斥信号量数组 chopstick[5]={1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。此外，还需要设置 互斥信号量mutex，用以保证哲学家进程左右两支筷子都可用。\n\n\n\n\n\n进程描述\n算法保证，一个哲学家再拿到筷子拿到一半时被阻塞，也不会有别的哲学家尝试拿筷子，即至少有一个哲学家进程不阻塞。\n\n\n其他方案：① 对哲学家进程施加一些限制条件，如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。\n\n\n\n吸烟者问题\n\n问题描述\n假设一个系统有 三个抽烟者进程 和 一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。\n\n\n\n问题分析\n\n1.关系分析\n同步关系：① 桌上有组合一，第一个抽烟者取走东西     ② 桌上有组合二，第二个抽烟者取走东西     ③ 桌上有组合三，第三个抽烟者取走东西     ④ 抽烟者抽完发出完成信号，供应者将下一个组合放到桌上互斥关系：对缓冲区的访问要互斥的进行。\n\n2.整理思路\n\n\n注：由于缓冲区大小为1，任意时刻同步信号量和互斥信号量最多只有一个1，因此互斥信号量可以不设置。\n\n\n3.信号量的设置\n12345semaphore offer1 = 0; //桌上组合一的数量semaphore offer2 = 0; //桌上组合二的数量semaphore offer3 = 0; //桌上组合三的数量semaphore finish = 0; //抽烟是否完成int i = 0; //用于实现“三个抽烟者轮流抽烟”\n\n\n\n进程描述\n\n\n能否从进程角度思考？\n 不可以。    同多生产者多消费者问题，假设从进程角度思考，那么第一个抽烟者抽完后，供应者再将第一个组合放到桌上；第二个抽烟者抽完后，供应者再将第二个组合放到桌上；第三个抽烟者抽完后，供应者再将第三个组合放到桌上。这样相比于从事件考虑的一个一前一后的关系，多出了多个关系，并且较为复杂。因此要从事件的角度思考 PV 关系。\n\n\n2.4 死锁\n2.4.1 死锁的概念1.死锁的定义\n 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉这些进程都将无法向前推进。\n2.死锁、饥饿、死循环的区别\n\n共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外)\n\n区别：\n\n死锁：两个及以上进程间互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。\n\n饥饿：可能只有单个进程由于长期得不到想要的资源，某进程无法向前推进的现象。\n比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”\n\n死循环：某进程执行过程中一直跳不出某个循环的现象。是被管理者出现的问题。\n有时是因为程序逻辑bug导致的，有时是程序员故意设计的。\n\n\n\n\n3.死锁产生原因\n\n对系统资源的竞争\n各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。\n\n进程推进顺序非法\n请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。\n\n信号量的使用不当也会造成死锁\n如生产者-消费者问题中，如果实现互斥的P操柞在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）\n\n\n4.死锁产出的必要条件\n产生死锁 必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。\n\n互斥条件：只有对必须 互斥使用的资源的争抢 才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。\n不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。\n请求和保持条件：进程已经 保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。\n循环等待条件：存在一种进程资源的 循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。\n\n注：发生死锁时一定有循环等待，但是发生循环等待时未必死锁，即 循环等待是死锁的必要不充分条件。\n\n如果同类资源数大于1，则即使有循环等待，也未必发生死锁（如上图 Pn 可以同时请求 P1 或者 Pk 的资源，得到 Pk 资源后，不会发生死锁）。 但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。\n5.死锁处理策略\n\n死锁预防。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。\n避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。\n死锁的检测及解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。\n\n死锁的几种处理策略的比较见下表。\n\n\n\n\n\n资源分配策略\n各种可能模式\n主要优点\n主要缺点\n\n\n\n\n死锁预防\n保守，宁可资源闲置\n一次请求所有资源，资源剥夺，资源按序分配\n适用于突发式处理的进程，不必进行剥夺\n效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源\n\n\n死锁避免\n是“预防”和“检测”的折中（在运行时判断是否可能死锁）\n寻找可能的安全允许顺序\n不必进行剥夺\n必须知道将来的资源需求；进程不能被长时间阻塞\n\n\n死锁检测\n宽松，只要允许就分配资源\n定期检查死锁是否已经发生\n不延长进程初始化时间，允许对死锁进行现场处理\n通过剥夺解除死锁，造成损失\n\n\n\n\n2.4.2 死锁预防死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁不会发生。\n1.破坏互斥条件\n把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。如: SPOOLing技术。使用 SPOOLing 技术可以把 独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…\n2.破坏不剥夺条件\n\n提供两种方案：\n申请资源得不到时，主动释放所占有资源，需要再申请。\n申请资源被其他进程占用时，由 OS 协助剥夺。\n\n\n策略的缺点：\n实现起来比较复杂；\n释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU；\n反复地申请和释放资源会增加系统开销，降低系统吞吐量；\n方案 ① 可能导致进程饥饿。\n\n\n\n3.破坏请求和保持条件\n采用 静态分配方法，即进程 在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。\n策略的缺点： 进程在整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有 可能导致某些进程饥饿。\n4.破坏循环等待条件\n采用 顺序资源分配法。首先给系统中的资源编号，要求进程只能按编号递增顺序请求资源。\n原理分析： 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象(类比拓扑排序)。\n策略的缺点： 不方便增加新的设备，因为可能需要重新分配所有的编号；进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；必须按规定次序申请资源，用户编程麻烦。\n2.4.3 死锁避免 死锁的避免是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。\n系统安全状态\n\n安全序列：是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。\n安全状态：系统如果存在安全序列，则处于安全状态，安全状态一定不发生死锁。安全序列可能有多个。\n不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）\n\n安全序列的计算方法：\n例子：假设系统中有三个进程p1 , p2 , p3 ，一共有12台磁带机。进程p1共需要10台，进程p2共需要4台，进程p3共需要9台。假设在某个时刻，进程p1 , p2 , p3已分别获得5台、2台和2台，还有3台没分配。\n\n\n\n\n进程\n最大需求\n已分配\n可用\n\n\n\n\np1\n10\n5\n3\n\n\np2\n4\n2\n\n\n\np3\n9\n2\n\n\n\n\n系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统变可避免进入死锁。\n分配2个资源给p2，满足p 2的最大需求，待p2释放所持资源，此时空闲资源共计5个单位；\n分配5个资源给p1，满足p 1的最大需求，待p1释放所持资源，此时空闲资源共计10个单位；\n分配7个资源给p3，满足p 3的最大需求，待p3释放所持资源，此时空闲资源共计12个单位；\n最后得到安全序列p2 , p1 , p3这种情况下不会发生死锁。\n但是如果先给p3分配一个资源，此时系统进入不安全状态。之后再将剩下的两个资源分配给p2，等待p2进程运行完毕，回收其资源，此时空闲资源共有4个单位。此时4个单元无法满足p1或者p3 ，则此时无法再找到一个安全序列，陷入僵局，最终导致死锁。\n并不是所有的不安全状态都是死锁状态，但是当系统进入不安全状态的时候，就有可能出现死锁情况。反之，如果系统处于安全状态，系统便可以找到安全序列，避免死锁状态。\n银行家算法\n核心思想： 在分配资源前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否答应资源分配请求，从而使得系统避免死锁。\n\n数据结构描述：\n(1) 可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 Available[j] = K，则表示系统中现Rj类资源K个。\n\n\n  (2) 最大需求矩阵Max。这是一个n x m的矩阵，它定义了系统中n个进程中的每个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj 类资源的最大数目为K。\n  分配矩阵 Allocation。这也是一个n x m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 Allocation[i,jl = K，则表示进程i当前己分得Rj类资源的数目为K。\n  (4) 需求矩阵Need.这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个方能完成其任务。  上述三个矩阵间存在下述关系:  　　　　　　　　　　　　　　Need[i,j] = Max[i,j] - allocation[i, j]\n\n银行家算法描述\n设 Request；是进程Pi的请求向量，如果 Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査:(1) 如果 Requesti[j] ≤ Need[i,j]便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。\n\n\n  (2) 如果 Requesti[j] ≤ Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。\n  (3) 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值  　　　　Available[j] = Available[j] - Requesti[j];  　　　　Allocation[i,j] = Allocation[i,j] + Requesti[j];  　　　　Need[i,j] = Need[i,j] - Requesti[j];\n  (4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。\n  注：安全性算法是银行家算法的核心。\n\n安全性算法描述\n(1) 设置两个向量:①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work = Available；② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[i] = false；当有足够资源分配给进程时，再令Finish[i] = true。\n\n\n  (2) 从进程集合中找到一个能满足下述条件的进程  　　　　① Finish[i] = false;  　　　　② Need[i,j] ≤ Work[j];  若找到，执行步骤(3)，否则，执行步骤(4)。\n  (3)当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:  　　　　Work[j] = Work[j] + Allocation[i,j];  　　　　Finish[i] = true;  　　　　go to step 2;(goto语句不推荐使用 _ )\n  (4)如果所有进程的 Finish[i] =true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\n  2.4操作系统之死锁详解(预防、避免、检测、解除)+思维导图_llf算法-CSDN博客\n王道书解法：\n\n\n2.4.4 死锁检测和解除 如果系统既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供死锁检测和解除的手段。\n资源分配图\n系统死锁可利用 资源分配图 来描述。圆代表一个进程，框代表一类资源，框中一个圆代表一类资源中的一个资源。\n\n\n两种结点：\n进程结点：对应一个进程\n资源结点：对应一类资源，一类资源可能有多个\n\n\n两种边：\n请求边：表示进程想申请几个资源（每条边代表一个）\n分配边：表示已经为进程分配了几个资源（每条边代表一个）\n\n\n\n死锁定理\n简化资源分配图可检测系统状态是否为死锁状态。简化方法如下：\n① 在资源分配图中，找出 既不阻塞又不是孤点的进程 Pi。\n\n不阻塞：表示进程申请的资源可以被满足，如 P1 进程。由于 R2 资源除分配给 P2 进程一个资源外，还剩有一个资源，因此 P1 进程申请的 R2 资源可以被满足。相反，P2 进程申请 R1 资源则不会被满足，由于 R1 资源全部被分配完。\n不是孤点：表示与该进程节点至少一个边相连。\n\n② 消去进程所有的请求边和分配边，使之成为孤点。\n重复以上步骤，若能消去图中所有的边，则称该图是可完全简化的。\n\n注：并不是系统中所有的进程都是死锁状态，用死锁检测算法 化简资源分配图后，还连着边的那些进程就是死锁进程。\n\n死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁\n死锁解除\n一旦检测出死锁的发生，就应该立即解除死锁。解除死锁的主要方法有：\n\n资源剥夺法\n挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是 应防止被挂起的进程长时间得不到资源而饥饿。\n\n撤销进程法（或称终止进程法）\n强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。撤销的原则可以按进程优先级和撤销进程代价的高低进行。\n\n进程回退法\n让一个或多个死锁进程回退到足以避免死锁的地步。进程回退时，自愿释放资源而非剥夺。这就要求系统要记录进程的历史信息，设置还原点。\n\n\n\n注：撤销进程法中参考的优先级，应考虑：进程优先级、已执行多长时间、还要多久能完成、进程已经使用了多少资源、进程是交互式的还是批处理式的等因素。\n\n三、内存管理3.1 内存管理概念3.1.1 内存管理的基本原理和要求1.内存管理的概念\n虽然计算机技术飞速发展，内存容量也在不断扩大，但仍然不可能将所有用户进程和系统所需的全部程序与数据放入内存，因此操作系统对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。\n内存空间的主要功能有：\n\n内存空间的分配与回收：OS 要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲；当进程运行结束之后，如何将进程占用的内存空间回收。\n内存空间的扩充：OS 利用虚拟内存技术或自动覆盖技术使得系统运行很大的程序，从逻辑上扩充内存。\n地址转换：为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而 逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，其中地址重定位有三种方式。\n内存保护：保证各进程在各自存储空间内运行，互不干扰。\n\n2.程序执行过程\n 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：\n\n编译：由编译程序将用户源代码编译成若干目标模块，编译就是把高级语言翻译为机器语言。\n链接：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。\n装入：由装入程序将装入模块装入内存运行。\n\n\n\n 编译后，每个目标模块都是从 0 号单元开始编址，这称为该目标模块的 逻辑地址 (或相对地址)。当链接程序将各个模块连接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编制的 逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到内存的不同位置。  物理地址空间 是指内存中物理单元的集合，它是地址转换的最终地址。进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址(动态重定位是地址转换推迟到程序真正要执行时才进行)，这个过程称为 地址重定位。\n\n3.程序的链接\n\n静态链接\n在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。\n\n\n装入时动态链接\n将各 目标模块装入内存时，边装入边链接的链接方式。\n\n\n运行时动态链接\n在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n\n\n4.程序的装入\n\n绝对装入\n在编译与链接后，得到的装入模块指定 直接使用了绝对地址。\n\n\n\n\n可重定位装入\n装入时对地址进行重定位，即将逻辑地址变换为物理地址，地址变换是在装入时一次完成的。\n\n静态重定位的特点： 在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。\n\n\n\n动态运行时装入\n装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址(装入时依然保持使用逻辑地址)，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。\n\n\n\n  \n  \n  动态重定位特点： 可以将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间；采用动态重定位时允许程序在内存中发生移动。\n\n注：链接的作用是形成了完整的装入模块与逻辑地址，但逻辑地址到物理地址的转换过程是重定位，而不是装入。\n\n5.内存映像\n 不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素：\n\n代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。\n数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。\n进程控制块（PCB）：存放在系统区。操作系统通过PCB来控制和管理进程。\n堆：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。\n栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。\n\n\n代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。\n当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。\n用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。\n\n\n 上图是一个进程在内存中的映像。\n\n其中，共享库用来存放进程用到的共享函数库代码，如printf函数等。\n在只读代码段中，.iit是程序初始化时调用的_init函数；.text是用户程序的机器代码；.rodata是只读数据。\n在读/写数据段中，.data是已初始化的全局变量和静态变量；.bss是未初始化及所有初始化为0的全局变量和静态变量。\n\n6.内存保护\n确保每个进程都有一个单独的内存空间。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：\n\n在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。\n\n采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。\n重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示。\n\n\n重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址；\n界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。\n\n 加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。\n\n\n7.内存共享\n并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。\n可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。\n在实际运行时，每个进程有自己的私有数据段，可以更改自己私有的数据区数据，不可改变共享的代码。\n\n例：考虑一个可以同时容纳40个用户的多用户系统，他们同时执行一个文本编辑程序，若该程序有160KB代码区和40KB数据区，则共需8000KB的内存空间来支持40个用户。如果160KB代码是可分享的纯代码，则不论是在分页系统中还是在分段系统中，整个系统只需保留一份副本即可，此时所需的内存空间仅为40KB×40+160KB=1760KB。\n对于分页系统，假设页面大小为4KB，则代码区占用40个页面、数据区占用10个页面。为实现代码共享，应在每个进程的页表中都建立40个页表项，它们都指向共享代码区的物理页号。此外，每个进程还要为自己的数据区建立10个页表项，指向私有数据区的物理页号。\n对于分段系统，由于是以段为分配单位的，不管该段有多大，都只需为该段设置一个段表项（指向共享代码段始址，以及段长160KB）。由此可见，段的共享非常简单易行。\n\n8.内存分配与回收\n在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。\n为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式一一页式存储管理。\n引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。\n3.1.2 覆盖与交换覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。\n覆盖\n\n基本思想：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个\n固定区\n和若干\n覆盖区\n\n\n\n将经常活跃的部分放在固定区，其余部分按调用关系分段。\n首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。\n\n\n特点：\n\n打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行；\n内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存；\n覆盖技术对用户和程序员不透明。\n\n\n\n交换\n\n基本思想：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。\n交换过程：例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。\n问题：\n交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。\n为了有效使用CPU，需要使每个进程的执行时间比交换时间长。\n若换出进程，则必须确保该进程完全处于空闲状态。\n交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。\n交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。\n普通的交换使用不多，但交换策略的某些变体在许多系统（如UNX）中仍发挥作用。\n\n\n\n区别\n交换技术主要在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。\n3.1.3 连续分配管理方式连续分配方式是指为一个用户程序分配一个连续的内存空间，包括单一连续分配、固定分区分配和动态分区分配。\n单一连续分配\n在单一连续分配方式中，内存被分为 系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。\n\n优点： 实现简单；无外部碎片；可以采用覆盖技术扩充内存；无需采取内存保护，因为内存中永远只有一道程序。\n缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。\n\n内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。\n外部碎片：是指内存中的某些空闲分区由于太小而难以利用。\n\n固定分区分配\n固定分区分配是最简单的一种多道程序存储管理方式，它将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。当有空闲分区时，便可从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。划分分区有两种方法：\n\n分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。\n分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区，增加了灵活性。\n\n\n 为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配），如下图所示。\n\n\n分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为“已分配”；若找不到这样的分区，则拒绝分配。\n回收内存时，只需将对应表项的状态置为“未分配”即可。\n\n优点： 实现简单，无外部碎片。\n缺点： 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。\n动态分区分配\n动态分区分配 又称为 可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统分区的大小和数目是可变的。\n\n例：如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。\n开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩4MB，进程4无法装入。\n在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。\n之后CPU又出现空闲，需要换入进程2，而主存无法容纳进程2，操作系统就换出进程1，换入进程2。\n\n\n紧凑技术：动态分区在开始时是很好的，但随着时间的推移，内存中会产生越来越多的外部碎片。需要通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。\n 在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：\n\n首次适应（FirstFit）算法\n\n算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n如何实现：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。\n算法简单，最好最快，回收分区后一般不需要对空闲分区队列重新排序\n\n\n最佳适应（BestFit）算法\n\n算法思想：优先使用更小的分区，以保留更多大分区。\n如何实现：空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。\n缺点：产生大量小的、难以利用的外部碎片\n\n\n最坏适应（WorstFit）算法\n（最大适应算法）\n\n算法思想：优先使用更大的分区，以防止产生太小的不可用的碎片。\n如何实现：空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。\n缺点：如果之后有“大进程”到达，无足够大连续内存空间分配。\n\n\n邻近适应（NextFit）算法\n（循环首次适应算法）\n\n算法思想：由首次适应演变而来，每次从上次查找结束位置开始查找。\n如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n缺点：导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。\n\n\n\n\n\n\n\n算法\n算法思想\n分区排列顺序\n优点\n缺点\n\n\n\n\n首次适应\n从头到尾找适合的分区\n空闲分区以地址递增次序排列\n性能最好 算法开销小\n\n\n\n最佳适应\n优先使用更小的分区\n空闲分区以容量递增次序排列\n保留更大分区\n产生大量碎小的外部碎片；算法开销大\n\n\n最坏适应\n优先使用更大的分区\n空闲分区以容量递减次序排列\n减少难以利用的碎片\n大分区容易被用完；算法开销大\n\n\n邻近适应\n每次从上次查找结束位置开始查找\n空闲分区以地址递增次序排列（可排列成循环链表)\n空闲分区有相同概率被使用，算法开销小\n使高地址大分区也被用完\n\n\n\n\n\n\n注：动态分区分配没有内部碎片，但是有外部碎片。\n\n\n分区的分配与回收\n回收内存分区时，有可能遇到四种情况：\n\n① 回收区的后面有一个相邻的空闲分区。\n② 回收区的前面有一个相邻的空闲分区。\n③ 回收区的前、后各有一个相邻的空闲分区。\n④ 回收区的前、后都没有相邻的空闲分区。\n\n无论那种情况，都要遵循相邻的空闲分区要合并的原则。\n\n\n3.1.4 基本分页存储管理 固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。为了避免碎片的产出，引出了分页的思想。​ 分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。\n 分页管理与固定分区类似，不会产生外部碎片；进程运行按块申请主存空间，只会在最后一块有内部碎片，每个进程平均只有半个块的内部碎片（页内碎片）。\n基本概念\n\n页面和页面大小\n\n进程中的块称为页或页面（Page)，\n内存中的块称为页框或页帧（Page Frame)\n外存也以同样的单位进行划分，直接称为块或盘块（Block)。\n\n进程在执行时需要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。\n\n\n\n将内存空间分为一个个大小相等的分区，每个分区就是一个页框 。每个页框有一个编号，即 页框号，页框号 从 0 开始。\n将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 页或页面。每个页面也有一个编号，即 页号，页号也是 从 0 开始。\n\n页框=页帧=内存块=物理块=物理页面\n\n为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，\n\n页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；\n页面过大又会使页内碎片增多，降低内存的利用率。\n\n\n地址结构\n 地址结构决定了虚拟内存的寻址空间有多大。\n分页存储管理的 逻辑地址结构 如下所示：\n\n 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。\n 在上图所示的例子中，地址长度为 32 位，其中 0 ~ 11位 为页内偏移量(或称页内地址)，即每页大小为 4KB；12~31 位为页号，进程地址空间最多允许 220 页。\n\n页表\n为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张 页表。页表通常存在 PCB (进程控制块，在操作系统的内核地址空间)中。页表记录进程 页面 和实际存放的 内存块 之间的 映射关系。\n\n①一个进程对应一张页表。\n②进程的每个页面对应一个页表项。\n③每个页表项由页号和块号组成。\n④每个页表项的长度是相同的。\n\n\n例：假设某系统物理内存大小为 4 GB，页面大小为 4 KB，则每个页表项至少应该为多少字节？\n\n内存块大小=页面大小=4KB=212B\n4GB的内存总共会被分为232／212=220个内存块\n内存块号的范围应该是0～220-1\n内存块号至少要用20 bit来表示\n至少要用3B来表示块号（3＊8=24 bit＞20bit）\n\n页表项在内存中是连续存放，因此页号是可以隐藏的，不占内存空间，页表项占 3 个字节。\n\n注：如果未特别强调，默认计算机按字节编址。\n\n地址转换\n分页存储特点： 虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。\n页号 = 逻辑地址 / 页面长度页内偏移量 = 逻辑地址 % 页面长度\n如果要访问逻辑地址 A 的物理块，则\n\n确定逻辑地址 A 对应的页号 P\n找到 P 号页面在内存中的起始地址（需要查页表）\n确定逻辑地址 A 的页内偏移量 W\n\n\n\n基本地址变换机构\n基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。变换机构如下图所示。\n\n通常会在系统中设置一个 页表寄存器(PTR)，存放 页表在内存中的起始地址 F 和页表长度 M。进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n\n设页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下：\n\n\n计算页号P和页内偏移量W\n如果用十进制数手算，则\n\nP=A/L，W=A%L但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量\n\n判断页号是否越界\n比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。\n注意：页号是从0开始的，而页表长度至少是1，因此P=M时也会越界\n\n查页表，找页号对应的页表项，确定内存块号\n\n页表中页号P对应的页表项地址=页表起始地址F+页号P∗页表项长度取出该页表项内容b，即为内存块号。\n\n注意区分页表项长度、页表长度、页面大小的区别。\n页表长度指的是这个页表中总共有几个页表项，即总共有几个页；\n页表项长度指的是每个页表项占多大的存储空间；\n页面大小指的是一个页面占多大的存储空间\n\n\n用内存块号和偏移量得到物理地址\n计算$E=b*L+W$，用得到的物理地址E去访存。\n如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了\n\n访问目标内存单元\n\n\n在分页存储管理（页式管理）的系统中，页是信息的物理单位，分页完全是系统行为，因此 页的大小由系统决定，逻辑地址在计算机的视角很好确定。所以，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。\n\n\n具有快表的地址变换机构\n快表，又称联想寄存器(TLB)，是一种 访问速度比内存快很多的高速缓存器，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。\n\n\n注：TLB 不是内存；快表与 Cache(高速缓冲器) 的区别在于，块表中只有页表项的副本，而普通 Cache 中可能有其他各种数据的副本，可以把快表理解为一种特殊的 Cache。\n\n\n设某进程执行过程中要访问 (0,4) 这个逻辑地址，访问过程如下：\n\n\nCPU 给出逻辑地址，由硬件进行地址转换，将页号与快表中的所有页号进行比较。\n如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表命中，存取数据仅一次访存。\n如果没有找到匹配的页号，则需要访问内存中的页表。找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表未命中，存取数据需两次访存。\n\n\n\n注：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定算法对旧的页表项进行替换（局部性原理）。\n两级页表\n两级页表的分配管理方式属于基本分页存储管理范畴，其用于解决页表项占据连续页框的问题。\n\n单级页表存在的问题\n问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。\n解决：可建立两级页表，一级页表为页目录表，二级页表离散存储。\n问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。\n解决：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存\n\n两级页表的原理、地址结构\n二级页表实际上是在原有页表结构上再加上一层页表，如下图所示。\n\n 建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。\n\n\n例：某系统按字节寻址，支持 30 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B，试问逻辑地址的结构。\n页面大小为4KB=212B，则页内偏移量要用12位表示。\n30-12=18，则顷号用18位表示，即进程最多有218个页面，一共需要218个页表项来记录这些页面与物理块的映射关系，且页号范围是：0~218-1。\n页表项长度是4B，一个内存块（页框）最多存储4K/4=212/4=210个页表项。\n218个页表项则需要218/210=28个内存块才能存储。\n即需要专门给进程分配28=256个连续的物理块（页框）来存放它的页表。\n为避免连续占用内存块问题，可以设置28=256个二级页表，并用一级页表来记录这些二级页表，因此一级页号占8位。\n\n\n地址变换\n例： 将逻辑地址 (00000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。\n\n首先，按照地址结构将逻辑地址拆分成三部分\n\n从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置。\n根据二级页号查二级页表，找到最终想访问的内存块号。\n结合页内偏移量得到物理地址。\n\n最终要访问的内存块号为 4，该内存块的起始地址为 4*4096 = 16384 页内偏移量为 4095。\n最终的物理地址为：16384 + 4095= 20479。\n\n两次页表，若采用“快表”，需要3次访存。\n\n第一次：访问页目录表。\n第二次：访问内存中的二级页表。\n第三次：访问目标内存单元。\n\n\n\n多级页表\n若分为两级页表后，页表依然很长，则可以采用更多级页表。并且，若采用多级页表机制，则各级页表的大小不能超过一个页面。\n\n例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用 (   ) 级页表，页内偏移量为 (   ) 位？\n\n页面大小=4KB=212B，按字节编址，因此页内偏移量为12位。\n页号=40-12=28位\n页面大小=212B，页表项大小=4B，则每个页面可存放212/4=210个页表项。\n因此，各级页表最多包含210个页表项，需要10位二进制位才能映射到210个页表项。\n因此每一级的页表对应页号应为10位。总共28位的页号至少要分为3级。\n\n此外，若未用“快表”，N 级页表机制，需要 N+1 次访问内存。\n\n\n3.1.5 基本分段式存储管理 分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。\n 分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。\n分段\n段式管理方式按照用户进程中的自然段划分逻辑空间。\n\n\n例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间。\n\n段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。\n其逻辑地址由段号S与段内偏移量W两部分组成，如下图所示分段系统中的逻辑地址结构。\n\n其中，段号为16位，段内偏移量为16位，因此一个作业最多有216=65536段，最大段长为64KB。\n\n在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。\n\n段表\n程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称段表。\n\n段表用于实现从逻辑段到物理内存区的映射。\n特点：\n\n① 每个段对应一个段表项，其中 记录了该段在内存中的起始位置（又称“基址”）和段的长度。\n② 各个段表项的长度是相同的。\n③ 由于段表项长度相同，在内存中是连续存放，因此段号可以是隐含的，不占存储空间。\n④ 段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。\n\n地址变换机构\n 分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：\n\n\n① 根据逻辑地址得到段号，段内地址\n从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。\n\n② 判断段号是否越界\n比较段号S和段表长度M，若 $段号S≥段表长度M$ ，则产生越界中断，否则继续执行。\n\n③ 查询段表，找到对应段表项\n段表中段号S对应的 $段表项地址=段表始址F+段号S×段表项长度$ 。\n\n④ 检查段内地址是否超过段长\n取出该段表项的前几位得到段长C。若$段内偏移量W≥段长C$，则产生越界中断，否则继续执行。\n\n⑤ 计算得到物理地址\n取出段表项中该段的始址b，计算 $物理地址E=段基址b+偏移量W$ ，得到物理地址E。\n\n⑥ 访问目标内存单元\n用得到的物理地址E去访问内存。\n\n\n段的共享与保护\n\n共享\n在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。\n不能修改的代码称为纯代码或可重入代码（它不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。\n\n保护\n分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。\n\n存取控制保护：指在段表的每个表项中，设置“存取控制”字段，规定对该段的访问方式。\n地址越界保护：指在进行存储访问时，要检查逻辑地址是否超出了进程的地址空间。\n\n\n\n分段、分页管理的对比\n\n\n\n\n存储信息\n地址空间\n信息保护\n访存次数\n\n\n\n\n\n分页管理\n页是信息的物理单位 对用户透明 系统行为\n一维 记忆符()\n不易\n分页(单级页表)需两次访问 页表+目标内存单元\n\n\n分段管理\n段是信息的逻辑单位 对用户可见 用户需求\n二维 段名+段内地址([D]\\\n)\n容易 纯代码\n分段需两次访问 段表+目标内存单元\n\n\n\n\n\n3.1.6 段页式管理段页式管理结构\n 分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。\n 段页式存储管理方式，将作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每个段分成若干大小固定的页，内存空间分为大小一个个大小相等的分区。如下图所示。\n\n 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。如下图所示。\n\n 段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。\n 在一个进程中，段表只有一个，而页表可能有多个。\n\n例：如下图所示的段页式格式，\n\n\n段号16位，因此进程中最多有216=64K个段。\n页号4位，因此每个段最多有24=16页。\n页内偏移量有12位，因此每个内存块大小为212=2KB\n\n\n分段对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段分页对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此，段页式管理的地址结构是二维的。\n地址转换\n 在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页号，最后形成物理地址。\n\n 如下图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。\n\n\n根据逻辑地址得到段号、页号、页内偏移量\n\n判断段号是否越界若S≥M，则产生越界中断，否则继续执行\n\n查询段表找到对应的段表项，段表项的存放地址为\n\nF+S×段表顶长度\n检查页号是香越界，若页号≥页表长度，则发生越界中断，否则继续执行\n\n根据页表存放块号、页号查询页表找到对应页表项\n\n根据内存块号页内偏移量得到最终的物理地址\n\n访问目标内存单元\n\n\n3.2 虚拟内存管理3.2.1 虚拟内存的基本概念传统存储管理方式的特征\n\n传统存储管理方式\n连续分配\n单一连续分配\n固定分区分配\n动态分区分配\n\n\n非连续分配\n基本分页存储管理\n基本分段存储管理\n基本段页式存储管理\n\n\n\n\n\n特征：\n\n一次性\n作业必须一次性全部装入内存后，才能开始运行\n这会导致两种情况：\n\n当作业很大而不能全部被装入内存时，将使该作业无法运行；\n当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。\n\n\n驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待IO而被阻塞，可能处于长期等待状态。\n\n\n由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。\n局部性原理\n快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。\n\n时间局部性。\n程序中的某条指令一且执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。\n\n空间局部性。\n一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式聚存储的。\n\n\n虚拟存储器的定义和特征\n程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。\n\n多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。\n对换性：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。\n虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。\n\n虚拟内存技术的实现\n虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。\n访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）\n内存空间不够时，将内存中暂时用不到的信息换出到外存（页面置换功能）\n\n虚拟内存的实现方式\n\n请求分页存储管理\n请求分段存储管理\n请求段页式存储管理\n\n\n所需要的\n硬件支持\n\n一定容量的内存和外存。\n页表机制（或段表机制），作为主要的数据结构。\n中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。\n地址变换机构，逻辑地址到物理地址的变换。\n\n\n\n3.2.2 请求分页管理方式请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。\n页表机制\n 请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况。因此在请求页表项中增加了 4个字段，如下图所示。\n\n\n状态位P：用于指示该页是否已调入内存，供程序访问时参考。\n访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。\n修改位M：标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。\n外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。\n\n缺页中断机构\n 在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。\n\n缺页中断执行过程\n先将缺页的进程阻塞（调页完成唤醒)，\n若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，\n若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。\n\n\n缺页中断和一般中断的区别：\n在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常。\n一条指令在执行期间，可能产生多次缺页中断。\n\n\n\n地址变换机构\n 请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的，如产生和处理缺页中断，及从内存中换出一页的功能等等。\n\n新增步骤1：请求调页（查到页表项时进行判断）\n新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行)\n新增步骤3：需要修改请求页表中新增的表项\n\n请求分页管理的地址变换过程，如下图所示，红框部分为新增步骤：\n\n\n只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。\n和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。\n需要用某种“页面置换算法”来决定一个换出页面（下节内容）\n换入/换出页面都需要启动慢速的I/O操作，可见，如果换入换出太频繁，会有很大的开销。\n页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。\n\n3.2.3 页框分配驻留集大小\n给一个进程分配的物理页框的集合就是这个进程的驻留集。\n\n分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率。\n若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高。\n若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。\n\n内存分配策略\n 在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。\n\n固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变\n可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变\n局部置换：发生缺页时只能选进程自己的物理块进行置换。\n全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。\n\n\n固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变\n局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出\n\n三种组合方案：\n\n固定分配局部置换\n它为每个进程分配一定数目的物理块，在整个运行期间都不改变。\n若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。\n\n可变分配全局置换\n为系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列。\n当某进程发生缺页时，系统从空闲物理块队列中取出物理块分配给该进程，井将欲调入的页装入其中。\n\n可变分配局部置换\n它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出动态变换，频繁缺页，分配物理块，缺页率低，减少物理块\n\n\n物理块调入算法\n采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法。\n\n平均分配算法，将系统中所有可供分配的物理块平均分配给各个进程。\n按比例分配算法，根据进程的大小按比例分配物理块。\n优先权分配算法，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程；一部分则根据优先权分配。\n\n调入页面的时机\n为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：\n\n预调页策略：将预计在不久后便会被访问的页面预先调入内存；主要用于进程的首次调入，由程序员指出应先调入哪些页。\n请求调页策略：进程在运行中需要访问的页面不再内存而提出请求，由系统将所需页面调入内存。每次仅调入一页，增加了磁盘I/O开销。\n\n从何处调入页面\n 请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。\n 对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘IO速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：\n\n系统拥有足够的对换区空间\n可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。\n\n系统缺少足够的对换区空间\n凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。\n\nUNIX方式\n运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。\n\n\n如何调入页面\n\n当进程所访问的页面不在内存中时（存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。\n\n该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。\n\n如果内存已满，则先按某种置换算法从内存中选出一页准备换出；\n\n如果该页未被修改过（修改位为0)，则无须将该页写回磁盘；\n如果该页已被修改（修改位为1)，则必须将该页写回磁盘，\n\n然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。\n\n调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。\n\n\n3.2.4 页面置换算法 进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，选择调出页面的算法就称为页面置换算法。\n最佳置换算法（OPT）\n 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。\n\n但由于人们目前无法预知进程在内存下的页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。\n先进先出置换算法（FIFO）\n优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。\n\n该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。\n\nBelady异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。\n只有FIFO算法回产生Belady异常，算法性能差。\n该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。\n\n\n最近最久未使用置换算法（LRU）\n 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。\n\n 该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。\n 该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。\n时钟置换算法（CLOCK）/最近未用算法（NRU）\n简单的CLOCK算法实现方法：\n\n为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。\n当某页被访问时，其访问位置为1。\n当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，\n若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）\n\n\n改进型的时钟置换算法\n\n简单时钟问题：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。\n因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。\n修改位=0，表示页面没有被修改过：修改位=1，表示页面被修改过。\n\n算法规则：将所有可能被置换的页面排成一个循环队列，用（访问位A，修改位M）表示各页面状态。\n\n替换帧优先级：\n\n1类A=0，M=0：最近未被访问且未被修改，是最佳淘汰页。\n2类A=0，M=1：最近未被访问，但已被修改，不是很好的淘汰页。\n3类A=1，M=0：最近已被访问，但未被修改，可能再被访问。\n4类A=1，M=1：最近已被访问且已被修改，可能再被访问。\n\n\n\n第一轮：第一优先级——最近设访问，且没修改的页面\n从当前位置开始扫描到第一个(0，0)的帧用于替换。本轮扫描不修改任何标志位\n\n第二轮：第二优先级——最近没访问，但修改过的页面\n若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0\n\n第三轮：第三优先级——最近访问过，但没修改的页面\n若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位\n\n第四轮：第四优先级——最近访问过，且修改过的页面\n若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。\n\n\n由于第二轮己将所有帧的访问位设为0，因此经过第三轮、第四轮扫描定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。\n\n性能：算法开销较小，性能也不错\n\n\n3.2.5 抖动和工作集抖动\n\n定义：抖动，又称颠簸，指在页面置换过程中，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存。\n抖动发生的原因：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。\n抖动的危害：\n使得在系统中排队等待页面调入/调出的进程数目增加。\n对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入/换出，而几乎不能再去做任何有效的工作，\n进而导致发生处理机的利用率急剧下降并趋于零的情况。\n\n\n\n工作集\n由于抖动的发生与系统为进程分配物理块的多少有关，于是又提出了关于进程工作集的概念。\n工作集是指在某段时间间隔内，进程要访问的页面集合。\n 基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集$W$可由时间$t$和工作集窗口大小$Δ$来确定。例如，某进程对页面的访问次序如下：\n\n 假设系统为该进程设定的工作集窗口大小$Δ$为5，则在$t_1$时刻，进程的工作集为{2,3,5}，在$t_2$时刻，进程的工作集为{1,2,3,4}。\n 工作集大小一般会比窗口小很多，工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页。\n 一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。\n3.2.6 内存映射文件 内存映射文件（Memory-MappedFiles）与虚拟内存有些相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件 I/O 操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。\n特性\n\n进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间\n以访问内存的方式读写文件\n进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射\n多个进程可以映射同一个文件，方便共享\n\n\n优点\n\n程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可\n文件数据的读入/写出完全由操作系统负责，I\\O效率可以由操作系统负责优化\n\n3.2.7 虚拟存储器性能影响因素页面大小\n根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。\n\n页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。\n页面较大时，虽然可以减少页表长度，但会使页内碎片增大。\n\n分配给进程的物理块\n分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。\n页面置换算法\n好的页面置换算法可使进程在运行过程中具有较低的缺页率。\n选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。\n写回磁盘的频率\n换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。\n建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将其写回磁盘。\n局部化程度\n编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象。\n3.2.8 地址翻译设某系统满足以下条件：\n\n有一个TLB与一个data Cache\n存储器以字节为编址单位\n虚拟地址14位\n物理地址12位\n页面大小为64B\nTLB为四路组相联，共有16个条目\ndata Cache是物理寻址、直接映射的，行大小为4B，共有16组\n\n写出访问地址为0x03d4, 0x00f1和0x0229的过程。\n写出其地址结构\n\n\n根据页面大小求页内偏移量与页号长度\n本系统以字节编址，页面大小为64B，则页内偏移量为$log_2(64B/1B)=6位$，所以虚拟页号为$14-6=8位$，物理页号为$12-6=6位$。\n\n根据TLB结构求虚拟页号地址结构\n因为TLB为四路组相联，共有16个条目，则TLB有16/4=4组，因此虚拟页号低$log_24=2位$就为组索引，高6位为TLB标记。\n\n根据Cache机构求物理页号地址结构\n因为Cache行大小为4B，因此物理地址中低$log_24=2位$为块索引，Cache共有16组，可知接下来$log_216=4位$为组索引，剩下高6位作为标记。\n\n\n根据TLB、页表寻找物理页号\n\n先把十六进制的虚拟地址0x03d4, 0x00f1和0x0229转化为二进制形式，如下表所示。\n\n得到每个地址的组索引和TLB标记，接下来就要找出每个地址的页面在不在主存中，若在主存中，则还要找出物理地址。\n\n查TLB得到物理块号\n对于0x03d4，组索引为3，TLB标记为0x03。\n查TLB表，第3组中有标记为03的项，且有效位为1，找到物理块0D。\n拼接页内地址（010100），得到物理地址为0x354。\n\n\n查TLB未得到物理块号，查页表得到物理块号\n对于0x00f1，组索引为3，TLB标记为0x00。\n查TLB表，第3组未找到有标记为00的项。\n访存查页表，根据虚拟页号0x03，找到物理块号02，且有有效位为1。\n拼接页内地址（110001），得到物理地址为0x0b1。\n\n\n查TLB未得到物理块号，查页表也未得到物理块号\n对于0x0229，组索引为0，TLB标记为0x02。\n查TLB表，第0组未找到有标记为02的项。\n访存查页表，根据虚拟页号0x08，页表08项有效位为0，页面不在主存中，产生缺页中断。\n\n\n\n根据Cache寻找内存地址\n\n 找出在主存中的页面的物理地址后，就要通过物理地址访问数据，接下来要找该物理地址的 内容在不在Cache中，物理地址结构如下表所示。\n)\n\nCache块命中\n对于0x354，Cache索引为5，Cache标记为0x0d。\n查询Cache索引为5的行，标记为0d，有效位为1，则该块在Cache中。\n偏移为0，即块0，可得虚拟地址0x03d4的内容为36H。\n\n\nCache块未命中\n对于0x0b1，Cache索引为C，Cache标记为0x02。\n查询Cache索引为C的行，标记为02，有效位为0，则该块不在Cache中。\n需去访问主存查找，物理页号为2、偏移为0x31的内容。\n\n\n\n虚拟地址寻址总流程\n\n四、文件管理4.1 文件系统基础4.1.1 文件的基本概念定义\n文件是以计算机硬盘为载体的存储在计算机上的信息集合，在用户进行的输入、输出中，以文件位基本单位。\n文件管理系统是实现的文件的访问、修改和保存，对文件维护管理的系统。\n文件的组成\n\n存储空间：用于存储数据\n标签：便于对数据的分类和索引\n访问权限：不同用户对数据有不同的访问权限\n\n文件的结构\n\n数据项：是文件系统中最低级的数据组织形式，可分为以下两种类型：\n基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。\n组合数据项：由多个基本数据项组成。\n\n\n记录：是一组相关的数据项的集合，用于描述一个对象在某方面的属性。\n文件：是指由创建者所定义的、具有文件名的一组相关元素的集合，分为有结构文件和无结构文件两种。\n在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；\n无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。\n\n\n\n4.1.2 文件控制块和索引结点文件的属性\n\n文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件\n标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。\n类型：指明文件的类型\n位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）\n大小：指明文件大小\n保护信息：对文件进行保护的访问控制信息\n创建时间、最后一次修改时间和最后一次存取时间：文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用。\n\n文件控制块FCB\n文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。\n操作系统通过文件控制块（FCB）来维护文件元数据。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。下图为一个典型的FCB。\n\nFCB包含以下信息：\n\n基本信息：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。\n存取控制信息：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。\n使用信息：如文件建立时间、上次修改时间等。\n\n\n一个文件目录也被视为一个文件，称为目录文件。\n\n索引结点\n 在检索目录时，只用到了文件名，因此有的系统采用文件名与文件描述分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 i 结点（inode)。\n 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。\n\n假设一个FCB为64B，盘块大小是1KB，则每个盘块中可以存放16个FCB（FCB必须连续存放），若一个文件目录共有640个FCB，则查找文件平均需要启动磁盘20次。\n而在UNIX系统中，一个目录项仅占16B，其中14B是文件名，2B是 i 结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的1/4，大大节省了系统开销。\n\n\n磁盘索引结点\n它是指存放在磁盘上的索引结点。每个文件有一个唯一的磁盘索引结点，主要包括以下内容：\n\n文件主标识符，拥有该文件的个人或小组的标识符。\n文件类型，包括普通文件、目录文件或特别文件。\n文件存取权限，各类用户对该文件的存取权限。\n文件物理地址，每个索引结点中含有13个地址项，即iaddr(0)～iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。\n文件长度，指以字节为单位的文件长度。\n文件链接计教，在本文件系统中所有指向该文件的文件名的指针计数。\n文件存取时间，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。\n\n\n内存索引结点\n它是指存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在内存索引结点中增加了以下内容：\n\n索引结点编号，用于标识内存索引结点。\n\n状态，指示 i 结点是否上锁或被修改。\n\n访问计数，每当有一进程要访问此 i 结点时，计数加1；访问结束减1。\n\n逻辑设备号，文件所属文件系统的逻辑设备号。\n\n链接指针，设置分别指向空闲链表和散列队列的指针。\n\n\n\n\n4.1.3 文件的操作文件的基本操作\n 文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。\n\n创建文件（create系统调用）\n\n为新文件分配必要的外存空间；\n在目录 中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息。\n\n\n删除文件（delete系统调用）\n\n先从目录中检索指定文件名的目录项\n然后释放该文件所占的存储空间，以便可被其他文件重复使用，并删除目录条目。\n\n\n读文件（read系统调用）\n\n对于给定文件名，搜索目录以查找文件位置。\n系统维护一个读位置的指针。\n每当发生读操作时，更新读指针。\n\n\n写文件（write系统调用）\n\n对于给定文件名，搜索目录以查找文件位置。\n系统必须为该文件维护一个写位置的指针。\n每当发生写操作时，便更新写指针。\n\n\n一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。\n由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度。\n\n\n重新定位文件\n也称文件定位。搜索目录以找到适当的条目，并将当前文件位置指针重新定位到给定值。\n重新定位文件不涉及读、写文件。\n\n截断文件\n允许文件所有属性不变，并删除文件内容，将其长度置为0并释放其空间。\n\n\n这6个基本操作可以组合起来执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入新文件。\n文件的打开与关闭\n\n打开文件（open系统调用）\n\n过程：调用open根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置)，从外存复制到内存打开文件表的一个表目中，并将该表目的编号（也称索引）返回给用户。\n\n\n打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”。\n\n打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。\n\n如上图所示，在多个不同进程同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。\n\n整个系统的打开文件表包含FCB的副本及其他信息。\n每个进程的打开文件表根据它打开的所有文件，包含指向系统表中适当条目的指针。\n\n一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目。\n\n关闭文件（close系统调用）\n\n1.将进程的打开文件表相应表项删除\n2.回收分配给该文件的内存空间等资源\n3.系统打开文件表的打开计数器count减1，若count=0，则删除对应表项。\n\n\n\n系统打开文件表为每个文件关联一个打开计数器（OpenCount)，以记录多少进程打开了该文件。\n\n文件名不必是打开文件表的一部分，因为一且完成对FCB在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。因此，只要文件未被关闭，所有文件操作就通过打开文件表来进行。\n\n\n打开文件信息\n文件指针。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。\n文件打开计数。计数器跟踪当前文件打开和关闭的数量。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。\n文件磁盘位置。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息。\n访问权限。每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的I/O请求。\n\n\n\n4.1.4 文件保护 文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。\n口令保护\n为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确。\n实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全\n加密保护\n用一个“密码“对文件加密，用户想要访问文件时，需要提供相同的“密码“才能正确的解密\n安全性高，但加密解密需要耗费一定的时间（Eg：异或加密）\n访问控制\n\n访问类型\n对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种。\n\n读。从文件中读。\n写。向文件中写。\n执行。将文件装入内存并执行。\n添加。将新信息添加到文件结尾部分。\n删除。删除文件，释放空间。\n列表清单。列出文件名和文件属性。\n\n此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。\n\n访问控制\n 解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。\n\n优点：可以使用复杂的访问方法，\n缺点：长度无法预计并且可能导致复杂的空间管理，\n\n使用精简的访问列表可以解决这个问题，精简的访问列表采用拥有者、组和其他三种用户类型。\n\n拥有者。创建文件的用户。\n组。一组需要共享文件且具有类似访问的用户。\n其他。系统内的所有其他用户。\n\n文件主在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，\n\n若用户是文件主，按照文件主所拥有的权限访问文件；\n若用户和文件主在同一个用户组，则按照同组权限访问，\n否则只能按其他用户权限访问。\n\n\n\n4.1.5 文件的逻辑结构 文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构（存储结构）是从实现观点出发看到的文件在外存上的存储组织形式。\n 文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。\n无结构文件（流式文件）\n无结构文件将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合，以字节（Byte）为单位。\n\n只能通过穷举搜索的方式访问记录。\n其管理简单，用户操作方便。\n对基本信息单位操作不多的文件适于采用字符流的无结构文件。例如源程序文件、目标代码文件等。\n\n有结构文件（记录式文件）\n\n顺序文件\n文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。\n各个记录在物理上可以顺序存储或链式存储。\n\n链式存储：无论是定长何变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找\n\n顺序存储：\n可实现随机存取，记录长度为L，则第ⅰ个记录存放的相对位置是i*L\n若采用串结构，记录之间的顺序与关键字无关，无法快速找到某关键字对应的记录\n若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）\n\n\n\n定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取：若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）\n\n优点：读写一大批文件时，效率最高。适用于顺序存储设备（磁带）\n缺点：不方便增加、删除记录\n\n索引文件\n\n索引表：高效查询变长记录文件。索引表本身是定长记录的顺序文件，因此可以快速找到第ⅰ个记录对应的索引项。\n\n\n方式：可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找\n每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。\n\n\n\n索引顺序文件\n索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。\n\n将记录分组，每组对应一个素引表项\n检素记录时先顺序查索引表，找到分组，再顺序查找分组\n当记录过多时，可建立多级素引表\n\n\n如上图所示，主文件名包含姓名和其他数据项。\n\n姓名为关键字，索引表中为每组的第一条记录（不是每条记录）的关键字值，用指针指向主文件中该记录的起始位置。\n索引表只包含关键字和指针两个数据项，所有姓名关键字递增排列。\n主文件中记录分组排列，同一个组中的关键字可以无序，但组与组之间的关键字必须有序。\n查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。\n\n\n直接文件或散列文件（Hash File）\n 给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。\n 散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。\n\n\n4.1.6 文件的物理结构 文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。\n 文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。\n连续分配\n连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。\n\n\n物理块号=起始块号+逻辑块号\n优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快。\n缺点：不方便文件拓展、存储空间利用率低、会产生磁盘碎片（外部碎片）。\n①文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。\n②为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度。\n③反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似）。\n④很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。\n\n\n访存次数：访问第n条记录需访问磁盘1次\n\n链接分配\n链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。\n访问第n条记录需访问磁盘n次\n\n隐式链接\n除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。\n\n\n优点：很方便文件拓展，不会有碎片问题，外存利用率高。\n缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。\n结论：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高\n\n\n\n\n显式链接\n把用于链接文件各物理块的指针显式地存放在文件分配表（FAT）中。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。\n\n\n优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。\n缺点：文件分配表的需要占用一定的存储空间。\n结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问ⅰ号逻辑块时，并不需要依次访问之前的0~ｉ-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。\n\n\n文件分配表：FAT不仅记录了文件分配信息（显示链接），还“兼职”做了空闲块管理\n\n\n\n索引分配\n 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。\n\n\n索引表的 逻辑块号 可以是隐含的，进一步节约空间；\n\n\n链接方案\n如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。\n\n缺点：需要顺序访问，当文件很大时，查我效率低下\n\n多层索引\n建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。\n\n采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作\n缺点：即使是小文件，访问数据块也需受K+1次读磁盘\n\n混合索引\n多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。\n\n所允许的文件最大长度：设有N0个直接地址项；N1个一次间接地址项；N2个二次间接地址项；每个盘块大小M字节；盘块号占m个字节，公式如下：\n\n文件最大长度=(N_0 + N_1·\\frac{M}{m}+N_2·(\\frac{M}{m})^2)·M优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）\n\n总结\n\n\n\n4.2 目录4.2.1 目录的基本概念 文件目录指FCB的有序集合，一个FCB就是一个文件的目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。\n\n目录管理的基本要求：\n\n从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；\n\n目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；\n\n在多用户系统中，应允许多个用户共享一个文件，因此目录还需要提供用于控制访问文件的信息。\n\n此外，应允许不同用户对不同文件采用相同的名字，以便于用户按自己的习惯给文件命名，目录管理通过树形结构来解决和实现。\n\n\n\n\n4.2.2 目录结构单级目录结构\n在整个文件系统中只建立一张目录表，每个文件占一个目录项，不允许文件重名，如下图所示。\n\n当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。\n当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中。\n两级目录结构\n 将文件目录分成主文件目录（MFD）和用户文件目录（UFD）两级，不同用户的文件可以重名，但不能对文件分类。\n\n主文件目录项记录用户名及相应用户文件目录所在的存储位置。\n用户文件目录项记录该用户文件的FCB信息。\n树形目录结构\n不同目录下的文件可以重名，可以对文件进行分类，不方便共享。\n\n根据“文件路径”找到目标文件。用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级日录之间用“/”隔开。从根目录出发的路径称为绝对路径。\n\n例如：自拍.jpg的绝对路径是“/照片/2015-08/自拍jpg”\n系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍Jpg”的存放位置。整个过程需要3次读磁盘I/O操作。\n\n引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。\n从根目录出发是绝对路径；从当前目录出发是相对路径。\n无环图目录结构\n在树形目录的基础上，增加一些指向同一结点的有向边，使整个目录成为一个有向无环图，实现文件的共享。\n\n为共享结点设置一个共享计数器，计数器为0时才真正删除该结点。\n对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见。\n4.2.3 目录的操作\n搜索。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。\n创建文件。当创建一个新文件时，需要在目录中增加一个目录项。\n删除文件。当删除一个文件时，需要在目录中删除相应的目录项。\n创建目录。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。\n删除目录。有两种方式：①不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。②可删除非空目录，目录中的文件和子目录同时被删除。\n移动目录。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。\n显示目录。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。\n修改目录。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。\n\n4.2.4 目录实现 目录实现有线性列表和哈希表两种方式，线性列表实现对应线性查找，哈希表的实现对应散列查找。\n线性列表\n最简单的目录实现方法是，采用文件名和数据块指针的线性列表。\n\n当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。\n\n当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。\n\n当要\n重用目录项\n时有许多种方法：\n\n可以将目录项标记为不再使用，或将它加到空闲目录项的列表上，\n还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。\n\n\n\n采用链表结构可以减少删除文件的时间。\n线性列表的优点在于实现简单，不过由于线性表的特殊性，查我比较费时。\n哈希表\n哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。\n\n优点：查找非常迅速，插入和删除也较简单，\n问题：需要一些措施来避免冲突（两个文件名称哈希到同一位置）。\n为了减少I/O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。\n\n\n4.2.5 文件共享 文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。\n基于索引结点的共享方式（硬链接）\n各个用户的目录项指向同一个索引结点，索引结点中需要链接计数count，用于表示链接到本索引结点上的用户目录项数。\n\n某用户删除文件只是删除该用户的目录项，count—\n只有count==0才能真正删除文件数据和索引结点。\n利用符号链实现文件共享（软链接）\n为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将该文件写入用户B的目录中，以实现用户B的目录与文件F的链接。\n\n在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式），操作系统根据路径一层层查找目录，最终找到共享文件。\n\n当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。\n\n即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）。\n由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问的速度要比硬链接更慢。\n 硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。\n4.3 文件系统4.3.1 文件系统结构 文件系统(File system)提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。\n\n用一个例子来辅助记忆文件系统的层次结构：假设某用户请求删除文件”D:/工作目录/学生信息.xIsx”的最后100条记录。\n\n用户需要通过操作系统提供的接口发出上述请求一一用户接口\n由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项一一文件目录系统\n不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限一一存取控制模块（存取控制验证层）\n验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区\n知道了标记录对应的逻辑地址后，还需要转换成实际的物理地址一一物理文件系统\n要删除这条记录，必定要对磁盘设备发出请求一一设备管理程序模块\n删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收一一辅助分配模块\n\n4.3.2 文件系统布局文件系统在磁盘中的结构\n 文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。文件系统可能包括如下信息：启动存储在那里的操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。如下图所示。\n\n\n主引导记录（MasterBootRecord，MBR)，位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。\n\n引导块（bootblock)，MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统。Windows系统称之为分区引导扇区。\n\n除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有如上图所列的一些项目。\n\n超级块（superblock)，包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。\n\n文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。\n\ni 结点。索引结点，连续存放，每个文件对应一个结点，可以把 i 结点区看成一个大数组；\n\n根目录，它存放文件系统目录树的根部。\n\n其他部分，存放了其他所有的目录和文件。\n\n\n文件系统在内存中的结构\n 内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构的类型可能包括：\n\n内存中的安装表(mount table)，包含每个己安装文件系统分区的有关信息。\n内存中的目录结构的缓存，包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。\n整个系统的打开文件表，包含每个打开文件的FCB副本及其他信息。\n每个进程的打开文件表，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息。\n\n进程创建：\n 为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式，它将为文件分配一个新的FCB。然后，系统将相应的目录读入内存，使用新的文件名和FCB进行更新，并将它写回磁盘。\n一旦文件被创建，它就能用于I/O，不过，首先要打开文件。系统调用open()将文件名传递给逻辑文件系统。\n\n\n调用open()首先\n搜索整个系统的打开文件表，以确定这个文件是否已被其他进程使用。\n\n如果已被使用，则在单个进程的打开文件表中创建一个条目，让其指向现有整个系统的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。\n如果这个文件尚未打开，则根据给定文件名来搜索目录结构。部分目录结构通常缓存在内存中，以加快目录操作。\n\n\n找到文件后，它的FCB会复制到整个系统的打开文件表中；该表不但存储FCB，而且跟踪打开该文件的进程的数量。\n\n然后，在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域（如文件当前位置的指针和文件访问模式等）相连。\n\n调用open()返回的是一个指向单个进程的打开文件表中的适当条自的指针。以后，所有文件操作都通过该指针执行。\n\n一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符（Windows称之为文件句柄）\n\n\n进程关闭：\n 当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除。\n4.3.3 外存空闲空间管理 一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为4个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷（volumme)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集，如图所示。\n\n 在一个卷中，存放文件数据的空间（文件区）和FCB的空间（目录区）是分离的。\n 文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。\n空闲表法\n空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。\n\n\n盘块的分配\n与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。\n同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。\n\n盘块的回收\n与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：\n\n①回收区的前后都没有相邻空闲区\n②回收区的前后都是空闲区\n③回收区前面是空闲区\n④回收区后面是空闲区\n\n总之，回收时需要注意表项的合并问题\n\n\n空闲链表法\n将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：\n\n空闲盘块链：将磁盘上的所有空闲空间以盘块为单位拉成一条链。\n\n操作系统保存着链头、链尾指针。\n\n如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。\n如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。\n\n适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作\n\n空闲盘区链：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。\n\n操作系统保存着链头、链尾指针。\n\n如何分配：\n若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。\n若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。\n\n如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。\n\n\n离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。\n\n\n位示图法\n 位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。\n 这样，一个m×n位组成的位示图就可用来表示m×n个盘块的使用情况，如图所示。行为位号，列为字号\n\n\n注意：盘块号、字号、位号到底是从0开始，还是从1开始。两者计算盘块号方式不同。\n\n\n盘块的分配\n\n顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。\n\n将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值为“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n为每行位数）：\n\n\n修改位示图，令$map[i,j]=1$\n\n\n\n盘块的回收\n\n将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为\n\n\n修改位示图，令$map[i,j]=0$。\n\n\n\n\n空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。\n成组链接法\n 在UNIX系统中采用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，它具有上述两种方法的优点，克服了两种方法均有的表太长的缺点。\n 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。\n\n用来存放一组空闲盘块号（空闲盘块的块号）的盘块称为成组链块。\n\n成组链接思想：把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。\n\n盘块的分配\n分配1个空闲块：\n\n①检查第一个分组的块数是否足够。1＜100，是足够的。\n②分配第一个分组中的1个空闲块，并修改相应数据\n\n\n分配100个空闲块：\n\n①检查第一个分组的块数是否足够。100=100，是足够的。\n②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中\n\n\n\n\n盘块的回收\n需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。\n\n\n\n\n4.3.4 虚拟文件系统 虚拟文件系统（VFS）为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节。\n普通文件系统\n 下图普通的文件系统，不同的外部存储设备，它的文件系统可能是不相同的，对于同一个操作的函数方法定义也许也各不相同；\n\n虚拟文件系统\n 下图为虚拟文件系统，用户程序可以通过VFS提供的统一调用函数（如open()等）来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。\n\n 虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。\n 为了实现VFS，Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法（函数）表的指针。\n\n超级块对象：表示一个已安装（或称挂载）的特定文件系统。\n索引结点对象：表示一个特定的文件。\n目录项对象：表示一个特定的目录项。\n文件对象：表示一个与进程相关的已打开文件。\n\n进程与VFS对象之间的交互如下图所示。\n\n\n三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。\n在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引结点对象, 这个索引结点对象标识的是超级块对象及随后的普通磁盘文件。\n\n 对于不同文件系统的数据结构，VFS 在每打开一个文件，就在主存建立一个vnode，用统一的数据结构表示文件；\n打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能\n\n\nvnode只存在于主存中，而inode既会被调入主存，也会在外存中存储\n\n特点：\n\n向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异\nVFS要求下层的文件系统必须实现某些规定的函数功能，如：open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求\n每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统\n\n4.3.5 分区和安装\n分区\n\n物理格式化（低级格式化）：划分扇区、检测坏扇区、用备用扇区替换坏扇区；当要访问某一块坏扇区时，会使用备用扇区，默默完成替换工作；\n\n\n逻辑格式化（高级格式化）：磁盘分区；每个区的大小、地址范围等信息，会使用 分区表 来记录；\n在每个区里可以建立各自独立的文件系统 ，例如在C盘里建立UNIZX文件系统；\n分区的第一部分是引导块，里面存储着引导信息，它有自身的格式，因为在引导时系统并未 加载文件系统代码，因此不能解释文件系统的格式。下图为一个典型的Linux分区。\n安装\n\n\n文件系统在进程使用前必须先安装，也称挂载，任务是将一个文件系统挂载到操作系统中。\n功能：\n\n①在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。\n②新挂载的文件系统，要向VFS提供一个函数地址列表\n③将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下\n\n\nUNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以首先要给根目录分配空间，这样才能操作这个目录树。\n\n5 输入/输出（I/O）管理5.1 I/O管理概述5.1.1 I/O设备 I/O设备是将数据输入到计算机中，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件；\n设备的分类\n\n按使用特性分类：\n人机交互类外部设备：鼠标、键盘、打印机等，用于人机交互。数据传输速度慢。\n存储设备：移动硬盘、光盘等，用于数据存储。数据传输速度快。\n网络通信设备：调制解调器等，用于网络通信。数据传输速度介于上述二者之间。\n\n\n按信息交换的单位分类：\n块设备。信息交换以数据块为单位。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读/写任意一块。\n字符设备。信息交换以字符为单位。它属于无结构类型，如交互式终端机、打印机等。\n\n\n按传输速率分类：\n低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等。\n中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。\n高速设备。传输速率在数百千字节至千兆字节的一类设备，如磁盘机、光盘机等。\n\n\n\nI/O接口\n I/O接口（设备控制器）位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能，主要由三部分组成，如下图所示。\n\n\n组成部分：\n\n设备控制器与CPU的接口：实现控制器与CPU之间的通信\n该接口有三类信号线：数据线、地址线和控制线。\n数据线与两类寄存器相连：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制/状态寄存器（存放从CPU送来的控制信息或设备的状态信息）。\n\n设备控制器与设备的接口：实现控制器与设备之间的通信\n一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。\n每个接口中都存在数据、控制和状态三种类型的信号。\n\nI/O逻辑：负责识别CPU发出的命令，并向设备发出命令\n用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。\nCPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。\n\n\n\n主要功能：\n\n接受和识别CPU发出的指令（控制寄存器）\n向CPU报告设备的状态（状态寄存器）\n数据交换（数据寄存器暂存数据）\n地址识别（由I/O逻辑实现）\n数据缓冲\n差错控制\n\n\n\nI/O端口\nI/O端口是指设备控制器中可被CPU直接访问的寄存器，主要有以下三类寄存器。\n\n寄存器类型：\n\n数据寄存器：实现CPU和外设之间的数据缓冲。\n状态寄存器：获取执行结果和设备的状态信息，以让CPU知道是否准备好。\n控制寄存器：由CPU写入，以便启动命令或更改设备模式。\n\n\n实现I/O端口通信，有两种编址方法：\n\n\n独立编址。为每个端口分配一个I/O端口号，所有I/O端口形成I/O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I/O指令才能访问端口。\n统一编址。又称内存映射I/O，每个端口被分配唯一的内存地址，且不会有内存被分配这地址，通常分配给端口的地址靠近地址空间的顶端。\n\n\n\n5.1.2 I/O控制方式 设备管理的主要任务之一是控制设备和内存或CPU之间的数据传送。外围设备与内存之间的输入/输出控制方式有以下4种。\n1.程序直接控制方式\n 如下图所示，计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。\n\n\n工作流程：\n\n\nCPU干预的频率：很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。\n\n数据传送的单位：每次读/写一个字\n\n数据的流向：\n\n读操作（数据输入）：I/O设备→CPU→内存\n写操作（数据输出）：内存→CPU→I/O设备\n每个字的读/写都需要CPU的帮助\n\n\n优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可\n\n缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。\n\n\n2.中断驱动方式\n 中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而”解放” CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。\n\n\n工作流程：\n引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。\n当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。\n处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。\n\n\n\n\n①CPU会在每个指令周期的末尾检查中断：②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的须率太高，也会降低系统性能。\n\n\nCPU干预的频率：每次I/O操作开始之前、完成之后需要CPU介入。等待I/O完成的过程中CPU可以切换到别的进程执行。\n数据传送单位：每次读/写一个字\n数据流向：\n读操作（数据输入）：I/O设备→CPU→内存\n写操作（数据输出）：内存→CPU→I/O设备\n\n\n优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。CPU和I/O设备可并行工作，CPU利用率得到明显提升。\n缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。\n\n3.DMA方式\n DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。下图为DMA工作流程。\n\n\n与“中断驱动方式”相比，DMA方式有这样几个改进：\n\n①数据的传送单位是“块”。不再是一个字、一个字的传送：\n②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。\n③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，数据传送通过DMA控制器完成。\n\n\nDMA控制器组成：\n下图为DMA控制器的组成。\n\nDMA控制器中设置如下4类寄存器：\n\n数据寄存器（DR）。暂存从设备到内存或从内存到设备的数据。\n内存地址寄存器（MAR）。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。\n数据计数器（DC）。存放本次要传送的字（节）数，剩余要读/写的字节数。\n命令/状态寄存器（CR）。接收从CPU发来的I/O命令、有关控制信息，或设备的状态。\n\n\nCPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。\n\n数据传送单位：每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）\n\n数据流向：\n\n读操作（数据输入）：I/O设备→内存\n写操作（数据输出）：内存→I/O设备\n\n\n优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。\n\n缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要发出多条I/O指令，进行多次中断处理才能完成。\n\n\n4.通道控制方式\n通道：I/O通道是指专门负责输入输出的处理机。是一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。\n\n与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存\n\n\n完成一次读写流程：\n\n\nCPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。\n\n数据传送的单位：每次读/写一组数据块\n\n数据的流向（在通道的控制下进行）\n\n读操作（数据输入）：I/O设备→内存\n写操作（数据输出）：内存→I/O设备\n\n\n缺点：实现复杂，需要专门的通道硬件支持\n\n优点：CPU、通道、I/O设备可并行工作，资源利用率很高。\n\n\n5.1.4 I/O软件层次结构 为了更好地设计 I/O 软件，采用 层次式结构 的 I/O 软件；\n\n 一个比较合理的层次划分如上图所示。整个I/O软件可以视为具有4个层次的系统结构，各层次功能如下：\n用户层软件\n 实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。\n 用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务\n设备独立性软件\n 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。\n\n功能：\n\n向上层提供统一的调用接口（如read/write系统调用）\n设备的保护\n差错处理\n设备的分配与可收\n数据缓冲区管理\n建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序\n\n\n逻辑设备\n 为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。\n使用逻辑设备名好处：\n\n①增加设备分配的灵活性\n②易于实现I/O重定向，指用于I/O操作的设备可以更换(即重定向)，而不必改变应用程序。\n设备独立性软件需要通过“逻辑设备表（LUT，Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。\n\n\n\n\nI/O设备被当做一种特殊的文件；不同类型的I/O设备需要有不同的驱动程序处理\n\n操作系统系统可以采用两种方式管理逻辑设备表（LUT）：\n\n第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。\n第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。\n\n\n\n设备驱动程序\n 与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。 将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。\n 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。\n 为I/O内核子系统隐藏设备控制器之间的差异。\n中断处理程序\n 当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。\n\n中断处理程序的处理流程如下：\n\n\n中断处理层的任务：\n\n进行进程上下文的切换，\n对处理中断信号源进行测试，\n读取设备状态和修改进程状态等。\n\n\n\n\n由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。\n\n总结\n说明用户对设备的一次命令过程如下所示：\n\n①当用户要读取某设备的内容时，通过操作系统提供的read命令接口，这就经过了用户层。\n②操作系统提供给用户使用的接口，一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令，如read命令，用户发出的read命令，首先经过设备独立层进行解析，然后交往下层。\n③接下来，不同类型的设备对read命令的行为会有所不同，如磁盘接收read命令后的行为与打印机接收read命令后的行为是不同的。因此，需要针对不同的设备，把read命令解析成不同的指令，这就经过了设备驱动层。\n④命令解析完毕后，需要中断正在运行的进程，转而执行read命令，这就需要中断处理程序。\n⑤最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。\n\n直接涉及到硬件其体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；\n没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的。\n5.1.4 应用程序I/O接口 在I/O系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干接口。\n字符设备接口\n 字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入输出时通常采用中断驱动方式。\n\n字符设备的操作\n\nget和put操作。由于字符设备不可寻址，只能采取顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。\nin-control指令。字符设备类型繁多，差异甚大，因此在接口中提供一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。\n\n字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。\n\n\n块设备接口\n 块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I/O常采用DMA方式。\n\n隐藏了磁盘的二维结构：在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从0到n-1依次编号，这样，就将二维结构变为一种线性序列。\n将抽象命令映射为低层操作：块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。\n内存映射接口：内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读写一样简单，极大地方便了程序员。\n\n网络设备接口\n 许多操作系统提供的网络I/O接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。\n\n阻塞/非阻塞I/O\n\n阻塞I/O：当用户进程调用I/O操作时，进程就被阻塞，需要等待I/O操作完成，进程才被唤醒继续执行。\neg：字符设备接口一一从键盘读一个字符get\n\n非阻塞I/O：用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I/O操作是否完成。\neg：块设备接口一一往磁盘写数据write\n\n\n5.2 设备独立性软件5.2.1 与设备无关的软件 与设备无关的软件是I/O系统的最高层软件，它的下层是设备驱动程序。\n\n设备保护：\n操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）\n在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。\n\n\n\n5.2.2 高速缓存与缓冲区磁盘高速缓存（Disk Cache）\n操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对访问高速缓存要比访问原始磁盘数据更为高效。\n 磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。\n\n高速缓存在内存中分为两种形式：\n\n一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定\n另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。\n\n\n\n缓冲区（Buffer）\n\n概念：缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。\n\n硬件做缓冲区：使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）\n内存做缓冲区：一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区\n\n\n作用\n\n缓和CPU与I/O设备之间速度不匹配的矛盾\n减少对CPU的中断频率，放宽对CPU中断相应时间的限制\n解决数据粒度不匹配的问题\n提高CPU与I/O设备之间的并行性\n\n\n单缓冲\n若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。\n\n\n\n注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。\n\n设块设备输入缓冲区时间为T，缓冲区传送至工作区时间为M，CPU处理工作区时间为C：\n\n若T&gt;C，从初始状态到下一个开始状态，整个过程用时为M+T\n若T&lt;C，从初始状态到下一个开始状态，整个过程用时为M+C\n\n结论：故单缓冲区处理每块数据的用时为$max(C,T)+M$。\n若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。\n\n双缓冲\n若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。\n\n\n双缓冲题目中，假设初始状态为；工作区空，其中一个缓冲区满，另一个缓冲区空\n\n若T&gt;C+M，则处理一块数据的平均用时为T\n若T&lt;C+M，意味着输入数据块速度要比处理机处理数据块速度更快，处理一个数据块的平均耗时为C+M\n\n结论：采用双缓冲策略，处理一个数据块的平均耗时为$Max(T,C+M)$\n\n\n若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。\n若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。\n\n\n循环缓冲\n将多个大小相等的缓冲区链接成一个循环队列。\n\n注：上图中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。\n\n缓冲池\n 缓冲池由系统中共用的缓冲区组成。\n这些缓冲区按使用状况可以分为：\n\n空缓冲队列\n装满输入数据的缓冲队列（输入队列）\n装满输出数据的缓冲队列（输出队列）\n\n\n根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：\n\n用于收容输入数据的工作缓冲区（hin）\n用于提取输入数据的工作缓冲区（sin）\n用于收容输出教据的工作绥冲区（hout）\n用于提取输出数据的工作缓冲区（sout）\n\n工作过程：\n\n输入进程请求输入数据\n从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾\n\n计算进程想要取得一块输入数据\n从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列\n\n计算进程想要将准备好的数据冲入缓冲区\n从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”，数据冲满后将缓冲区挂到输出队列队尾\n\n输出进程请求输出数据\n从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列\n\n\n\n\n5.2.3 设备的分配与回收设备分配概述\n 设备分配是指根据用户的I/O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。\n 从设备特性来看，分为以下三种设备：\n\n独占式使用设备。进程分配到独占设备后，便由其独占，直至该进程释放该设备。\n分时式共享使用设备。对于共享设备，可同时分配给多个进程，通过分时共享使用。\n以SPOOLing方式使用外部设备。SPOOLing技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I/O操作的批处理。\n\n设备分配的数据结构\n 设备分配依据的主要数据结构有设备控制表(DCT)、控制器控制表(COCT)、通道控制表 (CHCT)和系统设备表(SDT)，各数据结构功能如下。\n\n设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况\n\n\n控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。\n\n\n通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。\n\n\n系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。\n\n\n\n设备分配的策略\n\n设备分配原则。设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。\n\n设备分配方式。设备分配方式有静态分配和动态分配两种。\n\n①静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器。\n静态分配方式不会出现死锁，但设备的使用效率低。\n\n②动态分配：进程运行过程中动态申请设备资源。在进程执行过程中根据执行需要进行。\n这种方式有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁。\n\n\n\n设备分配算法。常用的动态设备分配算法有先请求先分配、优先级高者优先等。\n\n\n设备分配的安全性\n设备分配的安全性是指设备分配中应防止发生进程死锁。\n\n安全分配方式。\n\n为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。\n优点：破坏了“请求和保持”条件，不会死锁\n缺点：对于一个进程来说，CPU和I/O设备只能串行工作\n\n\n不安全分配方式。\n进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。\n\n优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进\n缺点：有可能发生死锁（死锁避免、死锁的检测和解除）\n\n\n\n设备分配的步骤\n\n步骤\n\n① 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）\n② 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。\n③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。\n④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。\n\n\n注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送\n\n\n缺点\n\n①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程\n②若换了一个物理设备，则程序无法运行\n③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待\n\n\n\n设备分配步骤的改进\n改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。\n\n逻辑设备表（LUT）\n逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。\n\n某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。\n如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。\n\n整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统\n每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统\n\n\n步骤\n\n根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）\n查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。\n根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。\n根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程\n\n\n\n5.2.4 SPOOLing技术（假脱机技术）概念\n\n脱机技术：脱离主机的控制进行的输入/输出操作。\n批处理阶段引入了脱机输入/输出技术（用磁带完成），在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。\n\nSPOOLing技术：“假脱机技术”，又称“SPOOLing技术”，用软件的方式模拟脱机技术。\n\n要实现SPOOLing技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”\n\n\n原理\n\n输入井和输出井\n在磁盘上开辟出两个存储区域一一“输入井”和“输出井”\n”输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据\n“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据\n\n\n输入进程和输出进程\n“输入进程”模拟脱机输入时的外围控制机\n“输出进程”模拟脱机输出时的外围控制机\n\n\n输入缓冲区和输出缓冲区\n在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中\n在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上\n注意，输入缓冲区和输出缓冲区是在内存中的缓冲区\n\n\n\n预读和滞后写\n\n预读（提前读）：\n如果采用的顺序访问方式对文件进行访问，便可预知下一次要读的盘块。此时可采用预读策略，即在读当前块的同时，也将下一个盘块提前读入内存缓冲区，这样在访问下一个盘块时就不需要再启动磁盘，从而提升磁盘I/O速度。\n\n滞后写（延迟写）\n滞后写是指缓冲区A中的数据本应立即写回磁盘，但考虑到其中的数据在不久之后有可能再次被访问，因此并不会立即把A中的数据写回磁盘，而是将缓冲区A挂到空闲缓冲区队列。如果有别的进程申请使用该缓冲区时，才把A中的数据写回磁盘。这样做的好处是，只要缓冲区A仍在队列中，任何访问该数据的进程，都可以直接读出其中的数据而不必访问磁盘。因而这种方式也可以减少磁盘I/O次数，改善性能。\n\n\n共享打印机的原理分析\nSPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。\n\n\n当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：\n1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中\n2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。\n\n\n\n当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。\n\n虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。\n\n5.2.5 设备驱动程序接口 要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。这样会使得添加一个新设备驱动程序变得很容易，同时也便于开发人员编制设备驱动程序。\n 对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数。\n 与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。\n 在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I/O设备。系统管理员可以为每个设备设置适当的访问权限。\n5.3 磁盘和固态硬盘5.3.1 磁盘磁盘结构\n\n\n磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据\n\n磁道：磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道\n\n扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”各个扇区存放的数据量相同\n最内侧磁道上的扇区面积最小，因此数据密度最大\n\n盘面：磁盘有多个盘片”摞”起来，每个盘片有两个盘面。\n\n柱面：所有盘面中相对位置相同的磁道组成柱面。\n\n\n如何在磁盘中读/写数据\n需要把“磁头”移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。\n磁盘的物理地址：磁盘地址用“柱面号•盘面号•扇区号”表示，可根据该地址读取一个“块”\n\n①根据“柱面号”移动磁臂，让磁头指向指定柱面；\n②激活指定盘面对应的磁头；\n③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。\n\n磁盘读写时间\n\n寻找时间Ts：在读/写数据前，将磁头移动到指定磁道所花的时间。\n\n①启动磁头臂是需要时间的。假设耗时为s；\n\n②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间\n\nTs=s+ m*n\n\n\n\n\n延迟时间TR：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。\n\n设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间\n\nTR=(1/2)*(1/r)= 1/2r\n硬盘的典型转速为5400 转/分，或7200转/分\n\n\n\n传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间\n\n假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。\n\n则：传输时间\n\nTt=(1/r)*(b/N)= b/(rN)\n\n\n\n\n平均存取时间\n\n总的平均存取时间\nT=Ts + 1/2r + b/(rN)\n\n\n延迟时间和传输时间都与磁盘转速相关，且为线性相关而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间\n\n\n磁盘的分类\n\n磁头是否移动\n磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道\n磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头\n\n\n根据盘片是否可更换\n固定盘磁盘\n可换盘磁盘\n\n\n\n5.3.2 磁盘管理磁盘初始化\n 一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化（或称物理格式化）。\n 低级格式化为每个扇区使用特殊的数据结构，填充磁盘。每个扇区的数据结构通常由头部、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息。\n分区\n在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步：\n\n第一步是，将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的C盘、D盘等形式的分区），每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中\n第二步是，对物理分区进行逻辑格式化（创建文件系统），操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。\n\n因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇（在Linux中称为块）。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是0字节），也要占用一簇的空间。\n引导块\n 计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存， 并转到起始地址，从而开始操作系统的运行。\n 自举程序通常存放在ROM中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。\n\nWindows允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。\n\nWindows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录（MBR）。\n\n引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码。\n除了包含引导代码，MBR还包含：一个磁盘分区表和一个标志（以指示从哪个分区引导系统）\n\n当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。\n\n\n坏块\n由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。\n\n对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明，因此程序不会使用它们。\n对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。\n\n对坏块的处理实质上就是用某种机制使系统不去使用坏块。\n减少磁盘延迟时间的方法\n\n磁盘地址结构的设计：\n\n为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？\n答：读取地址连续的磁盘块时，采用这样的的地址结构可以减少磁头移动消耗的时间\n\n\n方法\n\n交替编号\n\n具体做法：让编号相邻的扇区在物理上不相邻\n原理：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”\n\n\n错位命名\n\n具体做法：让相邻盘面的扇区编号”错位”\n\n原理：与”交替编号”的原理相同。“错位命名法”可降低延迟时间\n\n\n\n\n\n\n5.3.3 磁盘调度算法先来先服务（FCFS）\n根据进程请求访问磁盘的先后顺序进行调度。\n\n\n优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去\n缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。\n\n最短寻找时间优先（SSTF）\nSSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）\n\n\n优点：性能较好，平均寻道时间短\n\n缺点：可能产生“饥饿”现象，磁头有可能在一个小区域内来回来去地移动。\n\nEg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。\n\n\n\n扫描算法（SCAN）\n又称电梯算法，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。\n\n\n优点：性能较好，平均寻道时间较短，不会产生饥饿现象\n缺点：\n①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。\n②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）\n\n\n\nLOOK调度算法\n如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫 LOOK）\n\n\n优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短\n\n循环扫描算法（C-SCAN）\n只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。\n\n\n优点：比起SCAN来，对于各个位置磁道的响应频率很平均。\n缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。\n\nC-LOOK 调度算法\n如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。\n\n\n优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短\n\n5.3.4 固态硬盘固态硬盘的特性\n\n原理：固态硬盘(SSD)是基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM\n\n组成：\n\n\n闪存翻译层：负责翻译逻辑块号，找到对应页（Page）\n存储介质：多个闪存芯片（Flash Chip）；每个芯片包含多个块（block）；每个块包含多个页（page）。\n\n\n读写性能特性：\n\n数据是以页为单位读写的。相当于磁盘的“扇区”\n以块（bock）为单位“擦除“，擦干净的块，其中的每页都可以写一次，读无限次。\n支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址\n读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页\n\n\n与机械硬盘对比\n\nSSD读写速度快，随机访问性能高，用电路控制访问位置；机诚硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟\nSSD安静无噪音、耐摔抗震、能耗低、造价更贵\nSSD的一个”块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉\n\n\n\n磨碎均衡\n思想：将“擦除”平均分布在各个块上，以提升使用寿命\n\n动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。\n静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务\n\n\n例：某固态硬盘采用磨损均衡技术，大小为240B=1TB，闪存块的擦写寿命只有210=1K次。某男子平均每天会对该固态硬盘写237B=128GB数据。在最理想的情况下，这个固态硬盘可以用多久？\nSSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。\n\n1T/128G=8因此，平均8天，每个闪存块需要擦除一次。\n每个闪存块可以被擦除1K次，因此经过8K天，约23年，固态使用到寿命。\n\n","slug":"操作系统","date":"2024-09-01T00:00:00.000Z","categories_index":"理论","tags_index":"","author_index":"Gueason"},{"id":"c8b121ec7894987ab65ba8cb5cccd987","title":"机器学习初级（搬运）","content":"相关学习链接谷歌机器学习教育课程\n线性回归  | Machine Learning  | Google for Developers\n动手学深度学习\nhttps://zh.d2l.ai/index.html\n李沐学AI\nhttps://courses.d2l.ai/zh-v2/\nhttps://space.bilibili.com/1567748478/channel/series\n实用机器学习\nhttps://c.d2l.ai/stanford-cs329p/index.html\n一、绪论1.1 Machine Learning definitionArthur Samuel (1959). Machine Learning: “Field of study that gives computers the ability to learn without being explicitly programmed.”在没有明确设置的情况下，使计算机具有学习能力的研究领域。\nTom Mitchell (1998) Well-posed Learning Problem: “A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.”字幕翻译：计算机程序从经验E中学习解决某一任务T进行某一性能度量P，通过P测定在T上的表现因经验E而提高。\nDeepL：如果一个计算机程序在某个任务T和某个性能指标P方面的性能随着经验E的增加而提高，那么它就被称为从经验E中学习。\n样本(sample)、特征(feature)、标签(label)样本（Sample）是用于描述一个事件或一个对象的记录的集合，也可以理解为模型训练和学习的基础数据单元。\n特征（Feature）是描述一个实例的属性或特点，也可以称为自变量（Independent Variable）或输入变量（Input Variable）。特征构成了机器学习模型的输入部分，用于描述样本或数据点。模型通过学习样本的特征与其对应的标签（或输出）之间的关系来做出预测或分类。\n特征可以是任何类型的数据，包括数字、文本、图像和音频等。根据取值不同，特征可以分为离散特征和连续特征。\n标签（Label）是指与样本相关联的目标值或预期输出。它代表了我们希望模型从输入数据中学习并预测的结果。\n标签可以是离散的类别值，也可以是连续的数值。\n在分类问题中，标签通常表示样本所属的类别或分类结果。例如，在图像分类任务中，标签可以是图片中物体的类别（如“猫”、“狗”等）。\n在回归问题中，标签是连续的数值，代表了某种度量或预测结果，如房价、股票价格或温度预测等。\n标签为机器学习模型提供了明确的训练目标和方向。\n在监督学习任务中，模型需要通过学习从输入数据中提取特征，并将这些特征映射到正确的标签上。\n标签为模型提供了一个明确的标准，使模型能够评估其预测的准确性，并据此调整其参数和结构，以优化其性能。\n每个样本通常由一组特征（Feature）组成，这些特征可以是数值、文本、图像等各种形式的数据。\n样本可以看作是机器学习模型的输入，用于训练和优化模型。\n具体来说，样本是数据集中的一个元素，用于表示一个独立的数据点或实例。\n样本通常包括一个标签（Label），即与样本对应的预期输出或结果。\n模型通过比较预测结果与样本标签之间的差异，来优化自身的参数和结构，从而提高预测性能。\n举一个例子，假设我们正在构建一个用于识别手写数字的图像分类模型。\n在这个例子中，每一张手写数字的图片都可以看作是一个样本。\n每张图片中的像素值、颜色、纹理等信息都可以提取为特征。\n同时，我们还知道每张图片对应的真实数字（如0-9），这就是样本的标签。\n1.2 Supervised Learning1.2.1 Definition\n根据已有的数据集，知道输入和输出结果之间的关系。根据这种已知的关系，训练得到一个最优的模型。\n在监督学习中训练数据既有特征(feature)又有标签(label)，通过训练，让机器可以自己找到特征和标签之间的联系，在面对只有特征没有标签的数据时，可以判断出标签。\n简单理解：可以把监督学习理解为我们教机器如何做事情。\n\n1.2.2 Classification\n监督学习任务主要包括分类和回归两种类型，在监督学习中，数据集中的样本被称为“训练样本”，并且每个样本都有一个输入特征和相应的标签（分类任务）或目标值（回归任务）。\n分类（Classification）： 在分类任务中，目标是将输入数据分到预定义的类别中。每个类别都有一个唯一的标签。算法在训练阶段通过学习数据的特征和标签之间的关系来构建一个模型。然后，在测试阶段，模型用于预测未见过的数据的类别标签。例如，将电子邮件标记为“垃圾邮件”或“非垃圾邮件”，将图像识别为“猫”或“狗”。\n回归（Regression）： 在回归任务中，目标是预测连续数值的输出。与分类不同，输出标签在回归任务中是连续的。算法在训练阶段通过学习输入特征和相应的连续输出之间的关系来构建模型。在测试阶段，模型用于预测未见过的数据的输出值。例如，预测房屋的售价、预测销售量等。\n1.2.3 Common Algorithms\n监督学习算法种类众多，有着极其广泛的应用，下面是一些常见的监督学习算法：\n支持向量机（Support Vector Machine，SVM）：SVM是一种用于二分类和多分类任务的强大算法。它通过找到一个最优的超平面来将不同类别的数据分隔开。SVM在高维空间中表现良好，并且可以应用于线性和非线性分类问题。\n决策树（Decision Trees）：决策树是一种基于树结构的分类和回归算法。它通过在特征上进行递归的二分决策来进行分类或预测。决策树易于理解和解释，并且对于数据的处理具有良好的适应性。\n逻辑回归（Logistic Regression）：逻辑回归是一种广泛应用于二分类问题的线性模型。尽管名字中带有”回归”，但它主要用于分类任务。逻辑回归输出预测的概率，并使用逻辑函数将连续输出映射到[0, 1]的范围内。\nK近邻算法（K-Nearest Neighbors，KNN）：KNN是一种基于实例的学习方法。它根据距离度量来对新样本进行分类或回归预测。KNN使用最接近的K个训练样本的标签来决定新样本的类别。\n1.2.4 Applications\n图像识别：监督学习在图像识别任务中非常常见。例如，将图像分类为不同的物体、场景或动作，或者进行目标检测，找出图像中特定对象的位置。\n自然语言处理：在自然语言处理任务中，监督学习用于文本分类、情感分析、机器翻译、命名实体识别等。\n语音识别：监督学习在语音识别领域被广泛应用，例如将语音转换为文本、说话者识别等。\n医学诊断：在医学领域，监督学习可以用于疾病诊断、影像分析、药物发现等。\n1.3 Unsupervised Learning1.3.1 Definition\n我们不知道数据集中数据、特征之间的关系，而是要根据聚类或一定的模型得到数据之间的关系。\n在无监督学习中数据只有特征(feature)无标签(label)，是一种机器学习的训练方式，它本质上是一个统计手段，在没有标签的数据里可以发现潜在的一些结构的一种训练方式。\n简单理解：比起监督学习，无监督学习更像是自学，让机器学会自己做事情。\n1.3.2 Classification\n聚类（Clustering）：聚类是将数据样本分成相似的组别或簇的过程。它通过计算样本之间的相似性度量来将相似的样本聚集在一起。聚类是无监督学习中最常见的任务之一，常用于数据分析、市场细分、图像分割等。\n降维（Dimensionality Reduction）：降维是将高维数据转换为低维表示的过程，同时尽可能地保留数据的特征。降维技术可以减少数据的复杂性、去除冗余信息，并可用于可视化数据、特征提取等。常见的降维方法有主成分分析（PCA）和t-SNE等。\n关联规则挖掘（Association Rule Mining）：关联规则挖掘用于发现数据集中项之间的关联和频繁项集。这些规则描述了数据集中不同项之间的关联性，通常在市场篮子分析、购物推荐等方面应用广泛。\n异常检测（Anomaly Detection）：异常检测用于识别与大多数样本不同的罕见或异常数据点。它在检测异常事件、欺诈检测、故障检测等领域有着重要的应用。\n1.3.3 Common Algorithms\nK均值聚类（K-Means Clustering）：K均值聚类是一种常用的聚类算法，它将数据样本分成K个簇，使得每个样本与所属簇中心的距离最小化。\n主成分分析（Principal Component Analysis，PCA）：PCA是一种常用的降维算法，它通过线性变换将高维数据投影到低维空间，以保留最重要的特征。\n关联规则挖掘（Association Rule Mining）：关联规则挖掘是一种发现数据集中项之间关联性的方法，它常用于市场篮子分析、购物推荐等领域。\n异常检测（Anomaly Detection）：异常检测算法用于识别与大多数样本不同的罕见或异常数据点。常见的方法包括基于统计的方法、基于聚类的方法和基于生成模型的方法等。\n1.3.4 Applications\n无监督学习在数据挖掘、模式识别、特征学习等应用场景发挥着重要作用。通过无监督学习，我们可以从未标记的数据中获得有用的信息和洞察力，为其他任务提供有益的预处理步骤，并且有助于更好地理解和利用数据。：\n聚类与分组：无监督学习中的聚类算法可以帮助将数据样本分成相似的组别或簇，例如在市场细分中将顾客分成不同的群体、在图像分割中将图像区域分割成不同的物体等。\n特征学习与降维：无监督学习的降维算法如PCA和t-SNE可以用于特征学习和可视化高维数据，例如在图像、音频和自然语言处理中，以及用于数据压缩和可视化。\n异常检测：无监督学习中的异常检测算法可用于发现与大多数数据样本不同的罕见或异常数据点。这在欺诈检测、故障检测和异常事件监测等场景中具有重要应用。\n关联规则挖掘：无监督学习的关联规则挖掘算法可用于发现数据集中项之间的关联性，常应用于市场篮子分析、购物推荐等领域。\n1.4 Semi-supervised Learning1.4.1Definition\n半监督学习的目标是利用同时包含有标签和无标签的数据来构建一个模型，使得模型能够在测试阶段更好地泛化到新的、未见过的数据。\n半监督学习介于监督学习和无监督学习之间。在半监督学习中，训练数据同时包含有标签的数据和无标签的数据。\n与监督学习不同的是，半监督学习的训练数据中只有一小部分样本是带有标签的，而大部分样本是没有标签的。通常情况下，获取带有标签的数据可能会比较昂贵或耗费大量的时间，而采集无标签的数据则相对容易和便宜。\n在半监督学习中，无标签的数据可以起到两个重要作用：\n利用未标记数据的信息：未标记数据可能包含对数据分布、结构和隐含特征的有用信息，这些信息可以帮助模型更好地进行泛化。\n利用标记数据的传播效应：通过利用标记数据与无标签数据之间的数据分布相似性，可以通过传播标签信息到无标签样本，进而增强模型的性能。\n\n1.4.2 Classification\n半监督分类（Semi-supervised Classification）：在半监督分类中，训练数据中同时包含带有标签的样本和无标签的样本。模型的目标是利用这些标签信息和无标签数据的分布信息来提高分类性能。半监督分类算法可以在分类任务中利用未标记数据来扩展有标签数据集，从而提高模型的准确性。\n半监督回归（Semi-supervised Regression）：半监督回归任务与半监督分类类似，但应用于回归问题。模型通过有标签的数据和无标签数据进行训练，以提高对未标记数据的回归预测准确性。\n半监督聚类（Semi-supervised Clustering）：半监督聚类算法将有标签数据和无标签数据同时用于聚类任务。它们可以通过结合数据的相似性信息和标签信息，来更好地识别潜在的簇结构。\n半监督异常检测（Semi-supervised Anomaly Detection）：半监督异常检测任务旨在从同时包含正常样本和异常样本的数据中，利用有限的标签信息来检测异常。这在异常样本较少的情况下特别有用。\n生成对抗网络（GANs）中的半监督学习：GANs可以被用于实现半监督学习。在这种情况下，生成器和判别器网络可以使用有标签和无标签的样本，以提高生成模型的性能。\n1.4.3 Common Algorithms\n半监督学习算法可以在不同的问题和数据集上发挥作用。选择合适的半监督学习算法取决于问题的特性、可用的有标签和无标签数据量，以及算法的性能和复杂度要求。半监督学习在处理数据有限或数据标记成本高昂的场景下具有重要的应用价值。以下是一些常见的半监督学习算法：\n自训练（Self-Training）：自训练是一种简单的半监督学习方法。它通过使用有标签数据训练一个初始模型，然后使用该模型对未标记数据进行预测，并将置信度较高的预测结果作为伪标签，将未标记数据添加到有标签数据中，然后重新训练模型。\n协作训练（Co-Training）：协作训练是一种使用多个视图或特征的半监督学习方法。它通过将数据划分为两个或多个视图，并在每个视图上独立训练模型。然后，模型之间相互交互并使用对方的预测结果来增强训练。\n半监督支持向量机（Semi-Supervised Support Vector Machines）：半监督支持向量机是基于支持向量机的半监督学习方法。它利用有标签数据和未标记数据之间的关系来学习一个更好的分类器。\n生成式半监督学习（Generative Semi-Supervised Learning）：这类方法尝试使用生成模型来建模数据的分布，并利用有标签和无标签数据共同训练生成模型，以提高对未标记数据的预测。\n半监督深度学习：近年来，许多深度学习方法已经扩展到半监督学习。这些方法通过在深度神经网络中引入半监督性质，如半监督自编码器（Semi-Supervised Autoencoders）等，来利用未标记数据的信息。\n图半监督学习（Graph-based Semi-Supervised Learning）：图半监督学习方法利用数据样本之间的关系来辅助半监督学习。这些方法通常利用图模型或图卷积神经网络（GCN）来利用数据的拓扑结构。\n1.4.4 Applications\n半监督学习在许多实际应用场景中具有重要的应用价值，尤其在数据有限或数据标记成本高昂的情况下。以下是一些半监督学习的应用场景：\n自然语言处理：在自然语言处理任务中，很多时候获取大规模的标记数据是非常昂贵和耗时的。半监督学习可以利用少量有标签的文本数据和大量未标签的文本数据来提高文本分类、情感分析、命名实体识别等任务的性能。\n图像识别和计算机视觉：在图像识别和计算机视觉领域，获取大规模的标记图像数据也可能是困难的。半监督学习可以在少量有标签图像和大量未标签图像上进行训练，以提高图像分类、目标检测等任务的准确性。\n数据聚类：在聚类任务中，半监督学习可以将有标签和未标签数据结合起来进行聚类，从而提高聚类结果的准确性和稳定性。\n医学图像和诊断：在医学图像分析和诊断中，获取大量标记的医学图像数据可能是困难的。半监督学习可以在少量有标签医学图像和大量未标签医学图像上进行训练，提高医学图像分割、病变检测等任务的性能。\n机器人控制：在机器人控制领域，半监督学习可以帮助机器人在未知环境中进行自主决策和学习，从而提高其任务执行能力。\n图像生成和数据增强：在生成式模型中，半监督学习可以结合有标签和未标签数据来训练模型，以提高生成模型的质量和多样性。\n1.5 Reinforcement Learning1.5.1Definition\n强化学习是让一个智能体（agent）在环境中通过尝试和错误来学习行为策略。智能体通过与环境进行交互，根据奖励信号来调整其行为策略，以达到最大化累积奖励的目标。\n在强化学习中，智能体不需要明确地告诉如何执行任务，而是通过尝试和错误的方式进行学习。当智能体在环境中采取某个动作时，环境会返回一个奖励信号，表示该动作的好坏程度。智能体的目标是通过与环境交互，学习到一种最优策略，使其在长期累积的奖励最大化。\n1.5.2 Classification\n基于值的强化学习（Value-Based Reinforcement Learning）：基于值的强化学习方法旨在学习价值函数，即给定状态或状态-动作对的值，代表了智能体在该状态或状态-动作对上能够获得的累积奖励的估计值。这些方法通常通过使用贝尔曼方程或其变种来更新价值函数，并使用它来选择动作。\n基于策略的强化学习（Policy-Based Reinforcement Learning）：基于策略的强化学习方法直接学习策略函数，即将状态映射到动作的映射。策略可以是确定性的（对于每个状态只输出一个动作）或是概率性的（对于每个状态输出动作的概率分布）。这些方法通常通过梯度上升方法来更新策略参数，以最大化累积奖励。\n基于模型的强化学习（Model-Based Reinforcement Learning）：基于模型的强化学习方法学习环境的模型，即从状态和动作预测下一个状态和奖励。然后，它可以使用学到的模型进行规划和决策，而无需真实地与环境进行交互。这样可以提高样本效率和规划效率。\n深度强化学习（Deep Reinforcement Learning）：深度强化学习将深度神经网络与强化学习相结合。它通常使用深度神经网络来近似值函数或策略函数。深度强化学习在处理高维状态空间和动作空间的任务时表现出色。\n多智能体强化学习（Multi-Agent Reinforcement Learning）：多智能体强化学习研究多个智能体在相互作用环境中的学习问题。在这种情况下，每个智能体的策略和动作会影响其他智能体的状态和奖励，因此学习变得更加复杂。\n1.5.3 Common Algorithms\nQ-Learning：Q-Learning是一种基于值的强化学习算法。它通过学习一个值函数（Q函数）来表示在给定状态下采取某个动作的累积奖励。Q-Learning使用贝尔曼方程更新Q值，并使用贪心策略来选择动作。\nSARSA：SARSA是另一种基于值的强化学习算法。它与Q-Learning类似，但不同之处在于它在学习和决策阶段都使用当前策略的动作来更新Q值。\nDQN（Deep Q Network）：DQN是一种深度强化学习算法，结合了深度神经网络和Q-Learning。它使用深度神经网络来近似Q函数，通过经验回放和目标网络来稳定训练。\nA3C（Asynchronous Advantage Actor-Critic）：A3C是一种基于策略的强化学习算法，它结合了Actor-Critic方法和异步训练。A3C使用多个智能体并行地训练，以提高样本效率。\nPPO（Proximal Policy Optimization）：PPO是一种基于策略的强化学习算法，它通过限制更新幅度来稳定训练。PPO在深度强化学习中表现出色，并被广泛应用于各种任务。\nTRPO（Trust Region Policy Optimization）：TRPO是另一种基于策略的强化学习算法，它使用限制步长的方法来保证更新策略时不会使性能变差。\n1.5.4 Applications\n强化学习在许多实际应用场景中具有广泛的应用，尤其是那些需要自主决策和学习的任务。强化学习能够使智能体从与环境的交互中学习，并根据学到的知识做出适当的决策，以达到预定的目标或最大化累积奖励。由于强化学习的自主学习和决策特性，它在许多自主系统和智能系统中都有重要的应用潜力。以下是一些强化学习的应用场景：\n自动驾驶：强化学习可以应用于自动驾驶领域，使车辆能够根据环境和交通状况做出决策，例如规划路径、避免障碍物和遵守交通规则。\n机器人控制：强化学习可以帮助机器人在未知环境中进行自主探索和学习，以完成复杂的任务，例如导航、抓取物体和人机交互。\n游戏：强化学习在游戏玩法中有广泛的应用。例如，使用强化学习训练智能体来玩电子游戏、围棋、扑克等，使其能够与人类玩家媲美甚至超越。\n医疗治疗：强化学习可以在医疗领域中应用于个性化治疗和药物治疗决策，根据患者的情况和病情做出合适的治疗计划。\n语音识别和自然语言处理：强化学习可以应用于语音识别和自然语言处理任务，使智能体能够更好地理解和生成自然语言。\n\n二、单变量线性回归（Linear Regression with One Variable）用人话讲明白线性回归LinearRegression - 知乎 (zhihu.com)\n2.1 参数(Parameter)模型参数：模型内部的配置变量，可以通过数据估计（学习）模型参数的值超参数：模型的外部配置变量，需要手动设置，好的超参数可以进一步提高模型的性能\n模型参数的特点：1.进行模型预测时需要模型参数；2.可定义模型功能；3.可使用数据估计/学习得到；4.一般不用手动设置；5.作为学习模型的一部分保留比如：神经网络中的权重，线性回归中的系数\n超参数的特点：1.常应用于估计模型参数的过程中，在开始学习之前就要设置好；训练过程不影响超参数2.通常要手动设置3.通常不能从数据中估计（学习）得到，一般需要通过经验设定；4.定义关于模型的更高层次的概念，如复杂性或学习能力比如：学习率，K邻域中的K\n2.2 训练集（train set）、验证集（validation set）、验证集（validation set）训练集（train set） —— 用于训练模型（拟合参数）：即模型拟合的数据样本集合，如通过训练拟合一些参数来建立一个分类器。\n验证集（validation set）—— 用于确定网络结构或者控制模型复杂程度的超参数（拟合超参数）：是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。 通常用来在模型迭代训练时，用以验证当前模型泛化能力（准确率，召回率等），防止过你话的现象出现，以决定如何调整超参数。具体原理参照本文的二（三）。\n测试集（test set） —— 用来评估模最终模型的性能如何（评价模型好坏）：测试集没有参于训练，主要是测试训练好的模型的准确能力等，但不能作为调参、选择特征等算法相关的选择的依据。说白了就只用于评价模型好坏的一个数据集。\n基于数据集是否参与了训练过程，可通过下图来理解，即测试集完全没参与训练，它只是用于测试，评估模型到底性能如何\n\n\n在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。\n如果数据集仅仅分为训练集和测试集，那么通过修改一些超参数（不能通过学习来自动调整的参数）来降低误差，但是这种方法在实际中的应用效果却并没有想象的那么好。这是因为超参数都是基于测试集来调整的，就相当于把测试集当成了训练超参数的数据。这样对于新的数据效果不一定会更好。\n于是就想出一种解决办法，即保留一个数据集作为验证集，在这些步骤做完之后再进行最终的验证。\n\n2.3 交叉验证（Cross-Validation）     交叉验证是在机器学习建立模型和验证模型参数时常用的办法，一般被用于评估一个机器学习模型的表现。更多的情况下，我们也用交叉验证来进行模型选择(model selection)。\n     交叉验证把得到的样本数据进行切分，组合为不同的训练集和测试集，用训练集来训练模型，用测试集来评估模型预测的好坏。在此基础上可以得到多组不同的训练集和测试集，某次训练集中的某样本在下次可能成为测试集中的样本。\n     交叉验证用在数据不是很充足的时候。如果数据样本量小于一万条，我们就会采用交叉验证来训练优化选择模型。如果样本大于一万条的话，我们一般随机的把数据分成三份，一份为训练集（Training Set），一份为验证集（Validation Set），最后一份为测试集（Test Set）。用训练集来训练模型，用验证集来评估模型预测的好坏和选择模型及其对应的参数。把最终得到的模型再用于测试集，最终决定使用哪个模型以及对应参数。\n留出法 （holdout cross validation）\n随机的将样本数据分为两部分（比如： 70%的训练集，30%的测试集），然后用训练集来训练模型，在测试集上验证模型及参数。接着，我们再把样本打乱，重新选择训练集和测试集，继续训练数据和检验模型。最后选择损失函数评估最优的模型和参数。\nk 折交叉验证（k-fold cross validation）\nk 折交叉验证通过对 k 个不同分组训练的结果进行平均来减少方差， 因此模型的性能对数据的划分就不那么敏感。\n\n第一步，不重复抽样将原始数据随机分为 k 份。\n第二步，每一次挑选其中 1 份作为测试集，剩余 k-1 份作为训练集用于模型训练。\n第三步，重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集。在每个训练集上训练后得到一个模型，用这个模型在相应的测试集上测试，计算并保存模型的评估指标，\n第四步，计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标。k 一般取 10， 数据量小的时候，k 可以设大一点，这样训练集占整体比例就比较大，不过同时训练的模型个数也增多。 数据量大的时候，k 可以设小一点。\n\n\n\n留一法（Leave one out cross validation）\n当 k＝m 即样本总数时， 每次的测试集都只有一个样本，要进行 m 次训练和预测。\n这个方法用于训练的数据只比整体数据集少了一个样本，因此最接近原始样本的分布。 但是训练复杂度增加了，因为模型的数量与原始数据样本数量相同。 一般在数据缺乏时使用。 样本数很多的话，这种方法开销很大。\nBootstrap\n\n数据假设要分成10组，则先设置一个采样比例，比如采样比例70%。则10组数据是每次从原始数据集中随机采样总数70%的数据构成训练集1，没有选中的样本作为测试集1；然后把数据放回，再随机采样总数70%的数据构成训练集2，没选中的作为测试集2……以此类推，放回式采样10组。\n训练生成10个模型\n计算平均测试误差来评估当前参数下的模型性能\n\n2.4 损失函数/代价函数（Loss/Cost Function）在机器学习中，损失函数是代价函数的一部分，而代价函数则是目标函数的一种类型。\n损失函数(Loss Function)： 用于定义单个训练样本与真实值之间的误差，也就是就算一个样本的误差，比如我们想要分类，就是预测的类别和实际类别的区别，是一个样本的哦，用L表示。代价函数(Cost Function)： 用于定义单个批次/整个训练集样本与真实值之间的误差，也就是所有样本的误差的总和的平均，也就是损失函数的总和的平均，有没有这个平均其实不会影响最后的参数的求解结果。目标函数(Objective Function)： 泛指任意可以被优化的函数。\n在机器学习中，我们想让预测值无限接近于真实值，所以需要将差值降到最低（在这个过程中就需要引入损失函数）。而在此过程中损失函数的选择是十分关键的，在具体的项目中，有些损失函数计算的差值梯度下降的快，而有些下降的慢，所以选择合适的损失函数也是十分关键的。\n每一个样本经过模型后会得到一个预测值，然后得到的预测值和真实值的差值就成为损失（当然损失值越小证明模型越是成功），我们知道有许多不同种类的损失函数，这些函数本质上就是计算预测值和真实值的差距的一类型函数，然后经过库（如pytorch，tensorflow等）的封装形成了有具体名字的函数。\n输入的feature（或称为x）需要通过模型（model）预测出y，此过程称为向前传播（forward pass），而要将预测与真实值的差值减小需要更新模型中的参数，这个过程称为向后传播（backward pass），其中我们损失函数（lossfunction）就基于这两种传播之间，起到一种有点像承上启下的作用，承上指：接収模型的预测值，启下指：计算预测值和真实值的差值，为下面反向传播提供输入数据。\n2.4.1回归损失(Regression Loss)L1 Loss也称Mean Absolute Error，即平均绝对误差(MAE)，计算预测值与真实值的差的绝对值，衡量预测值与真实值之间距离的平均误差幅度，范围为0到正无穷。\n\n\nHypotheis:\n\n\n\nParameters:\n​                                                                          θ0,θ1\n\n\n\nCost function:\n\n\n\nGoal:\n\n\n优点：\nL1损失函数对离群点（Outliers）或者异常值更具有鲁棒性。\n缺点：\n在零处不可导，求解效率低，收敛速度慢；梯度始终相同，即使很小的损失值，梯度也很大，这样不利于模型的收敛。针对它的收敛问题，一般的解决办法是在优化算法中使用变化的学习率，在损失接近最小值时降低学习率。\nL2 Loss也称为Mean Squred Error，即均方差(MSE)，计算的是预测值与真实值之间距离的平方和，范围同为0到正无穷。\n\n优点：\n收敛速度快，能够对梯度给予合适的惩罚权重，而不是“一视同仁”，使梯度更新的方向可以更加精确。缺点：\n对异常值十分敏感，梯度更新的方向很容易受离群点所主导，不具备鲁棒性。\n2.4.2分类损失(Classification Loss)Entropy\n熵（信息熵），它可以很好地描述事件的不确定性，衡量的是得到的信息量的期望。同时也反映了在给定概率分布p中样本值的平均信息量的条件下，它的概率分布有多不可预测。一个事件的不确定性就越大，其信息量越大，它的信息熵就越高。\n交叉熵损失（Cross-entropy loss）衡量了模型预测结果与实际结果之间的差距，是优化模型参数的关键指标之一。交叉熵损失的公式如下： \n\nK-L DivergenceKL散度。对于交叉熵损失，除了我们在这里使用预测概率的对数（log(q(i))）外，它看起来与上面熵的方程非常相似。 如果我们的预测是完美的，那就是预测分布等于真实分布，此时交叉熵就等于熵。 但是，如果分布不同，则交叉熵将比熵大一些位数。交叉熵超过熵的量称为相对熵，或更普遍地称为库尔贝克-莱布里埃发散度（KL Divergence）。总结如下：\n\n2.5 梯度下降(Gradient Descent)梯度下降通过不断迭代计算函数的梯度，判断该点的某一方向和目标之间的距离，最终求得最小的损失函数和相关参数，为建立线性模型提供支持。\n梯度下降是一种广泛用于求解线性和非线性模型最优解的迭代算法，它的中心思想在于通过迭代次数的递增，调整使得损失函数最小化的权重。\n它的作用是用于优化一个目标函数，如果要最小化一个损失函数，使用的就是梯度下降法，如果要最大化一个效用函数，使用的是梯度上升法。\n作用：\n\n梯度下降梯度下降的目的就是求函数的极小值点，最小化损失函数。\n\n\n损失函数就是一个自变量为算法的参数，函数值为误差值的函数。所以梯度下降就是找让误差值最小时候算法取的参数。\n\n找到 J（θ）的最小值：\n\nJ(θ)的真正图形类似是一个凸函数，只有一个全局最优解，所以不必担心像上图一样找到局部最优解\n\n思想：\n先任取点（x0,f(x0))，求f(x)在该点x0的导数f’(x0),在用x0减去导数值f’(x0),计算所得就是新的点x1,然后再用x1减去f’(x1)得x2…。\n以此类推，循环多次，改变x的值使得导数的绝对值变小，无限接近极小值点。\n当导数小于0时候，让目前x值大一点点，再看它导数值。\n当导数大于0时候，让目前x值减小一点点，再看它导数值。\n当导数接近0时候，就得到想要的自变量x了。也就是说找到这个算法最佳参数，使得拟合曲线与真实值误差最小。\n官方点讲大概意思就是：梯度下降就是找让误差值最小时的算法取的参数\n\n损失函数的梯度（即偏导数）为\n\n按参数 θ 的梯度负方向，来更新θ，即梯度下降算法为\nrepeat until convergence {\n\n}\nα在梯度下降算法中被称作为学习率或者步长，a的大小，如果a太小，则迭代很多次才找到最优解，若a太大，可能跳过最优解。\n\n另外，在不断迭代的过程中，梯度值会不断变小，所以θ1的变化速度也会越来越慢，所以不需要使速率a的值越来越小。它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，所以在下图的梯度下降过程中可以看到，它是一个近乎直线的下降过程，直接前往最低点。\n\n当梯度下降到一定数值后，每次迭代的变化很小，这时可以设定一个阈值，只要变化小鱼该阈值，就停止迭代，而得到的结果也近似于最优解。\n\n算法求解过程：\n1）确定当前位置的损失函数的梯度，对于θi,其梯度表达式如下：\n\n2）用步长乘以损失函数的梯度，得到当前位置下降的距离\n3）确定是否所有的θi,梯度下降的距离都小于ε，如果小于ε则算法终止，当前所有的θi(i=0,1,…n)即为最终结果。否则进入步骤4\n4）更新所有的θ，对于θi，其更新表达式如下。更新完毕后继续转入步骤1.\n\n注意：\n\n更新方程时需要同时更新θ\n\n先同时计算右边部分，然后同时更新θ\n\n\n下面用线性回归的例子来具体描述梯度下降\n假设我们的样本是\n\n损失函数如前面先决条件所述：\n\n则在算法过程步骤1中对于θi 的偏导数计算如下：\n!\n由于样本中没有x0上式中令所有的xj0为1.\n步骤4中θi的更新表达式如下：\n\n\n三、多变量线性回归(Linear Regression with Multiple Variables)3.1 向量化（vectorization）向量化就是非常简单的去除for循环，在代码中使用for循环会让算法变得非常低效。在深度学习的领域中，我们的数据集是非常非常庞大的，如果使用for循环的话，那么代码的运行会花费很长很长的时间。由于numpy中的dot函数通过计算机硬件实现向量化，所以计算机可以在t0时得到向量w和x的所有值，并且同时将w和x相乘，然后在t1，计算机调用专门的硬件去计算这16个数字的和，而不需要一个接一个的做加法运算了，在大型数据集上使用向量可以更快的更高效的运行算法。\n\n举例\n在线性回归的初级版本中，只有一个特征x（房子的大小），可以预测y（房子的价格），所以该模型是fw,b(x)=wx+b，现在不仅考虑这一个特征，还知道其他特征，比如卧室数量、楼层数量以及房子年代来预测房子的价格使用x1 x2 x3 x4来表示这4个特征。\n\n\n\nw和b两个向量之间点积运算，就是w1x1 +w2x2 +w3x3 +……+wnxn下面的表达式和上面的表达式是一样的，点积表示法可以让我们用更少的字符，更紧凑的表示模型。这种具有多个输入特征的线性回归称为多元线性回归，这与只有一个特征变量的回归形成对比，将这个模型称为多元线性回归。\n3.2 用于多元线性回归的梯度下降法\n\n3.3 特征缩放（Feature Scaling）特征向量（Eigenvector）特征向量：一个向量经过线性变换，仍留在它所张成的空间中\n特征值：描述特征向量经过线性变换后的缩放程度\n大部分的向量经过线性变换都离开了它所张成的空间。 如图中黄色的向量经过线性变换 [3102] ,离开了它所张成的通过原点的直线张成的空间。\n\n\n但是也有一部分向量留在了它所张成的空间，这样线性变换起到的作用就是压缩或者拉升如：\n特别的, 对于 [−11] 经过线性变换 [3102] ，相当于将该向量拉升了两倍。\n对于处在它所在的对角线上的任何向量也仅被拉伸了2倍。\n他们的共同点就是线性变换后留在了原来向量所张成的线性空间里边， 对于其他的向量则离开他原来张成的向量空间\n\n\n因此将这些特殊的向量称为“特征向量” ， 每个特征向量都有一个对应的值，称为“特征值”，目的是衡量特征向量经过变换后的压缩或者拉伸因子。\n\n特征缩放意义在机器学习算法处理数据时通常是忽略数据的单位信息的，或者说不知道这些数据代表什么。比如50kg和50公里代表着两个不同的度量，人类是很容易区分它们的。但是对于机器来说，这两个数据是一样的。\n特征矩阵各个维度的取值通常是不一样的，此时如果采用欧几里得距离来衡量两个特征的距离，那么最终的距离将严重取决于取值范围跨度大的特征维度，比如说在代表人属性的特征向量有两个维度，分别是年龄和身高，其中年龄的取值范围可以是[1, 100]，身高的取值范围是[0.4, 2.5]（单位：米），那么两个特征向量的距离将严重取决于年龄这个特征，身高基本上对两者的距离没有太大的影响。但通常我们不希望我们的算法一开始就偏向于某个特征。\n\n数量级的差异将导致量级较大的属性占据主导地位\n数量级的差异将导致迭代收敛速度减慢\n依赖于样本距离的算法对于数据的数量级非常敏感\n\n好处：\n\n缩放后的特征矩阵，各个维度都具有相同的重要性\n\n加快梯度下降，同时防止梯度爆炸(消除过大值的影响)\n\n提升模型的精度：在机器学习算法的目标函数中使用的许多元素（例如支持向量机的 RBF 内核或线性模型的 l1 和 l2 正则化)，都是假设所有的特征都是零均值并且具有同一阶级上的方差。如果某个特征的方差比其他特征大几个数量级，那么它就会在学习算法中占据主导位置，导致学习器并不能像我们期望的那样，从其他特征中学习\n\n提升收敛速度：对于线性模型来说，数据归一化后，寻找最优解的过程明显会变得平缓，更容易正确地收敛到最优解\n\n标准化（Standardization/Z-Score Normalization）将数据变换为均值为0，标准差为1的分布切记，并非一定是正态的；                                                            \nStandardization会改变数据的均值、标准差(严格的说，均值和标准差变了，分布也是变了，但分布种类依然没变，原来是啥类型，现在就是啥类型)，实际数据大部分都是正态分布或近似正态，但本质上的分布并不一定是标准正态，完全取决于原始数据是什么分布。\n归一化（Rescaling/Normalization）将一列数据变化到某个固定区间(范围)中，通常，这个区间是[0, 1]，广义上，可以是各种区间，比如映射到[0，1]一样可以继续映射到其他范围，图像中可能会映射到[0,255]，其他情况可能映射到[-1,1]；\n\n均值归一化(Mean Normalization)将数值范围缩放到[ − 1 , 1 ]区间里，数据的均值变为0 \n​                                                         \n差异第一点：显而易见，Normalization会严格的限定变换后数据的范围，比如按之前最大最小值处理的Normalization，它的范围严格在[ 0 , 1 ]之间；而Standardization就没有严格的区间，变换后的数据没有范围，只是其均值是0，标准差为1。\n第二点：归一化(Normalization)对数据的缩放比例仅仅和极值有关，就是说比如100个数，你除去极大值和极小值其他数据都更换掉，缩放比例α=Xmax-Xmin是不变的；反观，对于标准化(Standardization)而言，它的α=σ，β = μ，如果除去极大值和极小值其他数据都更换掉，那么均值和标准差大概率会改变，这时候，缩放比例自然也改变了。\n如果你对处理后的数据范围有严格要求，那肯定是归一化，个人经验，标准化是ML中更通用的手段，如果你无从下手，可以直接使用标准化；如果数据不为稳定，存在极端的最大最小值，不要用归一化。在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，标准化表现更好；在不涉及距离度量、协方差计算的时候，可以使用归一化方法。\n3.4 多项式回归 多项式回归（Polynomial Regression）是线性回归（Linear Regression）的一种扩展形式。它通过在输入变量上添加高次项来拟合非线性关系。虽然多项式回归本质上还是线性模型，但它允许模型在输入特征的多项式基础上进行线性拟合，从而捕捉复杂的非线性关系。\n\n​              \n\n多项式回归的步骤\n选择多项式的阶数：选择合适的多项式阶数 n 是模型拟合的关键。阶数过低可能会导致欠拟合，阶数过高则可能导致过拟合。\n构建多项式特征：将输入特征扩展为多项式特征。例如，对于一个一维特征 x，构建的特征矩阵为\n\n拟合模型：使用线性回归方法在多项式特征上进行拟合。\n评估模型：通过均方误差（MSE）等指标评估模型的性能。\n3.5 正规方程正规方程公式：\n\n y，其中 是特征值矩阵，y是目标值矩阵。\n优点：正规方程可以直接求出最好结果（即最小损失）\n缺点：由于涉及到矩阵运算，当特征过多时矩阵运算变得很复杂，求解速度会很慢。所以只适用于小数据量。\n\n\n\n四、逻辑回归（Logistic Regression）4.1 理论推导线性回归拟合的是数值，并不符合我们预测类别的需求。但数值与类别也是有关联的。例如，天色越黑，下雨概率就越大。即值越大，属于某类别的概率也越大。值与概率之间可以互转。\n1、问题描述和转化\n\n一个二分类问题给的条件：\n\n分类标签Y {0，1}，特征自变量X{x1，x2，……，xn}\n如何根据我们现在手头上有的特征X来判别它应该是属于哪个类别（0还是1）\n\n问题的求解转化为：\n\n我们如何找一个模型，即一个关于X的函数来得出分类结果（0或1）\n2、初步思路：找一个线性模型来由X预测Y\n\n但是很明显，这样的函数图像是类似一条斜线，难以达到我们想要的（0或1）的取值\n所以我们引入了一个特殊的函数：\n3、Sigmoid函数（逻辑函数）公式\n\n函数图像\n\n4、刚刚的线性模型与Sigmoid函数合体\n\n这样我们就把取值控制在了0或1上，初步达成了我们的目标。\n5、条件概率\n我们令 ，则可得 \n若我们将y视为样本x作为正例的概率，那么1-y则为样本x作为反例的概率，二者的比值为，\n因此  被称为对数几率。\n因此有：\n所以推出了：\n\n可化简为：\n\n\n假设每个样本是独立事件，则总评估正确的概率为所有样本评估正确的积：\n\n\n 损失函数\n\n\n求最小值时的w\n梯度下降法（一阶收敛）\n通过 J(w) 对 w 的一阶导数来找下降方向，并以迭代的方式来更新参数\n\n(这里的k代表的是第k次迭代；是我们设定的学习率；就是我们上面所说的 )\n4.2 决策边界（Decision Boundary）利用训练好的模型对样本空间所有的坐标点进行预测，然后观察样本空间所有点的不同类别之间的边界，最终就是模型的决策边界。\n在二分类问题中，决策边界或决策表面是超曲面，其将基础向量空间划分为两个集合，一个集合。 分类器将决策边界一侧的所有点分类为属于一个类，而将另一侧的所有点分类为属于另一个类。可以通过绘制模型决策边界，来辅助判别分类模型的模型性能。\n不同模型的决策边界并不相同，逻辑回归在二维样本空间中的决策边界是一条直线，KNN模型决策边界实际上是一个个圆圈叠加而成的拥有一定幅度的边界，而对于决策树模型来说，其决策边界实际上是一条条折线。\n基于反向传播的人工神经网络或感知器的情况下，网络可以学习的决策边界的类型由网络具有的隐藏层的数量来确定。如果它没有隐藏层，那么它只能学习线性问题。如果它有一个隐藏层，则它可以学习Rn的紧致子集上的任何连续函数 ，如通用近似定理所示，因此它可以具有任意的决策边界。\n神经网络试图学习决策边界，最小化经验误差，而支持向量机试图学习决策边界，最大化决策边界和数据点之间的经验边际。\n阈值\n阈值的理解可以浅显的认为，相当于一个边界线，大于这个边界线是一个结果，小于这个边界线则是另一个结果。在逻辑回归中，大于这个边界线就是1，小于这个边界线则就是0。\n拿 sigmoid 函数举例\n当 x = 0 时为 sigmoid function 的决策边界。即所有 x &gt; 0 的部分 g ( x ) = 1，所有 x &lt; 0的部分 g ( x ) = 0。\n引用到 逻辑回归\ndecision boundary为 z = 0 z=0z=0 的时候，即 0.5 x + 1 = 0 0.5x+1=00.5x+1=0 时。\n五、正则化（Regularization）5.1 过拟合（overfitting）、欠拟合（underfitting）回归模型：\n\n分类模型：\n\n\n欠拟合\n泛化能力差，拟合程度比较低，训练样本集准确率低，测试样本集准确率低。\n欠拟合原因：\n\n训练样本数量少\n模型复杂度过低\n参数还未收敛就停止循环\n\n欠拟合的解决办法：\n\n增加样本数量\n增加模型参数，提高模型复杂度\n增加循环次数\n查看是否是学习率过高导致模型无法收敛\n\n过拟合\n泛化能力差，拟合程度非常高，训练样本集准确率高，测试样本集准确率低。\n过拟合原因：\n\n样本量少、样本噪声大（质量不好）\n特征太多\n模型太复杂或模型本身就不适用\n网络层数过多，导致后面学习得到的特征不够具有代表性\n\n过拟合的表现（判定方法）：\n\n训练集的正确率不增反减\n\n验证集的正确率不再发生变化\n\n训练集的error一直下降，但是验证集的error不减反增\n\n\n过拟合的解决办法：\n\n清洗数据\n减少模型参数，降低模型复杂度，包括greedy constructive learning、剪枝和权重共享等\n增加惩罚因子（正则化），保留所有的特征，但是减少参数的大小（magnitude）。\n\n5.2 正则化方法5.2.1 L1 正则化也称为 Lasso 正则化，是指权值向量w中各个元素的绝对值之和。比如 向量A=[1，-1，3]， 那么A的L1范数为 |1|+|-1|+|3|。它通过在模型的损失函数中增加权重的 L1 范数（权重向量的绝对值之和）来实现正则化。L1正则化可以让一部分特征的系数缩小到0，所以L1适用于特征之间有关联的情况可以产生稀疏权值矩阵（很多权重为0，则一些特征被过滤掉），即产生一个稀疏模型，可以用于特征选择。\nL1 正则化是一种通过在模型的损失函数中增加权重的 L1 范数作为惩罚项来控制模型复杂度的技术。L1 范数是向量中各个元素的绝对值之和，其数学表示如下：\n\n惩罚项可以写为权重的 L1 范数：\n\n其中 w是模型的权重向量，n是权重向量的长度，即权重的数量， λ是正则化参数，用于控制正则化的强度。\n线性回归L1正则化损失函数：\n\n正则化是权值的绝对值之和，所以L1是带有绝对值符号的函数，因此是不完全可微的。机器学习的任务就是要通过一些方法（比如梯度下降）求出损失函数的最小值。当我们在原始损失函数后添加L1正则化项时，相当于对损失函数做了一个约束。\nL1正则化可以使得参数稀疏化，即得到的参数是一个稀疏矩阵，可以用于特征选择。\n稀疏性，就是模型的很多参数是0。通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，很多参数是0，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，即使去掉对模型也没有什么影响，此时我们就可以只关注系数是非零值的特征。这相当于对模型进行了一次特征选择，只留下一些比较重要的特征，提高模型的泛化能力，降低过拟合的可能。\n5.2.2 L2 正则化也称为 Ridge 正则化，它通过在模型的损失函数中增加权重的 L2 范数（权重向量的平方和）来实现正则化。L2 正则化会使权重值变得较小，但不会直接导致权重稀疏，因此不具有特征选择的作用，但可以有效地控制模型的复杂度。\nL2正则化通过向模型的损失函数添加一个权重参数的 L2 范数的惩罚项来实现。用 L2 正则化的损失函数时，优化算法在优化过程中会同时考虑数据损失和正则化项，从而在保持对训练数据的拟合能力的同时，尽可能减小模型参数的大小，降低模型的复杂度。\n线性回归L2正则化损失函数：\n\n拟合过程中通常都倾向于让权值尽可能小，数据偏移得多一点也不会对结果造成什么影响，抗扰动能力强。\nL2正则化获得更小参数过程：\n(1) 以线性回归中的梯度下降法为例。假设要求的参数为θ，hθ(x)是假设函数，线性回归的代价函数如下：\n\n(2)在梯度下降中θ的迭代公式为：\n\n(3)在原始代价函数之后添加L2正则化，则迭代公式为：\n\n从上式可以看到，与未添加L2正则化的迭代公式相比，每一次迭代，θj都要先乘以一个小于1的因子，从而使得θj不断减小，因此总得来看，θ是不断减小的。\n调参经验从0开始，逐渐增大λ。在训练集上学习到参数，然后在测试集上验证误差。反复进行这个过程，直到测试集上的误差最小。一般的说，随着λ从0开始增大，测试集的误分类率应该是先减小后增大，交叉验证的目的，就是为了找到误分类率最小的那个位置。建议一开始将正则项系数λ设置为0，先确定一个比较好的learning rate。然后固定该learning rate，给λ一个值（比如1.0），然后根据validation accuracy，将λ增大或者减小10倍，增减10倍是粗调节，当你确定了λ的合适的数量级后，比如λ=0.01，再进一步地细调节，比如调节为0.02，0.03，0.009之类。\n5.2.3 Dropout可先跳至神经网络一章\n正常神经网络需要对每一个节点进行学习，而添加了DropOut的神经网络先随机选择中的一些神经元并将其临时隐藏(丢弃)，即暂时将其从网络中移除，以及它的所有传入和传出连接。在下一次迭代中，继续随机隐藏一些神经元，如此直至训练结束。由于是随机丢弃，故而每一个mini-batch都在训练不同的网络。\n将DropOut应用于神经网络相当于从神经网络中采样了一个“更薄的”网络，即单元个数较少。（如下图所示，DropOut是从左图采样了一个右图这样更薄的网络）在正反向传播的过程中，采样了多个稀薄网络，即Dropout可以解释为模型平均的一种形式。\n\n　在训练时，每个神经单元以概率pp被保留(Dropout丢弃率为1−p)；在预测阶段（测试阶段），每个神经单元都是存在的，权重参数w要乘以p，输出是：pw。\n模型描述\n前提：带有L层隐藏层的神经网络。\nl：第几层。z： 代表输入向量y： 代表输出向量W：代表权重b：偏差f： 激活函数\n没有DropOut的神经网络前向传播计算公式可以被描述为：l+1层的输入向量是l+1的权重乘以l层的输出向量加l+1层的偏差。l+1层的输出向量为经过激活函数的l+1层的输入向量。\n\n添加DropOut的神经网络前向传播计算公式可以被描述为：相比于之前输出向量经过了伯努利分布，类似于经过一个门筛选了一下。*代表的是点积。\n\n神经网络图描述\n神经网络图示如下所示：上图为标准的神经网络，下图为添加了Dropout的神经网络，相比于标准的神经网络，添加了Dropout的神经网络相当于为前一层的输出向量添加了一道概率流程，即是否经过筛选。\n\n\n防止过拟合原因\n（1）取平均的作用 \n　　先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。\n（2）减少神经元之间复杂的共适应关系\n　　用作者原话是“在标准神经网络中，每个参数接收的导数表明其应该如何变化才能使最终损失函数降低，并给定所有其它神经网络单元的状态。因此神经单元可能以一种可以修正其它神经网络单元的错误的方式进行改变。而这就可能导致复杂的共适应(co-adaptations)。由于这些共适应现象没有推广到未见的数据，将导致过拟合。我们假设对每个隐藏层的神经网络单元，Dropout通过使其它隐藏层神经网络单元不可靠从而阻止了共适应的发生。因此，一个隐藏层神经元不能依赖其它特定神经元去纠正其错误。”\n　　 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。\n（3）Dropout类似于性别在生物进化中的角色\n　　物种为了生存往往会倾向于适应这种环境，环境突变则会导致物种难以做出及时反应，性别的出现可以繁衍出适应新环境的变种，有效的阻止过拟合，即避免环境改变时物种可能面临的灭绝。\n\n六、神经网络（Neural Network）6.1 前言神经网络主要由：输入层，隐藏层，输出层构成。当隐藏层只有一层时，该网络为两层神经网络，由于输入层未做任何变换，可以不看做单独的一层。实际中，网络输入层的每个神经元代表了一个特征，输出层个数代表了分类标签的个数（在做二分类时，如果采用sigmoid分类器，输出层的神经元个数为1个；如果采用softmax分类器，输出层神经元个数为2个；如果是多分类问题，即输出类别&gt;=3时，输出层神经元为类别个数），而隐藏层层数以及隐藏层神经元是由人工设定。一个基本的两层神经网络可见下图（注意：说神经网络多少层数的时候一般不包括输入层。 在神经网络中的激活主要讲的是梯度的更新的激活）：\n\n神经元模型是一个包含输入，输出与计算功能的模型。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。\n　　下图是一个典型的神经元模型：包含有3个输入，1个输出，以及2个计算功能。\n　　注意中间的箭头线。这些线称为“连接”。每个上有一个“权值”。\n\n我们使用a来表示输入，用w来表示权值。一个表示连接的有向箭头可以这样理解：在初端，传递的信号大小仍然是a，端中间有加权参数w，经过这个加权后的信号会变成a * w。\n\n在MP模型里，函数g是sgn函数，也就是取符号函数。这个函数当输入大于0时，输出1，否则输出0。\n　　下面对神经元模型的图进行一些扩展。首先将sum函数与sgn函数合并到一个圆圈里，代表神经元的内部计算。其次，把输入a与输出z写到连接线的左上方，便于后面画复杂的网络。最后说明，一个神经元可以引出多个代表输出的有向箭头，但值都是一样的。\n　　神经元可以看作一个计算与存储单元。计算是神经元对其的输入进行计算功能。存储是神经元会暂存计算结果，并传递到下一层。\n\n当我们用“神经元”组成网络以后，描述网络中的某个“神经元”时，我们更多地会用“单元”（unit）来指代。同时由于神经网络的表现形式是一个有向图，有时也会用“节点”（node）来表达同样的意思。 \n6.2 单层神经网络（感知器 Perception）在“感知器”中，有两个层次。分别是输入层和输出层。输入层里的“输入单元”只负责传输数据，不做计算。输出层里的“输出单元”则需要对前面一层的输入进行计算。\n在原来MP模型的“输入”位置添加神经元节点，标志其为“输入单元”。其余不变，于是我们就有了下图：从本图开始，我们将权值w1, w2, w3写到“连接线”的中间。\n\n下图显示了带有两个输出单元的单层神经网络\n\n\n\n输入的变量是[a1，a2，a3]T（代表由a1，a2，a3组成的列向量），用向量a来表示。方程的左边是[z1，z2]T，用向量z来表示。\n系数则是矩阵W（2行3列的矩阵，排列形式与公式中的一样）。\n于是，输出公式可以改写成： g(W  a) = *z;\n6.3 两层神经网络（多层感知器MLP Multilayer Perceptron）两层神经网络除了包含一个输入层，一个输出层以外，还增加了一个中间层。此时，中间层和输出层都是计算层。\n\n\n矩阵计算公式：\n g(W(1)  a(1)) = *a(2)\ng(W(2)  a(2)) = *z\n偏置节点（bias unit）是默认存在的。它本质上是一个只含有存储功能，且存储值永远为1的单元。在神经网络的每个层次中，除了输出层以外，都会含有这样一个偏置单元。正如线性回归模型与逻辑回归模型中的一样。\n偏置单元与后一层的所有节点都有连接，我们设这些参数值为向量b\n\n矩阵运算公式：\ng(W(1)  a(1) + b(1)) = *a(2)\ng(W(2)  a(2) + b(2)) = *z\n在两层神经网络中，我们不再使用sgn函数作为函数g，而是使用平滑函数sigmoid作为函数g\n6.4 普通多层神经网络在两层神经网络的输出层后面，继续添加层次。原来的输出层变成中间层，新加的层次成为新的输出层。所以可以得到下图。\n依照这样的方式不断添加，我们可以得到更多层的多层神经网络。公式推导的话其实跟两层神经网络类似，使用矩阵运算的话就仅仅是加一个公式而已。\n在已知输入a(1)，参数W(1)，W(2)，W(3)的情况下，输出z的推导公式如下：\ng(W(1)  a(1)) = *a(2); \ng(W(2)  a(2)) = *a(3);\ng(W(3)  a(3)) = *z;\n\nW(1)中有6个参数，W(2)中有4个参数，W(3)中有6个参数，所以整个神经网络中的参数有16个（这里我们不考虑偏置节点，下同）。\n假设我们将中间层的节点数做一下调整。第一个中间层改为3个单元，第二个中间层改为4个单元。\n经过调整以后，整个网络的参数变成了33个。\n\n\n6.5 激活函数（Activation Function）神经元中使用的函数，在术语上通常叫做激活函数。主要的激活函数有step,sigmoid,softmax,tanh和ReLU等\n每一个隐藏层可以有一个不同的激活函数，例如，在同一个神经网络中，隐藏层layer1可能使用sigmoid函数，隐藏层layer2可能使用ReLU，后续的隐藏层layer3使用Tanh。激活函数的选择取决于待解决的问题以及使用的数据的类型。\n阶跃函数\n\n其中，如果x的值大于等于零，则输出为1；如果x的值小于零，则输出为0。我们可以看到阶跃函数在零点是不可微的。目前，神经网络采用反向传播法和梯度下降法来计算不同层的权重。由于阶跃函数在零处是不可微的，因此它并不适用于梯度下降法，并且也不能应用在更新权重的任务上。 为了克服这个问题，我们引入了sigmoid函数。\nSigmoid函数\n\n当z或自变量趋于负无穷大时，函数的值趋于零；当z趋于正无穷大时，函数的值趋于1。该函数表示因变量行为的近似值，并且是一个假设。\n用Sigmoid函数作为近似函数之一的原因：\n\n它在可以捕获数据的非线性。虽然是一个近似的形式，但非线性的概念是模型精确的重要本质。\n\nsigmoid函数在整个过程中是可微的，因此可以与梯度下降和反向传播方法一起使用，以计算不同层的权重。\n\n假设一个因变量服从一个sigmoid函数的固有假设的高斯分布的自变量，这是一个一般分布，我们可以获得许多随机发生的事件，这是一个好的的一般分布开始。\n\n\n然而，sigmoid函数也面临着梯度消失的问题。从图中可以看出，一个sigmoid函数将其输入压缩到一个非常小的输出范围[0,1]，并具有非常陡峭的渐变。因此，输入空间中仍然有很大的区域，即使是很大的变化也会在输出中产生很小的变化。这被称为梯度消失问题。这个问题随着层数的增加而增加，从而使神经网络的学习停留在一定的水平上。\nSoftmax函数\nsoftmax函数是用于多类分类问题的激活函数，在多类分类问题中，超过两个类标签则需要类成员关系。对于长度为K的任意实向量，Softmax函数可以将其压缩为长度为K，值在[ 0 , 1 ] 范围内，并且向量中元素的总和为1的实向量。 softmax 对向量进行操作，而 sigmoid 则采用标量。                                                                  \nSoftmax函数与正常的max函数不同：max函数仅输出最大值，但Softmax函数确保较小的值具有较小的概率，并且不会直接丢弃。\nTanh函数\nTanh(z)函数是sigmoid函数的缩放版本，它的输出范围变成了[-1,1]，而不是[0,1].当数据分布在0周围时，其导数值更高。一个更高的梯度对于更好的学习速率更有帮助\n\n\nReLU函数\n在深度学习模型中，修正线性单元(ReLU)是最常用的激活函数。当函数输入负数时，函数输出0，对于任意正数x，函数输出本身。因此它可以写成f(x)=max(0,x)\n\nLeaky ReLU是一个其中最出名的一种变形，对于正数输入，其输出和ReLU一样，但是对于所有负数输出，不再是0，而是具有一个常数斜率（小于1）.\n\n这个斜率是在构建模型时，需要使用者设置的参数。它通常被叫做alpha，例如，使用者设置alpha=0.3.这个激活函数则表示为f(x)=max(0.3x,x)。这具有一个理论优点，通过x在所有值处都能有一个影响，使得在x中包含的信息被充分利用。\n\n激活函数还有有其他可以替代的选择，但是对于从业者和研究人员，发现一般情况通过改变使用其他激活函数代替ReLU，并不能带来足够的收益。在平常实践中，ReLU比Sigmoid或者tanh函数表现的更好。\n6.6 代价函数6.6.1 交叉熵代价函数（Cross-entropy Loss Function）当输出只有两种可能，即输出层神经元只有一个节点时，代价函数如下：\n\n当输出有三种及以上种可能时，即输出层神经元有三个及以上节点时，（多分类问题），代价函数如下：\n\n\nh(x)是一个K维向量\nK为输出的类别数，即输出层神经元的个数\nh(x)_i表示第i个输出 →i表示选择输出神经网络输出向量中的第i个元素\n正则化项分别对 j i l 求和，除去了偏置单元（i=0)\n\n\n6.6.2 交叉熵代价函数+ softmax函数\n代价函数公式：\n\n6.7 前向传播（Forward Propagation）与反向传播（Back Propagation，BP）BP神经网络是一种多层的前馈神经网络，其主要的特点是：信号是前向传播的，而误差是反向传播的。\n正向传播数据（信息、信号）从输入端输入后，沿着网络的指向，乘以对应的权重后再加和，再将结果作为输入在激活函数中计算，将计算的结果作为输入传递给下一个节点。依次计算，直到得到最终结果。通过每一层的感知器，层层计算，得到输出，每个节点的输出作为下一个节点的输入。这个过程就是正向传播。                  \n反向传播将输出的结果与期望的输出结果进行比较，将比较产生的误差利用网络进行反向传播，本质是一个“负反馈”的过程。通过多次迭代，不断地对网络上的各个节点间权重进行调整（更新），权重的调整（更新）采用梯度下降法。\n\n6.7.1 BP算法的推导一文彻底搞懂BP算法：原理推导+数据演示+项目实战（上篇） - 人工智能遇见磐创 - 博客园 (cnblogs.com)\n6.8 独热编码（One-Hot Encoding）one-hot编码，又称独热编码、一位有效编码。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时间只有一位有效（标记为1），而其他所有特征都被标记为0。举个例子，假设我们有四个样本（行），每个样本有三个特征（列），如下图：\n\n我们拿feature2来说明：这里feature2有4种取值（状态），我们就用4个状态位来表示这个特征，one-hot编码就是保证每个样本中的单个特征只有1位处于状态1,其他的都是0。\n\n对于2种状态、3种状态、甚至更多状态都可以这样表示，所以我们可以得到这些样本特征的新表示：\n\none-hot编码将每个状态位都看成一个特征。对于前两个样本我们可以得到它的特征向量分别为\n12Sample_1---&gt;[0,1,1,0,0,0,1,0,0]Sample_2---&gt;[1,0,0,1,0,0,0,1,0]\none-hot在提取文本特征上的应用\none hot在特征提取上属于词袋模型(bag of words)。关于如何使用one-hot抽取文本特征向量我们通过以下例子来说明。\n性别特征：[“男”,”女”]（N=2）：\n男  =&gt;  10\n女  =&gt;  01\n祖国特征：[“中国”，”美国，”法国”]（这里N=3）：\n中国  =&gt;  100\n美国  =&gt;  010\n法国  =&gt;  001\n运动特征：[“足球”，”篮球”，”羽毛球”，”乒乓球”]（这里N=4）：\n足球  =&gt;  1000\n篮球  =&gt;  0100\n羽毛球  =&gt;  0010\n乒乓球  =&gt;  0001\n所以，当一个样本为[“男”,”中国”,”乒乓球”]的时候，完整的特征数字化的结果为：\n[1，0，1，0，0，0，0，0，1]\n独热编码的意义\n在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。\n为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。\n比如，有一个离散型特征，代表工作类型，该离散型特征，共有三个取值，不使用one-hot编码，其表示分别是x_1 = (1), x_2 = (2), x_3 = (3)。两个工作之间的距离是，(x_1, x_2) = 1, d(x_2, x_3) = 1, d(x_1, x_3) = 2。那么x_1和x_3工作之间就越不相似吗？显然这样的表示，计算出来的特征的距离是不合理。那如果使用one-hot编码，则得到x_1 = (1, 0, 0), x_2 = (0, 1, 0), x_3 = (0, 0, 1)，那么两个工作之间的距离就都是sqrt(2).即每两个工作之间的距离是一样的，显得更合理。\n但如果特征是离散的，并且不用one-hot编码就可以很合理的计算出距离，那么就没必要进行one-hot编码。 有些基于树的算法在处理变量时，并不是基于向量空间度量，数值只是个类别符号，即没有偏序关系，所以不用进行独热编码。 Tree Model不太需要one-hot编码： 对于决策树来说，one-hot的本质是增加树的深度。\n\n七、误差分析与偏斜类的误差度量（Error Analysis and Error Metrics for Skewed Classes）所谓的偏斜类（Skewed Class）的问题，对于二元分类来说，其实就是一种分类的数据量远远大于另外一种分类。\n以是否恶性肿瘤（癌症）的分类为例，我们希望能根据病人的一些特征判断病人是否患有癌症（y=1表示有癌症，y=0表示没有癌症）。\n我们用逻辑回归算法来解决问题，发现在测试集有99%的正确率，这个结果看上去很完美。但是，你要知道患有癌症的毕竟是少数，可能在我们的测试集中只有0.5%的人真的患有癌症。这样的话，全部给预测为y=0（没有癌症），那也只有0.5%的错误。\n混淆矩阵：\n\n　　\n我们将算法预测的结果分成四种情况：\n\n正确肯定（True Positive,TP）：预测为真，实际为真\n正确否定（True Negative,TN）：预测为假，实际为假\n错误肯定（False Positive,FP）：预测为真，实际为假\n错误否定（False Negative,FN）：预测为假，实际为真\n\n\n准确率（accuracy）\n所有预测正确的样本（包含正例或负例均预测正确，即正例预测为正TP或负例预测为负TN）占总样本的比例。\n准确率=(TP+TN)/(FP+FN+TN+TP)\n查准率/精确率（Precision）\n查准率=TP/(TP+FP)。例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。\n查全率/召回率（Recall）\n查全率=TP/(TP+FN)。例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。\nP-R曲线：\n\n\n曲线越靠近右上方，性能越好。（例如上图黑色曲线）\n\n当一个曲线被另一个曲线完全包含了，则后者性能优于前者。（例如橙蓝曲线，橙色优于蓝色）\n\n如果曲线发生交叉（黑橙曲线），判断依据：\n\n\n\n根据曲线下方面积大小判断，面积更大的更优于面积小的。\n\n根据平衡点F判断：平衡点是查准率与查重率相等时的点。F计算公式为F = 2  P  R ／( P +R )，F值    越大，性能越好。\n\n\nF1-score\n精确率和召回率互相影响，理想状态下肯定追求两个都高，但是实际情况是两者相互“制约”：追求精确率高，则召回率就低；追求召回率高，则通常会影响精确率。我们当然希望预测的结果精确率越高越好，召回率越高越好， 但事实上这两者在某些情况下是矛盾的。这样就需要综合考虑它们，最常见的方法就是F-score。 也可以绘制出P-R曲线图，观察它们的分布情况。\nF1值为算数平均数除以几何平均数，且越大越好，将Precision和Recall的上述公式带入会发现，当F1值小时，True Positive相对增加，而false相对减少，即Precision和Recall都相对增加，即F1对Precision和Recall都进行了加权。\n\nROC曲线\nReceiver Operating Characteristic，“受试者工作特征曲线”，其主要分析工具是一个画在二维平面上的曲线——ROC 曲线。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。     ROC 曲线距离基准线越远，则说明该模型的预测效果越好。\n\n一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC曲线来表示分类器的性能很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。\nAUC的值就是处于ROC曲线下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的性能。AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。\n从AUC判断分类器（预测模型）优劣的标准\n· AUC = 1，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。\n· 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。\n· AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。\n· AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。\n\n八、决策树（Decision Tree）决策树是一种以树形数据结构来展示决策规则和分类结果的模型，又称为判定树，是数据挖掘技术中的一种重要的分类与回归方法。其重点是将看似无序、杂乱的已知数据，通过某种技术手段将它们转化成可以预测未知数据的树状模型。\n其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。每个内部结点视为一个条件，每对结点之间的有向边视为一个选项，每一条从根结点（对最终分类结果贡献最大的属性）到叶子结点（最终分类结果）的路径都代表一条决策的规则。\n\n决策树的组成\n1、决策节点通过条件判断而进行分支选择的节点。如：将某个样本中的属性值(特征值)与决策节点上的值进行比较，从而判断它的流向。\n2、叶子节点没有子节点的节点，表示最终的决策结果。\n决策树通常有三个步骤：\n特征选择：选取有较强分类能力的特征。\n决策树生成：典型的算法有 ID3 和 C4.5， 它们生成决策树过程相似， ID3 是采用信息增益作为特征选择度量， 而 C4.5 采用信息增益比率。\n决策树剪枝：剪枝原因是决策树生成算法生成的树对训练数据的预测很准确， 但是对于未知数据分类很差， 这就产生了过拟合的现象。涉及算法有CART算法。\n\n决策树学习的目标：根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。并在损失函数的意义下，选择最优决策树的问题。\n\n决策树学习的本质：从训练集中归纳出一组分类规则，或者说是由训练数据集估计条件概率模型。\n\n决策树学习的损失函数：正则化的极大似然函数\n\n决策树学习的测试：最小化损失函数\n\n\n\n8.1 熵熵的作用熵（Entropy)是表示随机变量不确定性的度量。说简单点就是物体内部的混乱程度。比如下边的两幅图中，从 图1 到 图2 表示了熵增的过程。对于决策树的某个结点而言，它在对样本数据进行分类后，我们当然希望分类后的结果能使得整个样本集在各自的类别中尽可能有序，即希望某个特征在被用于分类后，能最大程度地降低样本数据的熵。\n\n现在假设有这样一个待分类数据（如下图所示），若分类器 1 选择特征 𝑥1、分类器 2 选择特征 𝑥2 分别为根构建了一棵决策树，其效果如下：\n\n则根据以上结果，可以很直观地认为，决策树 2 的分类效果优于决策树 1 。从熵的角度看，决策树 2 在通过特征 𝑥2 进行分类后，整个样本被划分为两个分别有序的类簇；而决策树 1 在通过特征 𝑥1 进行分类后，得到的分类结果依然混乱（甚至有熵增的情况），因此这个特征在现阶段被认为是无效特征。\n熵的定义\n构建决策树的实质是对特征进行层次选择，而衡量特征选择的合理性指标，则是熵。为便于说明，下面先给出熵的定义：设 𝑋 是取值在有限范围内的一个离散随机变量，其概率密度为：\n\n\n\n条件熵的引入\n在构建决策树时我们可采用一种很简单的思路来进行“熵减”：每当要选出一个内部结点时，考虑样本中的所有“尚未被使用”特征，并基于该特征的取值对样本数据进行划分。即有：\n\n对于每个特征，都可以算出“该特征各项取值对运动会举办与否”的影响（而衡量各特征谁最合适的准则，即是熵）。为此，引入条件熵。首先看原始数据集 𝐷 （共14天）的熵，该数据的标签只有两个（“举办”与“不举办”），且各占一半，故可算出该数据集的初始熵为：\n\n分析天气特征：\n\n\n条件熵的计算\n\n8.2 决策树的划分选择信息增益（ID3决策树）表示某特征 𝑋 使得数据集 𝐷 的不确定性减少程度，定义为集合 𝐷 的熵与在给定特征 𝑋 的条件下 𝐷 的条件熵 𝐻(𝐷 | 𝑋) 之差\n\n信息增益率（C4.5决策树）\n基尼指数（CART决策树）\n三种算法的对比适用范围：\nID3算法只能处理离散特征的分类问题，C4.5能够处理离散特征和连续特征的分类问题，CART算法可以处理离散和连续特征的分类与回归问题。\n假设空间：\nID3和C4.5算法使用的决策树可以是多分叉的，而CART算法的决策树必须是二叉树。\n优化算法：\nID3算法没有剪枝策略，当叶子节点上的样本都属于同一个类别或者所有特征都使用过了的情况下决策树停止生长。\nC4.5算法使用预剪枝策略，当分裂后的增益小于给定阈值或者叶子上的样本数量小于某个阈值或者叶子节点数量达到限定值或者树的深度达到限定值，决策树停止生长。\nCART决策树主要使用后剪枝策略。\n8.3 剪枝处理决策树会无休止的生长，直到训练样本中所有样本都被划分到正确的分类。实际上训练样本中含有异常点，当决策树节点样本越少的时候，异常点就可能使得该结点划分错误。另外，我们的样本属性并不一定能完全代表分类的标准，可能有漏掉的特征，也可能有不准确的特征。这样就会导致决策树在训练集上准确率超高，但是在测试集上效果不好，模型过拟合，泛化能力弱。因此我们需要适当控制决策树的生长。剪枝处理是防止决策树过拟合的有效手段。剪枝，其实就是把决策树里不该生长的枝叶剪掉，也就是不该划分的节点就不要继续划分了。剪枝分为“预剪枝”和“后剪枝”。\n\n预剪枝\n在决策树生成过程中，对每个结点在划分前先进性估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。它的位置在每一次生成分支节点前，先判断有没有必要生成，如没有必要，则停止划分。\n预剪枝方法有：（1）当叶节点的实例个数小于某个阈值时停止生长；（2）当决策树达到预定高度时停止生长；（3）当每次拓展对系统性能的增益小于某个阈值时停止生长；\n限制决策树的深度\n下图展示了通过限制树的深度以防止决策树出现过拟合风险的情况。\n\n限制决策树中叶子结点的个数\n下图展示了通过限制决策树中叶子结点的个数以防止决策树出现过拟合风险的情况。\n\n限制决策树中叶子结点包含的样本个数\n下图展示了通过限制决策树中叶子结点包含的样本个数以防止决策树出现过拟合风险的情况。\n\n限制决策树的最低信息增益\n下图展示了通过限制决策树中叶子结点包含的样本个数以防止决策树出现过拟合风险的情况。\n\n后剪枝\n先从训练集生成一棵完整的决策树（相当于结束位置），然后自底向上的对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点，相当于将子树剪去。如果剪掉该节点，带来的验证集中准确性差别不大或有明显提升，则可以对它进行剪枝，用叶子节点来代填该节点。\n值得注意的是，后剪枝时要用到一个测试数据集合，如果存在某个叶子剪去后能使得在测试集上的准确度或其他测度不降低（不变得更坏），则剪去该叶子。\n后剪枝决策树通常比预剪枝决策树保留了更多的分枝，一般情形下，后剪枝决策树的欠拟合风险很小，泛化能力往往优于预剪枝决策树。但后剪枝决策树是在生产完全决策树之后进行的，并且要自底向上地对所有非叶子节点进行逐一考察，因此其训练时间开销比未剪枝的决策树和预剪枝的决策树都要大很多。\n8.4 连续与缺失值连续值处理\n（1）提出原因\n看看我们上面的例子，有些属性取值是离散的，有些是连续的。连续属性的可取值数目不是有限的，所以不能直接根据连续属性的可取值来对节点进行划分。\n（2）做法——连续属性离散化技术\n最简单的方法是二分法。\n\n缺失值处理\n（1）提出原因\n在样本获得的过程中，难免会因某些原因致使最后拿到的样本集出现某些属性数据的缺失。\n（2）做法\n当缺失的数据非常少时，一般直接舍弃掉那些缺失的数据；而当缺失的数据较多时，简单舍弃则是对样本的极大浪费，则按照一定的方法进行处理。\n当缺失的数据较多时，对信息增益的计算公式进行修改：\n\n\n8.5 回归树（regression tree）常用的决策树有 ID3、C4.5、CART 等，其中 CART 就可以用来做回归问题，CART 全称就是 Classification And Regression Tree（分类和回归树）。\n回归树（regression tree）就是用树模型做回归问题，每一片叶子都输出一个预测值。预测值一般是该片叶子所含训练集元素输出的均值，即\n\nCART 在分类问题和回归问题中的相同和差异：\n\n相同：\n在分类问题和回归问题中，CART 都是一棵二叉树，除叶子节点外的所有节点都有且仅有两个子节点；\n所有落在同一片叶子中的输入都有同样的输出。\n\n\n差异：\n在分类问题中，CART 使用基尼指数（Gini index）作为选择特征（feature）和划分（split）的依据；在回归问题中，CART 使用 mse（mean square error）或者 mae（mean absolute error）作为选择 feature 和 split 的 criteria。\n在分类问题中，CART 的每一片叶子都代表的是一个 class；在回归问题中，CART 的每一片叶子表示的是一个预测值，取值是连续的。\n\n\n\n下面以 criteria = ‘mse’ 为例，介绍 CART 回归树。\n\n\n8.6 随机森林（Random Forest，RF）随机森林是一个由许多决策树组成的集成模型。它的核心思路是，当训练数据被输入模型时，随机森林并不是用整个训练数据集建立一个大的决策树，而是采用不同的子集和特征属性建立多个小的决策树，然后将它们合并成一个更强大的模型。通过对多个决策树的结果进行组合，随机森林可以增强模型的效果。\n另一个随机森林的重要特点是，每个子集都是通过随机选择的样本和随机选择的特征属性建立的。这种随机化可以减少决策树对训练数据的敏感性，从而防止过拟合。\n随机森林的可视化结构图如下：\n\n除叶子节点外，所有节点都有5个部分：\n ● 基于某个特征的一个值对数据进行的提问，每个提问都有一个真或假的答案可以分裂节点。根据答案，数据点相应地向下移动。 ● gini： 节点的Gini不纯度。当我们沿着树向下移动时，平均加权基尼不纯度会减少。 ● samples ：节点中的观测数据数量。 ● value： 每个类中的样本数。例如，根节点中有2个样本属于类0，有4个样本属于类1。 ● class： 该节点中大多数点的分类。在叶节点中，即是对节点中所有样本的预测。\n叶节点中不再提问，因为这里已经产生了最终的预测。要对某个新数据点进行分类，只需沿着树向下移动，使用新点的特征来回答问题，直到到达某个叶节点，该叶节点对应的分类就是最终的预测。\n8.6.1 转换器（transformer）和估计器（estimator）Scikit-learn (sklearn)中两个重要的概念是转换器（transformer）和估计器（estimator）\n转换器\n转换器是将数据集从一种形式转换为另一种形式的工具。例如，将原始数据进行标准化处理，将文本数据转换为数值特征等。在sklearn中，转换器类的名称以Transformer结尾。转换器通常有一个fit_transform()方法，可以在训练集上拟合模型并将其应用于测试集。\n特征工程的步骤\n\n实例化（实例化是一个转换器类（Transformer））\n\n调用fit_tranformer(对于文档建立分类词频矩阵)\n\n\n我们把特征工程的接口称之为转换器，其中转换器调用有这么几种形式：\n\nfit_transform\nfit 计算每列的平均值与标准差\ntransform 进行最终的标准化\n\n常见的转换器：\nStandardScaler：用于标准化数值特征。OneHotEncoder：用于将分类变量转换为数值特征。CountVectorizer：用于将文本数据转换为数值特征。PCA：用于将高维数据集降低维度。\n估计器在sklearn中，估计器（estimator）是一个重要角色，分类器和回归器都属于estimator，是一类实现了算法的API。\n估计器是一种从数据集中学习模型的工具。估计器的任务是使用拟合模型对新数据进行预测。在sklearn中，估计器类的名称以Estimator结尾。估计器有两个基本方法，fit()方法和predict()方法。fit()方法在训练集上训练模型，而predict()方法用于在新数据上进行预测。\n需要注意的是，某些转换器也可以作为估计器使用，这意味着它们可以使用fit()方法在训练集上拟合模型，并使用predict()方法对新数据进行预测。这些转换器估计器也被称为“带监督的转换器”。\n用于分类的估计器\nsklearn.neighbors                                        k-近邻算法sklearn.native_bayes                                   贝叶斯sklearn.linear_model.LogisticRegression 逻辑回归sklearn.tree                                                   决策树与随机森林\n用于回归估计器\nsklearn.linear_model.LinearRegression    线性回归sklearn.linear_model.Ridge                         岭回归\n用于无监督学习的估计器\nsklearn.cluster.KMeans 聚类\n估计器的流程\n数据划分为训练集和测试集，我们建立模型的时候只需要把训练集输入进去就可以。训练集包括x_train、y_train,调用fit传入x_train、y_train,这样此算法就能利用这个模型进行计算，模型建立好之后要预测数据，看模型预测的数据准确与否，输入测试集的数据x_test、y_test,调用predict(x_test)，把测试集的特征值输入进去，来预测此测试集的目标值是什么（就像把特征值输入进去预测房价走向），每个算法应该都包括score这个方法，查看预测的准确性score(x_test,y_test)，真实值是1类别，预测值是2类别，就视为不准确。预测的时候应该有预测的类别和真实的类别。\n1.实例化一个estimator类\n2.estimator.fit(x_train,y_train) 计算\n ——调用完毕，模型生成\n3.模型评估\n1）直接比对真实值和预测值\n y_predict = estimator.predict(x_test)\n y_test == y_predict\n2）计算准确率\n accuracy = estimator.score(x_test,y_test)\n\n8.6.2 集成学习集成学习通过训练学习出多个估计器，当需要预测时通过结合器将多个估计器的结果整合起来当作最后的结果输出。集成学习的优势是提升了单个估计器的通用性与鲁棒性，比单个估计器拥有更好的预测性能。集成学习的另一个特点是能方便的进行并行化操作。\n\nBagging算法  Bagging 算法是一种集成学习算法，其全称为自助聚集算法（Bootstrap aggregating），顾名思义算法由 Bootstrap 与 Aggregating 两部分组成。  图展示了Bagging 算法使用自助取样（Bootstrapping4）生成多个子数据的示例\n具体生成规则：\n在随机森林算法中，为了增强模型的多样性和避免过拟合，每棵决策树在拆分节点时只使用所有特征的一个随机子集。对于分类任务，通常会选择特征总数的平方根（sqrt(n_features)）作为子集的大小。例如，如果有16个特征，每个节点的拆分将只考虑4个特征。这个设置可以通过Scikit-Learn中的参数来调整，也可以选择使用全部特征进行拆分，特别是在回归问题中。\n假设有一个大小为 N 的训练数据集，每次从该数据集中有放回的取选出大小为 M 的子数据集，一共选 K 次，根据这 K 个子数据集，训练学习出 K 个模型。当要预测的时候，使用这 K 个模型进行预测，再通过取平均值或者多数分类的方式，得到最后的预测结果。\n　　1）如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的抽取N个训练样本（这种采样方式称为bootstrap sample方法），作为该树的训练集；每棵树的训练集都是不同的，而且里面包含重复的训练样本。\n在训练时，随机森林中的每棵树都会从数据点的随机样本中学习。样本被有放回的抽样，称为自助抽样法（bootstrapping），这意味着一些样本将在一棵树中被多次使用。背后的想法是在不同样本上训练每棵树，尽管每棵树相对于特定训练数据集可能具有高方差，但总体而言，整个森林将具有较低的方差，同时不以增加偏差为代价。\n　　2）如果每个样本的特征维度为M，指定一个常数m&lt;&lt;M，随机地从M个特征中选取m个特征子集，每次树进行分裂时，从这m个特征中选择最优的；\n　　3）每棵树都尽最大程度的生长，并且没有剪枝过程。\n　随机森林中的“随机”就是指的这里的随机性。随机性的引入对随机森林的分类性能至关重要。由于它们的引入，使得随机森林不容易陷入过拟合，并且具有很好得抗噪能力（比如：对缺省值不敏感）。\n随机森林算法将多个决策树结合在一起，每次数据集是随机有放回的选出，同时随机选出部分特征作为输入，所以该算法被称为随机森林算法。可以看到随机森林算法是以决策树为估计器的Bagging算法。\n\n结合器在分类问题中，选择多数分类结果作为最后的结果，在回归问题中，对多个回归结果取平均值作为最后的结果。使用Bagging算法能降低过拟合的情况，从而带来了更好的性能。单个决策树对训练集的噪声非常敏感，但通过Bagging算法降低了训练出的多颗决策树之间关联性，有效缓解了上述问题。\n随机森林分类效果（错误率）与两个因素有关：\n森林中任意两棵树的相关性：相关性越大，错误率越大；森林中每棵树的分类能力：每棵树的分类能力越强，整个森林的错误率越低。减小特征选择个数m，树的相关性和分类能力也会相应的降低；增大m，两者也会随之增大。所以关键问题是如何选择最优的m（或者是范围），这也是随机森林唯一的一个参数。\nRF在可解释性上不能同传统决策树相提并论，但是它的一大优势是不用太关注选择好的超参数。RF相比单个决策树，对噪声或者异常值十分具有鲁棒性，因而RF通常亦不需要剪枝。在实践中唯一需要关心的参数就是the number of trees: n。n越大，RF分类器的性能越好，同时其计算代价也越大。\n当然，如果需要，像bootstrap sample的采样数m，以及再每次split时随机选取的属性子集的数目d，这些超参数也是可以优化的。可以通过这些参数来控制RF的bias-variance trade-off。\n\n属性子集d，越小，个体树的性能有所降低，但整个RF模型会越健壮。d越大，属性随机性会降低，容易过拟合。\n减小采样数m，能增加个体树之间的多样性，因为一个样本被包含在bootstrap sample里的概率变小了。所以减小m可以增加RF的随机性，这将有助于降低过拟合风险。然而，更小的m将会使得RF的整体性能降低，使得training和test 性能之间的有小的gap，有更低的test performance。相反的，增大m会引起一定程度的过拟合，因为bootstrap sample以及后续的个体决策树会变得彼此更相似，他们会更加接近的学习拟合原始训练数据集。\n\n8.7 XGBoost（eXtreme Gradient Boosting）XGBoost全称为eXtreme Gradient Boosting，即极致梯度提升树。\nXGBoost是Boosting算法的其中一种，Boosting算法的思想是将许多弱分类器集成在一起，形成一个强分类器（个体学习器间存在强依赖关系，必须串行生成的序列化方法）。XGBoost是由多棵CART(Classification And Regression Tree)，即分类回归树组成，因此他可以处理分类回归等问题。\n整体思路\n（1）训练过程——构建XGBoost模型       \n​       从目标函数出发，可以推导出“每个叶子节点应该赋予的权值”，”分裂节点后的信息增益“，以及”特征值重要性排序函数“。\n  与决策树的建立方法类似。当前决策树的建立首先根据贪心算法进行划分，通过计算目标函数增益（及上面所说的”分裂节点后的信息增益“），选择该结点使用哪个特征。\n   选择好哪个特征后，就要确定分左右子树的条件了（比如选择特征A，条件是A&lt;7）：为了提高算法效率（不用一个一个特征值去试），使用“加权分位法”，计算分裂点（这里由”特征值重要性排序函数“得出分裂点）。\n  并且对应叶子节点的权值就由上述的“每个叶子节点应该赋予的权值”给出。\n  不断进行上述算法，直至所有特征都被使用或者已经达到限定的层数，则完整的决策树构建完成。\n（2）测试过程      将输入的特征，依次输入进XGBoost的每棵决策树。每棵决策树的相应节点都有对应的预测权值w，将“在每一棵决策树中的预测权值”全部相加，即得到最后预测结果，看谁大，谁大谁是最后的预测结果。\nXGBoost模型详解-CSDN博客\n机器学习算法（十五）：XGBoost_xgboost回归-CSDN博客\n\n九、支持向量机（SVM，support vector machines）超平面的数学表示在二维空间中，一个直线可以表示为 ( ax + by + c = 0 )。其中，向量 (a, b) 就是这条直线的法向量，指向垂直于直线的方向。\n在更高维度，比如三维空间，一个平面可以用方程 ( ax + by + cz + d = 0 ) 来描述，这里 ( a, b, c ) 是这个平面的法向量。\n神经网络试图学习决策边界，最小化经验误差，而支持向量机试图学习决策边界，最大化决策边界和数据点之间的经验边际。\n与Logistic Regression相比，SVM是一种优化的分类算法，其动机是寻找一个最佳的决策边界（超平面），能够将两个不同类别的样本划分开来，使得从决策边界与各组数据之间存在margin，并且需要使各侧的margin最大化。比较容易理解的是，从决策边界到各个training example的距离越大，在分类操作的差错率就会越小。因此，SVM也叫作Large Margin Classifier。\n\n\n分割超平面：将上述数据集分隔开来的直线成为分隔超平面。对于二维平面来说，分隔超平面就是一条直线。对于三维及三维以上的数据来说，分隔数据的是个平面，称为超平面，也就是分类的决策边界。\n间隔：点到分割面的距离，称为点相对于分割面的间隔。数据集所有点到分隔面的最小间隔的2倍，称为分类器或数据集的间隔。论文中提到的间隔多指这个间隔。SVM分类器就是要找最大的数据集间隔。\n支持向量：离分隔超平面最近的那些点。\n\n目标函数：\n\n支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局\n线性SVM不直接依赖于数据分布，分类平面不受一类点影响，影响SVM决策面的样本点只有少数的结构支持向量，当在支持向量外添加或减少任何样本点对分类决策面没有任何影响；而在LR中，每个样本点都会影响决策面的结果如果数据不同类别strongly unbalance，一般需要先对数据做balancing。用下图进行说明：\n支持向量机改变非支持向量样本并不会引起决策面的变化：\n逻辑回归中改变任何样本都会引起决策面的变化：\n机器学习之支持向量机（SVM）-CSDN博客\n支持向量机通俗导论（理解SVM的三层境界）-CSDN博客\n机器学习：深入解析SVM的核心概念【一、间隔与支持向量】_svm最小间隔是什么意思-CSDN博客\n核函数\n核函数详解-CSDN博客\n统计学习方法：核函数（Kernel function） - LeeLIn。 - 博客园 (cnblogs.com)\n核函数 高斯核函数，线性核函数，多项式核函数-CSDN博客\n十、无监督学习\n监督学习是一种目的明确的训练方式，你知道得到的是什么；而无监督学习则是没有明确目的的训练方式，你无法提前知道结果是什么。\n监督学习需要给数据打标签；而无监督学习不需要给数据打标签。\n监督学习由于目标明确，所以可以衡量效果；而无监督学习几乎无法量化效果如何。\n\n\n\n\n\n聚类方法\n适用场景\n代表算法\n优点\n缺陷\n延伸\n\n\n\n\n层次聚类\n小样本数据\n\n可以形成类相似度层次图谱，便于直观的确定类之间的划分。\n难以处理大量样本\n\n\n\n基于划分的聚类\n大样本数据\nK-means算法\n-是解决聚类问题的一种经典算法，简单、快速，复杂度为O(N)                      -对处理大数据集，该算法保持可伸缩性和高效率                                    -当簇近似为高斯分布时，它的效果较好\n-在簇的平均值可被定义的情况下才能使用，可能不适用于某些应用                                 -必须事先给出k(要生成的簇的数目)，而且对初值敏感，对于不同的初始值，可能会导致不同结果。       -不适合于发现非凸形状的簇或者大小差别很大的簇                                     -对躁声和孤立点数据敏感\n-可作为其他聚类方法的基础算法，如谱聚类                     -k值可以通过其他的算法来估计，如：BIC(Bayesian information criterion)、MDL(minimum description length)\n\n\n两步法聚类\n大样本数据\nBIRCH算法\n层次法和k-means法的结合，具有运算速度快、不需要大量递归运算、节省存储空间的优点\n\n\n\n\n基于密度的聚类\n大样本数据\nDBSCAN算法\n基于密度定义，相对抗噪音，能处理任意形状和大小的簇。 无需指定聚类数量，对数据的先验要求不高。\n当簇的密度变化太大时，会有麻烦对于高维问题，密度定义是个比较麻烦的问题\n\n\n\n\n10.1 k-means聚类算法(K-means clustering)与分类、序列标注等任务不同，聚类是在事先并不知道任何样本标签的情况下，通过数据之间的内在关系把样本划分为若干类别，使得同类别样本之间的相似度高，不同类别之间的样本相似度低（即增大类内聚，减少类间距）。\n K-means 的著名解释：牧师—村民模型（1）有四个牧师去郊区布道，一开始牧师们随意选了几个布道点，并且把这几个布道点的情况公告给了郊区所有的村民，于是每个村民到离自己家最近的布道点去听课。\n（2）听课之后，大家觉得距离太远了，于是每个牧师统计了一下自己的课上所有的村民的地址，搬到了所有地址的中心地带，并且在海报上更新了自己的布道点的位置。\n（3）牧师每一次移动不可能离所有人都更近，有的人发现A牧师移动以后自己还不如去B牧师处听课更近，于是每个村民又去了离自己最近的布道点……\n（4）就这样，牧师每个礼拜更新自己的位置，村民根据自己的情况选择布道点，最终稳定了下来。\nK-Means算法的思想\n对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。\n\n\n上图a表达了初始的数据集，假设k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为和该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图4所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。\n当然在实际K-Mean算法中，我们一般会多次运行图c和图d，才能达到最终的比较优的类别。\nK-Means 算法 步骤\n给定数据集  X , 该数据集有  n 个样本 , 将其分成  K 个聚类 ;\n① 中心点初始化 : 为 K 个聚类分组选择初始的中心点 , 这些中心点称为 Means ; 可以依据经验 , 也可以随意选择 ;\n② 计算距离 : 计算  n 个对象与  K 个中心点 的距离 ; ( 共计算  n×K 次 )\n③ 聚类分组 : 每个对象与 K 个中心点的值已计算出 , 将每个对象分配给距离其最近的中心点对应的聚类 ;\n④ 计算中心点 : 根据聚类分组中的样本 , 计算每个聚类的中心点 ;\n⑤ 迭代直至收敛 : 迭代执行 ② ③ ④ 步骤 , 直到新计算出来的质心和原来的质心之间的距离小于某一个设置的阈值（聚类算法收敛）, 即中心点和分组经过多少次迭代都不再改变 , 也就是本次计算的中心点与上一次的中心点一样 \n\n【海量数据挖掘/数据分析】之 K-Means 算法（K-Means算法、K-Means 中心值计算、K-Means 距离计算公式、K-Means 算法迭代步骤、K-Means算法实例）_kmeans聚类算法-CSDN博客\nK-Means的K值选择\nK 值的选取对 K-means 影响很大，这也是 K-means 最大的缺点，常见的选取 K 值的方法有：手肘法、Gap statistic 方法。\n（1）手肘法\n\n核心指标：SSE(sum of the squared errors，误差平方和), SSE值越小表示数据点越接近他们的质心，聚类效果也最好。因为对误差取了平方，因此更加重视远离中心的点。\n核心思想\n\n随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数\n显然，肘部对于的k值为3(曲率最高)，故对于这个数据集的聚类而言，最佳聚类数应该选3。\n（2）轮廓系数\n结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。\n\n轮廓系数的范围为[−1,1]，越趋近于1代表内聚度和分离度都相对较优。\n所以可以在k-means算法开始的时候，先设置k值的范围k∈[2,n]，从而计算k取每一个值的轮廓系数，轮廓系数最小的那个k值就是最优的分类总数。\nK-Means初始化优化K-Means++\nk个初始化的质心的位置选择对最后的聚类结果和运行时间都有很大的影响，因此需要选择合适的k个质心。如果仅仅是完全随机的选择，有可能导致算法收敛很慢。K-Means++算法就是对K-Means随机初始化质心的方法的优化。\n\nK-Means距离计算优化elkan K-Means\n\n大样本优化Mini Batch K-Means\n传统的K-Means算法中需要计算所有样本点到所有质心的距离，计算复杂度较高。如果样本量非常大的情况下，比如数据量达到10万，特征在100以上，此时用传统K-Means算法非常耗时。因此有了一种分批处理的改进算法Mini Batch K-Means。\nMini Batch K-Means算法是K-Means算法的变种，采用小批量的数据子集减小计算时间，同时仍试图优化目标函数，这里所谓的小批量是指每次训练算法时所随机抽取的数据子集，采用这些随机产生的子集进行训练算法，大大减小了计算时间，与其他算法相比，减少了k-均值的收敛时间，小批量k-均值产生的结果，一般只略差于标准算法。\n该算法的迭代步骤有两步：\n\n从数据集中随机抽取一些数据形成小批量，把他们分配给最近的质心\n更新质心与K均值算法相比，数据的更新是在每一个小的样本集上。对于每一个小批量，通过计算平均值得到更新质心，并把小批量里的数据分配给该质心，随着迭代次数的增加，这些质心的变化是逐渐减小的，直到质心稳定或者达到指定的迭代次数，停止计算。Mini Batch K-Means比K-Means有更快的 收敛速度，但同时也降低了聚类的效果，但是在实际项目中却表现得不明显，有差异的基本都是聚类边界上的点。\n\n　K-Means的主要优点有：\n　　　　1）原理比较简单，实现也是很容易，收敛速度快。\n　　　　2）聚类效果较优。\n　　　　3）算法的可解释度比较强。\n　　　　4）主要需要调参的参数仅仅是簇数k。\n　K-Means的主要缺点有：\n　　　　1）K值的选取不好把握\n　　　　2）对于不是凸的数据集比较难收敛\n　　　　3）如果各隐含类别的数据不平衡，比如各隐含类别的数据量严重失衡，或者各隐含类别的方差不同，则          聚类效果不佳。\n　　　　4） 采用迭代方法，得到的结果只是局部最优。\n　　　　5） 对噪音和异常点比较的敏感。\n10.2 异常检测（anomaly detection）异常检测是通过数据挖掘方法发现与数据集分布不一致的异常数据，也被称为离群点、异常值检测等等。在异常检测中，我们通常处理的是未标记的数据，即没有明确的标签指示哪些样本是异常的。相反，算法需要根据数据本身的特征来确定异常。这使得异常检测成为一项挑战，因为异常通常是稀有事件，不易获取大量标记的异常数据以进行训练，我们可以将其视为一种“半监督”学习，因为我们通常有一些正常样本，但没有足够的异常样本。这种情况下，我们可以利用正常样本来构建模型，然后将其应用于整个数据集以检测异常。\n异常检测算法适用的场景特点有：（1）无标签或者类别极不均衡；（2）异常数据跟样本中大多数数据的差异性较大；（3）异常数据在总体数据样本中所占的比例很低。\n【机器学习】李宏毅——Anomaly Detection（异常检测） - FavoriteStar - 博客园 (cnblogs.com)\n异常检测(Anomaly Detection)方法与Python实现 - 郝hai - 博客园 (cnblogs.com)\n一文详解8种异常检测算法（附Python代码）-CSDN博客\n异常检测方法总结_s.quantile(.25), s.quantile(.75)-CSDN博客\n10.3 推荐系统(Recommender System)（1）推荐系统的定义推荐系统（Recommendation System, RS）是一种自动联系用户和物品的工具，它能够帮助用户在信息过载的环境中发现令他们感兴趣的信息。它通常由前台的展示页面、后台的日志系统、推荐算法系统三个部分组成。\n10.3.1协同过滤（Collaborative Filtering）算法篇—协同过滤_协同过滤算法-CSDN博客\n推荐系统之协同过滤算法_协同过滤推荐算法-CSDN博客\n一文入门推荐系统——推荐系统实践读书笔记_推荐系统入门教程-CSDN博客\n10.3.2 PCA主成分分析法（PCA）-CSDN博客\n一文入门推荐系统——推荐系统实践读书笔记_推荐系统入门教程-CSDN博客\n降维算法之PCA：从原理到应用，8000多字，助你彻底理解！_pca降维-CSDN博客\n一文读懂PCA分析 （原理、算法、解释和可视化）-腾讯云开发者社区-腾讯云 (tencent.com)\n","slug":"机器学习初级","date":"2024-08-01T00:00:00.000Z","categories_index":"Deep Learning","tags_index":"","author_index":"Gueason"},{"id":"0bba57f59c9514b7a259aa10ab4307d3","title":"虚拟机相关问题","content":"一、VirtualBox 虚拟机 ping 不通sudo vim /etc/resolv.conf\n在里面输入 nameserver 8.8.8.8保存\n二、mysql密码重置1.首先输入“service mysqld status”查看当前mysql服务状态\n2.输入“killall -TERM mysqld”命令停止所有的mysqld进程。\n3.输入“service mysqld stop”命令停止mysqld服务。\n4.输入“mysqld_safe —skip-grant-tables &amp;”命令以无密码方式进入MySQL安全模式。\n5.输入“mysql -u root”并按回车键即可。\n6.输入“use mysql;”挂载数据库。\n7.输入”update user set password=password(“Newpassword”) where user=’root’;”将Root密码修改为Newpassword。\n8.输入”flush privileges;”更新权限。\n9.输入“quit”并按回车键退出。\n10.输入”service mysqld restart”重启mysqld服务。\n11.通过命令”pgrep -l mysqld” 查看进程\n12.”service mysqld status”查看状态\n13.输入“mysql -u root -p”并按回车键提示输入密码。\n在Linux上跳过密码登录MySQL报错“-bash: mysqld_safe: command not found“\nmysqld_safe --skip-grant-tables &amp; mysql -uroot -p报错\n解决\n执行命令mysqld --user=mysql --skip-grant-tables --skip-networking &amp;\n通过mysql -uroot -p命令直接跳过密码登录，不需要输入密码。\nmysql退出三种方法：mysql &gt; exit;mysql &gt; quit;mysql &gt; q;\n","slug":"虚拟机相关问题","date":"2024-08-01T00:00:00.000Z","categories_index":"技术栈","tags_index":"","author_index":"Gueason"},{"id":"aba5b7476e687cdc475e58c292a78a0a","title":"引擎搜索","content":"一、搜索语法\n限定关键词”XXX”(ctrl+F：快捷在PDF中搜索关键词）\n限定标题 intitle:xxx\n限定标题多个关键词 allintitle:xxx（空格）xxx\n限定文章内容关键词 intext:xxx\n限定网址关键词 inurl:xxx(【例】inurl:CCTV)\n限定网站来源site:xxx(【例】site:pexels.com)\n限制图片尺寸xxx imagesize:xxx(【例】elon musk imagesize: 5760x3840)\n限制文件格式 xxx filetype:xxx(【例】大模型filetype:PDF)\n\n特定搜索\n采用格式：keyword + format\n集成电路 + site: 1991T.com :专门从一个报告网站里查找集成电路有关的资源，会有很多行业分析报告文档\n最短路径+ site: zhihu.com: 可以专门从知乎查找有关的知识问答\n2023考研复试 site: fudan.edu.cn可以从官网筛选到需要的信息，权威\ntiger site: pexels.com 从一个知名素材图片视频网站查找。或者另外一个素材网站 pixabay.com,gettyimages.com\n二、知识技能1.搜化妆品成分：国家普通化妆品备案信息2.搜日本产品功能参数：亚马逊、乐天3.ChatGPT最新账号：X(twitter/Youtube)4.程序员：GltHub、 StackOverflow、CSDN5.产品经理导航网址、设计导航、新媒体导航网址6.国际论文：谷歌学术、Sci-Hub（免费、只能搜完整题目）、谷粉学术\n谷粉学术 (99lb.net)\n7.下载电子书：a．中文：鸠摩搜书b．英文：https://z-lib.id/、https://manybooks.net、www.pdfbooksworld.com\n8.公众号：quaro:国外知乎redit：国外论坛\n9．百度网盘搜索引擎（自己百度）找出类似网站：SimilarSites\n三、素材文件视频：best sites for free stock videos【例】pexels、pixabay\n1．特殊技巧，【例】youtube视频：在www．后面加上9x2．下载网站／插件：save.tube3．高分辨率：直接搜4K的频道\n音频：royalty free BGM sites【例】pixabay\n图片：1．静态图片：a．谷歌搜（imagesize)b．有版权的（gettyimages复制网址到下载器gettyimages downloader)\n2.GIF动图：best gif sites【例】GIPHY\n3.icon图标a．谷歌搜【例】火箭 icon filetype:PNGb.iconfont.cn\n文件：PPT模板：1.islide插件2．在线设计网站canva.com\n四、工具软件在线工具：(xxx需求＋Online)\n\n设计网站canva.com\n在线抠图remove.bg\n文字转语音 腾讯智影／Azure\n画脑图miro/canva \n找台词找台词网\n在线剪辑视频Clipchamp/FLexclip\n测网速 fast.com\n检测陌生链接安全性virustotal.com\n\n寻找生产力软件Plugin:1．谷歌／Youtube搜：2023 best APPs/Top10 best Mac APPs productivity/best chorme plugin2．找替代软件：alternativeto.net\n寻找生产力插件Extension:1．插件商店2．谷歌搜best chorme extension productivity\n五、网址整理Ladderhttps://binghe.gitbook.io/quan-ping-tai-fan-qiang-gong-ju\nhttps://fnyun.gitbook.io/fabu\nPPTPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】 (1ppt.com)\nhttps://www.ypppt.com/\nhttp://www.pptbz.com/pptmoban/jianyuejianjie/\nhttps://www.canva.cn/create/ppt-slides/\n音频处理https://audio-extractor.net/cn/\nhttps://vocalremover.org/zh/cutter\n熊猫无损音乐官网-全网无损音乐mp3歌曲免费下载网站 (xmwav.com)\n六、计算机技术https://github.com/\nCSDN - 专业开发者社区\n博客园 - 开发者的网上家园 (cnblogs.com)\n通义灵码安装教程-阿里云 (aliyun.com)\n整理来源\nhttps://github.com/tuteng/Best-websites-a-programmer-should-visit-zh?tab=readme-ov-file#when-you-get-stuck\n当你遇到问题时\nCodementor: 国际版在行，更侧重于开发者之间的帮助，可以从某些方面的专家那里获取帮助\ndevRant: 供你吐槽和释放压力的地方\nLearn Anything: 帮助你找到学习任何知识时的最佳路径\nQuora: 一个共享知识和更好的理解世界的地方\nStack Overflow: 订阅他们的每周新闻和任何你感兴趣的主题\n\n针对初学者的代码练习\nCave of programming : 学习编程，提升技巧\nCodeacademy : 交互式编码学习，免费\nCodeAbbey - 一个任何人都能精通编程的地方 : 从菜鸟到专家进阶之地\nExercism.io : 用超过30种不同的语言解决实践问题，与其他人分享你的解决方案\nfreeCodeCamp : 学习编码并且为非营利性组织构建项目。打造你的全栈开发技能\nkaran/Projects-Solutions 用不同语言实现的项目\nLod - Cloud : 开放数据云图\nProgramming by Doing : 编程进阶站点\nReddit.com/r/dailyprogrammer : 有趣的编程挑战，在这里你能学习其他人的编码，对于你解决不了的编码你能看看其他人是怎么解决的\nPeople Can Program :互联网上最友好的编程学习应用\nProgramming Tasks : 小程序汇总，不是微信的小程序\nVim adventures :边玩边学vim\nPramp : 尝试面试官角色，结束后，可以点击左边的按钮交换角色\nPaqmind :学习编程的指南和挑战\ntreehouse :快速容易和经济实惠的方法来提升技巧\n\n区块链基础 :区块链介绍\n\n\n小项目\nfreeCodeCamp | React project ideas :学习react的27个有趣的想法\nmartyr2s-mega-project-ideas-list : 包含125个项目，从初级到中级\nkaran/Projects : 针对新手的小项目的汇总\nWrong “big projects” for beginners : 怎样选择，从哪里开始\nvicky002/1000-Projects : 一个能够用任何编程语言解决的巨型项目清单\n\n通用编码建议\n成为一名优秀开发者的10种方法\n代码审查最佳实践: Kevin London的博客\nDieter Rams : 好的产品设计的10个原则\n设计模式 : 用例子详细说明设计模式\n如何成为一个程序员或谷歌搜索的艺术\njs项目指南:javascript项目最佳实践集合\nLearn to Code With Me : 一个资源非常全的网站，旨在为科技界的开发人员提供资源\n一个程序员一生应遵循的原则\n编程规范 :程序设计原理与模式分类综述\n软件设计模式 : 设计模式的汇总\n良好的编程原则\n我希望在我一开始学习编码的时候就能得到的一些建议 — Free Code Camp : 从教别人处学到的东西\n在计算机科学专业应该知道什么 :良好的编程规范\n软件开发者的工作 : Henrik Warne的博客\n\n编码风格\nAirbnb JS 风格指南 : 写JavaScript最好的方式\nAirbnb Ruby 风格指南 : Airbnb的ruby风格指南\nRuby 编码风格指南 : 社区驱动的Ruby编码风格指南\nAngular 1 风格指南 : 官方认可的风格指南，作者John Pappa\nCS 106B 编码风格指南 : 代码臃肿者必看\n调试问题 :检查如何调试程序\nCS课程目录(许多在线讲座) : 另一个在线CS课程\n在线CS课程目录 : 免费的在线CS课程\n优秀的 C 编码习惯 • /r/C_Programming\ngoogle C++ 编码风格\n怎样高效的报告Bug\n建议初学者避免使用的坏的编码习惯?\nPEP8 - Python编码风格指南\n标准 JS 风格指南 : JavaScript风格指南\nGoogle Python 风格指南\nAurelia 风格指南\n\n通用工具\nCodePad : 远程面试工具\nCodePen : 基于浏览器共享前端代码的地方\nDevicons : 免费图标汇总\nregex101 : 在线正则表达式测试和调试，国内也有不少\nregexr : 另一个在线学习、测试正则表达式的工具\nWit AI :帮助开发者灵活的控制应用，适合没有移动端开发经验的用户\n\nbash和shell脚本\nAdvanced Bash-Scripting Guide :对shell脚本艺术的深入挖掘\nBash Guide for Beginners :对新手的bash使用指南\nBash编程\nBash参考手册\nBash指南\nConquering the Command Line : 针对开发者的Unix和Linux命令\n\n面试准备\n/r/cscareerquestions : 这是一个非常大的面试问题列表是我在为4大面试时用到的，我认为对大家也是有用的\n10个最频繁的SQL查询面试问题\n逻辑题答案汇总\n算法设计流程\n资质问题与答案 : Quant and aptitude preparation\n一个技术面试题，逻辑题等的站点 : 各种让你思考的东西\nBeehYve :各种学生需要的资源\n面试准备时的链接的汇总 • /r/cscareerquestions\n算法复杂度笔记\n大家的误解\n位操作技巧\nChiperSoft/InterviewThis : 在面试期间问到对公司的了解的问题\nCode Project : 面向开发人员\nJava核心面试问题 - 每个主题的面试题\n一些有趣的C问题\nCS9: CS技术面试中的问题解决\n优秀的逻辑题\n确定不同循环的时间复杂度? :在stackoverflow上的一些好问题包括计算时间复杂度.\n5个基本的电话面试问题 - steveyegge2\n新人面试\nGeeksforGeeks | 针对geek的计算机科学入门 : 订阅他们获取新文章\n准备学习SQL篇：用语言描述一下数据库规范化 - Essential SQL\nhttps://github.com/odino/interviews : 面试重要问题列表\n让你的简历改头换面\n技术面试指南\n如何为技术面试做准备• /r/cscareerquestions\n怎样进行算法面试\n怎样进行自我介绍 | The Art of Manliness\n如何回答最棘手的40个面试问题| ICS Job Portal\n如何进入科技企业-求职和面试指南\n怎样面试\n怎样准备一个面试 - 1\nIIT Delhi 实习经验 :\nsamwincott/Internship-Guide : 与实习相关的链接汇总\n华尔街面试\n面试架构 - Java Honk\n工作面试：如何做好求职面试|展示个人魅力\n求职面试新闻、视频、评论和八卦 - Lifehacker\n求职面试问题和最佳答案\nkimberli/interviews : 面试学习表格\nMission-peace/interview problems : 一个大的编码面试的问题的汇总\n软件工程师面试实践平台 :与真正的同行进行编程交流\nProblems | LeetCode OJ : 针对面试的编码训练\n程序员和软件面试问答\nReddit.com/user/ashish2199/m/puzzles : Reddit逻辑题\nSQL面试问题 : 好的SQL测试\n使用韦恩图进行SQL连接\nsvozniuk/java-interviews : Java面试题\n25个最难的HR问题\n面试10大算法\nUnix／Linux笔记\n为求职者和雇主提供的建议\n通过动画可视化数据结构和算法\nWe Help Coders Get Hired : 提供系统设计，面试策略，软件技能等的web站点\n你的问题是什么?\n为何你会赚钱少 • /r/cscareerquestions\nwu :: riddles(hard) : 逻辑题\n夏季实习：最终篇\n求职面试问题和最好的答案\nJava面试问题与答案\n编程语言概念 课堂笔记 : 面向对象概念和编程语言概念\n系统设计面试\n一个站点提供技术面试题，逻辑题或者你想的其他内容\n前端常见面试题汇总\n\n学习新知识\n课程中心 : 超过10万名学生评价的目录\n计算机科学资源 : 针对自学者的mooc列表\nCoursera.org :在网上学习全世界最好的课程\nCS50\nedX : 免费在线课程，帮助你进步，改善你的生活\nKadenze | Creative Programming: 注重艺术和创造力的编程课\n麻省理工学院电气工程和计算机科学\nMOOC.fi : 赫尔辛基大学在线课程\nNPTEL Vidoes COMP_SCI_ENGG\nprakhar1989/awesome-CS-courses : CS课程大汇总\nUdacity\nUCBerkeley\n网上CS课程的收集\n极客教程\n\n编程语言相关的网站\n学习java的最好的书 : Java基础\nBjarne Stroustrup’s C++风格和技术问答 : C++问答\nBjarne Stroustrup’s FAQ : The C++ FAQ\nC++11 -新的ISO C++ 标准 : C++11问答\n编译器(视频)\n深入Java：垃圾回收!\n免费在线的章节用来学习java虚拟机\n垃圾搜集如何工作\n算法、数据结构、面试问题和答案的实现\nIntelliJ键盘快捷键 :使用IntelliJ的键盘快捷键用来提高生产力\nJava Corner at Artima.com\nJava课程笔记\nJava堆\nJava-source : Java开源软件\nJava Visualizer : 帮助将引用，值，变量可视化\nJournalDev - Java, Java EE, Android, Web Development Tutorials\nLearning Java:一个免费的在线学习Java语言的教材\nNetbeans的键盘快捷键 : 键盘快捷键能够使你在工作时提高生产力\n搜索开源的Java API : 浏览Java库的源代码，并且学习如何实现\nC++编程语言 : C++编程语言\nJava内存模型\nThe Java™ Tutorials : 最好的Java手册\n理解JVM\n垃圾回收是什么 : 动态垃圾搜集\nWelcome to JavaWorld.com\nXyzWs Java FAQs : Java面试题汇总\n\nAI学习\nfast.ai : 针对没有研究生水准的数学的开发者的免费实用的深度学习课程\ngrakn.ai : 数据库AI\nRobots that learn : 机器人学习\n无监督神经元\nAI、机器学习、深度学习的不同\nTensorFlow : 一个针对机器智能的软件开源库\nScikit-learn : 一个针对机器学习的Python模块\nDeepLearning.ai : 深度学习课程，作者coursera的创建者，吴恩达\n深度学习的历史\nSerpent AI : 游戏代理框架\n\n研讨会、研究性写作、会谈等\n关于研究和写作的建议\n在会议上讨论的实用技巧\n研讨会和报告\nLatex参考\nBegin Latex in minutes : 针对初学者的Latex的简单介绍帮助你轻松掌握Latex\nLshort : 对Latex2的详细介绍\n\n知识汇总\nreddit.com/user/ashish2199/m/cs_student_subs : 在reddits中计算机科学和编程相关的主题\n一个程序员应该访问的web站点 :发表在Quora上，作者ashish2199\nMoocha : 从edx、coursera、udacity等搜索在线课程\nRico’s cheatsheets : 常用知识备忘集合\nAPI Documentation : 一个众所周知的带有搜索接口的API文档，类似于dash\n\nyoutube频道\nC++Now (BoostCon) :当前的C++会议\ncode::dive conference : 有诺基亚技术中心组织的会议\nCoding Blocks : 指南，技巧\nComputerphile : 每个CS学生都应该看\nComputerHistory : 针对那些想知道如何达成目标的人\nCppCon : C++会议\nFacebook Developers\nFun Fun Function : 每周一次的对编程主题的分类，也包括一些与编码不直接相关的内容\nGoogle Developers\nGoogleTechTalks : 关于热门话题的视频和在技术界的一些趣事\nGynvael Coldwin :逆向工程和黑客（CTF）博客，每周三都有新的直播\nHowToBecomeTV : 与技术界相关的开发人员的好的面试\nJava : 有关Java的会谈\nJavaOne : Java会议\nMeeting C++ YT Kanalseite : C++会议\nNetflix UI Engineering : web开发者，移动开发者和对Netflix技术栈感兴趣的视频\nO’Reilly : 世界最佳技术作家访谈录\nPlacement Grid : 面试及校园实习经验\nScott Meyers: Past Talks\nSiraj Raval : AI和深度学习指南视频\nThinMatrix : 开发者在java中使用OpenGL制作的一个3D游戏的博客和指南\nthoughtbot : 谈论各种话题\nyegor256\n\n文章\n白话40个关键的计算机科学概念\n关于图论的一个介绍\n一个对程序员友好的语言\n软件开发者的阅读列表 : 这是一些好书和链接\n关于TCP/IP协议栈的代码: 编写一个TCP/IP的协议栈，5:TCP重传\n代码的转换:语言的选择\n数据结构与算法:一些算法和数据结构的解决方案\n深入字节码\n初级开发者的想法\nLinux内核\n算法清单\n提升编码技巧的关键\nUnicode编码\n我们正在通过创新重塑零售业\n每个程序员都需要知道的关于在文本中设置编码和字符的内容\n每个程序员都应该了解的关于内存的内容-pdf\n为什么网页的快速加载是很重要的:为什么一个APP的速度决定了其收入\nqotoqot-提升技巧:我是如何一个月工作200个小时的\nPixel Beat - Unix:使用unix工具并行处理\n学习Vim:我希望我应该知道什么\n\n播客\nCoding Blocks:一个播客，涵盖最佳编程实践，设计模式，性能编码，面向对象编码，数据库设计和实现、提示、技巧和许多其他主题的内容\n水深火热的开发者:一个播客，分享开发人员的人性，并讲述了由Dave Rael主持的一些令人惊叹的软件人物的故事\n前端的欢乐时光:来自Netflix，Evernote，Atlassian＆LinkedIn的软件工程师小组，讨论关于前端开发的所有事情的一个博客。\n无线电的所有流程:包括从产品设计和用户体验到单元测试和系统管理。\nJavaScript 论坛:每周一次关于JavaScript，前端开发，社区，职业和框架的讨论。\n用我的播客学习代码:以一个季为一集的科技播客，是由劳伦斯·布拉德福德（Laurence Bradford）主持，从科技职业到科技业务的课程\nMS示例展示:Jason Young和Carl Schweitzer谈到有关Azure云，Windows，Windows Phone，Visual Studio以及使用Microsoft平台的跨平台开发等最新的开发者新闻\nReact Native Radio:每周讨论使用JavaScript和React构建移动应用程序的工具，技术和技术\n软件工程日报:关于软件主题的日常技术面试\n软件工程无线电:针对专业软件开发人员的播客，目标是成为一个持久的教育资源而不是新闻\n语法 :对Wes Bos＆Scott Tolinski和Web开发人员来说是一个比较有趣的博客\nThe Bike Shed :参与者讨论他们的开发经验和Ruby，Rails，JavaScript等的挑战\nThe Change log : 每周一次的谈话，参与者都是开源技术的核心人员和创建者\n愤世嫉俗的开发者 :一个播客，旨在通过解释最新和最伟大的开发技术，为您提供开发知识和职业生涯，并提供您作为开发人员取得成功的需要。覆盖桌面，网络和移动开发，主要围绕.Net堆栈，也经常研究其他软件和框架\n\n教程\nA Hacker’s Guide to Git : 为那些想学习git的人打下坚实的基础\nBest Of - Gustavo Duarte : 包含各种主题的文章\nCMSI 281: Data Structures : 针对数据结构的轻量级的说明\nCollecting all the cheat sheets : 大量编程语言的接口表\nC Programming\nC编程语言常见问题\nData Structures and Algorithms by John Morris : 代码和其分析的另一个好的来源\n深入学习C语言 : 关于C语言的一个很好的演示\n设计模式：可重用面向对象的软件的基础 : aka the “Gang Of Four” book, or GOF\nDynamic programming - PrismoSkills : 学习如何解决动态规划问题\nGit从入门到精通\nHead First Design Patterns\nHow to Program in C++ : 怎样学习C++编程，关于学习C++和STL的好资源\nhttp://www.mysqltutorial.org/\nindradhanush tutotials : 写一个Unix核\nIntroduction to C Programming\n10分钟搞定UNIX\nLearning the shell.\nLinux Journey : 学习Linux的好站点\nLinux Tutorial : 学习Linux的好资源\nMore about Github-flavored markdown\nMySQL Essentials\nOpen Data Structures : 用来学习数据结构和算法的优秀的资源提供了C++ , Java等各种语言的伪代码\nOS Course Notes : Galvin’s书的章节笔记\n从新手到专家-编程、web开发、DevOps新闻，教程和工具\nSQL (Structured Query Language) in one page : SQL.SU : 结构化查询语言，一个非常好的SQL记录表\nSubtle | Poor Man’s CI : 了解连续集成平台如何工作，通过使用Node.js构建您自己的git之一\nTCP/IP图解\nThe Bash Guide : 学习Bash Shell的优秀教程\nThe Descent to C : 针对那些从高级编程语言像java或者python迁移到C的人\nThe Linux 命令行: yige完整介绍\nThe Unix环境编程\nTopCoder Tutorials\nTutorialspoint : UPSC，IAS，PCS，公务员，银行，能力，问题，答案，解释，面试，入学考试，解决方案的文本和视频教程\nUNIX和Linux系统管理员手册 第四版\nVimTutor+ : 从浏览器上学习VIM\nW3Schools在线Web教程\nUnix Shell : ksh / bash的Unix shell脚本\nSnap SVG : 现代Web的JavaScript SVG库\nvim.rtorr : Vim Cheat Sheet\nOpen Vim : 交互式Vim教程\nAlgorithm Using Dynamic Programming and A : 使用动态编程和A*设计树差分算法\nLearn Python : 免费的交互式Python教程\nC++17 : C ++指南17\n\n一个程序员应该知道的东西\nGitHub.com Build software better, together : 向其他人展示你的项目和与人协作的地方（为了更高效的使用它必须知道Git）\nGitlab提供无限制的私有库，和无限制的组织\n程序员能力矩阵 : 一篇用来了解我们作为程序员的水平的文章\n\n编程比赛\nArchived Problems - Project Euler : 问题归档\nArt of Problem Solving : 数学课对你来说太容易了吗？你来到正确的地方！\nCodeChef : 唯一的编程比赛Web 2.0平台\nCodefights : 测试你的编码技巧\nCodeforces : 编程竞赛，在线计算机编程\nCodewars : 根据完成代码排名\nCodility : 验证和提高编码技能\nCodingame : 通过游戏和挑战学习编码！\nGoogle Code Jam Practice and : 过去比赛的练习题\nHackerEarth - Programming challenges and Developer jobs\nHackerRank : 实践编码、竞争、找工作\nPKU ACM ICPC Practice problems : ACMACPC 在线审核\nSphere Online Judge (SPOJ) : 成为一名真正的编程硕士学习如何编写和构建高效的算法\nTopcoder : 通过更多的包为代码提供更快的速度\nUVa Online Judge : 支持多种语言的数百种问题\nWakaTime : 通过编辑器插件收集编码度量的排行榜\n\n计算机书籍\nBecome a Programmer, Motherfucker (list of books) :来自Zed A. Shaw的书籍详尽清单\ncses.fi/book.html\ngithub.com/vhf/free-programming-books : 超过500本免费电子书几乎包括你能想到的所有语言\nGitBook : GitBook 可以帮助您的团队在线编写，协作和发布内容\nData Science course : Python数据科学手册\n\n视频指南\ncodedamn : 前端Web开发教程\n代码学院 : PluralSight公司和一个有抱负和有经验的开发人员的互动学习的地方\nCodingMadeEasy : C ++教程\nCS1: Higher Computing - Richard Buckland UNSW : 一个很好的介绍性的CS课程\nDerek Banas : 优质的教程\n算法的设计与分析\nDevTips : web开发教程\nKathryn Hodge : 为初学者提供好视频\nmycodeschool : 数据结构和算法教程\nPluralsight :通过多个短期课程学习软件开发，DevOps和数据科学\nthenewboston : 课程很好但是与实际内容相比有点啰嗦\nTushar Roy : 印度Youtuber的算法和数据结构教程\nVim Tutorial Videos - Flarfnoogins : 用于学习Vim好的视频教程\nXDA-University - Helping You Learn Android Development:帮助您学习Android开发\nKhan Academy : 免费学习计算机科学\nFunctional programming : John Carmack功能编程（2013）\nVideo about vims : 关于Vim的一系列教程\n\n在线编译和共享代码片段\nCodePad : 支持代码编写，测试和运行，支持超过25种语言\nCodesandbox.io : CodeSandbox可以更轻松地创建，与他人共享和重用React项目\nGodbolt.org : 一款非常优秀的工具用来探索在不同编译器没有优化时的输出\nIdeone.com : 用于60多种编程语言的在线编译和调试工具\nJSFiddle : 在线测试你的javascript，CSS，HTML或者CoffeeScript\nPastebin.com\nC9.io : 在云端的开发环境\nGithub Gist : 即时分享代码，笔记和片段\n\n开发者博客\nAlgo-Geeks : 编程拼图，数学技巧，算法等\nAntirez - Redis Creator’s blog : Antirez的博客\nAntonio081014’s Algorithms Codes : RULE下的世界\nArchives — Ask a Manager : 人力资源相关的东西\nArmin Ronacher’s Thoughts and Writings : 关于Python和开源的博客\nblog.might.net : might dot net的博客\nBrendon Gregg - Linux Kernel Dev : Brendon D. Gregg博客\nClean Coder Blog : 《代码整洁之道》一书作者的博客\nCodeAhoy : 软件和人为因素的博客，100％测试人类\nCoderGears Blog Insights from : the CoderGears Team\nCoding Geek - A blog about IT, programming and Java : 关于IT，编程和Java的博客\nCoding Horror : 一个最好的编码博客\nCSE Blog : 量子，数学，计算机科学难题\nDaedtech.com : 有关软件的故事\nDan Dreams of Coding\nDaniel Lemire’s Blog : Daniel Lemire的博客\nEli Bendersky : 从Python到LLVM的一切\nGeek Land : 我珍贵的收藏品\nHackerEarth Blog : 黑客博客\nIT Enthusiast : IT热衷者\nJoel on Software : StackOverflow首席执行官的博客\nLate Developer : 一个老C ++人的随机想法\n1ucasvb’s laboriginal math and physics visualization : Lucas Vieira Barbosa的实验室原始数学和物理可视化\nMath ∩ Programming : Math ∩ Programming\nMy Tech Interviews : 准备技术访谈\nPaul Graham Essays : Paul Grahan Essays\nProgramming Blog : Yegor Bugayenko的编程博客\nProgramming in the 21st Century : 二十一世纪的编程\nrudhakar Rayavaram : Sudhakar Rayavaram博客\nRunhe Tian Coding Practice : 苹果，谷歌，Facebook，亚马逊和微软的技术面试问题\nSmall Programming Challenges and Puzzles : Nayuki项目\nStephen Haunts { Coding in the Trenches } : 软件开发，架构和技术领导力\nstevehanov.ca : 我知道如何在线制作和销售软件，我可以和你分享我的提示\nTakipi Blog : 主要关注Java和JVM语言\nWildMl : 机器学习博客\nXDA - Android Developer Forum : Android开源开发者论坛\n\n英语\nEnglishclub.com/learn-english\n语法和写作指南 : 对于那些想提高英语语言能力的人\n标点符号和字母大小写规则\nPPurdue大学在线写作实验室\nQuia - English\n\n","slug":"引擎搜索","date":"2024-07-01T00:00:00.000Z","categories_index":"技能","tags_index":"","author_index":"Gueason"},{"id":"aa511ac4879771de2733384acfc7e52f","title":"Linux操作系统（搬运）","content":"一、简史UNIX\n1970年，美国贝尔实验室的 Ken Thompson，以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且他用B语言写了第一个UNIX操作系统。因为B语言的跨平台性较差，为了能够在其他的电脑上也能够运行这个非常棒的Unix操作系统，Dennis Ritchie和Ken Thompson 从B语言的基础上准备研究一个更好的语言1972年，美国贝尔实验室的 Dennis Ritchie在B语言的基础上最终设计出了一种新的语言，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言1973年初，C语言的主体完成。Thompson和Ritchie迫不及待地开始用它完全重写了Unix操作系统\nMINUX\n因为AT&amp;T(通用电气)的政策改变，在Version 7 Unix推出之后，发布新的使用条款，将UNIX源代码私有化，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(塔能鲍姆)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。\nLINUX\nLinus Torvalds利用GNU的bash当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件\n1991年的10月5日，林纳斯·托瓦兹在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核的诞生（Freeminix-likekernel sources for 386-AT）。\n1993年，大约有100余名程序员参与了Linux内核代码编写/修改工作，其中核心组由5人组成，此时Linux 0.99的代码大约有十万行，用户大约有10万左右。\n1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议。\n二、简介2.1Linux内核版本内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。\nLinux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：\n稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。开发版：由于要试验各种解决方案，所以变化很快。\n内核源码网址：http://www.kernel.org \n2.2Linux发行版本GNU 是一个类 Unix 操作系统。它是由多个应用程序、系统库、开发工具乃至游戏构成的程序集合。GNU 的开发始于 1984 年 1 月，称为 GNU 工程。GNU 的许多程序在 GNU 工程下发布；我们称之为 GNU 软件包。\n“GNU”这个名字是“GNU’s Not Unix”的递归首字母缩写词。“GNU”的发音为g’noo，只有一个音节，发音很像“grew”，但需要把其中的r音替换为n音。\n类 Unix 操作系统中用于资源分配和硬件管理的程序称为 “内核”。GNU 所用的典型内核是 Linux。该组合叫做 GNU/Linux 操作系统。GNU/Linux 为几百万用户所使用，然而许多人 错误地称之为 “Linux”。\nGNU/Linux 发行版 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。\n一类是商业公司维护的发行版本    如RedHat（RHEL）一类是社区组织维护的发行版本    如Debian\nRedHat\nRedhat（小红帽），应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多 的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非 常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管 理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用， 但是Fedora Core的稳定性较差，最好只用于桌面应用。\n红帽 | Red Hat 企业开源技术领导者\nCentOS\nCentOS是一款企业级Linux发行版,它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱,又能领略红帽企业级Linux;对他们来说,CentOS值得一试。此外,CentOS的外观和行为似乎与母发行版红帽企业级Linux如出一辙。 CentOS使用YUM来管理软件包。\nThe CentOS Project\nFedora\n小巧的Fedora适合那些人:想尝试最先进的技术,等不及程序的稳定版出来。其实,Fedora就是红帽公司的一个测试平台;产品在成为企业级发行版之前,在该平台上进行开发和测试。Fedora是一款非常好的发行版,有庞大的用户论坛,软件库中还有为数不少的软件包。Fedora同样使用YUM来管理软件包。\nFedora Linux | The Fedora Project\nDebian\nDebian运行起来极其稳定,这使得它非常适合用于服务器。Debian平时维护三套正式的软件库和一套非免费软件库,这给另外几款发行版(比如Ubuntu和Kali等)带来了灵感。Debian这款操作系统派生出了多个Linux发行版。它有37500多个软件包,这方面唯一胜过Debian的其他发行版只有Gentoo。Debian使用apt或aptitude来安装和更新软件。\nDebian — 通用操作系统\nUbuntu\nUbuntu是Debian的一款衍生版,也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应用,在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。作为Debian Gnu Linux的一款衍生版,Ubuntu的进程、外观和感觉大多数仍然与Debian一样。它使用apt软件管理工具来安装和更新软件。它也是如今市面上用起来最容易的发行版之一。Ubuntu使用基于apt的程序包管理器。\nUbuntu系统下载 | Ubuntu\nGentoo\n与Debian一样,Gentoo这款操作系统也包含数量众多的软件包。Gentoo并非以预编译的形式出现,而是每次需要针对每个系统进行编译。连Gentoo社区都觉得Gentoo安装和使用起来很困难;不过它被认为是最佳学习对象,可以进而了解Linux操作系统的内部运作原理。提到Gentoo总有人这么说:”如果你要学用Linux发行版,那就学用该发行版吧;如果你学会了Gentoo,也就学会了Linux。”Gentoo使用portage来安装和更新软件。\nhttp://www.gentoo.org/main/en/where.xml\nOpenSuse\nOpenSuse这款Linux发行版是免费的,并不供商业用途使用,仍然供个人使用。OpenSuse的真正竞争对手是红帽企业级Linux。它使用Yast来管理软件包。有了Yast,使用和管理服务器应用程序就非常容易。此外,Yast安装向导程序可以配置电子邮件服务器、LDAP服务器、文件服务器或Web服务器,没有任何不必要的麻烦。它随带snapper快照管理工具,因而可以恢复或使用旧版的文件、更新和配置。由于让滚动发行版本成为可能的Tumbleweed,可将已安装的操作系统更新到最新版本,不需要任何的新发行版。\nopenSUSE - Linux OS. 桌面用户、开发者以及系统管理员的匠之所选。\nKali Linux\nKali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。它大概在三个月前才发行。Kali的前身是Backtrack。用于Debian的所有Binary软件包都可以安装到Kali Linux上,而Kali的魅力或威力就来自于此。此外,支持Debian的用户论坛为Kali加分不少。Kali随带许多的渗透测试工具,无论是Wifi、数据库还是其他任何工具,都设计成立马可以使用。Kali使用APT来管理软件包。\nKali Linux | Penetration Testing and Ethical Hacking Linux Distribution\nArch Linux\nArch是一款采用滚动发行方式的操作系统:只要安装一次就够了;每当发行了某个新版本,就可以升级发行版,不需要重新安装。Pacman是Arch Linux的软件包管理器。Arch Linux既支持X86处理器架构,又支持X86_64架构,安装程序可以从光盘或U盘来运行。Arch旨在从开发者的角度而不是从用户的角度做到力求简单。Arch配置和安装起来超容易。\nArch Linux\n\n2.3Linux系统目录\nLinux是树型目录结构，只有一个根目录’/‘，其余各个目录都是基于这个根目录发散，就是树形结构。将某个分区挂到一个对应的目录上，例如/home对应一块分区,home目录就是这块分区的挂载点、/boot对应一块分区,boot目录就是这块分区的挂载点。可以形象的理解：一棵大树(根目录/)有很多树枝(目录，挂载点)，每个树枝上都挂着一个箱子(分区，存储空间)。\nLinux 中的每一个分区都是构成支持一组文件和目录所必需的贮存区的一部分。它是通过挂载(mounting)来实现的，挂载是将分区关联到某一目录的过程，在linux系统中，磁盘分区后，需要将其挂载到其它目录下，才可以进行访问。将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件，如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。挂载分区使起始于这个指定目录(通称为挂载点，mount point)的贮存区能够被使用。\n总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载\n例如，如果分区 /dev/hda5 被 挂载在 /usr 上，这意味着所有在 /usr 之下的文件和目录在物理意义上位于 /dev/hda5 上。因此文件 /usr/share/doc/FAQ/txt/Linux-FAQ 被储存在 /dev/hda5上。\n/usr 之下的一个或多个目录还有可能是其它分区的挂载点。例如，某个分区(假设为，/dev/hda7)可以被挂载到 /usr/local 下，这意味着 /usr/local/man/whatis 将位于 /dev/hda7 上而不是 /dev/hda5 上。 \n/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。\n/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。\n/bin: Binary的缩写, 这个目录存放着可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。\n/sbin: 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。\n文件夹下的箭头是软链接（快捷方式）\n/dev：Device(设备)的缩写，存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。\n/dev/console: 系统控制台，也就是直接和系统连接的监视器。\n/dev/sda:硬盘驱动程序接口。如：/dev/sda指的是第一个硬盘，sda1则是指/dev/sda的第一个分区。如系统中有其他的硬盘，则依次为/dev/sdb /dev/sdc\n/dev/fd: 软驱设备驱动程序。如： /dev/fd0指系统的第一个软盘，也就是通常所说的a：盘，/dev/fd1指第二个软盘.\n/dev/stscsi:磁带驱动器驱动程序。\n/dev/tty: 提供虚拟控制台支持。如:/dev/tty1指的是系统的第一个虚拟控制台， /dev/tty2则是系统的第二个虚拟控制台。\n/dev/pty: 提供远程登陆伪终端支持。在进行telnet登录时就要用到/dev/pty设备。\n/dev/ttys: 计算机串行接口，对于windows来说就是com1口。 9. /dev/cua 计算机串行接口，与调制解调器一起使用的设备。\n/dev/null: “黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输出到/dev/null中即可。\n/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。\n/etc/rc或/etc/rc.d：启动、或改变运行级时运行的脚本或脚本的目录。\n/etc/passwd:用户数据库，其中的域给出了用户名、用户描述、用户起始目录、加密口令和用户的其他信息。\n/etc/group: 类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。\n/etc/fdprm: 软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见setfdprm的帮助页。\n/etc/fstab:指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。\n/etc/inittab: init 的配置文件。\n/etc/issue: 包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。\n/etc/magic: file的配置文件。包含不同文件格式的说明，file基于它猜测文件类型。\n/etc/motdmotd:是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。\n/etc/mtab: 当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。\n/etc/shadow: 在安装了影子( shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困难，以此增加系统的安全性。\n/etc/login.defs: login命令的配置文件。\n/etc/printcap: 类似/etc/termcap ，但针对打印机。语法不同。\n/etc/profile 、/ etc/csh.login、/etc/csh.cshrc: 登录或启动时bourne或cshells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。\n/etc/securetty: 确认安全终端，即哪个终端允许超级用户(root)登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem )或网络闯入系统并得到超级用户特权。\n/etc/shells: 列出可以使用的shell。chsh 命令允许用户在本文件指定范围内改变登录的shell。提供一台机器f t p服务的服务进程ftpd 检查用户shell是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。\n/etc/termcap: 终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。\n/usr：可记为Unix Software Resource。应用程序存放目录，类似于windows下的program files目录。\n/usr/bin :存放应用程序。\n/usr/share: 存放共享数据。\n/usr/lib: 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。\n/usr/src：内核源代码默认的放置目录。\n/usr/local: 存放软件升级包。\n/usr/share/doc: 系统说明文件存放目录。\n/usr/share/man: 程序说明文件存放目录。\n/var：放置系统执行过程中经常变化的文件\n/var/log/message：所有的登录文件存放目录。\n/var/spool/mail：邮件存放的目录。\n/var/run:程序或服务启动后，其PID存放在该目录下。\n/var 包括系统一般运行时要改变的数据.每个系统是特定的，即不通过网络与其他计算机共享。\n/var/catman: 当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man 中；有些man页可能有预格式化的版本，存在/usr/man/cat 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.)\n/var/lib: 系统正常运行时要改变的文件。\n/var/local:/usr/local 中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。\n/var/lock: 锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件。\n/var/log: 各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除。\n/var/run: 保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息。\n/var/spool，/var/mail, /var/news 打印队列和其他队列工作的目录.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中。\n/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，表示当前用户的家目录，edu 表示用户 edu 的家目录。\n/lib: Library的缩写，系统使用的函数库（动态连接共享库）的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。\n/lost+found：系统异常产生错误时，会将一些遗失的片段放置于此目录下。\n/media：linux系统自动识别设备，例如U盘、光驱并挂载到这个目录下。\n/mnt:光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。\n/opt：(optional)给主机额外安装软件所摆放的目录。\n/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。\n/root：系统管理员root的家目录。\n/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。\n/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n2.4网络连接模式\n桥接方式\n桥接方式下，虚拟机和宿主机处于同一网段，真实存在于网络中，像是一台真实的主机。虚拟机和宿主机彼此互通，且网络中的其他主机也可以互通。就像是连接在hub中的主机一样。\n\nNAT方式\nNAT方式全称Network Address Translation，即借助网络地址转换功能，通过宿主机所在的网络实现访问互联网。此种方式下，虚拟机并不真实的存在于网络中，所以宿主机无法ping通虚拟机，虚拟机彼此间也不通。但是通过nat虚拟机可以访问互联网，且可以访问宿主机以及宿主机同网络中的其他主机。\nhost-only方式\nhost-only方式下，虚拟机和真实的网络是互相隔离的，不过所有的虚拟机彼此是可以互通的，可是访问不了互联网。宿主机可以访问虚拟机。\n2.5运行级别1）CentOS6 的运行级别\n\n2）CentOS7 的运行级别简化为: \nmulti-user.target 等价于原运行级别 3\n graphical.target 等价于原运行级别 5\n 3） 查看当前运行级别:\n systemctl get-default\n 4）修改当前运行级别 \nsystemctl set-default TARGET.target （这里 TARGET 取 multi-user 或者 graph\n2.6网络管理手册与链接配置和管理网络 | Red Hat Product Documentation\n部分 II. 管理 IP 网络 | Red Hat Product Documentation\nCentos8的网络管理 - 运维小菜鸟 - 博客园 (cnblogs.com)\n使用nmcli/nmtui/ifcfg在RHEL8/CentOS8系统中配置静态IP地址 图文教程 - AndyX.Net - 安迪克斯\n2.7NetworkManager网络管理服务第 2 章 NetworkManager 入门 | Red Hat Product Documentation\n部分 II. 管理 IP 网络 | Red Hat Product Documentation\n2.8防火墙管理1:查看防火状态\nsystemctl status firewalld\n2:暂时关闭防火墙\nsystemctl stop firewalld\n3:永久关闭防火墙\nsystemctl disable firewalld\n4:重启防火墙\nsystemctl enable firewalld\nfirewalld\nCentos7默认安装了firewalld，如果没有安装的话，可以使用 yum install firewalld firewalld-config进行安装。\n1.启动防火墙\nsystemctl start firewalld2.禁用防火墙\nsystemctl stop firewalld3.设置开机启动\nsystemctl enable firewalld4.停止并禁用开机启动\nsytemctl disable firewalld5.重启防火墙\nfirewall-cmd —reload6.查看状态\nsystemctl status firewalld或者 firewall-cmd —state7.查看版本\nfirewall-cmd —version8.查看帮助\nfirewall-cmd —help9.查看区域信息\nfirewall-cmd —get-active-zones10.查看指定接口所属区域信息\nfirewall-cmd —get-zone-of-interface=eth011.拒绝所有包\nfirewall-cmd —panic-on12.取消拒绝状态\nfirewall-cmd —panic-off13.查看是否拒绝\nfirewall-cmd —query-panic14.将接口添加到区域(默认接口都在public)\nfirewall-cmd —zone=public —add-interface=eth0(永久生效再加上 —permanent 然后reload防火墙)15.设置默认接口区域\nfirewall-cmd —set-default-zone=public(立即生效，无需重启)16.更新防火墙规则\nfirewall-cmd —reload或firewall-cmd —complete-reload(两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务)17.查看指定区域所有打开的端口\nfirewall-cmd —zone=public —list-ports18.在指定区域打开端口（记得重启防火墙）\nfirewall-cmd —zone=public —add-port=80/tcp(永久生效再加上 —permanent)\nfirewall-cmd —zone=public —add-port=80/tcp —permanent\n注：开启后需要重启防火墙才生效\n【重启命令】： firewall-cmd —reload\n其他常用命令：\nfirewall-cmd —state ##查看防火墙状态，是否是runningfirewall-cmd —reload ##重新载入配置，比如添加规则之后，需要执行此命令firewall-cmd —get-zones ##列出支持的zonefirewall-cmd —get-services ##列出支持的服务，在列表中的服务是放行的firewall-cmd —query-service ftp ##查看ftp服务是否支持，返回yes或者nofirewall-cmd —add-service=ftp ##临时开放ftp服务firewall-cmd —add-service=ftp —permanent ##永久开放ftp服务firewall-cmd —remove-service=ftp —permanent ##永久移除ftp服务firewall-cmd —add-port=80/tcp —permanent ##永久添加80端口firewall-cmd —remove-port=80/tcp —permanent ##永久移除80端口firewall-cmd —zone=public —list-ports ##查看已开放的端口\niptables -L -n ##查看规则，这个命令是和iptables的相同的man firewall-cmd\n1、开放端口\nfirewall-cmd —zone=public —add-port=5672/tcp —permanent # 开放5672端口\nfirewall-cmd —zone=public —remove-port=5672/tcp —permanent #关闭5672端口\nfirewall-cmd —reload # 配置立即生效\n2、查看防火墙所有开放的端口\nfirewall-cmd —zone=public —list-ports\n3.、关闭防火墙\n如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估\nsystemctl stop firewalld.service\n4、查看防火墙状态\nfirewall-cmd —state\n5、查看监听的端口\nnetstat -lnpt\nPS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools\n6、检查端口被哪个进程占用\nnetstat -lnpt |grep 5672\n7、查看进程的详细信息\nps 6832\n8、中止进程\nkill -9 6832\n说明：–zone 作用域–add-port=8080/tcp 添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效\n2.9 RPMRPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe 是Linux这系列操作系统里面的打包安装工具\n它会建立统一的数据库文件，详细记录软件包安装 、卸载等变化信息，能够自动分析软件包依赖关系\n它最大的特点就是将你要安装的软件先编译过，并且打包成为 RPM 机制的文件，通过打包好的软件里面默认的数据库，记录这个软件要安装的时候必须具备的依赖属性软件。当在你的 Linux 主机安装时，RPM 会先依照软件里面的数据查询Linux 主机的依赖属性软件是否满足，若满足则子以安装，若不满足则不子安装。那么安装的时候就将该软件的信息整个写入 RPM 的数据库中，以便未来的查询、验证与反安装。\nRPM包的名称格式 \nApache-1.3.23-11.i386.rpm——\n\n“apache” 软件名称\n“1.3.23-11”软件的版本号，主版本和此版本\n“i386”是软件所运行的硬件平台，\nIntel32位处理器的统称 \n“rpm”文件扩展名，代表RPM包\n\n查询命令\n1）基本语法 \n123rpm -qa 软件名称rpm -qi 软件名称\n2）经验技巧 （功能描述：查询所安装的所有rpm软件包） 由于软件包比较多，一般都会采取过滤。\nrpm-qa|grep rpm软件包\n卸载命令\n1）基本语法 \n123rpm -e RPM软件包 rpm -e --nodeps 软件包 \n安装命令\n1）基本语法 \nrpm-ivh RPM包全名\n2）选项说明\n\n2.10 YUMYUM（全称为YellowdogUpdater, Modified）是一个在 Fedora和 RedHat以及 CentOS 中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次 次下载、安装\n1）基本语法 \n1yum [选项][参数] \n2）选项说明\n-y 同意\n3）参数说明\n显示：yum list installed\n\n\n三、Gnome下的快捷键Alt + F1：类似Windows下的Win键，在GNOME中打开”应用程序”菜单(Applications) （在KDE下同样适用。）\nAlt + F9：最小化窗口 Alt + F10：最大化窗口Alt + space：打开窗口的控制菜单 (点击窗口左上角图标出现的菜单)单击鼠标滚轮：当您选中一段文字后，按下鼠标滚轮键，可以将选中的文字复制到鼠标所指的位置，在中端中也有效。 （KDE中未测试。）Atl+单击鼠标拖动：移动窗口的位置。 （在KDE和Compiz中同样有效。）\nShift+Ctrl+N - 新建文件夹, 很有用\nAlt + Enter - 查看选择文件/文件夹的属性，代替单击右键选择属性\nCtrl + 1/2 - 改变文件夹视图查看方式，图标视图/列表视图\nCtrl + W - 关闭当前Nautilus窗口\nCtrl + Shift + W - 关闭所有Nautilus窗口\nCtrl+T - 在Nautilus中新建一个标签\nAlt + Up/Down Arrow - 移动到父文件夹/选择的文件夹\nAlt + Left/Right Arrow - 后退/前进\nAlt + Home -直接移动到主文件夹\nF9 - 开关显示Nautilus侧边栏\nCtrl + H -开关显示隐藏文件夹\n\n四、VIM编辑器vi概述vi（visual editor）编辑器通常被简称为vi，它是Linux和Unix系统上最基本的文本编辑器，类似于Windows 系统下的notepad（记事本）编辑器。\nvim编辑器Vim(Vi improved)是vi编辑器的加强版，比vi更容易使用。vi的命令几乎全部都可以在vim上使用。\n4.1 vim编辑器的四种模式命令模式使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。\n编辑模式或输入模式在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑\n末行模式在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作\n可视化模式可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）\n\n模式间切换方法：（1）命令模式下，输入:后，进入末行模式（2）末行模式下，按esc慢退、按两次esc快退、或者删除所有命令，可以回到命令模式（3）命令模式下，按下i、a等键，可以计入编辑模式（4）编辑模式下，按下esc，可以回到命令模式\n4.2 VIM编辑器的使用\n使用vim打开文件基本语法：\n1vim  文件名称\n① 如果文件已存在，则直接打开\n② 如果文件不存在，则vim编辑器会自动在内存中创建一个新文件\n案例：使用vim命令打开readme.txt文件\n1vim readme.txt\n\n\n\n\nVi 使用的选项\n说 明\n\n\n\n\nvim filename\n打开或新建一个文件，并将光标置于第一行的首部\n\n\nvim -r filename\n恢复上次 vim 打开时崩溃的文件\n\n\nvim -R filename\n把指定的文件以只读方式放入 Vim 编辑器中\n\n\nvim + filename\n打开文件，并将光标置于最后一行的首部\n\n\nvi +n filename\n打开文件，并将光标置于第 n 行的首部\n\n\nvi +/pattern filename\n打幵文件，并将光标置于第一个与 pattern 匹配的位置\n\n\nvi -c command filename\n在对文件进行编辑前，先执行指定的命令\n\n\n\n\nvim编辑器保存文件在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号:，进入到末行模式，输入wq，代表保存并退出。\n\n建议使用:x：使用效果等同于wq，如果文件有改动则先保存后退出；但是如果文件没有做修改，会直接退出，不会修改文件更新时间，避免用户混淆文件的修改时间\n\nvim编辑器强制退出（不保存）在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号：，进入到末行模式，输入q!，代表强制退出但是不保存文件。\n\n命令模式下的相关操作如何进入命令模式\n在Linux操作系统中，当我们使用vim命令直接打开某个文件时，默认进入的就是命令模式。如果我们处于其他模式（编辑模式、可视化模式以及末行模式）可以连续按两次Esc键也可以返回命令模式\n1.光标移动\n\n\n\n快捷键\n功能描述\n\n\n\n\njkhl\n基本上下左右\n\n\ngg\n光标移动到文档首行\n\n\nG\n光标移动到文档尾行\n\n\n^或_\n光标移动到行首第一个非空字符\n\n\nhome键或0或者g0\n光标移动到行首第一个字符\n\n\ng_\n光标移动到行尾最后一个非空字符\n\n\nend或者 g\n光标移动到行尾最后一个字符\n\n\ngm\n光标移动到当前行中间处\n\n\nb/B\n光标向前移动一个单词（大写忽略/-等等特殊字符）\n\n\nw/W\n光标向后移动一个单词（大写忽略/-等等特殊字符）\n\n\ne/E\n移到单词结尾（大写忽略/-等等特殊字符）\n\n\nctrl+b或pageUp键\n翻屏操作，向上翻\n\n\nctrl+f或pageDn键\n翻屏操作，向下翻\n\n\n行号+G\n快速将光标移动到指定行\n\n\n`.\n移动到上次编辑处\n\n\n数字+上下方向键\n以当前光标为准，向上/下移动n行\n\n\n数字+左右方向键\n以当前光标为准，向左/右移动n个字符\n\n\nH\n移动到屏幕顶部\n\n\nM\n移动到屏幕中间\n\n\nL\n移动到屏幕尾部\n\n\nz+Enter键\n当前行在屏幕顶部\n\n\nz+ .\n当前行在屏幕中间\n\n\nz+ -\n当前行在屏幕底部\n\n\nshift+6\n光标移动到行首\n\n\nshift+4\n光标移动到行尾\n\n\n-\n移动到上一行第一个非空字符\n\n\n+\n移动到下一行第一个非空字符\n\n\n)\n向前移动一个句子\n\n\n(\n向后移动一个句子\n\n\n}\n向前移动一个段落\n\n\n{\n向前移动一个段落\n\n\ncount l\n移动到count 列\n\n\ncounth\n向左移动count 字符\n\n\ncountl\n向右移动count字符\n\n\ncountgo\n移动到count字符\n\n\n\n\n2.选中内容\n\n\n\n快捷键\n功能描述\n\n\n\n\nv\n进行字符选中\n\n\nV 或shift+v\n进行行选中\n\n\ngv\n选中上一次选择的内容\n\n\no\n光标移动到选中内容另一处结尾\n\n\nO\n光标移动到选中内容另一处角落\n\n\nctr + V\n进行块选中\n\n\n\n\n3.复制（配合粘贴命令p使用）\n\n\n\n快捷键\n功能描述\n\n\n\n\ny\n复制已选中的文本到剪贴板\n\n\nn+yy\n复制光标所在行，此命令前可以加数字 n，可复制多行\n\n\nyw\n复制光标位置的单词\n\n\nctrl+v + 方向键+yy\nctrl+v，并按方向键选中区块，按下yy复制\n\n\n\n\n4.剪切\n\n\n\n快捷键\n功能描述\n\n\n\n\ndd\n剪切光标所在行\n\n\n数字+dd\n以光标所在行为准（包含当前行），向下剪切指定行数\n\n\nD\n剪切光标所在行\n\n\n\n\n5.粘贴\n\n\n\n快捷键\n功能描述\n\n\n\n\np\n将剪贴板中的内容粘贴到光标后\n\n\nP（大写）\n将剪贴板中的内容粘贴到光标前\n\n\n\n\n6.删除\n\n\n\n快捷键\n功能描述\n\n\n\n\nx\n删除光标所在位置的字符\n\n\nX(大写)\n删除光标前一个字符\n\n\ndd\n删除光标所在行，删除之后，下一行上移\n\n\nD\n删除光标位置到行尾的内容，删除之后，下一行不上移\n\n\nndd\n删除当前行（包括此行）后 n 行文本\n\n\ndw\n移动光标到单词的开头以删除该单词\n\n\ndG\n删除光标所在行一直到文件末尾的所有内容\n\n\n:a1,a2d\n删除从 a1 行到 a2 行的文本内容\n\n\n\n\n7.撤销/恢复\n\n\n\n快捷键\n功能描述\n\n\n\n\nu\n撤销最近修改\n\n\nctrl+r\n恢复\n\n\nU(大写)\n撤销当前行所有编辑\n\n\n\n\n8.字符转换\n\n\n\n快捷键\n功能描述\n\n\n\n\n~\n转换大小写\n\n\nu\n变成小写\n\n\nU\n变成大写\n\n\n\n\n9.编辑命令的快捷键\n\n\n\n快捷键\n功能描述\n\n\n\n\n↑或ctr + p\n上一条命令\n\n\n↓或ctr + n\n下一条命令\n\n\nctr + b\n移动到命令行开头\n\n\nctr + e\n移动到命令行结尾\n\n\nctr + ←\n向左一个单词\n\n\nctr + →\n向右一个单词\n\n\n\n\n末行模式下的相关操作在命令模式下使用冒号：的方式进入\n1.保存/退出文件操作\n\n\n\n命令\n功能描述\n\n\n\n\n:wq\n保存并退出 Vim 编辑器\n\n\n:wq!\n保存并强制退出 Vim 编辑器\n\n\n:q\n不保存就退出 Vim 编辑器\n\n\n:q!\n不保存，且强制退出 Vim 编辑器\n\n\n:w\n保存但是不退出 Vim 编辑器\n\n\n:w!\n强制保存文本\n\n\n:w filename\n另存到 filename 文件\n\n\nx！\n保存文本，并退出 Vim 编辑器\n\n\nZZ\n直接退出 Vim 编辑器\n\n\n\n\n2.查找：“/关键词”在查找结果中，用N、n可以切换上下结果；输入nohl，可以取消高亮\n\n\n\n\n快捷键\n功能描述\n\n\n\n\n/abc\n从光标所在位置向前查找字符串 abc\n\n\n/^abc\n查找以 abc 为行首的行\n\n\n/abc$\n查找以 abc 为行尾的行\n\n\n?abc\n从光标所在位置向后查找字符串 abc\n\n\nn或；\n向同一方向重复上次的查找指令\n\n\nN或,\n向相反方向重复上次的查找指定\n\n\n\n\n3.替换\n\n\n\n快捷键\n功能描述\n\n\n\n\nr\n替换光标所在位置的字符\n\n\nR\n从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束\n\n\n:s/a1/a2\n替换当前光标所在行第一处符合条件的内容\n\n\n:s/a1/a2/g\n替换当前光标所在行所有的 a1 都用 a2 替换\n\n\n:%s/a1/a2\n替换所有行中，第一处符合条件的内容\n\n\n:%s/a1/a2/g\n替换所有行中，所有符合条件的内容\n\n\n:n1,n2 s/a1/a2\n将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换\n\n\n:n1,n2 s/a1/a2/g\n将文件中 n1 到 n2 行中所有 a1 都用 a2 替换\n\n\n\n\n4.行号显示：“: set nu”;\n行号显示:set nu\n取消行号显示：:set nonu\n\n5.文件切换使用vim打开多个文件后，在末行模式下可以进行切换。\n查看当前已经打开的所有文件：:files(%a表示激活状态，#表示上一个打开的文件)切换到指定文件：:open 文件名切换到上一个文(back previous)：:bp切换到下一个文件(back next)：:bn\n6.编辑模式下的相关操作\n\n\n\n快捷键\n功能描述\n\n\n\n\ni\n在当前光标所在位置插入，光标后的文本相应向右移动\n\n\nI\n在光标所在行的行首插入，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令\n\n\no\n在光标所在行的下插入新的一行。光标停在空行首，等待输入文本\n\n\nO（大写）\n在光标所在行的上插入新的一行。光标停在空行的行首，等待输入文本\n\n\na\n在当前光标所在位置之后插入\n\n\nA\n在光标所在行的行尾插入，相当于光标移动到行尾再执行 a 命令\n\n\nesc键\n退出编辑模式\n\n\n\n\n7.扩展代码颜色显示：“：syntax on/off”\nvim内置计算器：\na.进入编辑模式b.按“ctrl+r，光标变成引号，，输入=，光标转到最后一行c.输入需要计算的内容，按下enter后，计算结果回替代上一步中的引号，光标恢复\nvim的配置\na.文件打开时，末行模式下输入的配置为临时配置，关闭文件后配置无效b.修改个人配置文件，可以永久保存个人配置（~/.vimrc，如果没有可以自行创建）c.修改全局配置文件，对每个用户生效（vim自带，/etc/vimrc）\n注：个人配置文件优先级更高，当个人配置和全局配置发生冲突时，系统以当前用户的个人配置文件为准\n异常退出\n在编辑文件后，未正常保存退出时，会产生异常退出交换文件（.原文件名.swp）将交换文件删除后，再次打开文件时，无提示：“#rm -f .原文件名.swp”\n别名机制：自定义指令\nLinux中，存在一个别名映射文件： ~/.bashrc修改文件内容，可以自定义指令，重新登录账号后生效\n文件快捷方式\n对于深层文件，可以创建文件快捷方式，便于后续操作：#ln -s 源路径 新路径\n\n五、Shell命令解释器快捷键编辑命令Ctrl + a ：移到命令行首Ctrl + e ：移到命令行尾Ctrl + f ：按字符前移（右向）Ctrl + b ：按字符后移（左向）Alt + f ：按单词前移（右向）Alt + b ：按单词后移（左向）Ctrl + xx：在命令行首和光标之间移动Ctrl + u ：从光标处删除至命令行首Ctrl + k ：从光标处删除至命令行尾Ctrl + w ：从光标处删除至字首Alt + d ：从光标处删除至字尾Ctrl + d ：删除光标处的字符Ctrl + h ：删除光标前的字符Ctrl + y ：粘贴至光标后（主要针对CTRL+U或CTRL+W）Alt + c ：从光标处更改为首字母大写的单词Alt + u ：从光标处更改为全部大写的单词Alt + l ：从光标处更改为全部小写的单词Ctrl + t ：交换光标处和之前的字符Alt + t ：交换光标处和之前的单词Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别\n搜索命令Ctrl + r：逆向搜索命令历史Ctrl + g：从历史搜索模式退出Ctrl + p：历史中的上一条命令Ctrl + n：历史中的下一条命令Alt + .：打印之前执行过的命令的最后一部分 以空格为分隔符\n控制命令Ctrl + l：清屏Ctrl + o：执行当前命令，并选择上一条命令Ctrl + s：阻止屏幕输出Ctrl + q：允许屏幕输出Ctrl + c：终止命令Ctrl + z：挂起命令ESC + .：自动补全最近的命令TAB：自动补全Ctrl + m：换行Ctrl + L：撤销操作\n其它!!                      – 执行上一条命令\n**!ifconfig     – 执行最近运行过的以ifconfig开头的命令\n!ifconfig:p      – 打印!ifconfig要执行的命令（并将其作为最后一条命令加入到命令历史中）\n!$                    – 上一条命令的最后一个单词 (等同于Alt + .)\n!:p                  – 打印!指代的单词\n!*                    – 上一条命令除最后一个词的部分\n\n六、命令行基本操作6.1 Linux终端命令格式命令提示符命令提示符解析：\n1[deng@localhost ~]$ \n[]：这是提示符的分隔符号，没有特殊含义。\ndeng：显示的是当前的登录用户\n@：分隔符号，没有特殊含义。\nlocalhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。\n~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。\n“#”：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是$。\n用户家目录Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家：主目录超级用户的家目录：/root。普通用户的家目录：/home/用户名。\n用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。\n123[deng@localhost ~]$ cd /usr/local/src[deng@localhost src]$ \n如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 /usr/ local/src，只显示最后一个目录 src)。\n命令的基本格式格式：\n12命令 [选项] [参数]command [-options] [parameter]\n命令： 可执行文件\n选项：用于调整命令的功能。命令不同，选项的个数和内容会有所不同；要实现的命令功能不同，选项的个数和内容也会有所不同。\n参数：是命令处理的对象，通常情况可以是文件名、目录、或用户名。\n温馨提示：命令格式中的 [] 代表可选项，也就是有些命令可以不写选项或参数，也能执行。\n选项的作用选项的作用就是调整命令的功能。\nls 命令之后不加选项和参数也能执行，不过只能执行最基本的功能，即显示当前目录下的文件名。\n123[deng@localhost local]$ lsbin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n如果加一个”-l”选项，则可以看到显示的内容明显增多了。”-l”是长格式（long list）的意思，也就是显示文件的详细信息。至于 “-l” 选项的具体含义，我们稍后再详细讲解。可以看到选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。\n1234567891011121314[deng@localhost local]$ ls -l总用量 0drwxr-xr-x. 2 root root  92 7月   4 16:19 bindrwxr-xr-x. 2 root root   6 4月  11 2018 etcdrwxr-xr-x. 2 root root   6 4月  11 2018 gamesdrwxr-xr-x. 3 root root  33 2月  21 11:36 includedrwxr-xr-x. 2 root root   6 4月  11 2018 libdrwxr-xr-x. 4 root root 159 7月   4 16:19 lib64drwxr-xr-x. 2 root root   6 4月  11 2018 libexecdrwxr-xr-x. 2 root root   6 4月  11 2018 sbindrwxr-xr-x. 6 root root  60 11月 14 2018 sharedrwxr-xr-x. 2 root root   6 4月  11 2018 srcdrwxr-xr-x  5 root root 140 7月   4 16:19 ssl[deng@localhost local]$ \nLinux 的选项又分为短格式选项（-l）和长格式选项（–all）。\n短格式选项是英文的简写，前面有一个-号。\n123[deng@localhost local]$ ls -a.  ..  bin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n而长格式选项是英文完整单词，前面用两个-号\n123[deng@localhost local]$ ls --all.  ..  bin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。\n参数的作用参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。\n123456789101112[itcast@localhost ~]$ ls -l /home/itcast/总用量 0drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 公共drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 模板drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 视频drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 图片drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 文档drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 下载drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 音乐drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 桌面[itcast@localhost ~]$ \n命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。\n123[itcast@localhost ~]$ ls公共  模板  视频  图片  文档  下载  音乐  桌面[itcast@localhost ~]$ \n这个 ls 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。\n\n注意事项命令、命令选项、命令参数之间用空格隔开。\n\n123456[itcast@localhost ~]$ ls -a .              .bash_profile  .dbus          .local    视频  音乐..             .bashrc        .esd_auth      .mozilla  图片  桌面.bash_history  .cache         .ICEauthority  公共      文档.bash_logout   .config        .kshrc         模板      下载[itcast@localhost ~]$ \n当有多个命令选项时，可以进行合并。例如，可以将 ls -a / 和 ls -l / 合并为\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[itcast@localhost ~]$ ls -l -a总用量 28drwx------  15 itcast itcast 319 7月  12 17:34 .drwxr-xr-x.  5 root   root    46 7月  12 17:32 ..-rw-------   1 itcast itcast  36 7月  12 17:36 .bash_history-rw-r--r--   1 itcast itcast  18 4月  11 2018 .bash_logout-rw-r--r--   1 itcast itcast 193 4月  11 2018 .bash_profile-rw-r--r--   1 itcast itcast 231 4月  11 2018 .bashrcdrwxrwxr-x  13 itcast itcast 275 7月  12 17:36 .cachedrwxrwxr-x  14 itcast itcast 261 7月  12 17:36 .configdrwx------   3 itcast itcast  25 7月  12 17:34 .dbus-rw-------   1 itcast itcast  16 7月  12 17:34 .esd_auth-rw-------   1 itcast itcast 314 7月  12 17:34 .ICEauthority-rw-r--r--   1 itcast itcast 172 4月  11 2018 .kshrcdrwx------   3 itcast itcast  19 7月  12 17:34 .localdrwxr-xr-x   4 itcast itcast  39 11月  8 2018 .mozilladrwxr-xr-x   2 itcast itcast   6 7月  12 17:34 公共drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 模板drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 视频drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 图片drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 文档drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 下载drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 音乐drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 桌面[itcast@localhost ~]$ ls -al总用量 28drwx------  15 itcast itcast 319 7月  12 17:34 .drwxr-xr-x.  5 root   root    46 7月  12 17:32 ..-rw-------   1 itcast itcast  36 7月  12 17:36 .bash_history-rw-r--r--   1 itcast itcast  18 4月  11 2018 .bash_logout-rw-r--r--   1 itcast itcast 193 4月  11 2018 .bash_profile-rw-r--r--   1 itcast itcast 231 4月  11 2018 .bashrcdrwxrwxr-x  13 itcast itcast 275 7月  12 17:36 .cachedrwxrwxr-x  14 itcast itcast 261 7月  12 17:36 .configdrwx------   3 itcast itcast  25 7月  12 17:34 .dbus-rw-------   1 itcast itcast  16 7月  12 17:34 .esd_auth-rw-------   1 itcast itcast 314 7月  12 17:34 .ICEauthority-rw-r--r--   1 itcast itcast 172 4月  11 2018 .kshrcdrwx------   3 itcast itcast  19 7月  12 17:34 .localdrwxr-xr-x   4 itcast itcast  39 11月  8 2018 .mozilladrwxr-xr-x   2 itcast itcast   6 7月  12 17:34 公共drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 模板drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 视频drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 图片drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 文档drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 下载drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 音乐drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 桌面[itcast@localhost ~]$ \n6.2 Linux文件类型\n\n\n\n前缀\n描述\n\n\n\n\n-\n普通文件。如文本文件、二进制可执行文件、源代码等。\n\n\nb\n块设备文件。硬盘可以使用块设备文件。\n\n\nc\n字符设备文件。硬盘也可以使用字符设备文件。\n\n\nd\n目录文件。目录可以包含文件和其他目录。\n\n\nl\n符号链接（软链接）。可以链接任何普通文件，类似于 Windows 中的快捷方式。\n\n\np\n具名管道。管道是进程间的一种通信机制。\n\n\ns\n用于进程间通信的套接字。\n\n\n\n\n普通文件\n我们用 ls -l 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具… … 或 cp工具等。这类文件的删除方式是用rm 命令。\n依照文件的内容，又大略可以分为：\n纯文本档(ASCII)\nLinux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的文件都属于这一种文件类型。 举例来说，你可以用命令： cat ~/.bashrc 来看到该文件的内容。\n 二进制文件(binary)\nLinux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。常用的一些命令几乎都是二进制文件。\n数据格式文件(data)\n有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个数据文件，他能够通过last这个指令读出来。 但是使用cat时，会读出乱码，因为该文件是一种特殊格式的文件。\n1234[deng@localhost ~]$ ls -l /etc/bashrc -rw-r--r--. 1 root root 2853 4月  11 2018 /etc/bashrc[deng@localhost ~]$ \n目录文件\n当我们查看文件的详细信息的时候，看到有类似 drwxr-xr-x ，这样的文件就是目录。目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。\n123[deng@localhost ~]$ ls -ld /homedrwxr-xr-x. 5 root root 46 7月  12 17:32 /home[deng@localhost ~]$ \n字符设备\n字符设备是指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等。在UNIX系统中，字符设备以特别文件方式在文件目录树中占据位置并拥有相应的结点。\n字符设备可以使用与普通文件相同的文件操作命令对字符设备文件进行操作，例如打开、关闭、读、写等。\n123[deng@localhost ~]$ ls -l /dev/input/mouse1crw-rw---- 1 root input 13, 33 7月  12 09:45 /dev/input/mouse1[deng@localhost ~]$\n我们看到/dev/input/mouse1的属性是crw-rw—— ，注意前面第一个字符是 c ，这表示字符设备文件。\n字符设备文件可以使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。\n块设备\n块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能独立于其它块而读写。磁盘是最常见的块设备。\n123[deng@localhost ~]$ ls -l /dev/sda1brw-rw---- 1 root disk 8, 1 7月  12 09:45 /dev/sda1[deng@localhost ~]$\n/dev/sda1 的属性是 brw-rw—— ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。\n套接字\n套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。\n1[root@localhost ~]*# ls -l /var/lib/mysql/mysql.sock* srwxrwxrwx 1 mysql mysql 0 7月  12 09:45 /var/lib/mysql/mysql.sock [root@localhost ~]*#* \n注意这个文件的属性的第一个字符是 s。\n符号链接\n符号链接（软链接）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。今天POSIX操作系统标准、大多数类Unix系统、Windows Vista、Windows 7都支持符号链接。Windows 2000与Windows XP在某种程度上也支持符号链接。\n符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。某些需要特别处理符号链接的程序（如备份程序）可能会识别并直接对其进行操作。\n一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。\n123[root@localhost ~]# ls -l /bin/cclrwxrwxrwx. 1 root root 3 11月  8 2018 /bin/cc -&gt; gcc[root@localhost ~]# \n当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。Windows操作系统中的快捷方式有点相似。\n管道文件\n它是一种文件类型，在文件系统中可以看到。程序中可以查看文件stat结构中st_mode成员的值来判断文件是否是FIFO文件。创建一个FIFO文件类似于创建文件，FIFO文件就像普通文件一样。\nFIFO中可以很好地解决在无关进程间数据交换的要求，并且由于它们是存在于文件系统中的，这也提供了一种比匿名管道更持久稳定的通信办法。\nFIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据。在shell中mkfifo命令可以建立有名管道，下面通过一个实例来帮助读者理解FIFO。\n123[root@localhost ~]# ls -l fifo prw-r--r-- 1 root root 0 7月  12 19:30 fifo[root@localhost ~]# \n查看文件属性时，第一个字符是p，就表示是管道文件。\n文件扩展名和文件名\n实际上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关， 与扩展名根本一点关系也没有。这个观念跟Windows的情况不相同喔！在Windows底下， 能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。\n不过，可以被执行跟可以执行成功是不一样的～举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行～因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容.\n不过我们仍然希望可以使用扩展名来了解该文件是什么东西，所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。Linux平台有以下常用的扩展名：\n*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh\nZ, .tar, .tar.gz, .zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！\n.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。\n基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。\n6.3 Linux帮助命令man查阅 command 命令的使用手册man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明\n使用 man 时的操作键\n\n\n常用选项\n12345678910111213141516171819202122232425262728293031323334353637383940Usage: man [OPTION...] [章节] 手册页...  -a, --all                  寻找所有匹配的手册页  -d, --debug                输出调试信息   -D, --default              将所有选项都重置为默认值      --warnings[=警告]    开启 groff 的警告   -f, --whatis               等同于 whatis  -h     显示man的语法和参数说明，执行完成后退出程序。  -k, --apropos              等同于 apropos将搜索whatis数据库，模糊查找关键字    -S, -s, --sections=列表  使用以半角冒号分隔的章节列表  -t, --troff                使用 groff 对手册页排版  -w, --where, --path, --location                             输出手册页的物理位置  -W, --where-cat, --location-cat                             输出 cat 文件的物理位置    -c, --catman               由 catman 使用，用来对过时的 cat                             页重新排版     -C, --config-file=文件   使用该用户设置文件  -K, --global-apropos       search for text in all pages  -M, --manpath=路径       设置搜索手册页的路径为“路径”  -?, --help                 give this help list      --usage                give a short usage message  -V, --version              print program version  -R, --recode=编码        output source page encoded in ENCODING 寻找手册页：  -L, --locale=区域                             定义本次手册页搜索所采用的区域设置  -m, --systems=系统       use manual pages from other systems  -e, --extension=扩展                             将搜索限制在扩展类型为“扩展”的手册页之内  -i, --ignore-case          查找手册页时不区分大小写字母                             (默认)  -I, --match-case           查找手册页时区分大小写字母。      --regex                show all pages matching regex      --wildcard             show all pages matching wildcard      --names-only           make --regex and --wildcard match page names only,                             not descriptions\n\n相关描述\nman命令帮助信息的结构以及意义\n\n man对应的章节概述\n123456789101112131415-S 区段清单    该清单是一组用冒号分隔的欲查找的手册清单。此选项将覆盖      MANSECT     环境变量。    有些指令或程序可能有一个以上的主题，它们位于不同的区段中。因此，要查看较后的区    段，你可以在此指定 man 查找区段的顺序。具体区段划分如下所示：    区段1：用户指令    区段2：系统调用    区段3：程序库调用    区段4：设备    区段5：文件格式    区段6：游戏    区段7：杂项    区段8：系统指令    区段9：内核内部指令    区段n：Tcl或Tk指令\nhelp说明：\n显示 command 命令的帮助信息\n命令格式：help [参数] 内部命令\n查看外部命令的用法\n命令格式：命令 —help\n\n6.4 tab键自动补全在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键\n如果输入的没有歧义，系统会自动补全如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令小技巧按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c\n6.5 find查找文件\n\n1.搜索桌面目录下，文件名包含 1 的文件\n\n1find -name &quot;*1*&quot;\n\n2.搜索桌面目录下，所有以 .txt 为扩展名的文件\n\n1find -name &quot;*.txt&quot;\n\n3.搜索桌面目录下，以数字 1 开头的文件\n\n1find -name &quot;1*&quot;\n\n12345678910111213141516171819202122232425262728293031323334353637命令参数：    pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。     -print： find命令将匹配的文件输出到标准输出。     -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;command&#x27; &#123;  &#125; \\;，注意&#123;   &#125;和\\；之间的空格。     -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。命令选项：    -name   按照文件名查找文件。    -perm   按照文件权限来查找文件。    -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。    -user   按照文件属主来查找文件。    -group  按照文件所属的组来查找文件。    -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。    -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。    -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。    -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。    -type  查找某一类型的文件，诸如：        b - 块设备文件。        d - 目录。        c - 字符设备文件。        p - 管道文件。        l - 符号链接文件。        f - 普通文件。    -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。    -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。    -mount：在查找文件时不跨越文件系统mount点。    -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。    -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。    另外,下面三个的区别:    -amin n   查找系统中最后N分钟访问的文件    -atime n  查找系统中最后n*24小时访问的文件    -cmin n   查找系统中最后N分钟被改变文件状态的文件    -ctime n  查找系统中最后n*24小时被改变文件状态的文件    -mmin n   查找系统中最后N分钟被改变文件数据的文件    -mtime n  查找系统中最后n*24小时被改变文件数据的文件\n6.6 history游览历史history内建命令用于显示用户以前执行过的历史命令，并且能对历史命令进行追加和删除等操作。\n该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。\n历史命令是被保存在内存中的，当退出或者登录shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。\n1格式: history [选项] [参数]\n123history N\t\t显示最近N条命令history -c\t\t清除所有的历史记录history -w  xxx.txt\t保存历史记录到文本xxx.txt\n12345678-a\t将当前shell会话的历史命令追加到命令历史文件中,命令历史文件是保存历史命令的配置文件-c\t清空当前历史命令列表-d\t删除历史命令列表中指定序号的命令-n\t从命令历史文件中读取本次Shell会话开始时没有读取的历史命令-r\t读取命令历史文件到当前的Shell历史命令内存缓冲区-s\t将指定的命令作为单独的条目加入命令历史内存缓冲区。\t在执行添加之前先删除命令历史内存缓冲区中最后一条命令-w\t把当前的shell历史命令内存缓冲区的内容写入命令历史文件\n\n七、系统管理命令1.shutdownshutdown命令用来系统关机命令。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。\n1格式：shutdown [选项] [参数]\n12345678-c\t当执行“shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令-f\t重新启动时不执行fsck-F\t重新启动时执行fsck-h\t将系统关机-k\t只是送出信息给所有用户，但不会实际关机-n\t不调用init程序进行关机，而由shutdown自己进行-r\tshutdown之后重新启动-t\t送出警告信息和删除信息之间要延迟多少秒\n2.poweroffpoweroff命令用来关闭计算机操作系统并且切断系统电源。如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用poweroff命令。\n1格式：poweroff [选项]\n123456-n\t关闭操作系统时不执行sync操作-w\t不真正关闭操作系统，仅在日志文件“/var/log/wtmp”中-d\t关闭操作系统时，不将操作写入日志文件“/var/log/wtmp”中添加相应的记录-f\t强制关闭操作系统-i\t关闭操作系统之前关闭所有的网络接口-h\t关闭操作系统之前将系统中所有的硬件设置为备用模式\n3.halthalt命令用来关闭正在运行的Linux操作系统，如果是线上跑了业务的服务器，执行此命令需谨慎。\nhalt命令会先检测系统的runlevel，若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。\n1格式：halt [选项]\n123456-n\t在关机或重启之前不对系统缓存进行同步。-w\t不真正重启或关机，而仅仅将关机信息写入wtmp（在/var/log/wtmp文件里）。-d\t不记录此次关机情况。当使用 -n 参数时隐含 -d。-f\t强制执行 halt 或 reboot 而不去调用 shutdown(8)。-i\t在关闭或重启系统之前关闭所有网络界面。-p\t当关闭系统时执行关闭电源操作。当以poweroff方式调用halt时，此为缺省参数。\n4.rebootreboot命令用于用来重新启动计算机。但是机器重启必须要root用户才有权限。\n1格式： reboot [选项]\n12345-n\t重开机之前不检查是否有未结束的程序-w \t并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d\t不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f\t强迫重开机，不呼叫 shutdown 这个指令-i\t在重开机之前先把所有网络相关的装置先停止\n\n八、磁盘管理命令1.lsblk查看磁盘大小\n命令：lsblk\n命令：lsblk -a\n功能：查看挂载磁盘信息，磁盘名称、大小、挂载目录等。\n\n\nIDE磁盘的文件名为：/dev/hdxx\nSCSI/SATA/USB磁盘文件名为：/dev/sdxx\n\nVDA管理虚拟磁盘，SDA管理实体硬盘，而SDB是SDA的扩展，管理的是第二个物理磁盘设备。此外，虚拟磁盘是虚拟机中的设备，而物理磁盘则是实体服务器中的设备。\n2.dudu - 报告磁盘空间使用情况\ndu命令**的英文全称是“Disk Usage”，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区。\n12用法：du [选项]... [文件]...　或：du [选项]... --files0-from=F\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657POSIX 选项       -a     显示对涉及到的所有文件的统计，而不只是包含子目录。       -k     用1024字节作为计数单位，替代缺省时512字节的计数单位。       -x     只输出指定参数的实际使用空间，而不包括其下的子目录。       -s     只统计指定参数的在同一设备上所使用的空间。GNU 选项       -a, --all              显示对所有文件的统计，而不只是包含子目录。       -b, --bytes              输出以字节为单位的大小，替代缺省时1024字节的计数单位。       --block-size=size              输出以块为单位的大小，块的大小为 size  字节。(  file-  utils-4.0              的新选项)       -c, --total              在处理完所有参数后给出所有这些参数的总计。这个选项被              用给出指定的一组文件或目录使用的空间的总和。       -D, --dereference-args              引用命令行参数的符号连接。但不影响其他的符号连接。    这对找出象              /usr/tmp          这样的目录的磁盘使用量有用，          /usr/tmp              等通常是符号连接。  译住：例如在  /var/tmp   下建立一个目录test,              而/usr/tmp  是指向  /var/tmp  的符号连接。du  /usr/tmp  返回一项              /usr/tmp , 而 du - D /usr/tmp 返回两项 /usr/tmp，/usr/tmp/test。       --exclude=pattern              在递归时，忽略与指定模式相匹配的文件或子目录。模式    可以是任何              Bourne shell 的文件 glob 模式。( file- utils-4.0 的新选项)       -h, --human-readable              为每个数附加一个表示大小单位的字母，象用M表示二进制 的兆字节。       -H, --si              与    -h    参数起同样的作用，只是使用法定的    SI    单位(   用              1000的幂而不是  1024  的幂，这样  M   代表的就是1000000   而不是              1048576)。(fileutils-4.0 的新选项)       -k, --kilobytes              输出以1024字节为计数单位的大小。       -l, --count-links              统计所有文件的大小，包括已经被统计过的(作为一个硬连接)。       -L, --dereference              引用符号连接(不是显示连接点本身而是连接指向的文件或              目录所使用的磁盘空间)。       -m, --megabytes              输出以兆字节的块为计数单位的大小(就是 1,048,576 字节)。       --max-depth=n              只输出命令行参数的小于等于第n层的目录的总计。--max-depth=0的作用同于-s选项。(fileutils-4.0的新选项)       -s, --summarize              对每个参数只显示总和。       -S, --separate-dirs              单独报告每一个目录的大小，不包括子目录的大小。       -x, --one-file-system              忽略与被处理的参数不在同一个文件系统的目录。       -X file, --exclude-from=file              除了从指定的文件中得到模式之外与         --exclude        一样。              模式以行的形式列出。如果指定的文件是&#x27;-&#x27;,那么从标准输              入中读出模式。(fileutils-4.0 的新选项) GNU 标准选项       --help 在标准输出上输出帮助信息后正常退出。       --version              在标准输出上输出版本信息后正常退出。       --     终结选项列表\n3.dfdf命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。\n日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。\n1用法：df [选项]... [文件]...\n1234567891011121314151617181920212223242526272829303132GNU 参数说明\t   -a, --all              列出包括BLOCK为0的文件系统       --block-size=SIZE use SIZE-byte blocks              指定块的大小       -h,--huma-readable&quot;              用常见的格式显示出大小(例如:1K 234M 2G)       -H,--si&quot;              同上,但是这里的1k等于1000字节而不是1024字节       -i, --inodes              用信息索引点代替块表示使用状况       -k, --kilobytes              指定块大小等于1024字节来显示使用状况       -l, --local              只显示本地文件系统使用状况       -m, --megabytes              以指定块大小等于1048576字节(1M)来显示使用状况       --no-sync              在取得使用信息前禁止调用同步 (default)       -P, --portability              使用POSIX格式输出       --sync 在取得使用信息前调用同步       -t, --type=TYPE              只显示指定类型(TYPE)的文件系统       -T, --print-type              输出每个文件系统的类型       -x, --exclude-type=TYPE              只显示指定类型(TYPE)之外的文件系统.       -v (忽略)       --help 输出该命令的帮助信息并退出       --version              输出版本信息并退出             \n4.freefree - 显示系统中已用和未用的内存空间总和.\nfree 命令能够显示系统中物理上的空闲和已用内存，还有交换内存，同时，也能显示被内核使用的缓冲和缓存。这些信息是通过解析文件 /proc/meminfo 而收集到的。\n不带任何选项运行 free 命令会显示系统内存，包括空闲、已用、交换、缓冲、缓存和交换的内存总数。\n1free [参数]\n123456789-b 选项 以字节为单位显示内存总和; -k 选项(缺省的)以KB为单位显示; -m 选项以MB 为单位.-t 选项 显示 一个 总计行.-o  选项  禁止  &quot;buffer adjusted&quot; 行的显示. 除非 指定 free 从 (相应的)已用/未用的 内存 减去/加上 缓冲区内存.-s 使 free 以 delay 秒为间隔,  连续抽样显示.  delay  可以设置成浮点数,它用 usleep(3) 做 微秒级 延迟.-V 显示版本信息.\n5.fdiskfdisk 是 Linux 的磁盘分区表操作工具。\n1fdisk [-l] 装置名称\n1-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。\n6.mkfs磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。\n123mkfs [-t 文件系统格式] 装置文件名-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)\n7.fsckfsck（file system check）用来检查和维护不一致的文件系统。\n若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。\n1fsck [-t 文件系统] [-ACay] 装置名称\n1234567891011-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数-s : 依序一个一个地执行 fsck 的指令来检查-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查-C : 显示完整的检查进度-d : 打印出 e2fsck 的 debug 结果-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R : 同时有 -A 条件时，省略 / 不检查-V : 详细显示模式-a : 如果检查有错则自动修复-r : 如果检查有错则由使用者回答是否修复-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。\n8.mount/umountLinux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。\n1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点\n1234umount [-fn] 装置文件名或挂载点-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况下卸除。\n\n九、文件管理命令1.pwdpwd命令是print working directory中每个单词的首字母缩写，其功能正如所示单词一样，为打印工作目录，即显示当前工作目录的绝对路径。\n1pwd [选项]\n1234567891011显示出 完整的 当前 活动目录 名称.   -L              \t打印 $PWD 变量的值，如果它命名了当前的工作目录   -P           \t\t打印当前的物理路径，不带有任何的符号链接    \t默认情况下，pwd 的行为和带 -L 选项一致\t--help \t\t显示 帮助 信息, 然后 退出\t--version \t\t显示 版本 信息, 然后 退出\n2.cdcd命令是”change directory”中单词的首字母缩写，其英文释义是改变目录，所以该命令的功能是从当前目录切换到指定目录。\n其中目录的路径可分为绝对路径和相对路径。若目录名称省略，则切换至使用者的用户目录(也就是刚登录时所在的目录)。\n另外，“~”也表示为用户目录的意思，“.”则是表示目前所在的目录，“…”则表示当前目录位置的上一级目录。\ncd 为最常用的命令，与 DOS 下的 cd 命令类似。\n1cd [选项] [目录名]\n12345678-p \t如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录-L \t如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。-  \t当仅实用&quot;-&quot;一个选项时，当前工作目录将被切换到环境变量&quot;OLDPWD&quot;所表示的目录，即回到前一个目录。..    回到上一层目录\n3.lsls 命令是Linux下最常用的指令之一。ls命令为英文单词 list 的缩写，正如英文单词 list 的意思，其功能是列出指定目录下的内容及其相关属性信息。通过 ls 命令，不仅可以查看 Linux 文件夹包含的文件，而且可以查看文件的权限（包括：目录、文件权限）、查看目录信息等。\n1ls [选项]… [文件]…\n12345678910111213141516171819202122232425262728293031323334选项\t说明-a\t列出目录下所有文件，包括以 . 开头的隐藏文件-b\t把文件名中不可输出的字符用反斜杠加字符编号（就像 C 语言一样）的形式列出-c\t输出文件的 i 节点的修改时间，并以此排序-d\t将目录像文件一样显示，而不是显示其下的文件-e\t输出时间的全部信息，而不是输出简略信息-f -U\t对输出的文件不排序-i\t输出文件的 i 节点的索引信息-k\t以 k 字节的形式表示文件的大小-l\t列出文件的详细信息-m\t横向输出文件名，并以 , 作为分隔符-n\t用数字 UID、GID 代替名称-o\t显示文件除组信息外的详细信息-r\t对目录反向排序-s\t对每个文件名后输出该文件的大小-t\t以时间排序-u\t以文件上次被访问的时间排序-v\t根据版本进行排序-x\t按列排序，横向排序-A\t显示除 . 和 .. 外的所有文件-B\t不输出以 ~ 结尾的备份文件-C\t按列输出，纵向排序-G\t列出文件的组的信息-L\t列出链接文件名，而不是链接到的文件-N\t不限制文件长度-Q\t把输出的文件名用双引号扩起来-R\t列出所有子目录下的文件-S\t以文件大小排序-X\t以文件的扩展名（最后一个 . 后的字符）排序-1\t一行只输出一个文件-color=no\t不显示彩色文件名--help\t在标准输出上显示帮助信息并退出--version\t在标准输出上显示版本信息并退出\n4.mkdirmkdir命令是”make directories”的缩写，若指定目录不存在则创建目录。。\n注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录。 所以在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。\n要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。\n1mkdir [选项] 目录…\n12345678长选项必须使用的参数对于短选项时也是必需使用的。  -m, --mode=模式       设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask  -p, --parents         需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理  -v, --verbose         每次创建新目录都显示信息  -Z, --context=CTX     将每个创建的目录的SELinux 安全环境设置为CTX      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n5.rmdir英文全称：“remove directory”, rmdir命令作用是删除空的目录。\n注意：rmdir命令只能删除空目录。当要删除非空目录时，就要使用带有“-R”选项的rm命令。\nrmdir命令的“-p”参数可以递归删除指定的多级目录，但是要求每个目录也必须是空目录。\n1rmdir [选项]… 目录…\n12345678\t  --ignore-fail-on-non-empty                      忽略仅由目录非空产生的所有错误-p, --parents         删除指定目录及其上级文件夹，例如&quot;rmdir -p a/b/c&#x27;&quot;                      与&quot;rmdir a/b/c a/b a&#x27;&quot; 基本相同-v, --verbose         输出处理的目录详情    --help            显示此帮助信息并退出    --version         显示版本信息并退出\n6.treetree命令以树状图列出目录的内容。\n1tree [选项] [参数]\n12345678910111213141516171819202122-a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-L 层级显示-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。\n7.mvmv命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或重命名文件。经常用来备份文件或者目录。\n123mv [选项]... 源文件 目标文件mv [选项]... 源文件... 目录mv [选项]... --target-directory=DIRECTORY SOURCE...\n123456789101112131415161718192021222324252627282930将源文件重命名为目标文件，或将源文件移动至指定目录。长选项必须使用的参数对于短选项时也是必需使用的。      --backup[=CONTROL]       为每个已存在的目标文件创建备份  -b                           类似--backup 但不接受参数  -f, --force                  覆盖前不询问  -i, --interactive            覆盖前询问  -n, --no-clobber             不覆盖已存在文件如果您指定了-i、-f、-n 中的多个，仅最后一个生效。      --strip-trailing-slashes  去掉每个源文件参数尾部的斜线  -S, --suffix=SUFFIX           替换常用的备份文件后缀  -t, --target-directory=DIRECTORY      将所有参数指定的源文件或目录                                        移动至 指定目录  -T, --no-target-directory     将目标文件视作普通文件处理  -u, --update                  只在源文件文件比目标文件新，或目标文件                                不存在时才进行移动  -v, --verbose         详细显示进行的步骤      --help            显示此帮助信息并退出      --version         显示版本信息并退出      备份文件的后缀为&quot;~&quot;，除非以--suffix 选项或是SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup 选项或VERSION_CONTROL 环境变量来选择。以下是可用的变量值：  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份\n8.cpcp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。\ncp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。\n1234用法：cp [选项]... [-T] 源文件 目标文件　或：cp [选项]... 源文件... 目录　或：cp [选项]... -t 目录 源文件...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667长选项必须使用的参数对于短选项时也是必需使用的。  -a, --archive\t\t\t等于-dR --preserve=all      --attributes-only\t\t\t只拷贝文件属性，不拷贝文件内容      --backup[=CONTROL\t\t为每个已存在的目标文件创建备份  -b\t\t\t\t类似--backup 但不接受参数      --copy-contents\t\t在递归处理是复制特殊文件内容  -d\t\t\t\t等于--no-dereference --preserve=links  -f, --force\t\t\t如果目标文件无法打开则将其移除并重试(当 -n 选项\t\t\t\t\t存在时则不需再选此项)  -i, --interactive\t\t覆盖前询问(使前面的 -n 选项失效)  -H\t\t\t\t跟随源文件中的命令行符号链接  -l, --link\t\t\t链接文件而不复制  -L, --dereference\t\t总是跟随符号链接  -n, --no-clobber\t\t不要覆盖已存在的文件(使前面的 -i 选项失效)  -P, --no-dereference\t\t不跟随源文件中的符号链接  -p\t\t\t\t等于--preserve=模式,所有权,时间戳      --preserve[=属性列表\t保持指定的属性(默认：模式,所有权,时间戳)，如果\t\t\t\t\t可能保持附加属性：环境、链接、xattr 等  -c                           same as --preserve=context      --sno-preserve=属性列表\t不保留指定的文件属性      --parents\t\t\t复制前在目标目录创建来源文件路径中的所有目录  -R, -r, --recursive\t\t递归复制目录及其子目录内的所有内容      --reflink[=WHEN]\t\t控制克隆/CoW 副本。请查看下面的内如。      --remove-destination\t尝试打开目标文件前先删除已存在的目的地\t\t\t\t\t文件 (相对于 --force 选项)      --sparse=WHEN\t\t控制创建稀疏文件的方式      --strip-trailing-slashes\t删除参数中所有源文件/目录末端的斜杠  -s, --symbolic-link\t\t只创建符号链接而不复制文件  -S, --suffix=后缀\t\t自行指定备份文件的后缀  -t,  --target-directory=目录\t将所有参数指定的源文件/目录                                           复制至目标目录  -T, --no-target-directory\t将目标目录视作普通文件  -u, --update                 copy only when the SOURCE file is newer                                 than the destination file or when the                                 destination file is missing  -v, --verbose                explain what is being done  -x, --one-file-system        stay on this file system  -Z, --context=CONTEXT        set security context of copy to CONTEXT      --help\t\t显示此帮助信息并退出      --version\t\t显示版本信息并退出默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文建为稀疏件。使用--sparse=never 参数禁止创建稀疏文件。当指定了--reflink[=always] 参数时执行轻量化的复制，即只在数据块被修改的情况下才复制。如果复制失败或者同时指定了--reflink=auto，则返回标准复制模式。备份文件的后缀为&quot;~&quot;，除非以--suffix 选项或是SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup 选项或VERSION_CONTROL 环境变量来选择。以下是可用的变量值：  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份有一个特别情况：如果同时指定--force 和--backup 选项，而源文件和目标文件是同一个已存在的一般文件的话，cp 会将源文件备份。\n9.rm删除 (unlink) 文件。\nrm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。\n注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。\n1rm [选项]… 文件…\n12345678910111213141516171819202122232425262728删除 (unlink) 文件。  -f, --force           强制删除。忽略不存在的文件，不提示确认  -i                    在删除前需要确认  -I                    在删除超过三个文件或者递归删除前要求确认。此选项比-i 提                        示内容更少，但同样可以阻止大多数错误发生      --interactive[=WHEN]      根据指定的WHEN 进行确认提示：never，once (-I)，                                或者always (-i)。如果此参数不加WHEN 则总是提示      --one-file-system         递归删除一个层级时，跳过所有不符合命令行参                                数的文件系统上的文件      --no-preserve-roo 不特殊对待&quot;/&quot;      --preserve-root   不允许删除&quot;/&quot;(默认)  -d, --dir\t删除空目录  -r, -R, --recursive   递归删除目录及其内容  -v, --verbose         详细显示进行的步骤      --help            显示此帮助信息并退出      --version         显示版本信息并退出默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定的目录，以及其下所有的内容。要删除第一个字符为&quot;-&quot;的文件 (例如&quot;-foo&quot;)，请使用以下方法之一：  rm -- -foo  rm ./-foo请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证该文件的内容无法还原，请考虑使用shred。\n10.touchtouch命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。\ntouch命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。\n注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有写文件的访问权限。\n1用法：touch [选项]... 文件...\n123456789101112131415161718192021不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。如果文件名为&quot;-&quot;则特殊处理，更改与标准输出相关的文件的访问时间。长选项必须使用的参数对于短选项时也是必需使用的。  -a                    只更改访问时间  -c, --no-create       不创建任何文件  -d, --date=字符串     使用指定字符串表示时间替代当前时间  -f                    (忽略)  -h, --no-dereference          会影响符号链接本身，替代符号链接所指示的目的地                                (当系统支持更改符号链接的所有者时，此选项才有用)  -m                    只更改修改时间  -r, --reference=文件  使用指定文件的时间属性替代当前时间  -t STAMP              使用[[CC]YY]MMDDhhmm[.ss] 格式的时间替代当前时间  --time=WORD           使用WORD 指定的时间：access、atime、use 都等于-a                        选项的效果，而modify、mtime 等于-m 选项的效果      --help            显示此帮助信息并退出      --version         显示版本信息并退出请注意，-d 和-t 选项可接受不同的时间/日期格式。\n11.basenamebasename - 从文件名中剥离目录和后缀\nbasename命令用于打印目录或者文件的基本名称。basename和dirname命令通常用于shell脚本中的命令替换来指定和指定的输入文件名称有所差异的输出文件名称。\n12basename 名称 [后缀]basename 选项\n1234567显示 去掉 目录成分 后的 NAME. 如果 指定了 SUFFIX, 就 同时 去掉 拖尾的SUFFIX.--help \t显示 帮助信息, 然后 结束--version\t显示 版本信息, 然后 结束\n12.dirnamedirname - 从文件名剥离非目录的后缀\ndirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个/及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个/后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。dirname 和 basename通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。\n12dirname 名字dirname 选项\n1234567打印去除了/后面部分的NAME;如果NAME没有包含/,则输出`.&#x27;(表示当前目录).--help \t显示帮助并退出--version\t输出版本信息并退出\n13.renamerename命令用字符串替换的方式批量改变文件名。\nrename 用于 对文件进行命名管理，可进行批量命名并支持正则表达式， rename命令存在两个版本用法上有所区别 一个是 C语言版本支持通配符，另一个是 Perl版本.支持正则表达式\n123456789rename [选项] 表达式 替换文件…rename [options] expression replacement file…expression 将文件名需要替换的字符串replacement 将文件名中含有的原字符替换成目标字符串file 指定要改变文件名的文件列表\n1234567891011121314151617 -v, --verbose    解释正在进行的操作 -s, --symlink    在符号链接上执行 -h, --help     显示此帮助并退出 -V, --version  输出版本信息并退出 【常用通配符说明】 ?    表示一个任意字符 *    表示一个或一串任意字符-------------------------------------------------【常用正则表达式符号说明】^    匹配输入的开始位置$    匹配输入的结尾.    匹配除换行符外的任意字符+    匹配前一个字符一次或多次 例如，&quot;zo+&quot;可以匹配&quot;zoo&quot;,但不匹配&quot;z&quot;[a-z]    表示某个范围内的字符，例如，&quot;[a-z]&quot;匹配&quot;a&quot;与&quot;z&quot;之间的任何一个小写字母字符。[^m-z]    否定的字符区间。与不在指定区间内的字符匹配。\n14.filefile - 确定文件类型\nfile命令用来识别文件类型，也可用来辨别一些文件的编码格式。它是通过查看文件的头部信息来获取文件类型，而不是像Windows通过扩展名来确定文件类型的。\n1file [ -bcnsvzL ] [ -f 命名文件 ] [ -m 幻数文件 ] file …\n123456789101112131415161718-b    不输出文件名 (简要模式).-c    检查时打印输出幻数文件的解析结果.常与 -m 一起使用，用来在安装幻数文件之前调试它.-f 命名文件    从在参数表前的 命名文件 中读出将要检查的文件名(每行一个文件).要有 命名文件 ，或者至少有一个文件名参数; 如果要检查标准输入, 使用``-作为文件参数.-m list    指定包含幻数的文件列表.可以是单个文件，也可以是 用冒号分开的多个文件.-n    每检查完一个文件就强制刷新标准输出. 仅在检查一组文件时才有效. 一般在将文件类型输出到管道时才采用此选项.-v    打印程序版本并退出.-z    试图查看压缩文件内部信息.-L    (在支持符号链接的系统上)选项显示符号链接文件的原文件, 就像 ls(1) 命令的like-named 选项.-s    通常, file 只是试图去检查在文件列表中那些 stat(2) 报告为正常文件的文件的类型.由于读特殊文件将可能导致 不可知后果，所以这样可以防止发生问题.使用 -s 选项时 file 命令也将去读文件列表中的块特殊文件和字符特殊文件. 一般用于从原始磁盘分区中获得文件系统类型，此文件为块 特殊文件. 这个选项也导致 file 命令忽略 stat(2) 报告的文件大小，因为在有些系统中原始磁盘分区的大小报告为0.\n15.cat将[文件]或标准输入组合输出到标准输出。\ncat 命令连接文件并打印到标准输出设备上，经常用来显示整个文件的内容。cat 只能查看文本内容的文件，如查看二进制文件，则屏幕会显示乱码。另外，cat 还可以用来创建文件、合并文件等。\n1用法：cat [选项] [文件]...\n12345678910111213141516171819202122将文件列表中的文件或标准输入连接到标准输出。-A, --show-all\t等价于 -vET 。-b, --number-nonblank\t给非空输出行编号。-e     等价于 -vE 。-E, --show-ends\t在每行结束显示 $ 。-n, --number\t给所有输出行编号。-s, --squeeze-blank\t将所有的连续的多个空行替换为一个空行。-t     等价于 -vT 。-T, --show-tabs\t把 TAB 字符显示为 ^I 。-u     (被忽略的选项)-v, --show-nonprinting\t除了 LFD 和 TAB 之外所有控制符用 ^ 和 M- 记方式显示。--help 显示帮助并退出。--version\t显示版本信息并退出。\t没有指定文件或指定的文件是 -，则从标准输入读取。\n16.moremore命令用于将内容较长的文本文件内容（不能在一屏显示完）进行分屏显示，并且支持在显示时定位关键字。而对于内容较少的文本文件内容则推荐使用cat命令查看\nmore命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。\n1more [-dlfpcsu] [-num] [+/ pattern] [+ linenum] [file …]\n1234567891011-d\t显示帮助，而不是响铃-f\t统计逻辑行数而不是屏幕行数-l\t抑制换页(form feed)后的暂停-p\t不滚屏，清屏并显示文本-c\t不滚屏，显示文本并清理行尾-u\t抑制下划线-s\t将多个空行压缩为一行-NUM\t指定每屏显示的行数为 NUM+NUM\t从文件第 NUM 行开始显示+/STRING\t从匹配搜索字符串 STRING 的文件位置开始显示-V\t显示版本信息并退出\n17.lessless 与more命令类似，但可以通过翻页键查看上下页的内容\nless命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向下浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。\n1less [参数] [文件]\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182-b&lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o&lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x&lt;数字&gt; 将“tab”键显示为规定的数字空格命令内部操作按键功能如下：b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行 1) 向前搜索    / ： 使用一个模式进行搜索，并定位到下一个匹配的文本    n ： 向前查找下一个匹配的文本    N ： 向后查找前一个匹配的文本2) 向后搜索    ? ： 使用模式进行搜索，并定位到前一个匹配的文本    n ： 向后查找下一个匹配的文本    N ： 向前查找前一个匹配的文本2 全屏导航    ctrl + F ：向前移动一屏    ctrl + B ：向后移动一屏    ctrl + D ：向前移动半屏    ctrl + U ：向后移动半屏3 单行导航    j ： 向前移动一行    k ： 向后移动一行4 其它导航    G ： 移动到最后一行    g ： 移动到第一行    q / ZZ ： 退出 less 命令5 编辑文件    v ： 进入编辑模式，使用配置的编辑器编辑当前文件6 标记导航    当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。    ma ： 使用 a 标记文本的当前位置    &#x27;a ： 导航到标记 a 处7 浏览多个文件    方式一，传递多个参数给 less，就能浏览多个文件。    less file1 file2    方式二，正在浏览一个文件时，使用 :e 打开另一个文件。    less file1    :e file2         当打开多个文件时，使用如下命令在多个文件之间切换    :n - 浏览下一个文件    :p - 浏览前一个文件\n18.grepLinux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\ngrep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。需要注意的是：一当模式中包含了空格，务必要用双引号将其引起来。\nlinux系统支持三种形式的grep命令，大儿子就是grep，标准，模仿的代表。二儿子兴趣爱好多-egrep，简称扩展grep命令，其实和grep -E等价，支持基本和扩展的正则表达式。小儿子跑的最快-fgrep，简称快速grep命令，其实和grep -F等价，不支持正则表达式，按照字符串表面意思进行匹配。\n12grep [options] PATTERN [FILE...]grep [options] [-e PATTERN | -f FILE] [FILE...]\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889匹配模式选择: -E, --extended-regexp     扩展正则表达式egrep -F, --fixed-strings       一个换行符分隔的字符串的集合fgrep -G, --basic-regexp        基本正则 -P, --perl-regexp         调用的perl正则 -e, --regexp=PATTERN      后面根正则模式，默认无 -f, --file=FILE           从文件中获得匹配模式 -i, --ignore-case         不区分大小写 -w, --word-regexp         匹配整个单词 -x, --line-regexp         匹配整行 -z, --null-data           一个 0 字节的数据行，但不是空行杂项: -s, --no-messages         不显示错误信息 -v, --invert-match        显示不匹配的行 -V, --version             显示版本号 --help                    显示帮助信息 --mmap                use memory-mapped input if possible输入控制: -m, --max-count=NUM       匹配的最大数 -b, --byte-offset         打印匹配行前面打印该行所在的块号码。 -n, --line-number         显示的加上匹配所在的行号 --line-buffered           刷新输出每一行 -H, --with-filename       当搜索多个文件时，显示匹配文件名前缀 -h, --no-filename         当搜索多个文件时，不显示匹配文件名前缀 --label=LABEL            print LABEL as filename for standard input -o, --only-matching       只显示一行中匹配PATTERN 的部分 -q, --quiet, --silent      不显示任何东西 --binary-files=TYPE   假定二进制文件的TYPE 类型；                                      TYPE 可以是`binary&#x27;, `text&#x27;, 或`without-match&#x27; -a, --text                匹配二进制的东西 -I                        不匹配二进制的东西 -d, --directories=ACTION  目录操作，读取，递归，跳过 -D, --devices=ACTION      设置对设备，FIFO,管道的操作，读取，跳过 -R, -r, --recursive       递归调用 --include=PATTERN     只查找匹配FILE_PATTERN 的文件 --exclude=PATTERN     跳过匹配FILE_PATTERN 的文件和目录 --exclude-from=FILE   跳过所有除FILE 以外的文件 -L, --files-without-match 匹配多个文件时，显示不匹配的文件名 -l, --files-with-matches  匹配多个文件时，显示匹配的文件名 -c, --count               显示匹配的行数 -Z, --null                在FILE 文件最后打印空字符文件控制: -B, --before-context=NUM  打印匹配本身以及前面的几个行由NUM控制 -A, --after-context=NUM   打印匹配本身以及随后的几个行由NUM控制 -C, --context=NUM         打印匹配本身以及随后，前面的几个行由NUM控制 -NUM                      根-C的用法一样的 --color[=WHEN], --colour[=WHEN]       使用标志高亮匹配字串；  -U, --binary               使用标志高亮匹配字串； -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式) 规则表达式：grep的规则表达式:^  #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。    $  #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。    .  #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。    *  #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。    .*   #一起用代表任意字符。   []   #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。    [^]  #匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    \\(..\\)  #标记匹配字符，如&#x27;\\(love\\)&#x27;，love被标记为1。    \\&lt;      #锚定单词的开始，如:&#x27;\\&lt;grep&#x27;匹配包含以grep开头的单词的行。    \\&gt;      #锚定单词的结束，如&#x27;grep\\&gt;&#x27;匹配包含以grep结尾的单词的行。    x\\&#123;m\\&#125;  #重复字符x，m次，如：&#x27;0\\&#123;5\\&#125;&#x27;匹配包含5个o的行。    x\\&#123;m,\\&#125;  #重复字符x,至少m次，如：&#x27;o\\&#123;5,\\&#125;&#x27;匹配至少有5个o的行。    x\\&#123;m,n\\&#125;  #重复字符x，至少m次，不多于n次，如：&#x27;o\\&#123;5,10\\&#125;&#x27;匹配5--10个o的行。   \\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。   \\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   \\b    #单词锁定符，如: &#x27;\\bgrep\\b&#x27;只匹配grep。  POSIX字符:为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。[:alnum:]    #文字数字字符   [:alpha:]    #文字字符   [:digit:]    #数字字符   [:graph:]    #非空字符（非空格、控制字符）   [:lower:]    #小写字符   [:cntrl:]    #控制字符   [:print:]    #非空字符（包括空格）   [:punct:]    #标点符号   [:space:]    #所有空白字符（新行，空格，制表符）   [:upper:]    #大写字符   [:xdigit:]   #十六进制数字（0-9，a-f，A-F）  \n19.egrepegrep命令用于在文件内查找指定的字符串。egrep执行效果与grep -E相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。\negrep支持扩展的正则表达式\n12345egrep [选项]... PATTERN [FILE]...在每个 FILE 或是标准输入中查找 PATTERN。PATTERN 是一个可扩展的正则表达式(缩写为 ERE)。例如: egrep -i &#x27;hello world&#x27; menu.h main.c\n注意: pattern如果是表达式或者超过两个单词的, 需要用引号引用. 可以是单引号也可双引号, 区别是单引号无法引用变量而双引号可以.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162在每个 FILE 或是标准输入中查找 PATTERN。PATTERN 是一个可扩展的正则表达式(缩写为 ERE)。例如: egrep -i &#x27;hello world&#x27; menu.h main.c正则表达式选择与解释:  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作  -f, --file=FILE           从 FILE 中取得 PATTERN  -i, --ignore-case         忽略大小写  -w, --word-regexp         强制 PATTERN 仅完全匹配字词  -x, --line-regexp         强制 PATTERN 仅完全匹配一行  -z, --null-data           一个 0 字节的数据行，但不是空行杂项:  -s, --no-messages         不显示错误信息  -v, --invert-match        选中不匹配的行  -V, --version             显示版本信息并退出      --help                显示此帮助并退出      --mmap                忽略向后兼容性输入控制:  -m, --max-count=NUM       匹配的最大数  -b, --byte-offset         打印匹配行前面打印该行所在的块号码。  -n, --line-number         显示的加上匹配所在的行号  --line-buffered           刷新输出每一行  -H, --with-filename       当搜索多个文件时，显示匹配文件名前缀  -h, --no-filename         当搜索多个文件时，不显示匹配文件名前缀  -o, --only-matching       只显示一行中匹配PATTERN 的部分  -q, --quiet, --silent     不显示所有输出      --binary-files=TYPE   假定二进制文件的TYPE 类型；                            TYPE 可以是`binary&#x27;, `text&#x27;, 或`without-match&#x27;  -a, --text                等同于 --binary-files=text  -I                        等同于 --binary-files=without-match  -d, --directories=ACTION  操作目录的方式；                            ACTION 可以是`read&#x27;, `recurse&#x27;,或`skip&#x27;  -D, --devices=ACTION      操作设备、先入先出队列、套接字的方式；                            ACTION 可以是`read&#x27;或`skip&#x27;  -R, -r, --recursive       等同于 --directories=recurse      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录      --exclude-from=FILE   跳过所有除FILE 以外的文件      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。  -L, --files-without-match  只打印不匹配FILEs 的文件名  -l, --files-with-matches  只打印匹配FILES 的文件名  -c, --count               只打印每个FILE 中的匹配行数目  -T, --initial-tab         行首tabs 分隔（如有必要）  -Z, --null                在FILE 文件最后打印空字符文件控制:  -B, --before-context=NUM  打印以文本起始的NUM 行  -A, --after-context=NUM   打印以文本结尾的NUM 行  -C, --context=NUM         打印输出文本NUM 行  -NUM                      等同于 --context=NUM      --color[=WHEN],      --colour[=WHEN]       使用标志高亮匹配字串；                            WHEN 可以是`always&#x27;, `never&#x27;或`auto&#x27;  -U, --binary              不要清除行尾的CR 字符(MSDOS 模式)  -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式)不带 FILE 参数，或是 FILE 为 -，将读取标准输入。如果少于两个 FILE 参数就要默认使用 -h 参数。如果选中任意一行，那退出状态为 0，否则为 1；如果有错误产生，且未指定 -q 参数，那退出状态为 2。\n20.wcwc - 输出文件中的行数、单词数、字节数\n1wc [选项列表]... [文件名列表]...\n1234567891011121314对每个文件输出行、单词、和字节统计数，如果指定了多于一个文件则还有个行数的总计。没有指定文件或指定的文件是 -，则读取标准输入。-c, --bytes, --chars\t输出字节统计数。-l, --lines\t输出换行符统计数。-L, --max-line-length\t输出最长的行的长度。-w, --words\t输出单词统计数。--help \t显示帮助并退出--version\t输出版本信息并退出\n21.sortsort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。\n1用法：sort [选项]... [文件]...\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556长选项必须使用的参数对于短选项时也是必需使用的。排序选项：  -b, --ignore-leading-blanks   忽略前导的空白区域  -d, --dictionary-order        只考虑空白区域和字母字符  -f, --ignore-case             忽略字母大小写  -g, --general-numeric-sort    按照常规数值排序  -i, --ignore-nonprinting      只排序可打印字符  -M, --month-sort              比较 (未知) &lt; &quot;一月&quot; &lt; ... &lt; &quot;十二月&quot;                                在LC_ALL=C 时为(unknown) &lt; `JAN&#x27; &lt; ... &lt; `DEC&#x27;  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)  -n, --numeric-sort            根据字符串数值比较  -R, --random-sort             根据随机hash 排序      --random-source=文件      从指定文件中获得随机字节  -r, --reverse                 逆序输出排序结果      --sort=WORD               按照WORD 指定的格式排序：                                        一般数字-g，高可读性-h，月份-M，数字-n，                                        随机-R，版本-V  -V, --version-sort            在文本内进行自然版本排序其他选项：      --batch-size=NMERGE       一次最多合并NMERGE 个输入；如果输入更多                                        则使用临时文件  -c, --check, --check=diagnose-first   检查输入是否已排序，若已有序则不进行操作  -C, --check=quiet, --check=silent     类似-c，但不报告第一个无序行      --compress-program=程序   使用指定程序压缩临时文件；使用该程序                                        的-d 参数解压缩文件      --debug                   为用于排序的行添加注释，并将有可能有问题的                                        用法输出到标准错误输出      --files0-from=文件        从指定文件读取以NUL 终止的名称，如果该文件被                                        指定为&quot;-&quot;则从标准输入读文件名  -k, --key=位置1[,位置2]       在位置1 开始一个key，在位置2 终止(默认为行尾)                                参看POS 语法。  -m, --merge                   合并已排序的文件，不再进行排序  -o, --output=文件             将结果写入到文件而非标准输出  -s, --stable                  禁用last-resort 比较以稳定比较算法  -S, --buffer-size=大小        指定主内存缓存大小  -t, --field-separator=分隔符  使用指定的分隔符代替非空格到空格的转换  -T, --temporary-directory=目录        使用指定目录而非$TMPDIR 或/tmp 作为                                        临时目录，可用多个选项指定多个目录      --parallel=N              将同时运行的排序数改变为N  -u, --unique          配合-c，严格校验排序；不配合-c，则只输出一次排序结果  -z, --zero-terminated 以0 字节而非新行作为行尾标志      --help            显示此帮助信息并退出      --version         显示版本信息并退出POS 是F[.C][OPTS]，F 代表域编号，C 是域中字母的位置，F 和C 均从1开始计数如果没有有效的-t 或-b 选项存在，则从前导空格后开始计数字符。OPTS 是一个或多个由单个字母表示的顺序选项，以此覆盖此key 的全局顺序设置。如果没有指定key 则将其整个行。指定的大小可以使用以下单位之一：内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。如果不指定文件，或者文件为&quot;-&quot;，则从标准输入读取数据。\n22.uniquniq - 删除排序文件中的重复行\nuniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。\nuniq命令全称是“unique”，中文释义是“独特的，唯一的”。该命令的作用是用来去除文本文件中连续的重复行，中间不能夹杂其他文本行。去除了重复的，保留的都是唯一的，也就是独特的，唯一的了。\n我们应当注意的是，它和sort的区别，sort只要有重复行，它就去除，而uniq重复行必须要连续，也可以用它忽略文件中的重复行。\n1用法：uniq [选项]... [文件]\n123456789101112131415161718192021222324从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。不附加任何选项时匹配行将在首次出现处被合并。长选项必须使用的参数对于短选项时也是必需使用的。  -c, --count           在每行前加上表示相应行目出现次数的前缀编号  -d, --repeated        只输出重复的行  -D, --all-repeated[=delimit-method    显示所有重复的行                        delimit-method=&#123;none(default),prepend,separate&#125;                        以空行为界限  -f, --skip-fields=N   比较时跳过前N 列  -i, --ignore-case     在比较的时候不区分大小写  -s, --skip-chars=N    比较时跳过前N 个字符  -u, --unique          只显示唯一的行  -z, --zero-terminated 使用&#x27;\\0&#x27;作为行结束符，而不是新换行  -w, --check-chars=N   对每行第N 个字符以后的内容不作对照      --help            显示此帮助信息并退出      --version         显示版本信息并退出若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将被跳过。提示：uniq 不会检查重复的行，除非它们是相邻的行。如果您想先对输入排序，使用没有uniq 的&quot;sort -u&quot;。同时，比较服从&quot;LC_COLLATE&quot; 变量所指定的规则。\n23.whichwhich 命令用于查找并显示给定命令的绝对路径，环境变量 PATH 中保存了查找命令时需要遍历的目录。which 指令会在环境变量 $PATH 设置的目录里查找符合条件的文件。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n1which [选项] 执行文件名 […]\n1234567891011121314151617181920查找环境变量中的文件-a   查找全部内容，而非第一个文件-n   &lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p   &lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 -w 　指定输出时栏位的宽度。 -V 　显示版本信息。--version, -[vV]\t显示版本信息并退出--help\t显示帮助信息并退出--skip-dot\t跳过 PATH 中以点开头的目录--skip-tilde\t跳过 PATH 中以波形符号开头的目录--show-dot\t不要在输出中将点扩展到当前目录--show-tilde\t为 HOME 目录（非根目录）输出波形--tty-only\t如果不在 tty 上，停止右边的处理选项--all, -a\t打印 PATH 中的所有匹配项，而不仅仅是第一个--read-alias, -i\t从 stdin 中读取别名列表--skip-alias\t忽略选项 --read-alias；不读 stdin--read-functions\t从 stdin 读取 shell 函数--skip-functions\t忽略选项 --read-functions；不读 stdin\n24.lnln软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放 了链接其他文件的路径。 1）基本语法\n ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接，注意要使用绝对路径） \n2）经验技巧\n删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名/ \n如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉 \n查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。\n硬链接（类似复制文件）\n1）基本语法\nln [原文件或目录] [硬链接名]\n如果文件被删除，则软链接文件失去指向，变为不可用如果文件被删除，由于硬链接文件直接指向内容，因此不受影响\n 输出重定向和&gt;&gt;追加\">25.> 输出重定向和&gt;&gt;追加可将本应显示在终端上的内容保存到指定文件中。\n如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 )\n1）ls -l &gt; 文件 （功能描述：列表的内容写入文件 a.txt 中（覆盖写））\n2）ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件 aa.txt 的末尾） \n3）cat 文件 1 &gt; 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2） \n4）echo “内容” &gt;&gt; 文件\n注意： &gt;输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。\n26.|管道：一个命令的输出可以通过管道做为另一个命令的输入。\n“ | ”的左右分为两端，从左端写入到右端。\n123456789101112python@ubuntu:/bin$ ll -h |more   总用量 13Mdrwxr-xr-x  2 root root  4.0K 8月   4  2016 ./drwxr-xr-x 26 root root  4.0K 7月  30  2016 ../-rwxr-xr-x  1 root root 1014K 6月  24  2016 bash*-rwxr-xr-x  1 root root   31K 5月  20  2015 bunzip2*-rwxr-xr-x  1 root root  1.9M 8月  19  2015 busybox*-rwxr-xr-x  1 root root   31K 5月  20  2015 bzcat*lrwxrwxrwx  1 root root     6 5月  16  2016 bzcmp -&gt; bzdiff*-rwxr-xr-x  1 root root  2.1K 5月  20  2015 bzdiff*lrwxrwxrwx  1 root root     6 5月  16  2016 bzegrep -&gt; bzgrep*--更多--\n\n十、 文件压缩解压命令1.tartar命令：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的\ntar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。\n首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。\n为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（bzip2和gzip命令）。\n1用法：tar 选项... 参数...\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203主操作模式: -A, --catenate, --concatenate   追加 tar 文件至归档 -c, --create               创建一个新归档 -d, --diff, --compare      找出归档和文件系统的差异 --delete               从归档(非磁带！)中删除 -r, --append               追加文件至归档结尾 -t, --list                 列出归档内容 --test-label           测试归档卷标并退出 -u, --update               仅追加比归档中副本更新的文件 -x, --extract, --get       从归档中解出文件 操作修饰符: --check-device         当创建增量归档时检查设备号(默认) -g, --listed-incremental=文件处理新式的 GNU 格式的增量备份 -G, --incremental          处理老式的 GNU 格式的增量备份 --ignore-failed-read当遇上不可读文件时不要以非零值退出 -n, --seek                 归档可检索 --no-check-device      当创建增量归档时不要检查设备号 --occurrence[=NUMBER]  仅处理归档中每个文件的第 NUMBER个事件；仅当与以下子命令 --delete, --diff, --extract 或是 --list中的一个联合使用时，此选项才有效。而且不管文件列表是以命令行形式给出或是通过 -T 选项指定的；NUMBER 值默认为 1 --sparse-version=MAJOR[.MINOR]设置所用的离散格式版本(隐含--sparse) -S, --sparse               高效处理离散文件 重写控制: -k, --keep-old-files       解压时不要替换存在的文件 --keep-newer-files不要替换比归档中副本更新的已存在的文件 --no-overwrite-dir     保留已存在目录的元数据 --overwrite            解压时重写存在的文件 --overwrite-dir解压时重写已存在目录的元数据(默认) --recursive-unlink     解压目录之前先清除目录层次 --remove-files         在添加文件至归档后删除它们 -U, --unlink-first         在解压要重写的文件之前先删除它们 -W, --verify               在写入以后尝试校验归档 选择输出流: --ignore-command-error 忽略子进程的退出代码 --no-ignore-command-error将子进程的非零退出代码认为发生错误 -O, --to-stdout            解压文件至标准输出 --to-command=COMMAND将解压的文件通过管道传送至另一个程序 操作文件属性: --atime-preserve[=METHOD]在输出的文件上保留访问时间，要么通过在读取(默认 METHOD=‘replace’)后还原时间，要不就不要在第一次(METHOD=‘system’)设置时间 --delay-directory-restore 直到解压结束才设置修改时间和所解目录的权限 --group=名称         强制将 NAME作为所添加的文件的组所有者 --mode=CHANGES         强制将所添加的文件(符号)更改为权限CHANGES --mtime=DATE-OR-FILE   从 DATE-OR-FILE 中为添加的文件设置mtime -m, --touch                不要解压文件的修改时间 --no-delay-directory-restore取消 --delay-directory-restore 选项的效果 --no-same-owner        将文件解压为您所有 --no-same-permissions从归档中解压权限时使用用户的掩码位(默认为普通用户服务) --numeric-owner        总是以数字代表用户/组的名称 --owner=名称         强制将 NAME作为所添加的文件的所有者 -p, --preserve-permissions, --same-permissions解压文件权限信息(默认只为超级用户服务) --preserve             与 -p 和 -s 一样 --same-owner           尝试解压时保持所有者关系一致 -s, --preserve-order, --same-order为解压至匹配归档排序名称 设备选择和切换: -f, --file=ARCHIVE         使用归档文件或 ARCHIVE 设备 --force-local即使归档文件存在副本还是把它认为是本地归档 -F, --info-script=名称, --new-volume-script=名称在每卷磁带最后运行脚本(隐含 -M) -L, --tape-length=NUMBER   写入 NUMBER × 1024 字节后更换磁带 -M, --multi-volume         创建/列出/解压多卷归档文件 --rmt-command=COMMAND  使用指定的 rmt COMMAND 代替 rmt --rsh-command=COMMAND  使用远程 COMMAND 代替 rsh --volno-file=文件    使用/更新 FILE 中的卷数 设备分块: -b, --blocking-factor=BLOCKS   每个记录 BLOCKS x 512 字节 -B, --read-full-records    读取时重新分块(只对 4.2BSD 管道有效) -i, --ignore-zeros         忽略归档中的零字节块(即文件结尾) --record-size=NUMBER   每个记录的字节数 NUMBER，乘以 512 选择归档格式: -H, --format=FORMAT        创建指定格式的归档 FORMAT 是以下格式中的一种: gnu                      GNU tar 1.13.x 格式 oldgnu                   GNU 格式 as per tar &lt;= 1.12 pax                      POSIX 1003.1-2001 (pax) 格式 posix                    等同于 pax ustar                    POSIX 1003.1-1988 (ustar) 格式 v7                       old V7 tar 格式 --old-archive, --portability等同于 --format=v7 --pax-option=关键字[[:]=值][,关键字[[:]=值]]...控制 pax 关键字 --posix                等同于 --format=posix -V, --label=TEXT           创建带有卷名 TEXT的归档；在列出/解压时，使用 TEXT作为卷名的模式串 压缩选项: -a, --auto-compress        使用归档后缀来决定压缩程序 -I, --use-compress-program=PROG通过 PROG 过滤(必须是能接受 -d选项的程序) -j, --bzip2                通过 bzip2 过滤归档 --lzma                 通过 lzma 过滤归档 --no-auto-compress     do not use archive suffix to determine thecompression program -z, --gzip, --gunzip, --ungzip   通过 gzip 过滤归档 -Z, --compress, --uncompress   通过 compress 过滤归档 -J, --xz                   filter the archive through xz --lzop                 通过 lzop 过滤归档 本地文件选择: --add-file=文件      添加指定的 FILE 至归档(如果名字以 -开始会很有用的) --backup[=CONTROL]     在删除前备份，选择 CONTROL 版本 -C, --directory=DIR        改变至目录 DIR --exclude=PATTERN      排除以 PATTERN 指定的文件 --exclude-caches       除标识文件本身外，排除包含CACHEDIR.TAG 的目录中的内容 --exclude-caches-all   排除包含 CACHEDIR.TAG 的目录 --exclude-caches-under 排除包含 CACHEDIR.TAG的目录中所有内容 --exclude-tag=文件   除 FILE 自身外，排除包含 FILE的目录中的内容 --exclude-tag-all=文件   排除包含 FILE 的目录 --exclude-tag-under=文件   排除包含 FILE的目录中的所有内容 --exclude-vcs          排除版本控制系统目录 -h, --dereference跟踪符号链接；将它们所指向的文件归档并输出 --hard-dereference 跟踪硬链接；将它们所指向的文件归档并输出 -K, --starting-file=MEMBER-NAME从归档中的 MEMBER-NAME 成员处开始 --newer-mtime=DATE     当只有数据改变时比较数据和时间 --no-null              禁用上一次的效果 --null 选项 --no-recursion         避免目录中的自动降级 --no-unquote           不以 -T 读取的文件名作为引用结束 --null                 -T 读取以空终止的名字，-C 禁用 -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE只保存比 DATE-OR-FILE 更新的文件 --one-file-system      创建归档时保存在本地文件系统中 -P, --absolute-names       不要从文件名中清除引导符‘/’ --recursion            目录递归(默认) --suffix=STRING        在删除前备份，除非被环境变量SIMPLE_BACKUP_SUFFIX覆盖，否则覆盖常用后缀(‘’) -T, --files-from=文件    从 FILE中获取文件名来解压或创建文件 --unquote              以 -T读取的文件名作为引用结束(默认) -X, --exclude-from=文件  排除 FILE 中列出的模式串 文件名变换: --strip-components=NUMBER   解压时从文件名中清除 NUMBER个引导部分 --transform=EXPRESSION, --xform=EXPRESSION使用 sed 代替 EXPRESSION 来进行文件名变换 文件名匹配选项(同时影响排除和包括模式串): --anchored             模式串匹配文件名头部 --ignore-case          忽略大小写 --no-anchored          模式串匹配任意‘/’后字符(默认对 exclusion 有效) --no-ignore-case       匹配大小写(默认) --no-wildcards         逐字匹配字符串 --no-wildcards-match-slash   通配符不匹配‘/’ --wildcards            使用通配符(默认对 exclusion ) --wildcards-match-slash通配符匹配‘/’(默认对排除操作有效) 提示性输出: --checkpoint[=NUMBER]  每隔 NUMBER个记录显示进度信息(默认为 10 个) --checkpoint-action=ACTION   在每个检查点上执行 ACTION --index-file=文件    将详细输出发送至 FILE -l, --check-links只要不是所有链接都被输出就打印信息 --no-quote-chars=STRING   禁用来自 STRING 的字符引用 --quote-chars=STRING   来自 STRING 的额外的引用字符 --quoting-style=STYLE  设置名称引用风格；有效的 STYLE值请参阅以下说明 -R, --block-number         每个信息都显示归档内的块数 --show-defaults        显示 tar 默认选项 --show-omitted-dir 列表或解压时，列出每个不匹配查找标准的目录 --show-transformed-names, --show-stored-names显示变换后的文件名或归档名 --totals[=SIGNAL]      处理归档后打印出总字节数；当此SIGNAL 被触发时带参数 -打印总字节数；允许的信号为: SIGHUP，SIGQUIT，SIGINT，SIGUSR1 和 SIGUSR2；同时也接受不带 SIG 前缀的信号名称 --utc                  以 UTC 格式打印文件修改信息 -v, --verbose              详细地列出处理的文件 -w, --interactive, --confirmation每次操作都要求确认 兼容性选项: -o                         创建归档时，相当于 --old-archive；展开归档时，相当于 --no-same-owner 其它选项: -?, --help                 显示此帮助列表 --restrict             禁用某些潜在的有危险的选项 --usage                显示简短的用法说明 --version              打印程序版本长选项和相应短选项具有相同的强制参数或可选参数。除非以 --suffix 或 SIMPLE_BACKUP_SUFFIX设置备份后缀，否则备份后缀就是“~”。可以用 --backup 或 VERSION_CONTROL 设置版本控制，可能的值为： none, off       从不做备份 t, numbered     进行编号备份 nil, existing如果编号备份存在则进行编号备份，否则进行简单备份 never, simple   总是使用简单备份\n2.gzipgzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。\ngzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。\n1gzip [ -acdfhlLnNrtvV19 ] [-S 后缀] [ 文件名 ...  ]\n1234567891011121314151617-a或——ascii：使用ASCII文字模式；-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；-N或——name：压缩文件时，保存原来的文件名称及时间戳记；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；--best：此参数的效果和指定“-9”参数相同；--fast：此参数的效果和指定“-1”参数相同。\n3.gunzipgunzip命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gunzip压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。\n1gunzip [ -acfhlLnNrtvV ] [-S 后缀] [ 文件名 ...  ]\n1234567891011121314-a或——ascii：使用ASCII文字模式；-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；\n4.bzip2Linux系统中bzip2命令的英文是“bunzip2”，即.bz2文件格式的压缩程序； bzip2命令系统默认是没有安装的，需要安装bzip2库才可以使用此命令。\nbzip2命令采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。\n1bzip2 [ -cdfkqstvzVL123456789 ] [ filenames ...  ]\n123456789101112-c或——stdout：将压缩与解压缩的结果送到标准输出；-d或——decompress：执行解压缩；-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；-h或——help：在线帮助；-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；-s或——small：降低程序执行时内存的使用量；-t或——test：测试.bz2压缩文件的完整性；-v或——verbose：压缩或解压缩文件时，显示详细的信息；-z或——compress：强制执行压缩；-V或——version：显示版本信息；--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。\n5.bunzip2bunzip2命令解压缩由bzip2指令创建的”.bz2”压缩包。对文件进行压缩与解压缩。此命令类似于gzip/gunzip)”命令，只能对文件进行压缩。对于目录只能压缩目录下的所有文件，压缩完成后，在目录下生成以“.bz2”为后缀的压缩包。bunzip2其实是bzip2的符号链接，即软链接，因此压缩解压都可以通过bzip2实现。\n1bunzip2 [ -fkvsVL ] [ filenames ...  ]\n12345-f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；-k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；-s或——small：降低程序执行时，内存的使用量；-v或——verbose：解压缩文件时，显示详细的信息；-l，--license，-V或——version：显示版本信息。\n6.bzip2recoverbzip2recover命令用来修复损坏的.bz2文件 ， bzip2是以区块的方式来压缩文件，每个区块视为独立的单位。因此，当某一区块损坏时，便可利用bzip2recover，试着将文件中的区块隔开来，以便解压缩正常的区块。通常只适用在压缩文件很大的情况。\n1bzip2recover filename\n\n7.zipzip 命令是一个应用广泛的跨平台的压缩工具，压缩文件的后缀为 .zip文件\nzip程序将一个或多个压缩文件与有关文件的信息(名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性)一起放入一个压缩存档中。可以使用一个命令将整个目录结构打包到zip存档中。\n对于文本文件来说，压缩比为2：1和3：1是常见的。zip只有一种压缩方法(通缩)，并且可以在不压缩的情况下存储文件。(如果添加了bzip 2支持，zip也可以使用bzip 2压缩，但这些条目需要一个合理的现代解压缩来解压缩。当选择bzip 2压缩时，它将通货紧缩替换为默认方法。)zip会自动为每个要压缩的文件选择更好的两个文件(通缩或存储，如果选择bzip2，则选择bzip2或Store)。\n\n1zip [参数] [文件]\n12345678910111213141516171819202122232425262728293031323334-A：调整可执行的自动解压缩文件；-b&lt;工作目录&gt;：指定暂时存放文件的目录；-c：替每个被压缩的文件加上注释；-d：从压缩文件内删除指定的文件；-D：压缩文件内不建立目录名称；-f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；-F：尝试修复已损坏的压缩文件；-g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；-h：在线帮助；-i&lt;范本样式&gt;：只压缩符合条件的文件；-j：只保存文件名称及其内容，而不存放任何目录名称；-J：删除压缩文件前面不必要的数据；-k：使用MS-DOS兼容格式的文件名称；-l：压缩文件时，把LF字符置换成LF+CR字符；-ll：压缩文件时，把LF+cp字符置换成LF字符；-L：显示版权信息；-m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；-n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；-o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；-q：不显示指令执行过程；-r：递归处理，将指定目录下的所有文件和子目录一并处理；-S：包含系统和隐藏文件；-t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；-T：检查备份文件内的每个文件是否正确无误；-u：更换较新的文件到压缩文件内；-v：显示指令执行过程或显示版本信息；-V：保存VMS操作系统的文件属性；-w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；-x&lt;范本样式&gt;：压缩时排除符合条件的文件；-X：不保存额外的文件属性；-y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；-z：替压缩文件加上注释；-$：保存第一个被压缩文件所在磁盘的卷册名称；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。\n8.unzipunzip命令用于解压缩由zip命令压缩的“.zip”压缩包。\n默认行为（就是没有选项）是从指定的ZIP存档中提取所有的文件到当前目录（及其下面的子目录）。一个配套程序zip（1L）创建ZIP存档；这两个程序都与PKWARE的PKZIP和PKUNZIP为MS-DOS创建的存档文件兼容，但许多情况下，程序选项或默认行为是不同的。\n1unzip [-Z] [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]] file[.zip] [file(s) ...] [-x xfile(s) ...] [-d exdir]\n123456789101112131415161718192021222324-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；-f：更新现有的文件；-l：显示压缩文件内所包含的文件；-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；-t：检查压缩文件是否正确；-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；-v：执行时显示详细的信息；-z：仅显示压缩文件的备注文字；-a：对文本文件进行必要的字符转换；-b：不要对文本文件进行字符转换；-C：压缩文件中的文件名称区分大小写；-j：不处理压缩文件中原有的目录路径；-L：将压缩文件中的全部文件名改为小写；-M：将输出结果送到more程序处理；-n：解压缩时不要覆盖原有的文件；-o：不必先询问用户，unzip执行后覆盖原有的文件；-P&lt;密码&gt;：使用zip的密码选项；-q：执行时不显示任何信息；-s：将文件名中的空白字符转换为底线字符；-V：保留VMS的文件版本信息；-X：解压缩时同时回存文件原来的UID/GID；-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；-x&lt;文件&gt;：指定不要处理.zip压缩文件中的哪些文件；-Z：unzip-Z等于执行zipinfo指令。\n9.zipinfozipinfo命令的全称为“zip information”，该命令用于列出压缩文件信息。执行zipinfo指令可得知zip压缩文件的详细信息。\n1zipinfo [-12hlmMstTvz][压缩文件][文件...][-x &lt;范本样式&gt;]\n123456789101112-1：只列出文件名称；-2：此参数的效果和指定“-1”参数类似，但可搭配“-h”，“-t”和“-z”参数使用；-h：只列出压缩文件的文件名称；-l：此参数的效果和指定“-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率；-m：此参数的效果和指定“-s”参数类似，但多会列出每个文件的压缩率；-M：若信息内容超过一个画面，则采用类似more指令的方式列出信息；-s：用类似执行“ls-l”指令的效果列出压缩文件内容；-t：只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率；-T：将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出；-v：详细显示压缩文件内每一个文件的信息；-x&lt;范本样式&gt;：不列出符合条件的文件的信息；-z：如果压缩文件内含有注释，就将注释显示出来。\n\n十一、信息显示命令1.unameuname命令的英文全称即“Unix name”。\n用于显示系统相关信息，比如主机名、内核版本号、硬件架构、操作系统类型等。\n如果未指定任何选项，其效果相当于执行uname -s命令，即显示系统内核的名字。\n1用法：uname [选项]...\n1234567891011121314输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。  -a, --all                     以如下次序输出所有信息。其中若-p 和                                -i 的探测结果不可知则被省略：  -s, --kernel-name             输出内核名称  -n, --nodename                输出网络节点上的主机名  -r, --kernel-release          输出内核发行号  -v, --kernel-version          输出内核版本  -m, --machine         输出主机的硬件架构名称  -p, --processor               输出处理器类型或&quot;unknown&quot;  -i, --hardware-platform       输出硬件平台或&quot;unknown&quot;  -o, --operating-system        输出操作系统名称      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n2.hostnamehostname命令用于显示和设置系统的主机名称。环境变量HOSTNAME也保存了当前的主机名。在使用hostname命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改/etc/hosts和/etc/sysconfig/network的相关内容。\n1hostname [选项] [参数]\n1234567891011121314151617181920212223242526hostname - 用来显示或者设置当前系统的主机名，主机名被许多网络程序使用，来标识主机。-a,--alias    显示主机的别名(如果使用了的话).-d,--domain    显示DNS域名.不要使用命令 domainname 来获得DNS域名,因为这会显示NIS域名而非DNS域名.可使用 dnsdomainname 替换之.-F,--file filename    从指定文件中读取主机名.注释(以一个`#&#x27;开头的行)可忽略.-f,--fqdn,--long    显示FQDN(完全资格域名).一个FQDN包括一个短格式主机名和DNS域名.除非你正在使用bind或 者NIS来作主机查询,否则你可以在/etc/hosts文件中修改FQDN和DNS域名(这是FQDN的一 部分).-h,--help    打印用法信息并退出.-I, --all-ip-addresses all addresses for the host     显示主机的所有地址-i,--ip-address    显示主机的IP地址(组).-n,--node    显示DECnet节点名.如果指定了参数(或者指定了 --file name ),那么root也可以设置一个新的节点名.-s,--short    显示短格式主机名.这是一个去掉第一个圆点后面部分的主机名.-V,--version    在标准输出上打印版本信息并以成功的状态退出.-v,--verbose    详尽说明并告知所正在执行的.-y,--yp,--nis    显示NIS域名.如果指定了参数(或者指定了 --file name ),那么root也可以设置一个新的NIS域.\n3.uptimeuptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。\n1uptime [参数]\n\n\n\n\n-p\n以漂亮的格式显示机器正常运行的时间\n\n\n\n\n-s\n系统自开始运行时间，格式为yyyy-mm-dd hh:mm:ss\n\n\n-h\n显示帮助信息\n\n\n\n\n4.statstat命令用来显示文件或文件系统的详细信息\n1stat [选项]... 文件...\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162显示文件或文件系统的状态。  -L, --dereference     跟随链接  -f, --file-system     显示文件系统状态而非文件状态  -c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行      --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作                                输出结尾。如果您仍希望使用换行，可以在格式中                                加入&quot;\\n&quot;  -t, --terse           使用简洁格式输出      --help            显示此帮助信息并退出      --version         显示版本信息并退出有效的文件格式序列(不使用 --file-system)：  %a    八进制权限  %A   用可读性较好的方式输出权限  %b   计算已分配块数(参见%B)  %B   以字节为单位输出%b 所报告的每个块的大小  %C   SELinux 安全环境字符串  %d    十进制设备编号  %D    十六进制设备编号  %f    十六进制原始模式  %F    文件类型  %g    文件的属组ID  %G    文件的属组组名  %h    硬链接数量  %i    Inode 编号  %m    挂载点  %n    文件名  %N    如果对象是一个符号链接，显示引用到的其它文件名  %o    I/O 块大小  %s    总计大小，以字节为单位  %t    十六进制主设备类型  %T    十六进制子设备类型  %u    文件的属主ID  %U    文件的属主用户名  %w    文件创建时间，若未知则显示&quot;-&quot;  %W    从UNIX 元年起以秒计的文件创建时间，若未知则显示&quot;-&quot;  %x    上次访问时间  %X    从UNIX 元年起以秒计的上次访问时间  %y    上次修改时间  %Y    从UNIX 元年起以秒计的上次修改时间  %z    上次更改时间  %Z    从UNIX 元年起以秒计的上次更改时间有效的文件系统格式序列：  %a    非超级用户可用的剩余块数  %b    文件系统的总数据块数  %c    文件系统中文件节点总数  %d    文件系统中空闲文件节点数  %f    文件系统中空闲块数  %i    十六进制文件系统ID  %I    允许的文件名最大长度  %n    文件名  %s    块大小(用于快速传输)  %S    基本块大小(用于块计数)  %t    十六进制类型描述  %T    可读性较好的类型描述注意：您的shell 内含自己的stat 程序版本，它会覆盖这里所提及的相应版本。请查阅您的shell 文档获知它所支持的选项。\n\n十二、用户和组管理命令1.susu命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。\n普通用户切换到root用户，可以使用su – 或su root,但是必须输入root密码才能完成切换。root用户切换到普通用户，可以使用su username,不需要输入任何密码即可完成切换。\n1su [选项] [-] [USER [参数]...]\n12345678910111213141516171819202122232425修改有效用户标识和组标识为USER的.-, -l, --login       使得shell为可登录的shell-c, --commmand=COMMAND       传递单个COMMAND给-c的shell.-f, --fast       传递-f给shell(针对csh或tcsh)-m, --preserve-environment       不重置环境变量-p     与-m同-s, --shell=SHELL       如果/etc/shells允许,运行SHELL.--help 显示帮助并退出--version       输出版本信息并退出单一的-意味着-l.如果没有给定USER,则假定为root.\n2.sudosudo - 以其他用户身份执行一条命令\nsudo命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。\nsudo 是一种权限管理机制，管理员可以给一些普通用户授权去执行一些 root 执行的操作，而不需要知道 root 的密码。\nsudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。\n12345678usage: sudo -h | -K | -k | -Vusage: sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user]            [command]usage: sudo [-AbEHknPS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p            prompt] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p            prompt] [-u user] file ...\n12345678910111213141516171819202122232425262728293031选项：  -A, --askpass               使用助手程序进行密码提示  -b, --background            在后台运行命令  -C, --close-from=num        关闭所有 &gt;= num 的文件描述符  -E, --preserve-env          在执行命令时保留用户环境  -e, --edit                  编辑文件而非执行命令  -g, --group=group           以指定的用户组或 ID 执行命令  -H, --set-home              将 HOME 变量设为目标用户的主目录。  -h, --help                  显示帮助消息并退出  -h, --host=host             在主机上运行命令(如果插件支持)  -i, --login                 以目标用户身份运行一个登录                              shell；可同时指定一条命令  -K, --remove-timestamp      完全移除时间戳文件  -k, --reset-timestamp       无效的时间戳文件  -l, --list                                               列出用户权限或检查某个特定命令；对于长格式，使用两次  -n, --non-interactive       非交互模式，不提示  -P, --preserve-groups                                    保留组向量，而非设置为目标的组向量  -p, --prompt=prompt         使用指定的密码提示  -r, --role=role             以指定的角色创建 SELinux 安全环境  -S, --stdin                 从标准输入读取密码  -s, --shell                 以目标用户运行                              shell；可同时指定一条命令  -t, --type=type             以指定的类型创建 SELinux 安全环境  -U, --other-user=user       在列表模式中显示用户的权限  -u, --user=user             以指定用户或 ID                              运行命令(或编辑文件)  -V, --version               显示版本信息并退出  -v, --validate              更新用户的时间戳而不执行命令  --                          停止处理命令行参数\nsudo配置文件sudo默认配置文件是/etc/sudoers ，一般使用Linux指定编辑工具visudo ，此工具的好处是可以进行错误检查。在添加规则不符合语法规则时，保存退出时会提示给我们错误信息；配置好后，可以用切换到您授权的普通用户下，通过sudo -l来查看哪些命令是可以执行的或禁止的；\n/etc/sudoers 文件中每行是一个规则，前面带有#号可以当作是注释的内容，并不执行；如果规则很长，可以写在多列上，可以用\\号来续行。\n/etc/sudoers 的规则可分为两类；一类是授权规则，另一类是别名定义；别名定义并不是必须的，但授权规则是必须的；\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[root@itcast ~]# cat /etc/sudoers## Sudoers allows particular users to run various commands as## the root user, without needing the root password.##该文件允许特定用户像root用户一样使用各种各样的命令，而不需要root用户的密码 #### Examples are provided at the bottom of the file for collections## of related commands, which can then be delegated out to particular## users or groups.## 在文件的底部提供了很多相关命令的示例以供选择，这些示例都可以被特定用户或  ## ## 用户组所使用  ## This file must be edited with the &#x27;visudo&#x27; command.## 该文件必须使用&quot;visudo&quot;命令编辑## Host Aliases#主机别名## Groups of machines. You may prefer to use hostnames (perhap using ## wildcards for entire domains) or IP addresses instead.## 对于一组服务器，你可能会更喜欢使用主机名（可能是全域名的通配符）## 或IP地址代替，这时可以配置主机别名  # Host_Alias     FILESERVERS = fs1, fs2# Host_Alias     MAILSERVERS = smtp, smtp2## User Aliases#用户别名## These aren&#x27;t often necessary, as you can use regular groups## (ie, from files, LDAP, NIS, etc) in this file - just use %groupname ## rather than USERALIAS## 这并不很常用，因为你可以通过使用组来代替一组用户的别名  # User_Alias ADMINS = jsmith, mikem## Command Aliases## These are groups of related commands...## 指定一系列相互关联的命令（当然可以是一个）的别名，通过赋予该别名sudo权限，  ## 可以通过sudo调用所有别名包含的命令，下面是一些示例## Networking#网络操作相关命令别名  Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig,  /sbin/mii-tool## Installation and management of software#软件安装管理相关命令别名  Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum## Services#服务相关命令别名 Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig## Updating the locate database#本地数据库升级命令别名  Cmnd_Alias LOCATE = /usr/sbin/updatedb## Storage#磁盘操作相关命令别名Cmnd_Alias STORAGE = /sbin/fdisk, /sbin/sfdisk, /sbin/parted, /sbin/partprobe, /bin/mount, /bin/umount## Delegating permissions#代理权限相关命令别名 Cmnd_Alias DELEGATING = /usr/sbin/visudo, /bin/chown, /bin/chmod, /bin/chgrp## Processes#进程相关命令别名Cmnd_Alias PROCESSES = /bin/nice, /bin/kill, /usr/bin/kill, /usr/bin/killall## Drivers#驱动命令别名Cmnd_Alias DRIVERS = /sbin/modprobe#环境变量的相关配置# Defaults specification## Disable &quot;ssh hostname sudo &lt;cmd&gt;&quot;, because it will show the password in clear. #         You have to run &quot;ssh -t hostname sudo &lt;cmd&gt;&quot;.#Defaults    requirettyDefaults    env_resetDefaults    env_keep = &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR \\                        LS_COLORS MAIL PS1 PS2 QTDIR USERNAME \\                        LANG LC_ADDRESS LC_CTYPE LC_COLLATE LC_IDENTIFICATION \\                        LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC \\                        LC_PAPER LC_TELEPHONE LC_TIME LC_ALL LANGUAGE LINGUAS \\                        _XKB_CHARSET XAUTHORITY&quot;## Next comes the main part: which users can run what software on## which machines (the sudoers file can be shared between multiple## systems).## 下面是规则配置：什么用户在哪台服务器上可以执行哪些命令（sudoers文件可以在多个系统上共享）## Syntax:##语法##      user    MACHINE=COMMANDS##  用户 登录的主机=（可以变换的身份） 可以执行的命令  #### The COMMANDS section may have other options added to it.## 命令部分可以附带一些其它的选项  #### Allow root to run any commands anywhere ## 允许root用户执行任意路径下的任意命令 root    ALL=(ALL)       ALL## Allows members of the &#x27;sys&#x27; group to run networking, software,## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## 允许sys中户组中的用户使用NETWORKING等所有别名中配置的命令  ## Allows people in group wheel to run all commands# %wheel        ALL=(ALL)       ALL## 允许wheel用户组中的用户执行所有命令  ## Same thing without a password## 允许wheel用户组中的用户在不输入该用户的密码的情况下使用所有命令# %wheel        ALL=(ALL)       NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root## 允许users用户组中的用户像root用户一样使用mount、unmount、chrom命令 # %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom## Allows members of the users group to shutdown this system# %users  localhost=/sbin/shutdown -h now## 允许users用户组中的用户像root用户一样使用shutdown命令\nsudo命令别名规则别名规则定义格式如下\n123Alias_Type NAME = item1, item2, ...或者Alias_Type NAME = item1, item2, item3 : NAME = item4, item5\n别名类型（Alias_Type）：别名类型包括如下\n\nHost_Alias 定义主机别名；\nUser_Alias 用户别名，别名成员可以是用户，用户组（前面要加%号）\nRunas_Alias 用来定义runas别名，这个别名指定的是“目的用户”，即sudo 允许切换至的用户；\nCommand_Alias 定义命令别名；\n\n别名规则格式解析\nNAME 就是别名了，NMAE的命名是包含大写字母、下划线以及数字，但必须以一个大写字母开头，比如SYNADM、SYN_ADM或SYNAD0是合法的，sYNAMDA或1SYNAD是不合法的；\nitem 按中文翻译是项目，在这里我们可以译成成员，如果一个别名下有多个成员，成员与成员之间，通过半角逗号分隔；成员在必须是有效并事实存在的。什么是有效的呢？比如主机名，可以通过w查看用户的主机名（或ip地址），如果您只是本地机操作，只通过hostname 命令就能查看；用户名当然是在系统中存在 的，在/etc/paswd中必须存在；对于定义命令别名，成员也必须在系统中事实存在的文件名（需要绝对路径）；\nitem成员受别名类型 Host_Alias、User_Alias、Runas_Alias、Command_Alias 制约，定义什么类型的别名，就要有什么类型的成员相配。我们用Host_Alias定义主机别名时，成员必须是与主机相关相关联，比如是主机名（包括远程登录的主机名）、ip地址（单个或整段）、掩码等； 当用户登录时，可以通过w命令来查看登录用户主机信息；用User_Alias和 Runas_Alias定义时，必须要用系统用户做为成员；用 Cmnd_Alias 定义执行命令的别名时，必须是系统存在的文件，文件名可以用通配符表示，配置Cmnd_Alias时命令需要绝对路径；\n其中 Runas_Alias 和User_Alias 有点相似，但与User_Alias 绝对不是同一个概念，Runas_Alias 定义的是某个系统用户可以sudo 切换身份到Runas_Alias 下的成员；我们在授权规则中以实例进行解说；\n别名规则是每行算一个规则，如果一个别名规则一行容不下时，可以通过\\来续行；同一类型别名的定义，一次也可以定义几个别名，他们中间用:号分隔，\nsudo 设置普通用户具有 root 权限1）添加 用户，并对其设置密码。\n [root@ ~]#useradd xxx\n [root@ ~]#passwd xxx\n2）修改配置文件 \n[root@ ~]#vim /etc/sudoers       修改 /etc/sudoers 文件，找到下面一行，在 root 下面添加一行，如下所示： \n1234## Allow root to run any commands anywhere root ALL=(ALL) ALL root xxx ALL=(ALL) ALL xxx\n或者配置成采用 sudo 命令时，不需要输入密码 \n123## Allow root to run any commands anywhere root ALL=(ALL) ALL root xxx  ALL=(ALL) NOPASSWD:ALL \n修改完毕，现在可以用 帐号登录，然后用命令 sudo ，即可获得 root 权限进行操作\n3.useradduseradd - 创建一个新用户或更新默认新用户信息\nuseradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。\ncat /etc/passwd 查看创建了哪些用户\n123useradd [选项] 用户名useradd -Duseradd -D [选项]\n123456789101112131415161718192021222324选项：  -b, --base-dir BASE_DIR       新账户的主目录的基目录  -c, --comment COMMENT         新账户的 GECOS 字段  -d, --home-dir HOME_DIR       新账户的主目录  -D, --defaults                显示或更改默认的 useradd 配置 -e, --expiredate EXPIRE_DATE  新账户的过期日期  -f, --inactive INACTIVE       新账户的密码不活动期  -g, --gid GROUP               新账户主组的名称或 ID  -G, --groups GROUPS   新账户的附加组列表  -h, --help                    显示此帮助信息并推出  -k, --skel SKEL_DIR   使用此目录作为骨架目录  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值  -l, --no-log-init     不要将此用户添加到最近登录和登录失败数据库  -m, --create-home     创建用户的主目录  -M, --no-create-home          不创建用户的主目录  -N, --no-user-group   不创建同名的组  -o, --non-unique              允许使用重复的 UID 创建用户  -p, --password PASSWORD               加密后的新账户密码  -r, --system                  创建一个系统账户  -R, --root CHROOT_DIR         chroot 到的目录  -s, --shell SHELL             新账户的登录 shell  -u, --uid UID                 新账户的用户 ID  -U, --user-group              创建与用户同名的组  -Z, --selinux-user SEUSER             为 SELinux 用户映射使用指定 SEUSER\n4.userdeluserdel - 删除用户账户和相关文件\nuserdel命令用于删除指定的用户及与该用户相关的文件，英文全称即“user delete”。其实userdel命令实际上是修改了系统的用户账号文件 /etc/passwd、/etc/shadow以及/etc/group文件。这与Linux系统”一切操作皆文件”的思想正好吻合。\n值得注意的是，但是如果有该要删除用户相关的进程正在运行，userdel命令通常不会删除一个用户账号。如果确实必须要删除，可以先终止用户进程，然后再执行userdel命令进行删除。但是userdel命令也提供了一个面对该种情况的参数，即”-f”选项。\n1userdel [选项] 用户名\n12345678选项：  -f, --force                   force some actions that would fail otherwise                                e.g. removal of user still logged in                                or files, even if not owned by the user  -h, --help                    显示此帮助信息并推出  -r, --remove                  删除主目录和邮件池  -R, --root CHROOT_DIR         chroot 到的目录  -Z, --selinux-user            为用户删除所有的 SELinux 用户映射\n5.passwdpasswd命令用于设置用户的认证信息，包括用户密码、账户锁定、密码失效等。直接运行passwd命令修改当前的用户密码，对其他用户的密码操作需要管理员权限。\n1用法: passwd [选项...] &lt;帐号名称&gt;\n12345678910111213141516  -k, --keep-tokens       保持身份验证令牌不过期  -d, --delete            删除已命名帐号的密码(只有根用户才能进行此操作)  -l, --lock              锁定指名帐户的密码(仅限 root 用户)  -u, --unlock            解锁指名账户的密码(仅限 root 用户)  -e, --expire            终止指名帐户的密码(仅限 root 用户)  -f, --force             强制执行操作  -x, --maximum=DAYS      密码的最长有效时限(只有根用户才能进行此操作)  -n, --minimum=DAYS      密码的最短有效时限(只有根用户才能进行此操作)  -w, --warning=DAYS      在密码过期前多少天开始提醒用户(只有根用户才能进行此操作)  -i, --inactive=DAYS     当密码过期后经过多少天该帐号会被禁用(只有根用户才能进行此操作)  -S, --status            报告已命名帐号的密码状态(只有根用户才能进行此操作)  --stdin                 从标准输入读取令牌(只有根用户才能进行此操作)Help options:  -?, --help              Show this help message  --usage                 Display brief usage message\n6.usermodusermod命令用于修改用户账号 。usermod可用来修改用户账号的各项设定，修改系统账号文件来反映通过命令行指定的变化。\n1用法：usermod [选项] 用户名\n1234567891011121314151617181920选项：  -c, --comment 注释            GECOS 字段的新值  -d, --home HOME_DIR           用户的新主目录  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态  -g, --gid GROUP               强制使用 GROUP 为新主组  -G, --groups GROUPS           新的附加组列表 GROUPS  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，                                并不从其它组中删除此用户  -h, --help                    显示此帮助信息并推出  -l, --login LOGIN             新的登录名称  -L, --lock                    锁定用户帐号  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)  -o, --non-unique              允许使用重复的(非唯一的) UID  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码  -R, --root CHROOT_DIR         chroot 到的目录  -s, --shell SHELL             该用户帐号的新登录 shell  -u, --uid UID                 用户帐号的新 UID  -U, --unlock                  解锁用户帐号  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射\n7.groupaddgroupadd - 创建一个新组\ngroupadd命令用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。\n1groupadd [选项] group\n12345678910选项:  -f, --force           如果组已经存在则成功退出                        并且如果 GID 已经存在则取消 -g  -g, --gid GID                 为新组使用 GID  -h, --help                    显示此帮助信息并推出  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值  -o, --non-unique              允许创建有重复 GID 的组  -p, --password PASSWORD       为新组使用此加密过的密码  -r, --system                  创建一个系统账户  -R, --root CHROOT_DIR         chroot 到的目录\n8.groupdelgroupdel - 删除一个组\ngroupdel命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。\nuserdel修改系统账户文件，删除与 GROUP 相关的所有项目。给出的组名必须存在。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。\n1用法：groupdel [选项] 组\n123选项:  -h, --help                    显示此帮助信息并推出  -R, --root CHROOT_DIR         chroot 到的目录\n9.groupmodgroupmod命令更改群组识别码或名称。需要更改群组的识别码或名称时，可用groupmod指令来完成这项工作。\n不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。\n1用法：groupmod [选项] 组\n1234567选项:  -g, --gid GID                 将组 ID 改为 GID  -h, --help                    显示此帮助信息并推出  -n, --new-name NEW_GROUP      改名为 NEW_GROUP  -o, --non-unique              允许使用重复的 GID  -p, --password PASSWORD       将密码更改为(加密过的) PASSWORD  -R, --root CHROOT_DIR         chroot 到的目录\n10.gpasswdgpasswd命令是Linux下工作组文件/etc/group和/etc/gshadow管理工具。\ngpasswd命令是Linux下工作组文件/etc/group和/etc/gshadow的管理工具 ，系统管理员可以使用-a选项定义组管理员，使用-m选项定义成员，由组管理员用组名调用的gpasswd只提示输入组的新密码。\n1用法：gpasswd [选项] 组\n12345678910选项：  -a, --add USER                向组 GROUP 中添加用户 USER  -d, --delete USER             从组 GROUP 中添加或删除用户  -h, --help                    显示此帮助信息并推出  -Q, --root CHROOT_DIR         要 chroot 进的目录  -r, --delete-password         remove the GROUP&#x27;s password  -R, --restrict                向其成员限制访问组 GROUP  -M, --members USER,...        设置组 GROUP 的成员列表  -A, --administrators ADMIN,...        设置组的管理员列表除非使用 -A 或 -M 选项，不能结合使用这些选项。\n11.newgrpnewgrp - 登录到一个新组\nnewgrp命令类的英文全称为“new group”,该命令类似login指令，当它是以相同的帐号，另一个群组名称，再次登入系统。欲使用newgrp指令切换群组，您必须是该群组的用户，否则将无法登入指定的群组。\n单一用户要同时隶属多个群组，需利用交替用户的设置。若不指定群组名称，则newgrp指令会登入该用户名称的预设群组。\n1用法：newgrp [-] [用户组名]\n\n\n\n\n–help\n在线帮助\n\n\n\n\n–vesion\n显示版本信息\n\n\n\n\n12.chagechage - 更改用户密码过期信息\nchage命令是用来修改帐号和密码的有效期限；这个信息由系统用于确定用户何时必须更改其密码。\n1用法：chage [选项] 登录名\n12345678910选项：  -d, --lastday 最近日期        将最近一次密码设置时间设为“最近日期”  -E, --expiredate 过期日期     将帐户过期时间设为“过期日期”  -h, --help                    显示此帮助信息并推出  -I, --inactive INACITVE       过期 INACTIVE 天数后，设定密码为失效状态  -l, --list                    显示帐户年龄信息  -m, --mindays 最小天数        将两次改变密码之间相距的最小天数设为“最小天数”  -M, --maxdays 最大天数        将两次改变密码之间相距的最大天数设为“最大天数”  -R, --root CHROOT_DIR         chroot 到的目录  -W, --warndays 警告天数       将过期警告天数设为“警告天数”\n13.groupsgroups - 显示用户所在的组\ngroups命令在标准输入输出上输出指定用户所在组的组成员，每个用户属于/etc/passwd中指定的一个组和在/etc/group中指定的其他组。\n1用法：groups [选项]... [用户名]...\n1234显示每个输入的用户名所在的全部组，如果没有指定用户名则默认为当前进程用户(当用户组数据库发生变更时可能导致差异)。      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n14.whowho命令用来打印当前登录用户信息，包含了系统的启动时间 、 活动进程 、 使用者 ID、使用终端等信息，是系统管理员了解系统运行状态的常用命令。\n1用法：who [选项]... [ 文件 | 参数1 参数2 ]\n12345678910111213141516171819显示当前已登录的用户信息。  -a, --all             等于-b -d --login -p -r -t -T -u 选项的组合  -b, --boot            上次系统启动时间  -d, --dead            显示已死的进程  -H, --heading 输出头部的标题列  -l，--login           显示系统登录进程      --lookup          尝试通过 DNS 查验主机名  -m                    只面对和标准输入有直接交互的主机和用户  -p, --process 显示由 init 进程衍生的活动进程  -q, --count           列出所有已登录用户的登录名与用户数量  -r, --runlevel        显示当前的运行级别  -s, --short           只显示名称、线路和时间(默认)  -T, -w, --mesg        用+，- 或 ? 标注用户消息状态  -u, --users           列出已登录的用户      --message 等于-T      --writable        等于-T      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n15.ww - 显示已经登录的用户以及他们在做什么\nw命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。\n1w - [husfV] [user]\n12345-h：不打印头信息；-u：当显示当前进程和cpu时间时忽略用户名；-s：使用短输出格式；-f：显示用户从哪登录；-V：显示版本信息。\n16.lastlast命令用于显示用户最近登录信息。单独执行last命令，它会读取/var/log/wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。\nlast命令的作用是显示近期用户或终端的登录情况，通过查看系统记录的日志文件内容，进而使管理员可以获知谁曾经或者企图连接系统。\n执行last命令时，它会读取/var/log目录下名称为wtmp的文件，并把该文件记录的登录系统或终端的用户名单全部显示出来。默认显示wtmp的记录，btmp能显示的更详细，可以显示远程登录，例如ssh登录。\n1last [-R] [-num] [ -n num ] [-adiox] [ -f file ] [name...]  [tty...]\n123456-a：把从何处登入系统的主机名称或ip地址，显示在最后一行；-d：将IP地址转换成主机名称；-f &lt;记录文件&gt;：指定记录文件。-n &lt;显示列数&gt;或-&lt;显示列数&gt;：设置列出名单的显示列数；-R：不显示登入系统的主机名称或IP地址；-x：显示系统关机，重新开机，以及执行等级的改变等信息。\n17.lastloglastlog命令用于显示系统中所有用户最近一次登录信息。\nlastlog文件在每次有用户登录时被查询。可以使用lastlog命令检查某特定用户上次登录的时间，并格式化输出上次登录日志/var/log/lastlog的内容。它根据UID排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog显示Never logged。注意需要以root身份运行该命令。\n1用法：lastlog [选项]\n12345678选项：  -b, --before DAYS             仅打印早于 DAYS 的最近登录记录  -C, --clear                   clear lastlog record of an user (usable only with -u)  -h, --help                    显示此帮助信息并推出  -R, --root CHROOT_DIR         chroot 到的目录  -S, --set                     set lastlog record to current time (usable only with -u)  -t, --time DAYS               仅打印晚于 DAYS 的最近登录记录  -u, --user LOGIN              打印 LOGIN 用户的最近登录记录\n18.usersusers命令用于显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。\n1用法：users [选项]... [文件]\n12345根据文件判断输出当前有谁正登录在系统上。如果文件未予指定，则使用/var/run/utmp，/var/log/wtmp 是通用的相关文件。      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n\n十三、权限命令1.chmod**chmod - 改变文件的访问权限\nchmod命令的英文原意是“change the permissions mode of a file”，我们简称为“change mode”，意为用来改变文件或目录权限的命令，但是只有文件的属主和超级用户root才能执行这个命令。有两种模式，一种是采用权限字母和操作符表达式；另一种是采用数字。\n文件属性 \nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。 为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做 了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属 的用户和组。\n\n\n\n\n如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示:\n （1）0 首位表示类型 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等 - 代表文件 d 代表目录 l 链接文档(link file)； \n\n“d” 代表文件夹\n“-” 代表普通文件\n“c” 代表硬件字符设备\n“b” 代表硬件块设备\n“s”表示管道文件\n“l” 代表软链接文件。\n\n后9个字母分别代表三组权限：文件所有者、用户组、其他用户拥有的权限。\n（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—-User \n（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—-Group \n（4）第7-9位确定其他用户拥有该文件的权限 —-Other\nrwx 作用文件和目录的不同解释 \n（1）作用到文件：\n[ r ]代表可读(read): 可以读取，查看 \n[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前 提条件是对该文件所在的目录有写权限，才能删除该文件\n[ x ]代表可执行(execute):可以被系统执行 \n（2）作用到目录： \n[ r ]代表可读(read): 可以读取，ls查看目录内容 \n[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录 \n[ x ]代表可执行(execute):可以进入该目录\nchmod 改变权限\n 1）基本语法\n\n权限范围的表示法如下：\nu   User，即文件或目录的拥有者；g   Group，即文件或目录的所属群组；o   Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a   All，即全部的用户，包含拥有者，所属群组以及其他用户；r   读取权限，数字代号为“4”;w   写入权限，数字代号为“2”；x   执行或切换权限，数字代号为“1”；\n“-“ 不具任何权限，数字代号为“0”；s   特殊功能说明：变更文件或目录的权限。\n第一种方式变更权限 \nchmod [{ugoa}{+-=}{rwx}] 文件或目录 \n第二种方式变更权限 \nchmod [mode=421 ] [文件或目录] \n权限进制表示\n\n2）经验技巧 u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)\nr=4 w=2 x=1    rwx=4+2+1=7\n-rw------- (600)      只有拥有者有读写权限。\n-rw-r--r-- (644)      只有拥有者有读写权限；而属组用户和其他用户只有读权限。\n-rwx------ (700)     只有拥有者有读、写、执行权限。\n-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。\n-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。\n-rw-rw-rw- (666)   所有用户都有文件读、写权限。\n-rwxrwxrwx (777)  所有用户都有读、写、执行权限。\n权限设定\n增加权限取消权限 =唯一设定权限\n123用法：chmod [选项]... 模式[,模式]... 文件...　或：chmod [选项]... 八进制模式 文件...　或：chmod [选项]... --reference=参考文件 文件...\n12345678910111213将每个文件的模式更改为指定值。  -c, --changes         类似 --verbose，但只在有更改时才显示结果      --no-preserve-root        不特殊对待根目录(默认)      --preserve-root           禁止对根目录进行递归操作  -f, --silent, --quiet 去除大部份的错误信息  -v, --verbose         为处理的所有文件显示诊断信息      --reference=参考文件      使用指定参考文件的模式，而非自行指定权限模式  -R, --recursive               以递归方式更改所有的文件及子目录      --help            显示此帮助信息并退出      --version         显示版本信息并退出每种 MODE 都应属于这类形式&quot;[ugoa]*([-+=]([rwxXst]*|[ugo]))+&quot;。\n3.chownchown - 修改文件所有者和所属组\nLinux/Unix 属于多用户多任务操作系统，所有的文件皆有拥有者。利用 chown 命令可以将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID，组可以是组名或者组ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 一般来说，这个指令仅限系统管理者(root)所使用，普通用户没有权限改变文件所属者及所属组。\n12用法：chown [选项]... [所有者][:[组]] 文件...　或：chown [选项]... --reference=参考文件 文件...\n12345678910111213141516171819当使用 --referebce 参数时，将文件的所有者和所属组更改为与指定参考文件相同。  -c, --changes                 类似 verbose，但只在有更改时才显示结果      --dereference             受影响的是符号链接所指示的对象，而非符号链接本身  -h, --no-dereference          会影响符号链接本身，而非符号链接所指示的目的地                                (当系统支持更改符号链接的所有者时，此选项才有用)      --from=当前所有者:当前所属组                                只当每个文件的所有者和组符合选项所指定时才更改所                                有者和组。其中一个可以省略，这时已省略的属性就不                                需要符合原有的属性。      --no-preserve-root        不特殊对待&quot;/&quot;(默认值)      --preserve-root           不允许在&quot;/&quot;上递归操作  -f, --silent, --quiet 去除大部份的错误信息      --reference=参考文件      使用参考文件的所属组，而非指定值  -R, --recursive               递归处理所有的文件及子目录  -v, --verbose                 为处理的所有文件显示诊断信息      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n4.chgrpchgrp是英语单词“change group”的缩写，命令的作用和其中文释义一样，为用于变更文件或目录的所属群组。\nchgrp命令用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户(root)，则不能改变该文件的组。\n在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。\n12用法：chgrp [选项]... 用户组 文件...　或：chgrp [选项]... --reference=参考文件 文件...\n123456-c或——changes：效果类似“-v”参数，但仅回报更改的部分；-f或--quiet或——silent：不显示错误信息；-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；-v或——verbose：显示指令执行过程；--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；\n5.chattrchattr命令用来改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下几种模式：\n\n\n\n\n参数\n作用\n\n\n\n\ni\n无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件\n\n\na\n仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）\n\n\nS\n文件内容在变更后立即同步到硬盘（sync）\n\n\ns\n彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）\n\n\nA\n不再修改这个文件或目录的最后访问时间（atime）\n\n\nb\n不再修改文件或目录的存取时间\n\n\nD\n检查压缩文件中的错误\n\n\nd\n使用dump命令备份时忽略本文件/目录\n\n\nc\n默认将文件或目录进行压缩\n\n\nu\n当删除该文件后依然保留其在硬盘中的数据，方便日后恢复\n\n\nt\n让文件系统支持尾部合并（tail-merging）\n\n\nx\n可以直接访问压缩文件中的内容\n\n\n\n\n如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。\n1用法：chattr [参数] 文件\n123456-R：递归处理，将指令目录下的所有文件及子目录一并处理；-v&lt;版本编号&gt;：设置文件或目录版本；-V：显示指令执行过程；+&lt;属性&gt;：开启文件或目录的该项属性；-&lt;属性&gt;：关闭文件或目录的该项属性；=&lt;属性&gt;：指定文件或目录的该项属性。\n6.lsattrlsattr命令的英文全称即“list attribute”，用于查看特定设备或特定文件在Linux第二扩展文件系统上的特有属性信息 。该命令常与chattr一起使用，chattr命令用于改变文件或目录的隐藏属性，而lsattr命令则用于查看其属性 。\n1格式：lsattr [参数] [文件]\n12345-a \t列出目录中的所有文件，包括隐藏文件-d \t只显示目录名称-R\t递归地处理指定目录下的所有文件及子目录-v \t显示文件或目录版本-V\t显示版本信息\n7.setfaclsetfacl的英文全称是“ set file access control list ”,即“设置文件访问控制列表”。改命令可以更精确的控制权限的分配，比如让某一个用户对某一个文件具有某种权限。\nACL指文件的所有者、所属组、其他人的读/写/执行之外的特殊的权限， 对于需要特殊权限的使用状况有一定帮助。 如某一个文件，不让单一的某个用户访问。\n1格式：setfacl [参数] [文件]\n123456789101112131415161718-m, --modify=acl 更改文件的访问控制列表-M, --modify-file=file 从文件读取访问控制列表条目更改-x, --remove=acl 根据文件中访问控制列表移除条目-X, --remove-file=file 从文件读取访问控制列表条目并删除-b, --remove-all 删除所有扩展访问控制列表条目-k, --remove-default 移除默认访问控制列表    --set=acl 设定替换当前的文件访问控制列表    --set-file=file 从文件中读取访问控制列表条目设定    --mask 重新计算有效权限掩码-n, --no-mask 不重新计算有效权限掩码-d, --default 应用到默认访问控制列表的操作-R, --recursive 递归操作子目录-L, --logical 依照系统逻辑，跟随符号链接-P, --physical 依照自然逻辑，不跟随符号链接    --restore=file 恢复访问控制列表，和“getfacl -R”作用相反    --test 测试模式，并不真正修改访问控制列表属性-v, --version           显示版本并退出-h, --help              显示本帮助信息\n选项-m和-x后边跟以acl规则。多条acl规则以逗号(,)隔开。选项-M和-X用来从文件或标准输入读取acl规则。选项—set和—set-file用来设置文件或目录的acl规则，先前的设定将被覆盖。选项-m(—modify)和-M(—modify-file)选项修改文件或目录的acl规则。选项-x(—remove)和-X(—remove-file)选项删除acl规则。当使用-M，-X选项从文件中读取规则时，setfacl接受getfacl命令输出的格式。每行至少一条规则，以#开始的行将被视为注释。\n当在不支持ACLs的文件系统上使用setfacl命令时，setfacl将修改文件权限位。如果acl规则并不完全匹配文件权限位，setfacl将会修改文件权限位使其尽可能的反应acl规则，并会向standard error发送错误消息，以大于0的状态返回。\n8.getfacl获取文件访问控制列表\n1getfacl  [选项]  文件 ...\n1234567891011121314-a,  --access           仅显示文件访问控制列表-d, --default           仅显示默认的访问控制列表-c, --omit-header       不显示注释表头-e, --all-effective     显示所有的有效权限-E, --no-effective      显示无效权限-s, --skip-base         跳过只有基条目(base entries)的文件-R, --recursive         递归显示子目录-L, --logical           逻辑遍历(跟随符号链接)-P, --physical          物理遍历(不跟随符号链接)-t, --tabular           使用制表符分隔的输出格式-n, --numeric           显示数字的用户/组标识-p, --absolute-names    不去除路径前的 &#x27;/&#x27; 符号-v, --version           显示版本并退出-h, --help              显示本帮助信息\n9.umaskumask命令用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask命令都被执行， 并自动设置掩码mode来限制新文件的权限。用户可以通过再次执行umask命令来改变默认值，新的权限将会把旧的覆盖掉。\n1语法格式：umask [参数] [权限掩码]\n12-S:以字符的形式显示当前创建文件的默认权限。-p：带umask开头以数字的形势显示当前掩码\n\n十四、进程管理和服务管理命令1.systemctlsystemctl命令是系统服务管理器指令，它实际上将 service和chkconfig这两个命令组合到一起。\nCentos7之后从init完全换成了systemd的启动方式，systemd 启动服务的机制主要是通过 systemctl 的这个系统服务管理指令来处理。systemctl在用法上也囊括 service / chkconfig / setup / init 的大部分功能。\n\n\n\n\n任务\n旧指令\n新指令\n\n\n\n\n使某服务自动启动\nchkconfig —level 3 httpd on\nsystemctl enable httpd.service\n\n\n使某服务不自动启动\nchkconfig —level 3 httpd off\nsystemctl disable httpd.service\n\n\n检查服务状态\nservice httpd status\nsystemctl status httpd.service （服务详细信息） systemctl is-enabled httpd.service （仅显示是否 Active)\n\n\n显示所有已启动的服务\nchkconfig —list\nsystemctl list-units —type=service\n\n\n启动某服务\nservice httpd start\nsystemctl start httpd.service\n\n\n停止某服务\nservice httpd stop\nsystemctl stop httpd.service\n\n\n重启某服务\nservice httpd restart\nsystemctl restart httpd.service\n\n\n某服务重新加载配置文件\nservice httpd reload\nsystemctl reload httpd.service\n\n\n\n\n1格式:systemctl [选项...] &#123;命令&#125; ...\n1234567-start\t启动服务-stop\t停止服务-restart\t重启服务-enable\t使某服务开机自启-disable\t关闭某服务开机自启-status\t查看服务状态-list-units –type=service\t列举所有已启动服务\n2.initinit命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。\n注意：Centos7.5 中第一个进程是systemd进程\n运行级别\n到底什么是运行级呢？简单的说，运行级就是操作系统当前正在运行的功能级别。这个级别从0到6 ，具有不同的功能。你也可以在/etc/inittab中查看它的英文介绍。\n1234567#0  停机（千万不能把initdefault 设置为0）#1  单用户模式#2  多用户，没有 NFS(和级别3相似，会停止部分服务)#3  完全多用户模式#4  没有用到#5  x11(Xwindow)#6  重新启动（千万不要把initdefault 设置为6）\n1格式：init [选项] [参数]\n123456789101112Send control commands to the init daemon.     --help      Show this help     --no-wall   Don&#x27;t send wall message before halt/power-off/rebootCommands:  0              Power-off the machine  6              Reboot the machine  2, 3, 4, 5     Start runlevelX.target unit  1, s, S        Enter rescue mode  q, Q           Reload init daemon configuration  u, U           Reexecute init daemon\n3.telinit设置当前系统的运行等级\n说明:\n\nThis is a legacy command available for compatibility only. It should not be used anymore, as the concept of runlevels is obsolete.\n\n1用法：telinit [选项] [参数]\n123456789101112Send control commands to the init daemon.     --help      Show this help     --no-wall   Don&#x27;t send wall message before halt/power-off/rebootCommands:  0              Power-off the machine  6              Reboot the machine  2, 3, 4, 5     Start runlevelX.target unit  1, s, S        Enter rescue mode  q, Q           Reload init daemon configuration  u, U           Reexecute init daemon\n4.psps命令用于报告当前系统的进程状态。ps命令是“process status”的缩写。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。\n\n（1）ps aux \nUSER：该进程是由哪个用户产生的 \nPID：进程的ID号 \n%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源； \n%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源； \nVSZ：该进程占用虚拟内存的大小，单位KB； \nRSS：该进程占用实际物理内存的大小，单位KB； \nTTY：该进程是在哪个终端中运行的。对于CentOS来说，tty1是图形化终端， tty2-tty6 是本地的字符界面终端。pts/0-255代表虚拟终端。 \nSTAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、 Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示 \n123456789101112131415R 运行    Runnable (on run queue) 正在运行或在运行队列中等待。S 睡眠    Sleeping                休眠中, 受阻, 在等待某个条件的形成或接受到信号。I 空闲    IdleZ 僵死    Zombie（a defunct process) 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。D 不可中断    Uninterruptible sleep (ususally IO)    收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。T 终止    Terminate 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。P 等待交换页W 无驻留页    has no resident pages 没有足够的记忆体分页可分配。X 死掉的进程&lt; 高优先级进程 高优先序的进程N 低优先    级进程 低优先序的进程L 内存锁页    Lock 有记忆体分页分配并缩在记忆体内s 进程的领导者（在它之下有子进程）；l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）+ 位于后台的进程组 \nSTART：该进程的启动时间 \nTIME：该进程占用CPU的运算时间，注意不是系统时间 \nCOMMAND：产生此进程的命令名 \n（2）ps-ef\nUID：用户ID \nPID：进程ID \nPPID：父进程ID \nC：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算， 执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 \nSTIME：进程启动的时间 \nTTY：完整的终端名称 \nTIME：CPU时间 \nCMD：启动进程所用的命令和参数\n1格式：ps [参数]\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-a  显示所有终端机下执行的进程，除了阶段作业领导者之外。　　 a  显示现行终端机下的所有进程，包括其他用户的进程。　　-A  显示所有进程。　　-c  显示CLS和PRI栏位。　　 c  列出进程时，显示每个进程真正的指令名称，而不包含路径，参数或常驻服务的标示。　　-C&lt;指令名称&gt; 　指定执行指令的名称，并列出该指令的进程的状况。　　-d 　显示所有进程，但不包括阶段作业领导者的进程。　　-e 　此参数的效果和指定&quot;A&quot;参数相同。　　 e 　列出进程时，显示每个进程所使用的环境变量。　　-f 　显示UID,PPIP,C与STIME栏位。　　 f 　用ASCII字符显示树状结构，表达进程间的相互关系。　　-g&lt;群组名称&gt; 　此参数的效果和指定&quot;-G&quot;参数相同，当亦能使用阶段作业领导者的名称来指定。　　 g 　显示现行终端机下的所有进程，包括群组领导者的进程。　　-G&lt;群组识别码&gt; 　列出属于该群组的进程的状况，也可使用群组名称来指定。　　 h 　不显示标题列。　　-H 　显示树状结构，表示进程间的相互关系。　　-j或j 　采用工作控制的格式显示进程状况。　　-l或l 　采用详细的格式来显示进程状况。　　 L 　列出栏位的相关信息。　　-m或m 　显示所有的执行绪。　　 n 　以数字来表示USER和WCHAN栏位。　　-N 　显示所有的进程，除了执行ps指令终端机下的进程之外。　　-p&lt;进程识别码&gt; 　指定进程识别码，并列出该进程的状况。　 　p&lt;进程识别码&gt; 　此参数的效果和指定&quot;-p&quot;参数相同，只在列表格式方面稍有差异。　　 r 　只列出现行终端机正在执行中的进程。　　-s&lt;阶段作业&gt; 　指定阶段作业的进程识别码，并列出隶属该阶段作业的进程的状况。　 　s 　采用进程信号的格式显示进程状况。　　 S 　列出进程时，包括已中断的子进程资料。　　-t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的进程的状况。　　 t&lt;终端机编号&gt; 　此参数的效果和指定&quot;-t&quot;参数相同，只在列表格式方面稍有差异。　　-T 　显示现行终端机下的所有进程。　　-u&lt;用户识别码&gt; 　此参数的效果和指定&quot;-U&quot;参数相同。　　 u 　以用户为主的格式来显示进程状况。　　-U&lt;用户识别码&gt; 　列出属于该用户的进程的状况，也可使用用户名称来指定。　　 U&lt;用户名称&gt; 　列出属于该用户的进程的状况。　　 v 　采用虚拟内存的格式显示进程状况。　　-V或V 　显示版本信息。　　-w或w 　采用宽阔的格式来显示进程状况。　　 　x 　显示所有进程，不以终端机来区分。　　 X 　采用旧式的Linux i386登陆格式显示进程状况。　　 -y 配合参数&quot;-l&quot;使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　　-&lt;进程识别码&gt; 　此参数的效果和指定&quot;p&quot;参数相同。　　--cols&lt;每列字符数&gt; 　设置每列的最大字符数。　　--columns&lt;每列字符数&gt; 　此参数的效果和指定&quot;--cols&quot;参数相同。　　--cumulative 　此参数的效果和指定&quot;S&quot;参数相同。　　--deselect 　此参数的效果和指定&quot;-N&quot;参数相同。　　--forest 　此参数的效果和指定&quot;f&quot;参数相同。　　--headers 　重复显示标题列。　　--help 　在线帮助。　　--info 　显示排错信息。　　--lines&lt;显示列数&gt; 设置显示画面的列数。　　--no-headers  此参数的效果和指定&quot;h&quot;参数相同，只在列表格式方面稍有差异。　　--group&lt;群组名称&gt; 　此参数的效果和指定&quot;-G&quot;参数相同。　　--Group&lt;群组识别码&gt; 　此参数的效果和指定&quot;-G&quot;参数相同。　　--pid&lt;进程识别码&gt; 　此参数的效果和指定&quot;-p&quot;参数相同。　　--rows&lt;显示列数&gt; 　此参数的效果和指定&quot;--lines&quot;参数相同。　　--sid&lt;阶段作业&gt; 　此参数的效果和指定&quot;-s&quot;参数相同。　　--tty&lt;终端机编号&gt; 　此参数的效果和指定&quot;-t&quot;参数相同。　　--user&lt;用户名称&gt; 　此参数的效果和指定&quot;-U&quot;参数相同。　　--User&lt;用户识别码&gt; 　此参数的效果和指定&quot;-U&quot;参数相同。　　--version 　此参数的效果和指定&quot;-V&quot;参数相同。　　--widty&lt;每列字符数&gt; 　此参数的效果和指定&quot;-cols&quot;参数相同。 \n5.pstreelinux系统中pstree命令的英文全称是“process tree”，即将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。\n1格式： pstree [参数]\n1234567891011-a 　显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。-c 　不使用精简标示法。-G 　使用VT100终端机的列绘图字符。-h 　列出树状图时，特别标明执行的程序。-H&lt;程序识别码&gt; 　此参数的效果和指定&quot;-h&quot;参数类似，但特别标明指定的程序。-l 　采用长列格式显示树状图。-n 　用程序识别码排序。预设是以程序名称来排序。-p 　显示程序识别码。-u 　显示用户名称。-U 　使用UTF-8列绘图字符。-V 　显示版本信息。\n6.toptop命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，常用于服务端性能分析。\n在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。\n1格式：top [参数]\n12345678910-b：以批处理模式操作；-c：显示完整的进程信息；-d：屏幕刷新间隔时间；-I：忽略失效过程；-s：保密模式；-S：累积模式；-i&lt;时间&gt;：设置间隔时间；-u&lt;用户名&gt;：指定用户名；-p&lt;进程号&gt;：指定进程；-n&lt;次数&gt;：循环显示的次数。\n7.killkill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。\n1语法格式：kill [参数] [进程号]\n1234-9  强制停止-l  &lt;信号变化哦啊&gt;，若不加信号的编号参数，则使用“-l”参数会列出全部的信号名称-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号-s  指定发送信号\n8.killallkillall命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。\n123killall [-egiqvw] [-signal] name ...killall -lkillall -V\n123456789-e：对长名称进行精确匹配；-l：忽略大小写的不同；-p：杀死进程所属的进程组；-i：交互式杀死进程，杀死进程前需要进行确认；-l：打印所有已知信号列表；-q：如果没有进程被杀死。则不输出任何信息；-r：使用正规表达式匹配要杀死的进程名称；-s：用指定的进程号代替默认信号“SIGTERM”；-u：杀死指定用户的进程。\n9.nicenice命令用于以指定的进程调度优先级启动其他的程序。\n系统的后台工作中，某些比较不重要的进程在运行，例如备份，由于备份工作相当耗系统资源，这个时候就可以调大备份命令的nice值，可以使系统资源更合理使用。\n1234用法： nice [-n] &lt;优先级&gt; [-p|--pid] &lt;pid&gt;... nice [-n] &lt;优先级&gt;  -g|--pgrp &lt;pgid&gt;... nice [-n] &lt;优先级&gt;  -u|--user &lt;用户&gt;...\n1234567选项： -g, --pgrp &lt;id&gt;        将参数解释为进程组 ID -n, --priority &lt;数字&gt;  指定 nice 增加值 范围在-20~19 -p, --pid &lt;id&gt;         将参数解释为进程 ID (默认) -u, --user &lt;name|id&gt;   将参数解释为用户名或用户 ID -h, --help             显示帮助文本并退出 -V, --version          显示版本信息并退出\n10.renicerenice命令可以修改正在运行的进程的调度优先级。\n该命令预设是以程序识别码指定程序调整其优先权，您亦可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先权。只有系统管理者可以改变其他用户程序的优先权，也仅有系统管理者可以设置负数等级。\n1234用法： renice [-n] &lt;优先级&gt; [-p|--pid] &lt;pid&gt;... renice [-n] &lt;优先级&gt;  -g|--pgrp &lt;pgid&gt;... renice [-n] &lt;优先级&gt;  -u|--user &lt;用户&gt;...\n1234567选项： -g, --pgrp &lt;id&gt;        将参数解释为进程组 ID -n, --priority &lt;数字&gt;  指定 nice 增加值 -p, --pid &lt;id&gt;         将参数解释为进程 ID (默认) -u, --user &lt;name|id&gt;   将参数解释为用户名或用户 ID -h, --help             显示帮助文本并退出 -V, --version          显示版本信息并退出\n11.jobsjobs命令主要用于显示系统中的任务列表及其运行状态。\n该命令可以显示任务号及其对应的进程号，其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应一个或者多个进程号。\n12jobs [-lnprs] [任务声明 ...]jobs -x 命令 [参数]\n12345678910111213141516列出活动的任务。JPBSPEC 限制仅输出指定的任务。不带选项时，所有活动任务的状态都会显示。选项：  -l        在正常信息基础上列出进程号  -n        列出上次通告之后改变了状态的进程  -p        仅列出进程号  -r        限制仅输出运行中的任务  -s        限制仅输出停止的任务如果使用了 -x 选项，ARG 参数中的所有任务声明会被替换为该任务的进程组头领的进程号，然后执行 COMMAND 命令。退出状态：返回成功，除非使用了无效的选项或者有错误发生。如果使用 -x选项，则返回 COMMAND 命令的退出状态。\n12.fgfg命令用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。与bg命令一样，若后台任务中只有一个，则使用该命令时，可以省略任务号。\n1语法格式：fg [参数]\n123456789fg: fg [任务声明]    将任务移至前台。        将以 JOB_SPEC 标识的任务放至前台，使其成为    当前任务。如果 JOB_SPEC 不存在，shell 观念中的当前任务     将被使用。        退出状态：    放至前台的命令状态，或者当错误发生时为失败。\n13.bgbg命令用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号&amp;的效果是相同的，都是将其放到系统后台执行。\n1语法格式：bg [参数]\n123456789bg: bg [任务声明 ...]    移动任务至后台。        将 JOB_SPEC 标识的任务放至后台，就像它们    是带 `&amp;&#x27; 启动的一样。如果 JOB_SPEC 不存在，shell 观念中的    当前任务将会被使用。        退出状态：    返回成功除非任务管理没有启用或者错误发生。\n14.nohupnohup命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。\n无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或打开以用于追加，那么 command参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。\n12用法：nohup 命令 [参数]...　或：nohup 选项\n123456执行 COMMAND 命令, 忽略 hangup (挂起) 信号.--help 显示此帮助, 然后退出--version       显示版本信息, 然后退出\n15.crontab1crontab [选项]\n\n\n\n\n\n十五、网络管理1.pingping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\nping, ping6 - 向网络主机发送ICMP回显请求(ECHO_REQUEST)分组。\n注意：Linux系统下的ping命令与Windows系统下的ping命令稍有不同。Windows下运行ping命令一般会发出4个请求就结束运行该命令；而Linux下不会自动终止，此时需要我们按CTR+C终止或者使用-c参数为ping命令指定发送的请求数目。\n1格式：ping [选项] [参数]\n123456789101112-d\t使用Socket的SO_DEBUG功能-c\t指定发送报文的次数-i\t指定收发信息的间隔时间-I\t使用指定的网络接口送出数据包-l\t设置在送出要求信息之前，先行发出的数据包-n\t只输出数值-p\t设置填满数据包的范本样式-q\t不显示指令执行过程-R\t记录路由过程-s\t设置数据包的大小-t\t设置存活数值TTL的大小-v\t详细显示指令的执行过程\n2.ifconfigifconfig命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。\n12ifconfig [接口]ifconfig 接口 [aftype] options | address ...\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768interface接口的名称。这通常是一个驱动程序名，后面跟着一个单元号，例如用于第一个以太网接口的eth0。up此标志将导致激活接口。如果将地址分配给接口，则会隐式指定该地址。down此标志导致关闭此接口的驱动程序。[-]arp启用或禁用在此接口上使用ARP协议。[-]promisc启用或禁用接口的混杂模式。如果选中，网络上的所有数据包都将由接口接收。[-]allmulti启用或禁用所有多播模式。如果选中，则接口将接收网络上的所有多播数据包。metric N此参数设置接口度量。它在GNU/Linux下不可用mtu N此参数设置接口的最大传输单元(MTU)。dstaddr addr为点对点链路(如PPP)设置远程IP地址.这个关键字现在已经过时了；使用pointopoint关键字代替。netmask addr设置此接口的IP网络掩码。此值默认为通常的A、B或C类网络掩码(从接口IP地址派生)，但可以设置为任何值。add addr/prefixlen向接口添加IPv 6地址del addr/prefixlen从接口中删除IPv 6地址tunnel ::aa.bb.cc.dd创建一个新的SIT(IPv6-in-IPv4)设备，通过隧道到达给定的目的地。irq addr设置此设备使用的中断行。并非所有设备都可以动态更改其IRQ设置。io_addr addr为该设备设置I/O空间中的起始地址mem_start addr设置此设备使用的共享内存的起始地址。只有少数几个设备需要这个media type设置设备要使用的物理端口或介质类型。并非所有设备都可以更改此设置，以及那些可以更改其支持的值的设备。典型的类型值是10 base 2(细以太网)、10 base T(双绞线10 Mbps以太网)、AUI(外收发信机)等。驱动的特殊介质类型可以用来告诉驱动对媒体进行自动感知。同样，并不是所有的驱动都能做到这一点。[-]broadcast [addr]如果地址参数给定，则为该接口设置协议广播地址。否则，设置(或清除)接口的IFF_BROADCAST标志。[-]pointopoint [addr]这个关键字启用了接口的点对点模式，这意味着它是两台机器之间的直接链接，没有其他人监听它。如果地址参数也给出了，就像过时的dstaddr关键字一样，设置链接另一端的协议地址。否则，设置或清除接口的IFF_POINTOPOINT标志。hw class address如果设备驱动程序支持此操作，则设置此接口的硬件地址。关键字后面必须跟着硬件类的名称和相当于硬件地址的可打印的ASCII。目前支持的硬件类包括ether (以太网)、ax25(AMPRAX.25)、ARCnet和netrom(AMPR NET/ROM)。multicast在接口上设置多播标志。这通常不应该需要，因为驱动程序本身设置正确的标志。address要分配给此接口的IP地址。txqueuelen length设置设备的传输队列的长度。对于具有高延迟(调制解调器链路，ISDN)的较慢设备，将其设置为小值是有用的，以防止快速批量传输过多地干扰诸如telnet之类的交互通信。\n3.ifupifup命令用于激活指定的网络接口。ifup命令会去读取/etc/sysconfig/network-scripts/目录下的相关网络接口的配置文件，并根据配置文件的内容来激活该网络接口。\n注意：网络接口名称必须是/etc/sysconfig/network-scripts/目录配置文件中设置的才可以。如果使用ifconfig命令改变了网络接口后，ifup命令就不会识别了。因为ifup命令会对比当前网络的参数与/etc/sysconfig/network-scripts/中配置文件的内容是否相符。\n1用法：ifup &lt;设备名&gt;\n4.ifdownifdown命令用于禁用指定的网络接口。该命令会去读取/etc/sysconfig/network-scripts/目录下的相关网络接口的配置文件，并根据配置文件的内容来关闭该网络接口。\n注意：网络接口名称必须是/etc/sysconfig/network-scripts/目录配置文件中设置的才可以。如果使用ifconfig命令改变了网络接口后，ifdown命令就不会识别了。因为ifdown命令会对比当前网络的参数与/etc/sysconfig/network-scripts/中配置文件的内容是否相符。\n1格式：ifdown [网络接口]\n5.ifcfgifcfg命令是一个Bash脚本程序，用来设置Linux中的网络接口参数。\n1语法格式： ifcfg [参数]\n1234网络接口：指定要操作的网络接口add/del：添加或删除网络接口上的地址ip地址：指定IP地址和子网掩码stop：停用指定的网络接口的IP地址\n6.dhclientdhclient命令使用动态主机配置协议动态的配置网络接口的网络参数，也支持BOOTP协议。\n1dhclient [参数] [网络接口]\n12345678910-4 : 使用DHCPv4-6 : 使用DHCPv6-p\t指定dhcp客户端监听的端口号（默认端口号86）-d\t总是以前台方式运行程序-q\t安静模式，不打印任何错误的提示信息-r\t释放ip地址-n\t不配置任何接口-x\t停止正在运行的DHCP客户端，而不释放当前租约，杀死现有的dhclient-s\t在获取ip地址之前指定DHCP服务器-w\t即使没有找到广播接口，也继续运行\n7.ncnc是netcat的简写\nnc的作用\n（1）实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口\n（2）端口的扫描，nc可以作为client发起TCP或UDP连接\n（3）机器之间传输文件\n（4）机器之间网络测速\n1格式：nc [选项] [参数]\n1234567891011121314-g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个；-G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数；-h：在线帮助；-i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口；-l：使用监听模式，监控传入的资料；-n：直接使用ip地址，而不通过域名服务器；-o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存；-p&lt;通信端口&gt;：设置本地主机使用的通信端口；-r：指定源端口和目的端口都进行随机的选择；-s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址；-u：使用UDP传输协议；-v：显示指令执行过程；-w&lt;超时秒数&gt;：设置等待连线的时间；-z：使用0输入/输出模式，只在扫描通信端口时使用。\n8.nslookupnslookup命令是常用域名查询工具，就是查DNS信息用的命令。\nnslookup命令的英文全称为 “query Internet name server interactively ”。nslookup有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。\n进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。\n1格式：nslookup [参数] [域名]\n123456-sil\t不显示任何警告信息exit\t退出命令server\t指定解析域名的服务器地址set type=soa\t设置查询域名授权起始信息set type=a\t设置查询域名A记录set type=mx\t设置查询域名邮件交换记录\n9.hosthost命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。\nhost命令是一个用于执行DNS查找的简单实用程序。它通常用于将名称转换为IP地址，反之亦然。 如果没有给出参数或选项，host将打印其命令行参数和选项的简短摘要。\n1格式：host [选项] [参数]\n12345678910-a\t显示详细的DNS信息-c\t指定查询类型，默认值为“IN”-C\t查询指定主机的完整的SOA记录-r\t不使用递归的查询方式查询域名-t\t指定查询的域名信息类型-v\t显示指令执行的详细信息-w\t如果域名服务器没有给出应答信息，则总是等待，直到域名服务器给出应答-W\t指定域名查询的最长时间，如果在指定时间内域名服务器没有给出应答信息则退出-4\t使用IPv4查询传输 （默认）-6\t使用IPv6查询传输\n10.arparp命令用于操作主机的arp缓冲区，它可以显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的ip地址与MAC地址对应关系。\narp命令的英文全拼“Address Resolution Protocol” 。\n1格式：arp [选项] [参数]\n123456789-a\t显示arp缓存的所有条目，主机位可选参数-H\t指定arp指令使用的地址类型-d\t从arp缓存中删除指定主机的arp条目-D\t使用指定接口的硬件地址-e\t以linux的显示风格显示arp缓存中的条目-i\t指定要操作arp缓存的网络接口-n\t以数字方式显示arp缓存中的条目-v\t显示详细的arp缓存条目，包括缓存条目的统计信息-f\t设置主机的IP地址与MAC地址的静态映射\n11.netstatnetstat命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。\n从整体上看，netstat的输出结果可以分为两个部分：一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到；另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。\n1格式：netstat [选项] [参数]\n\n123456789101112131415161718192021222324-a或--all：显示所有连线中的Socket；-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；-c或--continuous：持续列出网络状态；-C或--cache：显示路由器配置的快取信息；-e或--extend：显示网络其他相关信息；-F或--fib：显示FIB；-g或--groups：显示多重广播功能群组组员名单；-h或--help：在线帮助；-i或--interfaces：显示网络界面信息表单；-l或--listening：显示监控中的服务器的Socket；-M或--masquerade：显示伪装的网络连线；-n或--numeric：直接使用ip地址，而不通过域名服务器；-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；-o或--timers：显示计时器；-p或--programs：显示正在使用Socket的程序识别码和程序名称；-r或--route：显示Routing Table；-s或--statistice：显示网络工作信息统计表；-t或--tcp：显示TCP传输协议的连线状况；-u或--udp：显示UDP传输协议的连线状况；-v或--verbose：显示指令执行过程；-V或--version：显示版本信息；-w或--raw：显示RAW传输协议的连线状况；-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同；--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。\n12.traceroutetraceroute命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是40字节。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。\ntraceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其ip地址。\n1格式：traceroute [选项] [参数]\n123456789101112131415-d\t使用Socket层级的排错功能-f&lt;存活数值&gt;\t设置第一个检测数据包的存活数值TTL的大小-F\t设置勿离断位-g&lt;网关&gt;\t设置来源路由网关，最多可设置8个-i&lt;网络界面&gt;\t使用指定的网络界面送出数据包-I\t使用ICMP回应取代UDP资料信息-m&lt;存活数值&gt;\t设置检测数据包的最大存活数值TTL的大小-n\t直接使用IP地址而非主机名称-p&lt;通信端口&gt;\t设置UDP传输协议的通信端口-r\t忽略普通的Routing Table，直接将数据包送到远端主机上-s&lt;来源地址&gt;\t设置本地主机送出数据包的IP地址-t&lt;服务类型&gt;\t设置检测数据包的TOS数值-v\t详细显示指令的执行过程-w\t设置等待远端主机回报的时间-x\t开启或关闭数据包的正确性检验\n13.tracepathtracepath命令用来追踪并显示报文到达目的主机所经过的路由信息，能够发现路由中的MTU值。tracepath使用套接字API来实现其所有功能，不需要root权限。\n1用法：tracepath [-n] [-b] [-l &lt;len&gt;] [-p port] &lt;destination&gt;\n12345-n\t只显示ip地址-b\t同时显示ip地址和主机名-l\t设置初始化的数据包长度，默认为65535-m\t设置最大TTL值，默认为30-p\t设置要使用的初始目标端口\n14.routeroute命令用来显示并设置linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。\n在linux系统中设置路由通常是为了解决以下问题：该linux系统在一个局域网中，局域网中有一个网关，能够让主机访问Internet，那么就需要将这台机器的ip地址设置为linux机器的默认路由。\n要注意的是：直接在命令行下执行route命令来添加路由，不会永久保存。当网卡重启或者机器重启之后，该路由就失效了。可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。\n1234route [-nNvee] [-FC] [&lt;AF&gt;]           List kernel routing tablesroute [-v] [-FC] &#123;add|del|flush&#125; ...  Modify routing table for AF.route &#123;-h|--help&#125; [&lt;AF&gt;]              Detailed usage syntax for specified AF.route &#123;-V|--version&#125;                  Display version/author and exit.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-v    选用细节操作模式-A family    用指定的地址族(如`inet&#x27;，`inet6&#x27;)。-n    以数字形式代替解释主机名形式来显示地址。此项对试图检测对域名服务器进行路由发生故障的原因非常有用。-e    用netstat(8)的格式来显示选路表。-ee将产生包括选路表所有参数在内的大量信息。-net    路由目标为网络。-host    路由目标为主机。-F    显示内核的FIB选路表。其格式可以用-e 和 -ee选项改变。-C    显示内核的路由缓存。del    删除一条路由。add    添加一条路由。target    指定目标网络或主机。可以用点分十进制形式的IP地址或主机/网络名。netmask Nm    为添加的路由指定网络掩码。gw Gw    为发往目标网络/主机的任何分组指定网关。注意：指定的网关首先必须是可达的。也就是说必须为该网关预先    指定一条静态路由。如果你为本地接口之一指定这个网关地址的话，那么此网关地址将用于决定此接口上的分组    将如何进行路由。这是BSD风格所兼容的。metric M    把选路表中的路由值字段(由选路进程使用)设为M。mss M    把基于此路由之上的连接的TCP最大报文段长度设为M字节。这通常只用于优化选路设置。默认值为536。window W    把基于此路由之上的连接的TCP窗口长度设为W字节。这通常只用于AX.25网络和不能处理背对背形式的帧的设    备。irtt I    把基于此路由之上的TCP连接的初始往返时间设为I毫秒(1-12000)。这通常也只用于AX.25网络。如果省略此    选项，则使用RFC1122的缺省值300ms。reject    设置一条阻塞路由以使一条路由查找失败。这用于在使用缺省路由前先屏蔽掉一些网络。但这并不起到防火墙的    作用。mod, dyn, reinstate    设置一条动态的或更改过的路由。这些标志通常只由选路进程来设置。这只用于诊断目的，dev If    强制使路由与指定的设备关联，因为否则内核会自己来试图检测相应的设备(通常检查已存在的路由和加入路由    的设备的规格)。在多数正常的网络上无需使用。    如果dev If是命令行上最后一个指定的选项，那么可以省略关键字dev，因为它是缺省值。否则路由修改对象    (metric - netmask- gw - dev)无关紧要。\n15.ssss是Socket Statistics的缩写。\nss命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。\n当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。\n天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。\n12ss [选项]ss [选项] [过滤]\n12345678910111213141516171819202122232425262728-h, --help\t帮助信息-V, --version\t程序版本信息-n, --numeric\t不解析服务名称-r, --resolve        解析主机名-a, --all\t显示所有套接字（sockets）-l, --listening\t显示监听状态的套接字（sockets）-o, --options        显示计时器信息-e, --extended       显示详细的套接字（sockets）信息-m, --memory         显示套接字（socket）的内存使用情况-p, --processes\t显示使用套接字（socket）的进程-i, --info\t显示 TCP内部信息-s, --summary\t显示套接字（socket）使用概况-4, --ipv4           仅显示IPv4的套接字（sockets）-6, --ipv6           仅显示IPv6的套接字（sockets）-0, --packet\t        显示 PACKET 套接字（socket）-t, --tcp\t仅显示 TCP套接字（sockets）-u, --udp\t仅显示 UCP套接字（sockets）-d, --dccp\t仅显示 DCCP套接字（sockets）-w, --raw\t仅显示 RAW套接字（sockets）-x, --unix\t仅显示 Unix套接字（sockets）-f, --family=FAMILY  显示 FAMILY类型的套接字（sockets），FAMILY可选，支持  unix, inet,   \tinet6, link, netlink-A, --query=QUERY, --socket=QUERY      QUERY := &#123;all|inet|tcp|udp|raw|unix|packet|netlink&#125;[,QUERY]-D, --diag=FILE     将原始TCP套接字（sockets）信息转储到文件-F, --filter=FILE   从文件中都去过滤器信息       FILTER := [ state TCP-STATE ] [ EXPRESSION ]\n16.sshssh命令是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器，实现对服务器的远程管理。\n1格式：ssh [选项] [参数]\n1234567891011121314151617181920-1\t强制使用ssh协议版本1-2\t强制使用ssh协议版本2-4\t强制使用IPv4地址-6\t强制使用IPv6地址-A\t开启认证代理连接转发功能-a\t关闭认证代理连接转发功能-b&lt;IP地址&gt;\t使用本机指定的地址作为对位连接的源IP地址-C\t请求压缩所有数据-F&lt;配置文件&gt;\t指定ssh指令的配置文件，默认的配置文件为“/etc/ssh/ssh_config”-f\t后台执行ssh指令-g\t允许远程主机连接本机的转发端口-i&lt;身份文件&gt;\t指定身份文件（即私钥文件）-l&lt;登录名&gt;\t指定连接远程服务器的登录用户名-N\t不执行远程指令-o&lt;选项&gt;\t指定配置选项-p&lt;端口&gt;\t指定远程服务器上的端口-q\t静默模式，所有的警告和诊断信息被禁止输出-X\t开启X11转发功能-x\t关闭X11转发功能-y\t开启信任X11转发功能\n17.sshdsshd命令是opensshd软件套件中的服务器守护进程。\nopenssh套件在不安全的网络中为两台为信任的主机之间建立加密的数据通信，是rlogin、rsh等明文传输数据的通信工具的替代品。sshd指令是openssh套件中的核心程序，其他的指令（如，sftp-server、slogin、scp）等都是基于sshd命令的。\n1格式: sshd [参数]\n12345678910111213-4\t强制使用IPv4地址-6\t强制使用IPv6地址-D\t以非后台守护进程的方式运行服务器-d\t调试模式-e\t将错误发送到标准错误设备，而不是将其发送到系统日志-f&lt;配置文件&gt;\t指定服务器的配置文件-g&lt;登录过期时间&gt;\t指定客户端登录的过期时间（默认时间为120秒），如果在此期限内，用户没有正确认证，则服务器断开此客户端的连接-h&lt;主机key文件&gt;\t指定读取主机key文件-i\tsshd以inetd方式运行-o&lt;选项&gt;\t指定sshd的配置选项-p&lt;端口&gt;\t指定使用的端口号-q\t静默模式，没有任何信息写入系统日志-t\t测试模式\n18.ssh-keygenssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。\n1234567891011121314151617语法     ssh-keygen [-q] [-b bits] -t type [-N new_passphrase] [-C comment] [-f output_keyfile]     ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]     ssh-keygen -i [-f input_keyfile]     ssh-keygen -e [-f input_keyfile]     ssh-keygen -y [-f input_keyfile]     ssh-keygen -c [-P passphrase] [-C comment] [-f keyfile]     ssh-keygen -l [-f input_keyfile]     ssh-keygen -B [-f input_keyfile]     ssh-keygen -D reader     ssh-keygen -F hostname [-f known_hosts_file]     ssh-keygen -H [-f known_hosts_file]     ssh-keygen -R hostname [-f known_hosts_file]     ssh-keygen -U reader [-f input_keyfile]     ssh-keygen -r hostname [-f input_keyfile] [-g]     ssh-keygen -G output_file [-v] [-b bits] [-M memory] [-S start_point]     ssh-keygen -T output_file -f input_file [-v] [-a num_trials] [-W generator]\n12345678910-b：指定密钥长度；-e：读取openssh的私钥或者公钥文件；-C：添加注释；-f：指定用来保存密钥的文件名；-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；-l：显示公钥文件的指纹数据；-N：提供一个新密语；-P：提供（旧）密语；-q：静默模式；-t：指定要创建的密钥类型。\n19.ipip命令用来显示或操纵linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。\n1格式：ip [参数] [选项]\n1234567-V：显示指令版本信息-s：输出更详细的信息-f：强制使用指定的协议族-4：指定使用的网络层协议是IPv4协议-6：指定使用的网络层协议是IPv6协议-0：输出信息每条记录输出一行，即使内容较多也不换行显示-r：显示主机时，不使用IP地址，而使用主机的域名\n20.tcpdumptcpdump命令是一款sniffer工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。\n1格式：tcpdump [选项] [参数]\n12345678910111213141516171819202122232425-a：尝试将网络和广播地址转换成名称-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出-e：在每列倾倒资料上显示连接层级的文件头-f：用数字显示网际网络地址-F&lt;表达文件&gt;：指定内含表达方式的文件-i&lt;网络界面&gt;：使用指定的网络截面送出数据包-l：使用标准输出列的缓冲区-n：不把主机的网络地址转换成名字-N：不列出域名-O：不将数据包编码最佳化-p：不让网络界面进入混杂模式-q ：快速输出，仅列出少数的传输协议信息-r&lt;数据包文件&gt;：从指定的文件读取数据包数据-s&lt;数据包大小&gt;：设置每个数据包的大小-S：用绝对而非相对数值列出TCP关联数-t：在每列倾倒资料上不显示时间戳记-tt： 在每列倾倒资料上显示未经格式化的时间戳记-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型-v：详细显示指令执行过程-vv：更详细显示指令执行过程-x：用十六进制字码列出数据包资料-w&lt;数据包文件&gt;：把数据包数据写入指定的文件\n21.scpscp 就是 secure copy ，是一个在 Linux 下用来进行 远程拷贝文件 的命令它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的\n12345678910# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo\n22.wgetwget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\nwget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。\n1用法： wget [选项]... [URL]...\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141长选项所必须的参数在使用短选项时也是必须的。启动：  -V,  --version           显示 Wget 的版本信息并退出。  -h,  --help              打印此帮助。  -b,  --background        启动后转入后台。  -e,  --execute=COMMAND   运行一个“.wgetrc”风格的命令。日志和输入文件：  -o,  --output-file=FILE    将日志信息写入 FILE。  -a,  --append-output=FILE  将信息添加至 FILE。  -d,  --debug               打印大量调试信息。  -q,  --quiet               安静模式 (无信息输出)。  -v,  --verbose             详尽的输出 (此为默认值)。  -nv, --no-verbose          关闭详尽输出，但不进入安静模式。  -i,  --input-file=FILE     下载本地或外部 FILE 中的 URLs。  -F,  --force-html          把输入文件当成 HTML 文件。  -B,  --base=URL            解析与 URL 相关的                             HTML 输入文件 (由 -i -F 选项指定)。       --config=FILE         Specify config file to use.下载：  -t,  --tries=NUMBER            设置重试次数为 NUMBER (0 代表无限制)。       --retry-connrefused       即使拒绝连接也是重试。  -O,  --output-document=FILE    将文档写入 FILE。  -nc, --no-clobber              skip downloads that would download to                                 existing files (overwriting them).  -c,  --continue                断点续传下载文件。       --progress=TYPE           选择进度条类型。  -N,  --timestamping            只获取比本地文件新的文件。  --no-use-server-timestamps     不用服务器上的时间戳来设置本地文件。  -S,  --server-response         打印服务器响应。       --spider                  不下载任何文件。  -T,  --timeout=SECONDS         将所有超时设为 SECONDS 秒。       --dns-timeout=SECS        设置 DNS 查寻超时为 SECS 秒。       --connect-timeout=SECS    设置连接超时为 SECS 秒。       --read-timeout=SECS       设置读取超时为 SECS 秒。  -w,  --wait=SECONDS            等待间隔为 SECONDS 秒。       --waitretry=SECONDS       在获取文件的重试期间等待 1..SECONDS 秒。       --random-wait             获取多个文件时，每次随机等待间隔                                 0.5*WAIT...1.5*WAIT 秒。       --no-proxy                禁止使用代理。  -Q,  --quota=NUMBER            设置获取配额为 NUMBER 字节。       --bind-address=ADDRESS    绑定至本地主机上的 ADDRESS (主机名或是 IP)。       --limit-rate=RATE         限制下载速率为 RATE。       --no-dns-cache            关闭 DNS 查寻缓存。       --restrict-file-names=OS  限定文件名中的字符为 OS 允许的字符。       --ignore-case             匹配文件/目录时忽略大小写。  -4,  --inet4-only              仅连接至 IPv4 地址。  -6,  --inet6-only              仅连接至 IPv6 地址。       --prefer-family=FAMILY    首先连接至指定协议的地址                                 FAMILY 为 IPv6，IPv4 或是 none。       --user=USER               将 ftp 和 http 的用户名均设置为 USER。       --password=PASS           将 ftp 和 http 的密码均设置为 PASS。       --ask-password            提示输入密码。       --no-iri                  关闭 IRI 支持。       --local-encoding=ENC      IRI (国际化资源标识符) 使用 ENC 作为本地编码。       --remote-encoding=ENC     使用 ENC 作为默认远程编码。       --unlink                  remove file before clobber.目录：  -nd, --no-directories           不创建目录。  -x,  --force-directories        强制创建目录。  -nH, --no-host-directories      不要创建主目录。       --protocol-directories     在目录中使用协议名称。  -P,  --directory-prefix=PREFIX  以 PREFIX/... 保存文件       --cut-dirs=NUMBER          忽略远程目录中 NUMBER 个目录层。HTTP 选项：       --http-user=USER        设置 http 用户名为 USER。       --http-password=PASS    设置 http 密码为 PASS。       --no-cache              不在服务器上缓存数据。       --default-page=NAME     改变默认页                               (默认页通常是“index.html”)。  -E,  --adjust-extension      以合适的扩展名保存 HTML/CSS 文档。       --ignore-length         忽略头部的‘Content-Length’区域。       --header=STRING         在头部插入 STRING。       --max-redirect          每页所允许的最大重定向。       --proxy-user=USER       使用 USER 作为代理用户名。       --proxy-password=PASS   使用 PASS 作为代理密码。       --referer=URL           在 HTTP 请求头包含‘Referer: URL’。       --save-headers          将 HTTP 头保存至文件。  -U,  --user-agent=AGENT      标识为 AGENT 而不是 Wget/VERSION。       --no-http-keep-alive    禁用 HTTP keep-alive (永久连接)。       --no-cookies            不使用 cookies。       --load-cookies=FILE     会话开始前从 FILE 中载入 cookies。       --save-cookies=FILE     会话结束后保存 cookies 至 FILE。       --keep-session-cookies  载入并保存会话 (非永久) cookies。       --post-data=STRING      使用 POST 方式；把 STRING 作为数据发送。       --post-file=FILE        使用 POST 方式；发送 FILE 内容。       --content-disposition   当选中本地文件名时                               允许 Content-Disposition 头部 (尚在实验)。       --auth-no-challenge     发送不含服务器询问的首次等待                               的基本 HTTP 验证信息。HTTPS (SSL/TLS) 选项：       --secure-protocol=PR     选择安全协议，可以是 auto、SSLv2、                                SSLv3 或是 TLSv1 中的一个。       --no-check-certificate   不要验证服务器的证书。       --certificate=FILE       客户端证书文件。       --certificate-type=TYPE  客户端证书类型，PEM 或 DER。       --private-key=FILE       私钥文件。       --private-key-type=TYPE  私钥文件类型，PEM 或 DER。       --ca-certificate=FILE    带有一组 CA 认证的文件。       --ca-directory=DIR       保存 CA 认证的哈希列表的目录。       --random-file=FILE       带有生成 SSL PRNG 的随机数据的文件。       --egd-file=FILE          用于命名带有随机数据的 EGD 套接字的文件。FTP 选项：       --ftp-user=USER         设置 ftp 用户名为 USER。       --ftp-password=PASS     设置 ftp 密码为 PASS。       --no-remove-listing     不要删除‘.listing’文件。       --no-glob               不在 FTP 文件名中使用通配符展开。       --no-passive-ftp        禁用“passive”传输模式。       --retr-symlinks         递归目录时，获取链接的文件 (而非目录)。递归下载：  -r,  --recursive          指定递归下载。  -l,  --level=NUMBER       最大递归深度 (inf 或 0 代表无限制，即全部下载)。       --delete-after       下载完成后删除本地文件。  -k,  --convert-links      让下载得到的 HTML 或 CSS 中的链接指向本地文件。  -K,  --backup-converted   在转换文件 X 前先将它备份为 X.orig。  -m,  --mirror             -N -r -l inf --no-remove-listing 的缩写形式。  -p,  --page-requisites    下载所有用于显示 HTML 页面的图片之类的元素。       --strict-comments    用严格方式 (SGML) 处理 HTML 注释。递归接受/拒绝：  -A,  --accept=LIST               逗号分隔的可接受的扩展名列表。  -R,  --reject=LIST               逗号分隔的要拒绝的扩展名列表。  -D,  --domains=LIST              逗号分隔的可接受的域列表。       --exclude-domains=LIST      逗号分隔的要拒绝的域列表。       --follow-ftp                跟踪 HTML 文档中的 FTP 链接。       --follow-tags=LIST          逗号分隔的跟踪的 HTML 标识列表。       --ignore-tags=LIST          逗号分隔的忽略的 HTML 标识列表。  -H,  --span-hosts                递归时转向外部主机。  -L,  --relative                  只跟踪有关系的链接。  -I,  --include-directories=LIST  允许目录的列表。  --trust-server-names             use the name specified by the redirection                                   url last component.  -X,  --exclude-directories=LIST  排除目录的列表。  -np, --no-parent                 不追溯至父目录。\n\n十六、内建命令1.typetype命令用来显示指定命令的类型，判断给出的命令是内建命令还是外部命令。\n1格式：type [选项] [参数]\n1234-a 显示一个名字的所有可能-t 判断一个名字当前是否是alias、keyword、function、builtin、file-p 查看一个外部命令的执行路径-P 查看内部命令路径\n命令类型：\n\nalias：别名。\nkeyword：关键字，Shell保留字。\nfunction：函数，Shell函数。\nbuiltin：内建命令，Shell内建命令。\nfile：文件，磁盘文件，外部命令。\nunfound：没有找到。\n\n2.envenv命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。该命令只使用”-“作为参数选项时，隐藏了选项”-i”的功能。若没有设置任何选项和参数时，则直接显示当前的环境变量。\n如果使用env命令在新环境中执行指令时，会因为没有定义环境变量”PATH”而提示错误信息”such file or directory”。此时，用户可以重新定义一个新的”PATH”或者使用绝对路径。\n1用法：env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n12345678910-i, --ignore-environment    不带环境变量启动 -u, --unset=NAME    从环境变量中删除一个变量 --help    显示帮助并退出 --version    输出版本信息并退出 单独的-隐含-i.如果没有COMMAND,那么打印结果环境变量. \n3.setset命令作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号”+“和”-“的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用declare命令以变量名=值的格式进行定义即可。\n1用法：set [选项] [参数]\n123456789101112131415161718-a\t标示已修改的变量，以供输出至环境变量-b\t使被中止的后台程序立刻回报执行状态-C\t转向所产生的文件无法覆盖已存在的文件-d\tShell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消-e\t若指令传回值不等于0，则立即退出shell-f\t取消使用通配符-h\t自动记录函数的所在位置-H \tShell可利用”!”加&lt;指令编号&gt;的方式来执行history中记录的指令-k\t指令所给的参数都会被视为此指令的环境变量-l\t记录for循环的变量名称-m\t使用监视模式-n\t只读取指令，而不实际执行-p\t启动优先顺序模式-P\t启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接-t\t执行完随后的指令，即退出shell-u\t当执行时使用到未定义过的变量，则显示错误信息-v\t显示shell所读取的输入值-x\t执行指令后，会先显示该指令及所下的参数\n4.unsetunset命令用于删除已定义的shell变量（包括环境变量）和shell函数。unset命令不能够删除具有只读属性的shell变量和只读属性的环境变量。\n1用法：unset [-f] [-v] [名称 ...]\n12-f\t将每个 NAME 名称当作函数对待-v\t将每个 NAME 名称当作变量对待\n5.echoecho命令用于在shell中打印shell变量的值，或者直接输出指定的字符串。linux的echo命令，在shell编程中极为常用, 在终端下打印变量value的时候也是常常用到的，因此有必要了解下echo的用法echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。\n1格式：echo[OPTION]... [STRING]...\n12345678910111213141516-n 不输出行尾的换行符.-e 允许对下面列出的加反斜线转义的字符进行解释.-E 禁止对在STRINGs中的那些序列进行解释.--help 显示帮助并退出(须单独运行)--version 输出版本信息并退出(须单独运行)\\NNN  字符的ASCII代码为NNN(八进制)\\\\    反斜线\\a    报警符(BEL)\\b    退格符\\c    禁止尾随的换行符\\f    换页符\\n    换行符\\r    回车符\\t    水平制表符\\v    纵向制表符\n6.aliasalias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号 ‘ ‘ 将原来的命令引起来，防止特殊字符导致错误。\nalias命令的作用只局限于该次登入的操作。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件 /etc/bashrc中。\n1用法:alias [-p] [名称[=值] ... ]\n1-p\t以可重用的格式打印所有的已定义的别名\n7.unaliasunalias命令用来取消命令别名，是为shell内建命令。如果需要取消任意一个命令别名，则使用该命令别名作为指令的参数选项即可。如果使用-a选项，则表示取消所有已经存在的命令别名。\n1用法:unalias [-a] 名称 [名称 ...]\n1-a\t删除所有的别名定义.\n8.enableenable命令可以用于启动或关闭 shell 的内建指令。 如要执行的文件名称与shell内建指令相同，可用enable -n来关闭shell内建指令。若不加-n参数，enable可重新启动关闭的指令。\n注意：\nlinux shell命令执行时，shell总是先在自己的shell builtin中查找该命令，如果找到则执行该命令；如果找不到该命令，则会从环境变量$PATH指定的路径中依次去查找待执行的命令。因为了解了这一点，所以看起来好像没有办法编写用户自己的命令来替代shell builtin命令。有了enable命令我们就能做到了。\n12用法：\tenable [-a] [-dnps] [-f 文件名] [名称 ...]\n123456789101112131415选项：      -a        打印一个内嵌的列表，并显示其中每一个是否启用      -n        禁用每一个 NAME 内嵌或者显示一个被禁用的内嵌的列表      -p        以可重用的格式打印一个内嵌的列表      -s        仅打印Posix `special&#x27;  内嵌的名称        控制动态加载的选项：      -f        从共享对象 FILENAME 文件中加载 NAME 内嵌      -d        删除以 -f 选项加载的内嵌        不带选项时，每一个 NAME 内嵌都被启用。        如果要使用 $PATH 中找到的 `test&#x27; 而不是 shell 内嵌的版本，    输入 `enable -n test&#x27;。   \n9.readread命令用于从标准输入读取数值。read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\nread命令一般用在shell脚本中。\n1用法：read [选项] [参数]\n123456789-a\t后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符– d\t后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志– p\t后面跟提示信息，即在输入前打印提示信息– e\t在输入的时候可以使用命令补全功能– n\t后跟一个数字，定义输入文本的长度– r\t屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了– s\t安静模式，在输入字符时不再屏幕上显示– t\t后面跟秒数，定义输入字符的等待时间– u\t后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的\n10.letlet命令是bash中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。\n1用法：let 参数 [参数 ...]\n1234567891011121314151617181920id++, id--      variable post-increment, post-decrement++id, --id      variable pre-increment, pre-decrement-, +            unary minus, plus!, ~            logical and bitwise negation**              exponentiation*, /, %         multiplication, division, remainder+, -            addition, subtraction&lt;&lt;, &gt;&gt;          left and right bitwise shifts&lt;=, &gt;=, &lt;, &gt;    comparison==, !=          equality, inequality&amp;               bitwise AND^               bitwise XOR|               bitwise OR&amp;&amp;              logical AND||              logical ORexpr ? expr : expr                conditional operator=, *=, /=, %=,+=, -=, &lt;&lt;=, &gt;&gt;=,&amp;=, ^=, |=      assignment\n11.fcfc命令自动调用vi编辑器修改已有历史命令，当保存时立即执行修改后的命令，也可以用来显示历史命令。fc命令编辑历史命令时，会自动调用vi编辑器。fc保存文件后，会自动执行所编辑过的命令。\n1用法：fc [选项] [参数]\n12345-e&lt;文本编辑器&gt;\t指定用来编辑命令的文本编辑器，默认是vi-l\t列出第一条和最后一天命令范围内的历史命令，如果不跟命令范围则默认显示最近使用过的16条历史命令-n\t显示历史命令时不显示命令序号-r\t反序显示所有历史命令-s&lt;命令名&gt;\t从历史命令中当前位置往前找到指定命令，并执行\n12.commandcommand命令调用指定的指令并执行，命令执行时不查询shell函数。command命令只能够执行shell内部的命令。\n1用法： command [-pVv] 命令 [参数 ...]\n123-p\t使用 PATH 变量的一个默认值以确保所有的标准工具都能被找到。-v\t打印 COMMAND 命令的描述，和 `type&#x27; 内嵌相似-V\t打印每个 COMMAND 命令的详细描述\n13.exitexit命令用来退出当前的shell或退出终端 ，并返回给定值。\n执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。状态值参数多用于脚本中，在终端状态下，直接输入“exit” 退出终端 。\n1用法：exit [状态值]\n14.execexec命令用于调用并执行指令的命令。exec命令通常用在shell脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。\n1用法:exec [-cl] [-a 名称] [命令 [参数 ...]] [重定向 ...]\n1234选项：-a 名称   作为第0个参数传递给 COMMAND 命令-c\t在一个空环境中执行 COMMAND 命令-l\t在COMMAND 命令的第0个参数中加一个短线\n15.logoutlogout指令退出一个登录 shell，其功能和login指令相互对应。\n123用法：logout [n]--help\t在线帮助--vesion\t显示版本信息\n16.loginlogin指令让用户登入系统，您亦可通过它的功能随时更换登入身份。在Slackware发行版中 ，您可在指令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当/etc目录里含名称为nologin的文件时，系统只root帐号登入系统，其他用户一律不准登入。\n1用法：login [ -p ] [ -h host ] [ -H ] [ -f username | username ]\n12-p：告诉login指令不销毁环境变量-h：指定远程服务器的主机名\n\n十七、Shell编程 Shell 指 “提供给使用者使用界面” 的软件，即 Command Interpreter - 命令解析器。Shell 接收用户或者其他应用程序的命令，然后将这些命令转化成内核能够理解的语言并传递给内核，内核执行命令完成后，再将执行结果返回给用户或者应用程序。\n Shell 是包裹在操作系统外层的一道程序，负责外界与 Linux “内核” 的交互，但它隐藏了操作系统底层的具体细节，就像是 Linux 内核的一个 “外壳”，所以 Shell（壳）的名称也由此而来。\n图形化界面也是一种广义的 Shell，因为图形界面操作的本质也是 —— 将用户的命令传递给内核执行\n终端 只是人机交互的一个接口，提供输入输出命令的交互界面。终端的主要任务是接收用户输入的命令，并提交给 Shell。\nShell 是命令解析器，主要任务是翻译命令。Shell 将终端输入的命令转化成内核能够理解的语言并传递给内核，由内核执行命令，并将执行结果返回给终端。\n当我们打开终端时，Shell 也会自动启动，操作系统会将终端和 Shell 关联起来。接着我们在终端输入命令，Shell 就负责解释命令。\n17.1shell脚本的执行123[root@localhost ~]$ vim test.sh#!/bin/bashecho &quot;hello world&quot;\n两种方式执行shell脚本\n第一种：给文件增加执行权限\n12[root@localhost ~]$ chmod u+x test.sh[root@localhost ~]$ ./test.sh  #绝对路径或相对路径执行\n第二种：通过Bash调用执行脚本\n1[root@localhost ~]$ bash test.sh\n第三种：.\n1[root@localhost ~]$ . test.sh\n17.2shell变量在一个脚本周期内,其值可以发生改变的量就是变量。\n\n局部变量：shell也有自定义函数，函数里面的变量为局部变量，但是它也是相当于全局变量，函数中的变量，在函数外调用也是可以的，如果要仅限函数使用，需要在函数变量前加个关键字：local\n全局变量：每打开一个终端就是一个shell会话，在这个shell会话（终端）定义的变量就是全局变量，它在这个shell会话有效，当你打开另一个终端就是另一个shell会话，这个变量在另一个终端就失效了。\n环境变量：在全局变量前加 export ，如：export a=1  那么这个变量就是环境变量了。创建这个变量的shell成为父shell，这个shell中，在创建一个shell叫做子shell，环境变量可以由父shell往下一级一级传，而不能逆转往上传递。当shell会话销毁时，这个环境变量也会随之销毁。想要永久保存就得环境变量写到启动文件中去。\n\n变量的命名规则\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n等号左右两侧不能有空格，可以使用下划线“_”，变量的值如果有空格，需要使用单引号或双引号包括。如:“test=“hello world!””。其中双引号括起来的内容“$”，“(”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。\n不能使用标点符号，不能使用bash里的关键字（可用help命令查看保留关键字）。\n环境变量建议大写，便于区分\n如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含”$变量名”或用${变量名}包含变量名。\n\n123456789[root@localhost ~]$ test=123[root@localhost ~]$ test=&quot;$test&quot;456[root@localhost ~]$ echo $test123456#叠加变量test，变量值变成了123456[root@localhost ~]$ test=$&#123;test&#125;789[root@localhost ~]$ echo $test123456789#再叠加变量test，变量值编程了123456789\nShell特殊符号\n\n用户自定义变量变量定义\n123456789[root@localhost ~]$ 2name=&quot;shen chao&quot;-bash: 2name=shen chao: command not found#变量名不能用数字开头[root@localhost ~]$ name = &quot;shenchao&quot;-bash: name: command not found#等号左右两侧不能有空格[root@localhost ~]$ name=shen chao-bash: chao: command not found#变量的值如果有空格，必须用引号包含\n 变量调用\n12345[root@localhost ~]$ name=&quot;shen chao&quot;#定义变量name[root@localhost ~]$ echo $name #调用变量使用  $变量名shen chao#输出变量name的值\n变量查看\n1[root@localhost ~]$ set [选项]\n选项:-u:如果设定此选项，调用未声明变量时会报错（默认无任何提示）-x:如果设定此选项，在命令执行之前，会把命令先输出一次+&lt;参数&gt; :取消某个set曾启动的参数。\n1234567891011121314151617[root@localhost ~]$ setBASH=/bin/bash…省略部分输出…name=&#x27;shen chao&#x27;#直接使用set 命令，会查询系统中所有的变量，包含用户自定义变量和环境变量[root@localhost ~]$ set -u[root@localhost ~]$ echo $file-bash: file: unbound variable#当设置了-u选项后，如果调用没有设定的变量会有报错。默认是没有任何输出的。[root@localhost ~]$ set -x[root@localhost ~]$ ls+ls --color=autoanaconda-ks.cfginstall.loginstall.log.syslog sh tdir testtestfile#如果设定了-x选项，会在每个命令执行之前，先把命令输出一次[root@localhost ~]$ set +x#取消启动的x参数\n变量删除\n1[root@localhost ~]$ unset 变量名\n环境变量环境变量设置\n12[root@localhost ~]$  export age=&quot;18&quot;#使用export声明的变量即是环境变量\n环境变量查询和删除env命令和set命令的区别：set命令可以查看所有变量，而env命令只能查看环境变量。\n12[root@localhost ~]$ unset gender   #删除环境变量gender[root@localhost ~]$ env | grep gender\n系统默认环境变量\n12345678910[root@localhost ~]$ envHOSTNAME=localhost.localdomain      #主机名SHELL=/bin/bash                     #当前的shellTERM=linux                          #终端环境HISTSIZE=1000                       #历史命令条数SSH_CLIENT=192.168.4.1594824 22     #当前操作环境是用ssh连接的，这里记录客户端ipSSH_TTY=/dev/pts/1                  #ssh连接的终端时pts/1USER=root                           #当前登录的用户..........更多参数可以使用set和env命令查看.............\n位置参数变量\n$1 是你给你写的shell脚本传的第一个参数，$2 是你给你写的shell脚本传的第二个参数…\n12345[root@localhost sh]$ vim test.sh#!/bin/shecho &quot;shell脚本本身的名字: $0&quot;echo &quot;传给shell的第一个参数: $1&quot;echo &quot;传给shell的第二个参数: $2&quot;\n保存退出后，你在Test.sh所在的目录下输入 bash Test.sh 1 2\n结果输出：\nshell脚本本身的名字: Test.sh传给shell的第一个参数: 1传给shell的第二个参数: 2\n$*会把接收的所有参数当成一个整体对待，而$@则会区分对待接收到的所有参数:\n123456789101112131415161718192021[root@localhost sh]$ vi parameter2.sh#!/bin/bashfor i in&quot;$*&quot;#定义for循环，in后面有几个值，for会循环多少次，注意“$*”要用双引号括起来#每次循环会把in后面的值赋予变量i#Shell把$*中的所有参数看成是一个整体，所以这个for循环只会循环一次\tdo\t\techo &quot;The parameters is: $i&quot;\t\t#打印变量$i的值\tdonex=1#定义变量x的值为1,用于跟踪参数的索引for y in&quot;$@&quot;#同样in后面的有几个值，for循环几次，每次都把值赋予变量y#可是Shel1中把“$@”中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次\tdo\t\techo &quot;The parameter$x is: $y&quot;\t\t#输出变量y的值\t\tx=$((x +1))\t\t#然变量x每次循环都加1，为了输出时看的更清楚\tdone\n预定义变量\n”$?”变量例子说明\n123456789101112[root@localhost sh]$ lscount.sh hello.sh parameter2.sh parameter.sh#ls命令正确执行[root@localhost sh]$ echo $?#预定义变量“$?”的值是0，证明上一个命令执行正确[root@localhost sh]$ ls install.logls:无法访问install.log:没有那个文件或目录#当前目录中没有install.log文件，所以ls命令报错了[root@localhost sh]$ echo $?2#变量“$?”返回一个非О的值，证明上一个命令没有正确执行#至于错误的返回值到底是多少，是在编写ls命令时定义好的，如果碰到文件不存在就返回数值2\n说明下”$$”和”$!”这两个预定义变量\n12345678910[root@localhost sh]$ vi variable.sh#!/bin/bashecho &quot;The current process is $$&quot;#输出当前进程的PID.#这个PID就是variable.sh这个脚本执行时，生成的进程的PIDfind /root -name hello.sh &amp;#使用find命令在root目录下查找hello.sh文件#符号&amp;的意思是把命令放入后台执行，工作管理我们在系统管理章节会详细介绍echo &quot;The last one Daemon process is $!&quot;#输出这个后台执行命令的进程的PID，也就是输出find命令的PID号\n只读变量1234567[root@localhost sh]$ vi readonly.sh#!/bin/basha=10#语法：readonly 变量名readonly aa=20   #会报错readonly variableecho $a\n接受键盘输入12345678910111213[root@localhost ~]$ read [选项][变量名]选项:\t-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。\t-p： “提示信息”：在等待read输入时，输出提示信息\t-t： 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间\t-n： 数字：read命令只接受指定的字符数，就会执行\t-s： 隐藏输入的数据，适用于机密信息的输入    -d： 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。    -e： 在输入的时候可以使用命令补全功能。变量名:变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY.如果只提供了一个变量名，则整个输入行赋予该变量.如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字\n123456789101112131415161718192021[root@localhost sh]$ vi read.sh#!/bin/bashread -t 30 -p &quot;Please input your name: &quot; name#提示“请输入姓名”并等待30 秒，把用户的输入保存入变量name 中echo &quot;Name is $name&quot;#看看变量“$name”中是否保存了你的输入read -s -t 30 -p &quot;Please enter your age: &quot; age#提示“请输入年龄”并等待30秒，把用户的输入保存入变量age中#年龄是隐私，所以我们用“-s”选项隐藏输入echo -e &quot;\\n&quot;#调整输出格式，如果不输出换行，一会的年龄输出不会换行echo &quot;Age is $age&quot;read -n 1 -t 30 -p &quot;Please select your gender[M/F]:&quot; gender#提示“请选择性别”并等待30秒，把用户的输入保存入变量gender#使用“-n1”选项只接收一个输入字符就会执行（都不用输入回车）echo -e &quot;\\n&quot;echo &quot;Sex is $gender&quot;\n17.3shell运算符算数运算符原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：\n1234567[root@localhost ~]$ vi computer.sh#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot;#注意#表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。#完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。\n\n加法 |expr $a + $b 结果为 30。\n\n减法 |expr $a - $b 结果为 -10。\n\n乘法 |expr $a * $b 结果为 200。\n除法 |expr $b / $a 结果为 2。\n取余 | expr $b % $a 结果为 0。\n赋值 | a=$b 将把变量 b 的值赋给 a。\n相等。用于比较两个数字，相同则返回 true（真）。| [ $a == $b ] 返回 false（假）。\n不相等。用于比较两个数字，不相同则返回 true。    |[ $a != $b ] 返回 true。\n\n注意：条件表达式要放在方括号之间，并且要有空格，必须写成 [ $a == $b ]。\n123456789101112131415161718[root@localhost ~]$ vi computers.sh#!/bin/basha=10b=20echo &#x27; &#x27;echo &#x27;a+b= &#x27; `expr $a + $b`echo &#x27;a-b= &#x27; `expr $a - $b`echo &#x27;a*b= &#x27; `expr $a \\* $b`echo &#x27;a/b= &#x27; `expr $a / $b`echo &#x27;a%b= &#x27; `expr $a % $b`#判断是否相等if [ $a == $b ]then\techo &#x27;a等于b&#x27;else\techo &#x27;a不等于b&#x27;fi\n关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\n\n注意括号前后空格\n123456[root@localhost ~]$ [ 10 -gt 10 ] [root@localhost ~]$ echo $?  1[root@localhost ~]$ [ 10 -eq 10 ] [root@localhost ~]$ echo $?  0\n如果要在shell脚本使用linux命令，可以使用$()包裹命令\n12345678910111213141516[root@localhost ~]$ vim demo.sh #!/bin/bash#接受用户的输入read -p &#x27;请输入需要查询的用户名:&#x27; username#获取指定用户名在passwd文件中出现的次数count=$(cat /etc/passwd | grep $username | wc -l)#count=`cat /etc/passwd | grep $username | wc -l`#判断出现的次数，如果次数=0则用户不存在，反之存在if [  $count == 0 ]then \t\techo &#x27;用户不存在&#x27;\telse \t\techo &#x27;用户存在&#x27;fi\n逻辑运算符常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\n\n字符串运算符常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：\n\n文件测试运算符（重点）文件测试运算符用于检测 Unix/Linux 文件的各种属性。\n\n17.4流程控制if条件判断单分支if条件语法：\n1234if [ 条件判断式 ]\tthen\t\t程序fi\n案例：统计根分区使用率\n123456789101112[root@localhost ~]$ vi sh/if1.sh#!/bin/bash#统计根分区使用率rate=$(df -h | grep &quot;/dev/sda2&quot; | awk &#x27;&#123;print $5&#125;’| cut -d &quot;%&quot;-f1)#把根分区使用率作为变量值赋予变量rateif [ $rate -ge 80 ]#判断rate的值如果大于等于80，则执行then程序\tthen\t\techo &quot;Warning!/dev/sda3 is fu11!!&quot;\t#打印警告信息。在实际工作中，也可以向管理员发送邮件。fi\n案例：创建目录\n12345678910[root@localhost ~]$ vi sh/add_dir.sh#!/bin/bash#创建目录，判断是否存在，存在就结束，反之创建echo &quot;当前脚本名称为$0&quot;DIR=&quot;/media/cdrom&quot;if [ ! -e $DIR ]then\tmkdir -p $DIRfiecho &quot;$DIR 创建成功&quot;\n双分支if条件语句语法：\n123456if [ 条件判断式 ]\tthen\t\t条件成立时，执行的程序\telse\t\t条件不成立时，执行的另一个程序fi\n案例1：备份mysql数据库\n12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost ~]$ vi sh/bakmysql.sh#!/bin/bash#备份mysql数据库。ntpdate asia.pool.ntp.org &amp;&gt;/dev/null#同步系统时间date=$(date +%y%m%d)#把当前系统时间按照“年月日”格式赋子变量datesize=$(du -sh/var/lib/mysql)#统计mysql数据库的大小，并把大小赋予size变量if [ -d /tmp/dbbak ]#判断备份目录是否存在，是否为目录\tthen\t#如果判断为真，执行以下脚本\techo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt\t#把当前日期写入临时文件\techo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt\t#把数据库大小写入临时文件\tcd/tmp/dbbak\t\t#进入备份目录\ttar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt; /dev/null\t#打包压缩数据库与临时文件，把所有输出丢入垃圾箱（不想看到任何输出）\trm -rf /tmp/dbbak/dbinfo.txt\t#删除临时文件else\tmkdir /tmp/dbbak\t#如果判断为假，则建立备份目录\techo &quot;Date : $date!&quot; &gt; /tmp/dbbak/dbinfo.txt\techo &quot;Data size : $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt\t#把日期和数据库大小保存如临时文件\tcd /tmp/dbbak\ttar -zcf mysql-lib-$date.tar. gz dbinfo.txt /var/lib/mysql &amp;&gt; /dev/null\t#压缩备份数据库与临时文件\trm -rf/tmp/dbbak/dbinfo.txt\t#删除临时文件fi\n案例2：判断apache是否启动，如果没有启动则自动启动\n123456789101112131415161718[root@localhost ~]$ vi sh/autostart.sh#!/bin/bash#判断apache是否启动，如果没有启动则自动启动port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;’)#使用nmap命令扫描服务器，并截取 apache服务的状态，赋予变量port#只要状态是open，就证明正常启动if [ &quot;$port&quot; == &quot;open&quot;]#如果变量port的值是“open”\tthen\techo &quot;$(date) httpd is ok!” &gt;&gt; /tmp/autostart-acc.log\t#则证明apache 正常启动，在正常日志中写入一句话即可else\t/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null\t#否则证明apache没有启动，自动启动apache\techo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.log\t#并在错误日志中记录自动启动apche 的时间fi\nnmap端口扫描命令，格式如下：\n123456789101112[root@localhost ~]$ nmap -sT 域名或IP选项:-s      扫描-T      扫描所有开启的TCP端口#知道了nmap命令的用法，我们在脚本中使用的命令就是为了截取http的状态，只要状态是“or.#就证明apache启动正常，否则证明apache启动错误。来看看脚本中命令的结果:[root@localhost ~]$ nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27; fprint $2&#125;’#扫描指定计算机，提取包含tcp 的行，在提取包含httpd 的行，截取第二列open#把截取的值赋予变量port\n多分支if条件语句\n语法：\n12345678910if [ 条件判断式1 ]\tthen\t\t当条件判断式1成立时，执行程序1elif [ 条件判断式2 ]\tthen\t\t当条件判断式2成立时，执行程序2…省略更多条件…else\t当所有条件都不成立时，最后执行此程序fi\n案例：判断用户输入的是什么文件\n12345678910111213141516171819202122232425262728293031323334[root@localhost ~]$ vi sh/if-elif.sh#!/bin/bash#判断用户输入的是什么文件read -p &quot;Please input a filename: &quot; file#接收键盘的输入，并赋予变量fileif [ -z &quot;$file” ]#判断file变量是否为空\tthen\t\techo &quot;Error, please input a filename&quot;\t\t#如果为空，执行程序1，也就是输出报错信息\t\texit 1\t\t#退出程序，并返回值为Ⅰ(把返回值赋予变量$P）elif [ ! -e &quot;$file” ]\t\t#判断file的值是否存在\t\tthen\t\techo &quot;Your input is not a file!&quot;\t\t#如1果不存在，则执行程序2\t\texit 2\t\t#退出程序，把并定义返回值为2elif [ -f &quot;$file” ]\t\t#判断file的值是否为普通文件\t\tthen\t\techo &quot;$file is a regulare file!”\t\t#如果是普通文件，则执行程序3elif [ -d &quot;$file” ]\t\t#到断file的值是否为目录文件\t\tthen\t\techo &quot;$file is a directory!&quot;\t\t#如果是目录文件，网执行程序4else\techo &quot;$file is an other file!”\t#如果以上判断都不是，则执行程序5fi\n多分支case条件语句case语句语法如下:\n123456789101112case $变量名 in\t&quot;值1&quot;)\t如果变量的值等于值1，则执行程序1\t;;\t&quot;值2&quot;)\t如果变量的值等于值2，则执行程序2\t::\t…省略其他分支…\t*)\t如果变量的值都不是以上的值，则执行此程序\t;;esac\n这个语句需要注意以下内容:\n\ncase语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行 “)” (代表所有其他值）中的程序。\ncase语句以“case”开头，以“esac”结尾。\n\n每一个分支程序之后要通过“;;”双分号结尾，代表该程序段结束(千万不要忘记，每次写case语句，都不要忘记双分号）。\n\n\n1234567891011121314151617181920案例：[root@localhost ~]$ vi sh/if-case.sh#!/bin/bashread -p &quot;请输入一个字符，并按Enter确认：&quot; KEYcase &quot;$KEY&quot; in\t[a-z]|[A-Z])\techo &quot;您输入的是字母&quot;\t;;\t\t[0-9])\techo &quot;您输入的是数字&quot;\t;;\t\t*)\techo &quot;您输入的是其他字符&quot;\t;;esac\nfor循环语法一:\n1234for 变量 in 值1 值2 值3 …(可以是一个文件等)\tdo\t\t程序\tdone\n这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。也就是说，假设in后面有三个值，for会循环三次，第一次循环会把值1赋予变量，第二次循环会把值2赋予变量，以此类推。\n语法一举例：打印时间\n12345678[root@localhost ~]$ vi sh/for.sh#!/bin/bash#打印时间for time in morning noon afternoon evening\tdo\t\techo &quot;This time is $time!&quot;\tdone\n语法一举例：批量解压缩脚本\n123456789101112131415161718[root@localhost ~]$ vi sh/auto-tar. sh#!/bin/bash#批量解压缩脚本cd/lamp#进入压缩包目录ls *.tar.gz &gt; ls.log#把所有.tar.gz结尾的文件的文件覆盖到ls.log 临时文件中for i in $(cat ls.log) `#或者这样写for i in `cat ls.log`#读取ls.log文件的内容，文件中有多少个值，就会循环多少次，每次循环把文件名赋予变量i\tdo\t\ttar -zxf $i &amp;&gt;/dev/null\t\t#加压缩，并把所有输出都丢弃\tdonerm -rf /lamp/ls.log#删除临时文件ls.log\n语法二:\n1234for (( 初始值;循环控制条件;变量变化 ))\tdo\t\t程序\tdone\n语法二中需要注意:初始值:在循环开始时，需要给某个变量赋予初始值，如i=1;\n循环控制条件:用于指定变量循环的次数，如i&lt;=100，则只要i的值小于等于100，循环就会继续;\n变量变化:每次循环之后，变量该如何变化，如i=i+1。代表每次循环之后，变量i的值都加1。\n语法二举例：从1加到100\n12345678910111213[root@localhost ~]$ vi sh/add. sh#!/bin/bash#从1加到100s=0for (( i=1;i&lt;=100;i=i+1 ))#定义循环100 次do\ts=$(( $s+$i ))\t#每次循环给变量s赋值\tdoneecho &quot;The sum of 1+2+...+100 is : $s&quot;#输出1加到100的和\n语法二举例：批量添加指定数量的用户\n123456789101112131415161718192021222324252627282930313233[root@localhost ~]$ vi useradd.sh#!/bin/bash#批量添加指定数量的用户read -p &quot;Please input user name: &quot; -t 30 name#让用户输入用户名，把输入保存入变量nameread -p &quot;Please input the number of users: &quot; -t 30 num#让用户输入添加用户的数量，把输入保存入变量numread -p &quot;Please input the password of users: &quot; -t 30 pass#让用户输入初始密码，把输入保存如变量passif [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot;-a ! -z &quot;$pass&quot;]#判断三个变量不为空theny=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)#定义变量的值为后续命令的结果#后续命令作用是，把变量num 的值替换为空。如果能替换为空，证明num 的值为数字#如果不能替换为空，证明num的值为非数字。我们使用这种方法判断变量num 的值为数字\tif [ -z &quot;$y&quot;]\t#如果变量y的值为空，证明num变量是数字\t\tthen\t\tfor (( i=1 ; i&lt;=$num; i=i+1 ))\t\t#循环num变量指定的次数\t\t\tdo\t\t\t/usr/sbin/useradd $name$i &amp;&gt;/dev/null\t\t\t#添加用户，用户名为变量name 的值加变量i的数字\t\t\techo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null\t\t\t#给用户设定初始密码为变量pass 的值\t\t\tdone\tfifi\n语法二举例：批量删除用户\n12345678910111213[root@localhost ~]$ vi sh/userdel.sh#!/bin/bash#批量删除用户user=$(cat /etc/passwd | grep &quot; /bin/bash&quot;|grep -v &quot;root&quot;Icut -d &quot;:&quot; -f 1)#读取用户信息文件，提取可以登录用户，取消root用户，截取第一列用户名for i in $user#循环，有多少个普通用户，循环多少次\tdo\t\tuserdel -r $i\t\t#每次循环，删除指定普通用户\tdone\nwhile循环语法：\n1234while [ 条件判断式 ]\tdo\t\t程序\tdone\n案例：1加到100\n123456789101112131415[root@localhost ~]$ vi sh/addnum.sh#!/bin/bash#从1加到100i=1s=0#给变量i和变量s赋值while [ $i -le 100 ]#如果变量i的值小于等于100，则执行循环\tdo\t\ts=$(( $s+$i ))\t\ti=$(( $i+1 ))\tdoneecho &quot;The sum is: $s&quot;\n案例：输入的数值进行比较判断\n12345678910111213141516171819202122[root@localhost ~]$ vi sh/addnum.sh#!/bin/bashPRICE=$(expr $RANDOM % 1000)TIMES=0echo &quot;商品的价格为0-999之间，猜猜看是多少？&quot;while truedo  read -p &quot;请输入您猜的价格：&quot; INTlet TIMES++\tif [ $INT -eq $PRICE ] ; then\t  echo &quot;恭喜您猜对了，实际价格是 $PRICE&quot;\t  echo &quot;您总共猜了 $TIMES 次&quot;\texit 0\telif [ $INT -gt $PRICE ] ; then\t  echo &quot;太高了&quot;\telse\t  echo &quot;太低了&quot;\tfidone\nuntil循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。\n语法:\n1234until [ 条件判断式 ]\tdo\t\t程序\tdone\n案例一：1加到100\n123456789101112131415[root@localhost ~]$ vi sh/until.sh#!/bin/bash#从1加到100i=1s=0#t给变量i和变量s赋值until [ $i -gt 100 ]#循环直到变量i的值大于100，就停止循环\tdo\t\ts=$(( $s+$i ))\t\ti=$(( $i+1 ))\tdoneecho &quot;The sum is: $s&quot;\n函数语法：\n123function 函数名 () &#123;\t程序&#125;\n案例：接收用户输入的数字，然后从1加到这个数字\n12345678910111213141516171819202122232425262728293031[root@localhost ~]$ vi sh/function.sh#!/bin/bash#接收用户输入的数字，然后从1加到这个数字function sum () &#123;\t#定义函数sum\ts=0\tfor (( i=0; i&lt;=$num;i=i+1 ))\t\t#循环直到i大于$1为止。$1是函数sum 的第一个参数\t\t#在函数中也可以使用位置参数变量，不过这里的$1指的是函数的第一个参数\t\tdo\t\t\ts=$(( $i+$s ))\t\tdone\techo &quot;The sum of 1+2+3...+$1 is :$s&quot;\t#输出1加到$1的和&#125;read -p &quot;Please input a number: &quot; -t 30 num#接收用户输入的数字，并把值赋予变量numy=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)#把变量num的值替换为空，并赋予变量yif [ -z &quot;$y&quot;]#判断变量y是否为空，以确定变量num中是否为数字\tthen\t\tsum $num\t\t#调用sum函数，并把变量num的值作为第一个参数传递给sum函数else\t\techo &quot;Error!! Please input a number!&quot;\t\t#如果变量num 的值不是数字，则输出报错信息fi\n特殊流程控制语句exit语句系统是有exit命令的，用于退出当前用户的登录状态。可是在Shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而直接退出脚本。\nexit的语法如下:\nexit [返回值]\n如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过查询$?这个变量，来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit 语句之前，最后执行的一条命令的返回值。写一个exit 的例子:\n12345678910111213[root@localhost ~]$ vi sh/exit.sh#!/bin/bash#演示exit的作用read -p &quot;Please input a number: &quot; -t 30 num#接收用户的输入，并把输入赋予变量numy=$ (echo $num | sed &#x27;s/[0-9]//g&#x27;)#如果变量num 的值是数字，则把num的值替换为空，否则不替换#把替换之后的值赋予变量y[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18#判断变量y的值如果不为空，输出报错信息，退出脚本，退出返回值为18echo &quot;The number is: $num&quot;#如果没有退出加班，则打印变量num中的数字\nbreak语句当程序执行到break语句时，会结束整个当前循环。而continue 语句也是结束循环的语句，不过continue 语句单次当前循环，而下次循环会继续。\n案例：\n12345678910111213141516[root@localhost ~]$ vi sh/break.sh#!/bin/bash#演示break 跳出循环for (( i=1;i&lt;=10; i=i+1 ))#循环十次\tdo\t\tif [&quot;$i&quot; -eq 4 ]\t\t#如果变量i的值等于4\t\t\tthen\t\t\tbreak\t\t\t#退出整个循环\t\tfi\techo $i\t#输出变量i的值\tdone\n1234执行下这个脚本，因为一旦变量i的值等于4，整个循环都会跳出，所以应该只能循环三次:[root@localhost ~]$ chmod 755 sh/break.sh[root@localhost ~]#sh/break.sh\ncontinue语句\ncontinue也是结束流程控制的语句。如果在循环中，continue语句只会结束单次当前循环。\n案例：\n12345678910111213141516[root@localhost ~]$ vi sh/break.sh#!/bin/bash#演示continuefor (( i=1;i&lt;=10;i=i+1 ))#循环十次\tdo\t\tif [&quot;$i&quot; -eq 4 ]\t\t#如果变量i的值等于4\t\t\tthen\t\t\tcontinue\t\t\t#退出换成continue\t\tfi\techo $i\t#输出变量i的值\tdone\n1234567891011121314执行下这个脚本:[root@localhost ~]$ chmod 755 sh/continue.sh[root@localhost ~]#sh/break.sh1235678910#少了4这个输出\n17.5字符截取、替换和处理命令正则表达式\n\n| 匹配之前的项1次或者多次 | sa-6+匹配sa-6、sa-666，不能匹配sa-\n| 匹配之前的项0次或者多次| co*l匹配cl、col、cool、coool等\n() | 匹配表达式，创建一个用于匹配的子串 | ma(tri)?匹配max或maxtrix\n{n} | 匹配之前的项n次，n是可以为0的正整数 |[0-9]{3}匹配任意一个三位数，可以扩展为[0-9][0-9][0-9]\n{n,}| 之前的项至少需要匹配n次 | [0-9]{2,}匹配任意一个两位数或更多位数不支持{n,}{n,}{n,}\n{n,m}| 指定之前的项至少匹配n次，最多匹配m次，n&lt;=m | [0-9]{2,5}匹配从两位数到五位数之间的任意一个数字\n|| 交替匹配|两边的任意一项 | ab(c|d)匹配abc或abd\n\n字符截取、替换命令cut 列提取命令\n12345678[root@localhost ~]$ cut [选项] 文件名选项:-f 列号: 提取第几列-d 分隔符: 按照指定分隔符分割列-n\t取消分割多字节字符-c 字符范围: 不依赖分隔符来区分列，而是通过字符范围（行首为0）来进行字段提取。“n-”表示从第n个字符到行尾;“n-m”从第n个字符到第m个字符;“一m”表示从第1个字符到第m个字符。--complement\t补足被选择的字节、字符或字段--out-delimiter\t指定输出内容是的字段分割符\ncut命令的默认分隔符是制表符，也就是“tab”键，对空格符不怎么支持。\n12345[root@localhost ~]$ vi student.txtid\tname\tgender\tmark1\tliming\tm\t\t862\tsc\t\tm\t\t673\ttg\t\tn\t\t90\n12[root@localhost ~]$ cut -f 2 student.txt#提取第二列内容\n那如果想要提取多列呢?只要列号直接用“，”分开，命令如下:\n1[root@localhost ~]$ cut -f 2,3 student.txt\ncut可以按照字符进行提取，需要注意“8-”代表的是提取所有行的第十个字符开始到行尾，而“10-20”代表提取所有行的第十个字符到第二十个字符，而“-8”代表提取所有行从行首到第八个字符:\n12[root@localhost ~]$ cut -c 8- student.txt#提取第八个字符开始到行尾，很乱，那是因为每行的字符个数不相等啊\n12[root@localhost ~]$ cut -d &quot;:&quot; -f 1,3 /etc/passwd#以“:”作为分隔符，提取/etc/passwd_文件的第一列和第三列\n如果我想用cut命令截取df命令的第一列和第三列，就会出现这样的情况:\n123456[root@localhost~]$ df -h | cut -d &quot; &quot; -f 1,3Filesystem /dev/sda2 tmpfs /dev/sda1\nawk 编程AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。\nprintf 格式化输出1234567891011121314151617[root@localhost ~]$ printf ‘输出类型输出格式’ 输出内容输出类型:%c:     ASCII字符.显示相对应参数的第一个字符%-ns:   输出字符串，减号“-”表示左对齐(默认右对齐)，n是数字指代输出几个字符,几个参数就写几个%-ns%-ni:   输出整数，n是数字指代输出几个数字%f：    输出小数点右边的位数%m.nf:  输出浮点数，m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。输出格式:\\a: 输出警告声音\\b: 输出退格键，也就是Backspace键\\f: 清除屏幕\\n: 换行\\r: 回车，也就是Enter键\\t: 水平输出退格键，也就是Tab 键\\v: 垂直输出退格键，也就是Tab 键\n为了演示printf命令，需要修改下刚刚cut命令使用的student.txt文件，文件内容如下:\n12345678910111213[root@localhost ~]$ vi student.txtID      Name    php  \t Linux  \tMySQL \t  Average1       AAA      66         66       66           662       BBB      77         77       77           773       CCC      88         88       88           88#printf格式输出文件[root@localhost ~]$ printf &#x27;%s\\t %s\\t %s\\t %s\\t %s\\t %s\\t \\n’ $(cat student.txt)#%s分别对应后面的参数,6列就写6个ID      Name    php   Linux  MySQL   Average1       AAA      66         66       66           662       BBB      77         77       77           773       CCC      88         88       88           88\n如果不想把成绩当成字符串输出，而是按照整型和浮点型输出，则要这样:\n123[root@localhost ~]$ printf &#x27;%i\\t %s\\t %i\\t %i\\t %i\\t %8.2f\\t \\n’ \\ $(cat student.txt | grep -v Name)\nawk 基本使用123456789101112131415161718[root@localhost ~]$ awk‘条件1&#123;动作1&#125; 条件2&#123;动作2&#125;…’ 文件名条件（Pattern）:\t一般使用关系表达式作为条件。这些关系表达式非常多，例如:\tx &gt; 10  判断变量x是否大于10\tx == y  判断变量x是否等于变量y\tA ~ B   判断字符串A中是否包含能匹配B表达式的子字符串\tA !~ B  判断字符串A中是否不包含能匹配B表达式的子字符串\t动作（Action） :\t格式化输出\t流程控制语句常用参数：   -F\t指定输入时用到的字段分隔符   -v\t自定义变量   -f\t从脚本中读取awk命令   -m\t对val值设置内在限制\n我们这里先来学习awk基本用法，也就是只看看格式化输出动作是干什么的。\n12[root@localhost ~]$ awk &#x27;&#123;printf $2 &quot;\\t&quot; $6 &quot;\\n&quot;&#125;’ student.txt#输出第二列和第六列\n比如刚刚截取df命令的结果时，cut命令已经力不从心了，我们来看看awk命令:\n12[root@localhost ~]$ df -h | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27;#截取df命令的第一列和第三列\nawk 的条件\nBEGIN\nBEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在 awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。\n例如:\n12345[root@localhost ~]$ awk &#x27;BEGIN&#123;printf &quot;This is a transcript \\n&quot; &#125; &#123;printf $2 &quot;\\t&quot; $6 &quot;\\n&quot;&#125;’ student.txt#awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入“|”,就是一行命令#这里定义了两个动作#第一个动作使用BEGIN条件，所以会在读入文件数据前打印“这是一张成绩单”(只会执行一次)#第二个动作会打印文件的第二字段和第六字段\nEND\nEND也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如:\n12[root@localhost ~]$ awk &#x27;END&#123;printf &quot;The End \\n&quot;&#125; &#123;printf $2 &quot;\\t&quot; $6 &quot;\\n&quot;&#125;’ student.txt#在输出结尾输入“The End”，这并不是文档本身的内容，而且只会执行一次\n关系运算符举几个例子看看关系运算符。假设我想看看平均成绩大于等于87分的学员是谁，就可以这样输入命令:例子1:\n123[root@localhost ~]$ cat student.txt | grep -v Name | awk &#x27;$6 &gt;= 87 &#123;printf $2 &quot;\\n&quot;&#125;&#x27;#使用cat输出文件内容，用grep取反包含“Name”的行#判断第六字段（平均成绩）大于等于87分的行，如果判断式成立，则打第六列（学员名$2）\n加入了条件之后，只有条件成立动作才会执行，如果条件不满足，则动作则不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的:\n1）如果有BEGIN条件，则先执行BEGIN定义的动作。2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。4）读入下一行数据，重复执行以上步骤。\n再举个例子，如果我想看看Sc用户的平均成绩呢:\n例子2:\n123[root@localhost ~]$ awk &#x27;$2 ~ /AAA/ &#123;printf $6 &quot;\\n&quot;&#125;&#x27; student.txt#如果第二字段中输入包含有“Sc”字符，则打印第六字段数据85.66\n这里要注意在awk中，使用“//”包含的字符串，awk命令才会查找。也就是说字符串必须用“//”包含，awk命令才能正确识别。\n正则表达式\n如果要想让awk 识别字符串，必须使用“//”包含，例如:例子1:\n12[root@localhost ~]$ awk &#x27;/Liming/ &#123;print&#125;’student.txt#打印Liming的成绩\n当使用df命令查看分区使用情况是，如果我只想查看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以:\n例子2:\n12[root@localhost ~]$ df -h | awk &#x27;/sda[O-9]/ &#123;printf $1 &quot;\\t&quot; $5 &quot;\\n&quot;&#125;’#查询包含有sda数字的行，并打印第一字段和第五字段\nawk 内置变量\nawk常用统计实例1、打印文件的第一列(域) ： awk ‘{print $1}’ filename\n2、打印文件的前两列(域) ： awk ‘{print $1,$2}’ filename\n3、打印完第一列，然后打印第二列 ：awk ‘{print $1 $2}’ filename\n4、打印文本文件的总行数 ：awk ‘END{print NR}’ filename\n5、打印文本第一行 ：awk ‘NR==1{print}’ filename\n6、打印文本第二行第一列 ：sed -n “2, 1p” filename | awk ‘print $1’\n\n获取第一列ps -aux | grep watchdog | awk ‘{print $1}’\n\n获取第一列，第二列，第三列ps -aux | grep watchdog | awk ‘{print $1, $2, $3}’\n\n获取第一行的第一列，第二列，第三列ps -aux | grep watchdog | awk ‘NR==1{print $1, $2, $3}’\n\n获取行数NRdf -h | awk ‘END{print NR}’\n\n获取列数NF（这里是获取最后一行的列数，注意每行的列数可能是不同的）ps -aux | grep watchdog | awk ‘END{print NF}’\n\n获取最后一列ps -aux | grep watchdog | awk ‘{print $NF}’\n\n对文件进行操作awk ‘{print $1}’ fileName\n\n指定分隔符（这里以:分割）ps -aux | grep watchdog |awk  -F’:’ ‘{print $1}’\n\n超出范围不报错ps -aux | grep watchdog | awk ‘{print $100}’\n\n\n12[root@localhost ~]$ cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;&#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\\t&quot; $3 &quot;\\n&quot;&#125;’#查询可以登录的用户的用户名和UID\n这里“:”分隔符生效了，可是第一行却没有起作用，忘记了“BEGIN”条件，那么再来试试;\n1[root@localhost ~]$ cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\\t&quot; $3 &quot;\\n&quot;&#125;’\n12345[root@localhost ~]$ cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\\t&quot; $3 &quot;\\t 行号:” NR &quot;\\t 字段数:&quot; NF &quot;\\n&quot;&#125;’#解释下awk命令#开始执行&#123;分隔符是“:”&#125;&#123;输出第一字段和第三字段输出行号(NR值）字段数(NF值）&#125;root     0      行号:1       字段数:7user1   501     行号:2       字段数:7\n如果我只想看看sshd这个伪用户的相关信息，则可以这样使用:\n12[root@localhost ~]$ cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\\t&quot; $3 &quot;\\t 行号:&quot; NR &quot;\\t 字段数:&quot; NF &quot;\\n&quot;&#125;’#可以看到sshd 伪用户的UID是74，是/etc/passwd_文件的第28行，此行有7个字段\nawk 流程控制我们再来利用下student.txt文件做个练习，后面的使用比较复杂，我们再看看这个文件的内容:\n12345[root@localhost ~]$ cat student.txtID      Name    php   Linux  MySQL   Average1       AAA      66         66       66           662       BBB      77         77       77           773       CCC      88         88       88           88\n我们先来看看该如何在awk中定义变量与调用变量的值。假设我想统计PHP成绩的总分，那么就应该这样:\n1234[root@localhost ~]$ awk &#x27;NR==2 &#123;php1=$3&#125;NR==3 &#123;php2=$3&#125;NR==4 &#123;php3=$3;totle=phpl+php2+php3;print &quot;totle php is &quot; totle&#125;’ student.txt#统计PHIP成绩的总分\n我们解释下这个命令。“NR==2 {iphp1=$3}” (条件是NR==2，动作是php1=$3） 这句话是指如果输入数据是第二行（第一行是标题行），就把第二行的第三字段的值赋予变量“php1”。“NR==3 {php2=$3}” 这句话是指如果输入数据是第三行,就把第三行的第三字段的值赋予变量“php2”。“NR==4 {php3=$3;totle=phpl+php2+php3;print “totle php is “ totle}”（“NR==4”是条件，后面(中的都是动作)这句话是指如果输入数据是第四行﹐就把第四行的第三字段的值赋予变量”php3”;然后定义变量totle的值是“php1+php2+php3”;然后输出“totle php is”关键字，后面加变量totle的值。\n在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容:\n\n多个条件 {动作} 可以用空格分割，也可以用回车分割。\n\n在一个动作中，如果需要执行多个命令，需要用 “;” 分割，或用回车分割。\n\n在awk中，变量的赋值与调用都不需要加入“$”符。\n\n条件中判断两个值是否相同，请使用 “==”，以便和变量赋值进行区分。\n\n\n在看看该如何实现流程控制，假设如果Linux成绩大于90，就是一个好男人(学PHP的表示压力很大!) :\n1234[root@localhost ~]$ awk &#x27;&#123;if (NR&gt;=2) &#123;if ($4&gt;60) printf $2 &quot;is a good man!\\n&quot;&#125;&#125;’ student.txt#程序中有两个if判断，第一个判断行号大于2，第二个判断Linux成绩大于90分Liming is a good man !Sc is a good man !\n其实在 awk中 if判断语句，完全可以直接利用awk自带的条件来取代，刚刚的脚本可以改写成这样:\n123456[root@localhost ~]$  awk ’NR&gt;=2 &#123;test=$4&#125;test&gt;90 &#123;printf $2 &quot;is a good man! \\n&quot;&#125;’ student.txt#先判断行号如果大于2，就把第四字段赋予变量test#在判断如果test的值大于90分，就打印好男人Liming is a good man!Sc is a good man!\nawk 函数awk编程也允许在编程时使用函数，我们讲讲awk的自定义函数。awk函数的定义方法如下:\n123function 函数名（参数列表）&#123;\t函数体&#125;\n我们定义一个简单的函数，使用函数来打印student.txt的学员姓名和平均成绩，应该这样来写函数：\n12345678[root@localhost ~]$ awk &#x27;function test(a,b) &#123; printf a &quot;\\t&quot; b &quot;\\n&quot;&#125;#定义函数test，包含两个参数，函数体的内容是输出这两个参数的值&#123; test($2,$6) &#125; &#x27; student.txt#调用函数test，并向两个参数传递值。Name    AverageAAA      87.66BBB      85.66CCC      91.66\nawk 中调用脚本对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。例如，我们可以先编写一个awk脚本:\n123[root@localhost ~]$ vi pass.awkBEGIN &#123;FS=&quot;:&quot;&#125;&#123; print $1 &quot;\\t&quot;  $3&#125;\n然后可以使用“一f”选项来调用这个脚本:\n12345[root@localhost ~]$ awk -f pass.awk /etc/passwdrootobin1daemon2…省略部分输出…\n参考原文链接：\n【Linux】一步一步学Linux系列教程汇总（更新中……）_一步一步学linux 极客学院-CSDN博客\n","slug":"Linux操作系统","date":"2024-07-01T00:00:00.000Z","categories_index":"技术栈","tags_index":"","author_index":"Gueason"},{"id":"c346e5cb761ad8572ad1cf2d93ff167b","title":"服务器基础知识（搬运）","content":"一、服务器概述1.1概念服务器是计算机的一种，是网络中为客户端计算机提供各种服务的高性能的计算机；\n服务器在网络操作系统的控制下，将与其相连的硬盘、磁带、打印机及昂贵的专用通讯设备提供给网络上的客户站点共享，在网络中为其它客户机（如PC机、智能手机、ATM等终端）提供集中计算、信息发布及数据管理或者应用设备。 服务器具有高速的CPU运算能力、长时间的可靠运行、强大的I/O外部数据吞吐能力以及更好的扩展性。\n（1）服务器硬件：是指在互联网上具有独立IP地址的计算机，比如我们自己用的计算机也可以作为服务器使用。\n（2）服务器软件：就是一个计算机程序。比如Mysql服务器软件，tomcat服务器软件。服务器软件分为很多类型，比如：ftp服务器，数据库服务器，web服务器软件，邮件服务器等。\n1.2作用\n通俗的说，服务器主要是用来响应终端的服务请求，并进行处理。\n我们在上网的时候是不可能直接将网络接入互联网的，我们都需要通过服务器来连接网络，只有服务器响应你的联网请求，并且进行处理以后才可以联网\n存储的功能，服务器的存储空间一般比较充足，可以存储非常多的信息。\n\n1.3分类按物理形态 ECS服务器云服务器(Elastic Compute Service)，通常用户可以根据自己的需要选定主机容量、CPU能力、内存大小、带宽及购买时长等，因此也称之为弹性计算服务器。\nECS在使用上和独立的服务器没有区别，且可以让企业节省自行购买和维护服务器硬件的成本，ECS已被中小企业广泛使用。\nVPS服务器虚拟专用服务器（Virtual Private Server),即将一台独立服务器通过虚拟技术分割为若干个虚拟服务器，每个VPS可以独立安装系统，拥有独立的IP，实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。\nVPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器，形式上和ECS没有区别，但总体性能和付费灵活性不如ECS。\n虚拟主机即将一台已安装操作系统和安全防范的服务器通过技术手段分割为若干个独立的空间，分配给用户独立使用，用户只需要上传网站程序，解析和绑定域名即可使用。\n虚拟主机不同于服务器，用户无法安装操作系统和操作软件，只能运行网站脚本语言、html文件、图片及其他静态文件等。\n虚拟主机相当于若干个用户一起租用一台服务器，价格实惠，简单易用，因此大多数企业网站选择了虚拟主机，而自助建站及云建站使用的也是虚拟主机。\n按物理位置国内主机\n国外主机（美国、德国等地区的主机)\n区别：\n备案方面\n国内主机必须备案，国外主机不需要提交备案资料的。\n访问速度\n国内主机国内访问快，海外主机海外访问快。\n线路\n国内主机有线路限制，海外主机没有，国内主机线路以联通和电信为主，相同的线路访问不存在速度限制，但相互访问就有点问题\n按处理器架构分类1）X86架构服务器（CISC架构服务器） \nIA-32、x86-32、x86-64都属于x86，即英特尔的32位x86架构，x86-64是AMD在其最新的Athlon 64处理器系列中采用的新架构，但这一处理器基础架构还是IA-32（因英特尔的x86架构并未申请专利保护，所以绝大多数处理器厂商为了保持与Intel的主流处理器兼容，都不得不采用这一x86架构），只是在此架构基础之上作了一些扩展，以支持64位程序的应用，进一步提高处理器的运算性能。\n2）RISC架构服务器\nRISC的英文全称为“Reduced Instruction Set Computing”（减少的指令集计算），中文即“精简指令集”，它的指令系统相对简单，它只要求硬件执行很有限且最常用的那部分执令，大部分复杂的操作则使用成熟的编译技术，由简单指令合成。目前在中高档服务器中普遍采用这一指令系统的CPU，特别是高档服务器全都采用RISC指令系统的CPU，并且此类服务器都采用UNIX操作系统。在中高档服务器中采用RISC指令的CPU主要有Compaq（康柏，即新惠普）公司的Alpha、HP公司的PA-RISC、IBM公司的Power PC、SGI公司的MIPS、SUN公司的Sparc、华为基于ARM架构级研发的鲲鹏920。\n3）IA-64\nEPIC（Explicitly Parallel InstructionComputers，精确并行指令计算机）。Intel采用EPIC技术的服务器CPU是安腾Itanium。它是64位处理器，也是IA-64系列中的第一款。在Intel采用了X86指令集之后，它又转而寻求更先进的64-bit微处理器，Intel这样做的原因是，它们想摆脱容量巨大的x86架构，从而引入精力充沛而又功能强大的指令集，于是采用EPIC指令集的IA-64架构便诞生了。IA-64在很多方面来说，都比x86有了长足的进步。突破了传统IA32架构的许多限制，在数据的处理能力，系统的稳定性、安全性、可用性、可观理性等方面获得了突破性的提高。IA-64微处理器最大的缺陷是它们缺乏与x86的兼容。\n\n按功能应用分类域控制服务器（Domain Server）\n文件服务器（File Server）\n打印服务器（Print Server）\n数据库服务器（Database Server）\n邮件服务器（E-mail Server）\nWeb服务器（Web Server）\n多媒体服务器（MultimediaServer）\n通讯服务器（Communication Server）\n终端服务器（Terminal Server）\n基础架构服务器（Infrastructure Server）\n虚拟化服务器（Virtualization Server）\n目前的技术来说，这些功能划分为逻辑形态。可以把多个功能把多个功能部署在一台服务器上面。从物理形态上来说，可以是一台服务器完成多个功能。\n按产品形态分类1U服务器、2U服务器、4U服务器\n服务器规定的尺寸是服务器的宽（48.26cm=19英寸）与高（4.445cm的倍数），厚度（高度））以4.445cm为基本单位。\n在机架式服务器尺寸当中，常见的就是1U服务器、2U服务器、4U服务器，这些服务器的尺寸是：1U=4.445厘米，2U=4.4452=8.89厘米，4U=4.4454=17.78 厘米。在实际使用当中，1U或者2U服务器是最经常使用的。因为服务商是根据服务器占用空间来计算费用的，所以采用1U服务器是最节省空间的和价格最低的，但是1U服务器的扩展性不如2U服务器的好。1U的硬盘数最多可以插4个，2U可以插8个，另外PCI的插槽数目也不同，1U最多2个，2U的可以到6个。\n标准机柜的结构比较简单，主要包括基本框架、内部支撑系统、布线系统、通风系统。19寸标准机柜外型有宽度、高度、深度三个常规指标。\n塔式服务器\n塔式服务器是最基本的服务器类型，通常被误认为台式计算机的传统CPU。在外部，塔式服务器的外观和感觉非常类似于传统的塔式PC。这些服务器旨在提供基本的性能水平，因此即使在价格方面也处于较低端。但是，当前有许多塔式服务器，它们成本很高，并且可以处理大量和多项任务。\n塔式服务器会占用大量要安装和使用的物理空间。由于它们体积大（大多数情况下），因此对其进行物理管理变得困难。而且，由于尺寸的原因，很难将它们堆叠在一起或将它们从一个地方重新布置到另一个地方。\n每个塔式服务器都占用大量办公空间，并且还需要一个单独的KVM（键盘，视频和鼠标，keyboard，Video，Mouse）开关才能进行管理。\n\n机架服务器\n机架服务器比塔式服务器小，安装在机架内部。这些机架与普通机架类似，我们使用它们来堆叠一组文件和文件夹。通过将服务器与其他设备（例如存储单元，冷却系统，SAN设备，网络外围设备和电池）垂直堆叠在一起，可以将机架服务器设计为位于机架中。\n用于安装这些机架服务器的机架符合IEEE标准，通常以机架单位或“ U”进行测量。每个U宽约19英寸，高约1.5-1.75英寸。使用这些机架的优点是它允许用户将其他电子设备与服务器一起堆叠。单个机架可以包含多个服务器以及上述其他设备。因此，与塔式服务器相比，这些机架式服务器使用起来非常方便，并且占用的空间更少。\n\n优点\n\n故障抑制：在机架式服务器中，只需花费很少的精力就可以识别，卸下和更换故障服务器。\n简化的电缆管理：机架中的管理工具可轻松有效地组织电缆。\n经济高效：它们以相对较低的成本提供了大量的计算能力和效率。\n\n缺点\n功耗：机架服务器由于总体组件密度高而常常需要具有附加的冷却系统，从而消耗更多的功率。\n维护：由于将多个设备一起放置在机架中，因此随着机架数量的增加，维护它们变得非常困难。\n刀片服务器\n刀片服务器是市场上最新，最先进的服务器。它们可以称为混合机架服务器，其中服务器被放置在刀片机箱内，形成刀片系统。刀片服务器的最大优势在于，这些服务器是目前可用的最小类型的服务器，非常适合节省空间。\n\n二、服务器技术2.1核心数/线程数多内核是指在一枚处理器中集成两个或多个完整的计算引擎（内核）。多核处理器是单枚芯片（也称为“硅核”），能够直接插入单一的处理器插槽中，但操作系统会利用所有相关的资源，将它的每个执行内核作为分立的逻辑处理器。通过在两个执行内核之间划分任务，多核处理器可在特定的时钟周期内执行更多任务。\n多线程是指从软件或者硬件上实现多个线程并发执行的技术。线程是操作系统能够进行运算调度的最小单位；它被包含在进程之中，是进程中的实际运作单位。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。\n多核心技术需要系统和软件的支持。windows2000以后的系统提供了多核心的支持，而之前的win me和win98等则仅支持单核。现阶段大部分程序都只是不超过4核心的优化支持，超过4核后性能提升不明显。\n一般来说，线程数等于核心数。但Intel为了更充分的利用CPU资源，开发了超线程技术。\nHT超线程技术，也就是Hyper-Threading，是Intel早在2001年就提出的一种技术。尽管提高时钟频率和缓存容量可以改善CPU的性能，但是受到工艺和成本的限制，CPU无法无限的提升参数来提升性能，实际上在应用中基于很多原因，CPU的执行单元都没有被充分使用。\n为此，Intel则采用另一个思路去提高CPU的性能，让CPU可以同时执行多重线程，就能够让CPU发挥更大效率，即所谓“超线程（Hyper-Threading，简称“HT”）”技术。超线程技术就是利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。目前的多线程技术一般采用多个微处理器即多处理器结构，线程与处理器形成一一对应关系。而英特尔Hyper-Threading技术的特点是:\n（1）物理上用一个处理器处理多个线程\n（2）多线程的分配采用根据计数器的空闲状态进行线程处理的SMT（simultaneous multi-threading）方式。\nHT技术最早出现在2002年的Pentium4上，它是利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高CPU的运行效率。但是，由于这个设计太过超前，奔腾4并没有借助HT大放光彩，在之后的酷睿架构中，Intel也再没有使用这个技术。然而，基于Nehalem架构的Core i7再次引入超线程技术，使四核的Corei7可同时处理八个线程操作，大幅增强其多线程性能。\n现在的HT技术很成熟，超线程技术带来的效率提升可达30%之多。不过对于一般的程序来说，超线程带来的提升或许很小，尤其是超过了四线程之后。\n4个物理CPU的对称多处理器结构：\n\n4个物理CPU，8个逻辑CPU的超线程结构：\n\n4个CPU，8个核的多核结构:\n在一个CPU里面布置两个执行核，即两套执行单元，如ALU、FPU和L2缓存等。而其他部分则两个核共享。这样，由于使用的是一个CPU，其功耗和单CPU一样。由于布置了多个核，其指令级并行将是真正的并行，而不是超线程结构的半并行。\n\n4个CPU，8个核，16个逻辑的多核超线程结构:\n即每个物理执行核里面又分解为两个或多个逻辑执行单元\n\n2.2内存服务器内存，可以看做普通内存进行了技术升级，使之更加安全稳定。服务器内存上拥有的技术ECC、Chipkill、热插拔、register寄存器等功能。\nECC服务器内存中，ECC可以被视为核心技术之一，ECC是 Error Checking and Correcting(错误检查和纠正)的简写，ECC和奇偶校验(Parity)类似，然而，在那些Parity只能检测到错误的地方，ECC实际上可以纠正绝大多数错误。经过内存的纠错，计算机的操作指令才可以继续执行。绝大多数常见的内存出错都是：单位错，多位错，列错，行错。它们都比较相似。单位错大多发生在读一个完整的比特或词的时候有一位比特出错。当读相同的比特和词时总是同一位数据出错，则称为多位错。单位错发生在很多词中，就称列错或行错。\n\nECC内存使用额外的比特(bit)存储一个用数据加密的代码。当数据被写入内存，相应的ECC代码与此同时也被保存下来。当重新读回刚才存储的数据时，保存下来的ECC代码就会和读数据时产生的ECC代码做比较。如果两个代码不相同，他们则会被解码，以确定数据中的那一位是不正确的。然后这一错误位会被抛弃，内存控制器则会释放出正确的数据。 被纠正的数据很少会被放回内存。假如相同的错误数据再次被读出，则纠正过程再次被执行。重写数据会增加处理过程的开销，这样则会导致系统性能的明显降低。如果是随机事件而非内存的缺点产生的错误，则这一内存地址的错误数据会被再次写入的其他数据所取代。\n而因为服务器内存使用了这些技术，导致必须有对应的服务器主板配合才能使用，也就是说服务器内存放在普通PC机上是认不到的。而且也无法对服务器内存进行颗粒拆除，自制内存，因为内存颗粒中的数据位宽都不一样。\nDDR SDRAMDDR SDRAM英文全称：Double Data Rate Synchronous Dynamic Random Access Memory.\n即为双倍速率的同步动态随机存取存储器，就是我们平时说的内存颗粒，也就是内存芯片。\nDDR SDRAM是传统动态随机存取存储器（DRAM）的一种改进版本。与传统的SDRAM相比，DDR SDRAM在同样的工作频率下能够实现双倍的数据传输速率，从而大幅提升了数据传输效率。这是通过在每个时钟周期内进行两次数据传输来实现的，因此称为“双倍数据率”。\n随着技术的发展，DDR经历了多轮技术迭代，发展出了DDR2、DDR3、DDR4、DDR5，从DDR到DDR5主要的区别是在于传输速率的不同，随着时钟周期的不断降低，传输速率也不断提高。\nDDR4 vs DDR5DDR5 内存在物理上与现有的 DDR4 极为相似。与从 DDR3 过渡到 DDR4时不同（240 引角增加到 288），新的 DDR5 与其前身相比，没有新增引脚数，它仍然保留了 288 引脚的布局，但引脚防呆缺口位置却略有不同。\n两者之间真正的区别在于架构设计层面，DDR4 采用单个 64 位通道，而 DDR5 则具有两个独立的 32 位子（双）通道。传输长度也从 8 字节增加到了 16 字节。\n\n外观和接口\n每一代新的 DDR SDRAM 都比旧一代拥有更先进的功能和更好的性能。它们乍一看外观几乎相同，但实际上存在一些细微差别。例如，DDR4 比 DDR3 略厚。此外，在从 DDR3 到 DDR4 的迭代过程中，插槽防呆口趋向于靠近中间；在 DDR5 时代，虽然防呆口仍然略偏向一侧，但更接近中间了。\n初始频率\nDDR5 内存最大的优势之一是更高的频率。随着多核心处理器的不断推出和更新，内存频率升级变得至关重要。例如，Intel Core i9-13900K 共有 24 个核心，即使是相对低功率的 Core i5-13400 也有十个核心。未来，主流 PC 市场只会提供强大的 CPU，核心数量也会更多，因此提高内存频率是非常有必要的。\nJEDEC（联合电子器件工程理事会）规定：DDR4 的数据速率（或频率）范围从 DDR4-1600 到DDR4-3200；对于 DDR5，规定的频率范围为 DDR5-3200 到 DDR5-6400。但可以肯定的是，DDR5-4800 将会成为初始基线，标准会随着时间的推移而不断拉高。DDR5 更高的频率成为了它比 DDR4 有更优秀带宽的原因。\n单条内存最大容量\nDDR5 标准带来的另一个好处是更高容量的内存。在 DDR4 时代，单条内存条的最大容量可达 32GB。基于支持 2DPC（每通道 2 个 DIMM）的主流主板，DDR4 平台上最常见的总内存容量限制为 128GB；而在 DDR5 时代，单条内存已经完全跨越到了一个新水平，可以达到 128GB。如果使用相同的 2DPC 主板进行比较，则总内存容量可达 512GB。\n工作电压\n电源效率也是 DDR5 内存的主要亮点之一。从表面上看，DDR5 内存的工作电压为 1.1V，低于 DDR4 的 1.2V。但已经有 DDR4 内存可以扩展到 1.6V，可以肯定地说，DDR5 也将进一步增加到更高电压。随着对更快内存速度的市场需求增加，DDR5 的工作电压也将随之攀升。\n\nDIMMDIMM（Dual Inline Memory Module）双列直插内存模块，也就是我们常见的内存条。将若干个内存颗粒，单独焊接在一块独立的电路板上，方便模块化和安装。\nUDIMM：无缓冲双信道内存模块 (Unbuffered Dual In-Line Memory Modules)，这是我们平时所用到的标准台式电脑DIMM，也就是通常意义上的RAM或DIMM和SODIMM；\nRDIMM：registered DIMM（Registered Dual In-line Memory Module），带寄存器的双线内存模块，就是我们所说的服务器内存了。为了增加内存的容量和稳定性分有ECC和无ECC两种，但市场上几乎都是ECC的。服务器内存较为常见的是4G内存条和8G内存条，偶尔有16G内存条，不过因为成本较高所以很少大规模使用，另外2G内存条基本已淘汰，还能看到的都是老旧机器上拆下来的，俗称拆机条。\nSO-DIMM：全称（Small Outline DIMM），小外型DIMM，笔记本电脑中所使用的DIMM，分ECC和无ECC两种。\nMini-DIMM：DDR2时代新出现的模组类型，它是Registered DIMM的缩小版本，用于刀片式服务器等对体积要求苛刻的高端领域。\nLRDIMM：全称Load Reduced DIMM，低负载双列直插内存模块。相比RDIMM，LRDIMM并未使用复杂寄存器，只是简单缓冲，缓冲降低了下层主板上的电力负载，但对内存性能几乎无影响。LRDIMM内存将RDIMM内存上的Register芯片改为iMB（isolation Memory Buffer）内存隔离缓冲芯片，直接好处就是降低了内存总线负载，进一步提升内存支持容量。\n2.3存储硬盘硬盘种类1、固态硬盘（SSD），采用闪存颗粒来储存；2、机械硬盘（HDD），采用磁性碟片来储存；3、混合硬盘（HHD），是把磁性硬盘和闪存集成到一起的一种硬盘。\n\n接口种类IDE/ATA\nIDE(Integrated Drive Electronics), 本意是指把控制器与盘体集成在一起的硬盘驱动器，是一种硬盘的传输接口, 有另一个名称叫做ATA（Advanced Technology Attachment），指的是相同的东西。\nATA 全称 Advanced Technology Attachment，是用传统的40-pin 并口数据线连接主板与硬盘的，外部接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占空间，不利计算机散热，将慢慢被SATA 所取代。\nSATA\nSATA（Serial ATA）口的硬盘又叫串口硬盘. SATA以它串行的数据发送方式得名。在数据传输的过程中，数据线和信号线独立使用，并且传输的时钟频率保持独立，因此同以往的PATA相比，SATA的传输速率可以达到并行的30倍。可以说:SATA技术并不是简单意义上的PATA技术的改进，而是一种全新的总线架构，串行ATA总线运用嵌入式时钟信号，具备了更强的纠错能力。\nSCSI\nSCSI英文全称：Small Computer System Interface(小型计算机系统接口)，是同IDE(ATA)完全不一样的接口，IDE接口是普通PC的标准接口，而SCSI并不是专门为硬盘规划的接口，是一种广泛使用于小型机上的高速数据传输技术。它出现的原因主要是因为原来的IDE接口的硬盘转速太慢，传输速率太低，因此高速的SCSI硬盘出现。其实SCSI并不是专为硬盘设计的，实际上它是一种总线型接口。独立于系统总线工作.\nSCSI接口具有使用范围广、多任务、带宽大、处理器占用率低，以及热插拔等优点，但较高的价格使得它很难如IDE硬盘般普及，因此SCSI硬盘主要使用于中、高端服务器和高档工作站中。\nSAS\nSAS(Serial Attached SCSI)即串行连接SCSI，是新一代的SCSI技术。和现在流行的Serial ATA(SATA)硬盘相同，都是采用串行技术以获得更高的传输速度，并通过缩短连结线改善内部空间等。SAS是并行SCSI接口之后开发出的全新接口。此接口的设计是为了改善存储系统的效能、可用性和扩充性，并且提供与SATA硬盘的兼容性。\nSAS的接口技术可以向下兼容SATA。具体来说，二者的兼容性主要体现在物理层和协议层的兼容。\n光纤通道\n光纤通道的英文拼写是Fibre Channel，和SCSI接口一样光纤通道最初也不是为硬盘规划开发的接口技术，是专门为网络系统规划的，但随着储存系统对速度的需要，才慢慢使用到硬盘系统中。光纤通道硬盘是为提升多硬盘储存系统的速度和灵活性才开发的，它的出现大大提升了多硬盘系统的通信速度。光纤通道的主要特点有：热插拔性、高速带宽、远程连接、连接设备数量大等。\n光纤通道是为在像服务器这样的多硬盘系统环境而规划的，能满足高端工作站、服务器、海量储存子网络、外设间通过集线器、交换机和点对点连接进行双向、串行数据通讯等系统对高数据传输率的要求。\n固态硬盘固态驱动器（Solid State Drive），俗称固态硬盘，固态硬盘是用固态电子存储芯片阵列而制成的硬盘，通常使用 NAND 闪存来保存持久数据，为“闪存介质+主控”的半导体存储芯片结构。SSD由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。\n每个 NAND 闪存芯片均由一个块阵列（也称为网格）构成，且每个块内均有一个存储单元阵列（称为页面或扇区）。每个单元中存储的位数可能有所不同，而这些单元也通常被归类为单位单元（即“单级单元”或“SLC”）、2 位单元和 3 位单元（即“多级单元/MLC”和“三级单元/TLC”）或 4 位单元（“QLC”）。每种单元类型也有其优点和缺点。SLC 以其可靠性、高速度和价格而著称，而 QLC 的优势则在于价格更低廉。每个网格均可存储 256 KB 到 4 MB 之间的数据。中央处理单元 (CPU) 会充当所有内存读取或写入作业的控制器。由于它们尺寸很小且功率要求低，因而非常适合笔记本电脑、平板电脑和智能手机。\n固态硬盘 (SSD) 试图通过使用非易失性固态内存来模仿 HDD，但它们的速度却比传统硬盘驱动器或软盘要快得多。HDD 具有固有的延迟和访问时间，而这源于盘片旋转和读/写磁头移动所产生的机械延迟。由于固态硬盘 (SSD) 不含移动部件，因此访问和存储数据的延迟和时间均会大幅缩短。\n新一代的固态硬盘普遍采用SATA-2接口、SATA-3接口、SAS接口、MSATA接口、PCI-E接口、NGFF接口、CFast接口、SFF-8639接口和M.2 NVME/SATA协议。\n目前固态硬盘应用最多的硬盘接口为SATA 3.0。普通2.5英寸SSD以及HDD硬盘都使用这种接口，理论传输带宽6Gbps，由于理论带宽的限制读写速度在600MB/s。\n\nFlash和EEPROM都属于非易失性存储器，但它们在一些方面有一些关键的区别。\nFlash和EEPROM之间的主要区别：\n擦除和写入操作：\nFlash: Flash存储器通常以较大的块（通常为扇区或页）进行擦除，然后再写入新的数据。这意味着在更新或修改存储的数据时，必须擦除整个块，而不仅仅是修改的位置。EEPROM: EEPROM支持单个字节的擦除和写入，允许更灵活地修改存储的数据，而无需擦除整个块。写入速度：\nFlash: Flash存储器通常具有较高的写入速度，尤其是在大容量存储中。写入时，整个块需要擦除，但这也可以增加写入的效率。【CPU系统】EEPROM: EEPROM的写入速度相对较慢，因为它允许逐个字节的擦除和写入。这在某些应用中可能会导致较长的写入时间。\n容量和应用：\nFlash: Flash存储器通常具有较大的存储容量，广泛用于嵌入式系统、移动设备、固态硬盘（SSD）等需要大容量存储的场合。EEPROM: EEPROM通常用于存储小量的关键数据，如配置设置、校准参数等，而不太适用于需要大容量存储的场景。\n寿命和耐用性：\nFlash: Flash存储器的擦写寿命通常较高，适合用于频繁擦写的应用，如操作系统和应用程序存储。EEPROM: EEPROM的擦写寿命相对较低，因为它支持单字节擦写，但这使其更适合于相对较小规模的数据存储和较少的擦写操作。\n使用场景：\nFlash: Flash广泛用于存储操作系统、应用程序代码、大型文件等。EEPROM: EEPROM适用于存储小型数据、设备配置信息、参数设置等。\nPCIePCI Express (peripheral component interconnect express) 简称 PCIe，是一种高速串行计算机扩展总线标准。是一种全双工总线，使用高速串行传送方式，能够支持更高的频率，连接的设备不再像 PCI 总线那样共享总线带宽。PCIe目前发布了4个版本——PCIe1.0、PCIe2.0、PCIe3.0、PCIe4.0\nPCIe传输的数据从上到下，都是以packet的形式传输的，每个packet都是有其固定的格式的。\n事务层的主要职责是创建（发送）或者解析（接收）TLP (Transaction Layer packet)，流量控制，QoS，事务排序等。\n数据链路层的主要职责是创建（发送）或者解析（接收）DLLP(Data Link Layer packet)，Ack/Nak协议（链路层检错和纠错），流控，电源管理等。\n物理层的主要职责是处理所有的Packet数据物理传输，发送端数据分发到各个Lane传输（stripe），接收端把各个Lane上的数据汇总起来（De-stripe），每个Lane上加扰（Scramble，目的是让0和1分布均匀，去除信道的电磁干扰EMI）去扰（De-scramble)，以及8/10或者128/130编码解码，等等。\nM.2(NVME)ssd是固态硬盘，普通的ssd配的是SATA口（AHCI协议），nvme ssd配的是PCIe口（nvme传输协议）\nmSATA接口，全称迷你版SATA接口（mini-SATA）。是早期为了更适应于超级本这类超薄设备的使用环境，针对便携设备开发的mSATA接口应运而生。可以把它看作标准SATA接口的mini版，而在物理接口上（也就是接口类型）是跟mini PCI-E接口是一样的。\nM.2接口是Intel推出的一种替代mSATA的新的接口规范，也就是我们以前经常提到的NGFF，即Next Generation Form Factor。M.2接口能够同时支持PCI-E通道以及SATA，其中前者在提高速度方面更轻松一些。最开始该接口所采用的是PCI-E 2.0 x2通道，理论带宽10Gbps，可以说它也突破了SATA接口理论传输瓶颈。\n如今的M.2接口全面转向PCI-E 3.0 x4通道，理论带宽达到了32Gbps，相比以往水准提升了很多，这也让SSD性能潜力大幅提升。\nNVM Express（NVMe），或称非易失性内存主机控制器接口规范(Non-Volatile Memory express),是一个逻辑设备接口规范。他是与AHCI类似的、基于设备逻辑接口的总线传输协议规范（相当于通讯协议中的应用层），运行在PCIe 接口之上，用于访问通过PCI-Express（PCIe）总线附加的非易失性内存介质，虽然理论上不一定要求 PCIe 总线协议。\n此规范目的在于充分利用PCI-E通道的低延时以及并行性，还有当代处理器、平台与应用的并行性，在可控制的存储成本下，极大的提升固态硬盘的读写性能，降低由于AHCI接口带来的高延时，彻底解放SATA时代固态硬盘的极致性能。\nRAID独立磁盘冗余阵列(Redundant Array of Independent Disks)\n简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。\n软件RAID\n优点1、成本低，无需购置硬件;2、允许用户重新配置磁盘阵列，不受硬件限制。缺点1、读写性能差;2、软件RAID会占用系统资源。\n硬件RAID\n优点:1、不消耗硬盘性能及存储空间;·相对于操作系统独立;2、磁盘故障易更换。缺点:1、相比较软件RAID成本高;2、硬件RAID卡故障，必须更换同型号或与故障卡相互兼容的型号。\nRAID保护方式有两种镜像与校验镜像就是克隆出来一个副本，数据相同校验就是使用奇偶校验法逻辑算法为异或\n组成磁盘阵列的不同方式称为RAID级别（RAID Levels）\n常用的RAID级别:RAID0、RAID1、RAID3、RAID5、RAID6、RAID10、RAID50\n\n2.4热插拔热插拔（hot-plugging或Hot Swap）即带电插拔，是指将设备板卡或模块等带电接入或移出正在工作的系统，而不影响系统工作的技术。我们日常最常用的应用就是USB热插拔。\n2.5BIOSBIOS是英文“Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统“。是刻在主板 ROM 芯片上不可篡改的启动程序，BIOS 负责计算系统自检程序（POST，Power On Self Test）和系统自启动程序，因此是计算机系统启动后的第一道程式。由于不可篡改性，故程序存储在 ROM 芯片中，并且在断电后，依然可以维持原有设置。\n它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机后自检程序和系统自启动程序。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。\nBIOS是连接软件程序与硬件设备的一座”桥梁”，负责解决硬件的即时要求。 一块主板性能优越与否，很大程度上就取决于BIOS程序的管理功能是否合理、先进。主板上的BIOS芯片或许是主板上唯一贴有标签的芯片，一般它是一块32针的双列直插式的集成电路，上面印有”BIOS”字样。586以前的BIOS多为可重写EPROM芯片，上面的标签起着保护BIOS内容的作用(紫外线照射会使EPROM内容丢失)，不能随便撕下。586以后的ROM BIOS多采用EEPROM(Electrically Erasable Programmable Read-Only Memory)带电可擦可编程只读存储器，通过跳线开关和系统配带的驱动程序盘，可以对EEPROM进行重写，方便地实现BIOS升级。 常见的BIOS芯片有Award、AMI、Phoenix、MR等，在芯片上都能见到厂商的标记。\nBIOS的作用 \n自检及初始化程序：计算机电源接通后，系统将有一个对内部各个设备进行检查的过程，这是由一个通常称之为POST（Power On Self Test/上电自检）的程序来完成，这也是BIOS程序的一个功能。\n完整的自检包括了对CPU、640K基本内存、1M以上的扩展内存、ROM、主板、CMOS存贮器、串并口、显示卡、软硬盘子系统及键盘的测试。\n在自检过程中若发现问题，系统将给出提示信息或鸣笛警告。如果没有任何问题，完成自检后BIOS将按照系统CMOS设置中的启动顺序搜寻软、硬盘驱动器及CDROM、网络服务器等有效的启动驱动器 ，读入操作系统引导记录，然后将系统控制权交给引导记录，由引导记录完成系统的启动，你就可以放心地使用你的宝贝了。\n硬件中断处理：计算机开机的时候，BIOS会告诉CPU等硬件设备的中断号，当你操作时输入了使用某个硬件的命令后，它就会根据中断号使用相应的硬件来完成命令的工作，最后根据其中断号跳会原来的状态。\n程序服务请求：从BIOS的定义可以知道它总是和计算机的输入输出设备打交道，它通过最特定的数据端口发出指令，发送或接收各类外部设备的数据，从而实现软件应用程序对硬件的操作。 \n\nCMOS是”Complementary Metal Oxide Semiconductor”的缩写，翻译出来的本意是互补金属氧化物半导体存储器，指一种大规模应用于集成电路芯片制造的原料。\n但在这里CMOS的准确含义是指目前绝大多数计算机中都使用的一种用电池供电的可读写的RAM芯片。作用是具有数据保存功能，但它也只能起到存储的作用，而不能对存储于其中的数据进行设置，要对CMOS中各项参数的设置就要通过专门的设置程序。现在多数厂家将CMOS的参数设置程序做到了BIOS芯片中，在计算机打开电源时按特殊的按键进入设置程序就可以方便地对系统进行设置。也就是说BIOS中的系统设置程序是完成CMOS参数设置的手段，而CMOS RAM是存放设置好的数据的场所\n\n宏观上整个从CPU加电到操作系统启动的过程：\nBIOS 程序首先将存储设备的引导记录（Boot Record）载入内存，并执行引导记录中的引导程序（Boot）；引导程序会将存储设备中的操作系统内核载入内存，并进入内核的入口点开始执行后操作系统内核完成系统的初始化，并允许用户与操作系统进行交互\n三、服务器硬件\n\n\n硬盘背板接口\n\n\n","slug":"服务器基础知识","date":"2024-07-01T00:00:00.000Z","categories_index":"理论","tags_index":"","author_index":"Gueason"},{"id":"85d3fedd41ce5b619a50d7691e9b44cb","title":"计算机组成原理408（搬运）","content":"第一章 计算机系统概述1.1 本章大纲要求与核心考点1.1.1 大纲内容(一) 计算机系统层次结构\n\n计算机系统的基本组成\n\n计算机硬件的基本结构\n\n计算机软件和硬件的关系\n\n计算机系统的工作原理\n“存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。\n\n\n(二) 计算机性能指标\n​        吞吐量、响应时间；\n​        CPU时钟周期、主频、CPI、CPU执行时间；\n​        MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。\n真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          计算机系统层次结构\n          6\n          0\n      \n      \n          计算机性能指标\n          9\n          2\n      \n  \n\n\n\n1.2 计算机系统简介1.2.1 计算机系统的概念和分类​        计算机系统由“硬件”和“软件”两大部分组成。\n\n“硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。\n\n“软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。\n\n\n​        计算机的软件通常又可以分为两大类：系统软件和应用软件。\n\n系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。\n应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。\n\n1.2.2 计算机的发展硬件的发展\n​        1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是”用电子管组成的电子数字积分机和计算机”。\n​        从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。\n硬件技术对计算机更新换代的影响\n\n\n\n\n\n代\n时间\n硬件技术\n速度（次/秒）\n\n\n\n\n一\n1946~1957\n电子管\n40, 000\n\n\n二\n1958~1964\n晶体管\n200, 000\n\n\n三\n1965~1971\n中、小规模集成电路\n1, 000, 000\n\n\n四\n1972~1977\n大规模集成电路\n10, 000, 000\n\n\n五\n1978~现在\n超大规模集成电路\n100, 000, 000\n\n\n\n\n摩尔定律\n​        集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。\n​        微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。\n​        摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。\n1.3 计算机系统的层次结构1.3.1 计算机系统的基本组成（一） 计算机硬件\n\n冯·诺依曼计算机\n\n​        冯·诺依曼在研究EDVAC计算机时提出了 “存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯•诺依曼计算机，其特点如下：\n\n采用“存储程序”的工作方式。\n\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。\n\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n\n指令和数据均用二进制代码表示。\n\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n\n\n\n\n计算机的功能部件\n\n\n存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。\n运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。\n控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n输入设备：用来输入原始数据和程序，如键盘、鼠标。\n输岀设备：用来输出计算机的处理结果，如显示器和打印机。\n\n​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。\n（二） 计算机软件\n\n软件的分类\n\n​        软件按其功能分类，可分为系统软件和应用软件。\n\n三个级别的计算机语言\n\n（1） 机器语言\n​        机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。\n（2） 汇编语言           \n​        汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。\n（3） 高级语言\n​        高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。\n​        由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。\n\n1.3.2 计算机硬件的基本结构​        典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。\n\n现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。\n\n图中各部件的功能是：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；\n存储器用来存放数据和程序；\n控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；\n输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。\n\n​        由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I/O设备(Input/Output equipment) 。\n​        这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I/O设备叫作外部设备。\n\n\n主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。\nALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。\nCU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。\n\n​        ALU和CU是CPU的核心部件。I/O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。\n1.3.3 计算机系统的多级层次结构​        从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：\n\n​    从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.4 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.5 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。\n​    （2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。\n​    （3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。\n​    （4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。\n2. 存储程序的基本思想​        “存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。\n\n\n程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；\n将PC的内容作为地址访问主存，取出指令；\n在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；\n当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。\n\n​        这样，计算机就可以周而复始地自动执行程序中的每一条指令了。\n3. 计算机硬件组成的细化说明\n​    （1）主存储器\n​        主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”存储字长“。\n​        主存中的每个存储单元有一个唯一的编号，叫做存储单元的”地址“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。\n​        为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。\n\nMAR（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。\nMDR（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。\n\n​    （2）运算器\n​        运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。\n\nACC： Accumulator，累加器；\nMQ： Multiplier-Quotient Register，乘商寄存器；\nX： 操作数寄存器\n\n​        这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：\n\n\n\n\n\n加法\n减法\n乘法\n除法\n\n\n\n\nACC\n被加数及和\n被减数及差\n乘积高位\n被除数及余数\n\n\nMQ\n——\n——\n乘数及乘积低位\n商\n\n\nX\n加数\n减数\n被乘数\n除数\n\n\n\n\n​        不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。\n​    （3）控制器\n​        控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。\nPC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。\nIR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。\n​        CU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。\n​    （4）I/O\n​        I/O 系统包括各种 I/O 设备及其相应的接口。每一种 I/O 设备都由 I/O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。\n4. 计算机硬件的工作过程​        总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：\n\n把程序和数据装入主存储器；\n从程序的起始地址运行程序；\n按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；\n用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。\n\n​        我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：\n​    （1）取指令： PC → MAR → M → MDR → IR\n​        根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。\n​    （2）分析指令： OP（IR） → CU\n​        指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。\n​    （3）执行指令：Ad（IR） → MAR → M → MDR → ACC\n​        取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。\n​    （4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC\n1.4 计算机性能指标1.4.1 主要性能指标\n机器字长\n\n​        机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。\n​        字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。\n\n指令字长：一条指令中包含的二进制代码的位数。\n存储字长：一个存储单元中存储的二进制代码的长度。\n\n​        指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。\n\n数据通路带宽\n\n​        数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。\n\n存储容量\n\n​        存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。\n​        主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。\n​                                                存储容量 = 存储单元个数 × 存储字长\n​        在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 216 = 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K=1024）；而如果 MDR 为32位， 那么主存的存储容量为 216 × 32 = 221 = 2Ｍ 位（1Ｍ=220）。\n​        现代计算机中常以字节的个数来描述容量的大小，一个字节（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 218 字节（Byte，简写为 B）表示，记作 218 B 或 256KB。\n​        同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G = 1KM = 230 ）。\n\n运算速度\n\n​        计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。\n1.5.2 专业术语解释​    吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n​    响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I/O操作等的时间）。\n​    主频（CPU 时钟频率）：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。\n​    CPU 时钟周期：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。\n​                                                            CPU 时钟周期 = 1 / 主频\n​    CPI：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。\n​    CPU 执行时间：运行一个程序所花费的时间。\n​                                                CPU 执行时间 = （指令数 × CPI）/ 主频\n​        对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。\n​        现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。\n​        MIPS：Million Instructions Per Second，每秒执行百万条指令的数目。\n​                                                            MIPS = 主频 /（CPI × 106）\n​        FLOPS：FLoating-point Operations Per Second，每秒执行浮点运算的次数。\n​        MFLOPS：百万次浮点运算每秒。 MFLOPS = 浮点操作次数 /（执行时间 * 106）\n​        GFLOPS：十亿次浮点运算每秒。 GFLOPS = 浮点操作次数 /（执行时间 * 109）\n​        TFLOPS：万亿次浮点运算每秒。 TFLOPS = 浮点操作次数 /（执行时间 * 1012）\n​        PFLOPS：千万亿次浮点运算每秒。 PFLOPS = 浮点操作次数 /（执行时间 * 1015）\n​        EFLOPS：百京次浮点运算每秒。 EFLOPS = 浮点操作次数 /（执行时间 * 1018）\n​        ZFLOPS：十万京次浮点运算每秒。 ZFLOPS = 浮点操作次数 /（执行时间 * 1021）\n​        需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB =  210 B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb/s = 103 b/s。\n1.5 章节练习一、单项选择题\n【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。\n\n​        A. 指令操作码的译码结果                B. 指令和数据的寻址方式\n​        C. 指令周期的不同阶段                    D. 指令和数据所在的数据单元\n​    答案： C\n\n【2015真题】计算机硬件能够直接执行的是 （  ）。\n\n​        I. 机器语言程序    II. 汇编语言程序    III. 硬件描述语言程序\n​        A. 仅 I             B. 仅 I、II            C. 仅 I、III            D. I、II、III\n​    答案： A\n\n【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。\n\n​        A. 汇编程序            B. 链接程序            C. 编译程序            D. 解释程序\n​    答案： C\n\n【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。\n\n​        A. 程序的功能都通过中央处理器执行指令实现            B. 指令和数据都用二进制表示，形式上无差别\n​        C. 指令按地址访问，数据都在指令中直接给出            D. 程序执行前，指令和数据需预先存放在存储器中\n​    答案： C\n\n【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。\n\n​        I. ALU        II. 指令寄存器        III. 通用寄存器        IV. 浮点寄存器\n​        A. 仅 I、II            B. 仅 I、III            C. 仅 II、III            D. 仅 II、III、IV\n​    答案： B\n\n【2010真题】下列选项中，能缩短程序执行时间的是（  ）。\n\n​        I. 提高 CPU 时钟频率    II. 优化数据通路结构    III. 对程序进行编译优化\n​        A. 仅 I 和 II            B. 仅 I 和 III            C. 仅 II 和 III            D. I、II、III\n​    答案： D\n\n【2011真题】下列选项中，描述浮点数操作速度的是（  ）。\n\n​        A. MIPS                    B. CPI                    C. IPC                    D. MFLOPS\n​    答案： D\n\n【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I/O 时间。若 CPU 速度提高 50%，I/O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。\n\n​        A. 55s                B. 60s                C. 65s                D. 70s\n​    答案： D\n\n【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。\n\n\n\n\n\n指令类型\n所占比例\nCPI\n\n\n\n\nA\n50%\n2\n\n\nB\n20%\n3\n\n\nC\n10%\n4\n\n\nD\n20%\n5\n\n\n\n\n​        该机的 MIPS 是 （  ）。\n​        A. 100                B. 200                C. 400                D. 600\n​    答案： C\n\n【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。\n\n​        A. 8.4s                B. 11.7s                C. 14s                D. 16.8s\n​    答案： D\n\n【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。\n\n​        A. 0.4                B. 0.625                C. 1.6                D. 2.5\n​    答案： C\n二、综合应用题\n说明机器字长、指令字长、存储字长的区别和联系。\n\n​    答案：\n​        机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。\n​        指令字长：一个指令字中包含二进制代码的位数。\n​        存储字长：一个存储单元存储二进制代码的长度。\n​        它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。\n\n用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 I）。\n|      指令类型      | CPI  | 指令混合比 || :————————: | :—: | :————: ||     算术和逻辑     |  1   |    60%     ||        转移        |  4   |    12%     || 高速缓存命中的访存 |  2   |    18%     || 高速缓存失效的访存 |  8   |    10%     |\n\n\n​    答案：\n​        CPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：\n​                        CPI = 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% = 0.6 + 0.48 + 0.36 +0.8 = 2.24\n​        MIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：\n​                                                    MIPS = 40 × 106 /（2.24 × 106 ）≈ 17.9\n​        程序的执行时间 T = 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：\n​                        T = CPI × 时钟周期 × 指令条数 = 2.24 ×（1 / 40MHz）× I = 5.6 × 10-8 × I  秒\n​        \n\n第二章 数据的表示和运算2.1 本章大纲要求与核心考点2.1.1 大纲内容（一）数制与编码\n\n进位计数制及其数据之间的相互转换\n定点数的表示和运算\n\n（二）运算方法和运算电路\n\n基本运算部件：加法器、算数逻辑部件（ALU）\n加/减运算：补码加/减运算器，标志位的生成\n乘/除运算：乘/除运算的基本原理，乘法电路和除法电路的基本结构\n\n（三）整数的表示和运算\n\n无符号整数的表示和运算\n有符号整数的表示和运算\n\n（四）浮点数的表示和运算\n\n浮点数的表示：IEEE 754标准\n浮点数的加/减运算\n\n2.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n真值、机器数，定点数的表示及原理\nC 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换\nALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法\nIEEE 754标准浮点数的表示和特点，浮点数的加/减运算方法\nC 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换\n数据按边界对齐方式的存储，数据按大端和小端方式存储\n\n2.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          定点数的表示与运算\n          10\n          8\n      \n      \n          IEEE 754标准浮点数，浮点数的运算\n          10\n          3\n      \n      \n          C语言中各种数据的转换\n          3\n          2\n      \n      \n          数据按边界对齐方式的存储，数据按大小端方式存储\n          4\n          0\n      \n  \n\n\n\n\n\n\n2.2 数制与编码2.2.1 进位计数制及其相互转换（一）进位计数制\n​        进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为基数；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。\n​        下表是十进制数、二进制数、十六进制数对照表。\n​        书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)16；八进制数后面加上“O”，如372O或(372)8；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)2。\n​                                        十进制数、二进制数、八进制数、十六进制数对照表\n\n\n\n\n十进制数\n二进制数\n八进制数\n十六进制数\n十进制数\n二进制数\n八进制数\n十六进制数\n\n\n\n\n0\n00000\n0\n0\n16\n10000\n20\n10\n\n\n1\n00001\n1\n1\n17\n10001\n21\n11\n\n\n2\n00010\n2\n2\n18\n10010\n22\n12\n\n\n3\n00011\n3\n3\n19\n10011\n23\n13\n\n\n4\n00100\n4\n4\n20\n10100\n24\n14\n\n\n5\n00101\n5\n5\n21\n10101\n25\n15\n\n\n6\n00110\n6\n6\n22\n10110\n26\n16\n\n\n7\n00111\n7\n7\n23\n10111\n27\n17\n\n\n8\n01000\n10\n8\n24\n11000\n30\n18\n\n\n9\n01001\n11\n9\n25\n11001\n31\n19\n\n\n10\n01010\n12\nA\n26\n11010\n32\n1A\n\n\n11\n01011\n13\nB\n27\n11011\n33\n1B\n\n\n12\n01100\n14\nC\n28\n11100\n34\n1C\n\n\n13\n01101\n15\nD\n29\n11101\n35\n1D\n\n\n14\n01110\n16\nE\n30\n11110\n36\n1E\n\n\n15\n01111\n17\nF\n31\n11111\n37\n1F\n\n\n\n\n​        计算机系统为什么要采用二进制？\n\n使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。\n二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。\n二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。\n\n\n（二）不同进制数的相互转换\n​        任意一个数 N，可以用 r 进制表示成下面的形式：\n​                                            N =（dn-1dn-2 … d1d0.d-1d-2 … d-m）\n​                                                = dn-1rn-1 + dn-2rn-2 + … + d1r1 + d0r0 + d-1r-1 + d-2r-2 + … + d-mr-m\n​                                                = ∑ diri\n​        其中，r 为基数；d 为系数，di 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；ri 叫做第 i 位上的权值。n、m 分别代表 N 的整数部分和小数部分的位数。\n（1）二进制和八进制、十六进制间的转换\n​        将二进制数1110011101.0010111转换为八进制数为：\n​                                                左侧补0                  分界点                右侧补0\n​                                                   ↓                         ↓                   ↓\n​                                                001 110 011 101 .  001 011 100\n​                                                 1       6     3      5  .    1      3      4\n​        所以 (1110011101.0010111)2 = (1635.134)8 ；\n​        同样道理，转换为十六进制数为：\n​                                                0011 1001 1101 .  0010 1110\n​                                                    3        9        D   .     2        E\n​        所以 (1110011101.0010111)2 = (39D.2E)16 ；\n\n二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。\n二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。\n八进制转换为二进制：每位都转换成对应的3位二进制数。\n十六进制转换为二进制：每位都转换成对应的4位二进制数。\n\n（2）任意进制数转换为十进制数\n​        任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 按权展开法。\n​        例如，将二进制数 11011.101 转换为十进制数为：\n​        (11011.101)2  = 1 × 24 + 1 × 23 + 0 × 22 + 1 × 21 + 1 × 20 + 1 × 2-1 + 0 × 2-2 + 1 × 2-3\n​                            = 27.625\n​        另一种方法是“按基数重复相乘/除法”，需要分整数部分和小数部分分别转换。\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n（3）十进制数转换为二进制数\n​        将十进制数转换为二进制数，一般采用 基数乘除法。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。\n\n整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）\n\n小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）\n\n\n​        例如，将十进制数 123.6875 转换为二进制数。\n​        整数部分：\n​          除2得商                            余数\n​        2 |123                …                1                最低位\n​          2  |61               …                1\n​           2 |30               …                0\n​           2 |15               …                1\n​            2  |7               …                1\n​            2  |3               …                1\n​            2  |1               …                1                最高位\n​            2  |0\n​        所以 (123)10 = (1111011)2\n​        小数部分：\n​          乘积取小数                                乘2得积                取整数部分\n​            0.6875                × 2                = 1.375                        1                        最高位\n​            0.375                  × 2                = 0.75                           0        \n​            0.75                    × 2                = 1.5                             1    \n​            0.5                      × 2                 = 1                                1                        最低位    \n​        所以 (0.6875)10 = (0.1011)2\n​        综合整数和小数部分，得到 (123.6875)10 = (1111011.1011)2\n​        另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：\n​        十进制数                位权                转换后的结果\n​            123                                            26    25    24    23    22    21    20\n​        ➖ 64                        26                1\n​              59\n​        ➖ 32                        25                        1\n​              27\n​        ➖ 16                        24                                1\n​              11\n​        ➖   8                        23                                        1\n​                3\n​        ➖   2                        21                                                        1\n​                1\n​        ➖   1                        20                                                                1\n​                0\n​        所以 (123)10 = (1111011)2 \n​        这种方法一般在转换很大的十进制数时比较方便。\n2.2.2 真值和机器数​        在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。\n​        对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。\n例如，一个有符号的小数：\n​                + 0.1011                在机器中表示为        0    1 0 1 1\n​                -  0.1011                在机器中表示为        1    1 0 1 1\n再比如，一个有符号的整数：\n​                + 1100                    在机器中表示为        0    1 1 0 0\n​                -  1100                    在机器中表示为        1    1 1 0 0\n​        把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。\n\n真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。\n机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。\n\n​        在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即定点表示和浮点表示。\n​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。\n​        在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。\n2.2.3 定点数及其编码表示​        小数点固定在某一位置的数为定点数，有以下两种格式。\n\n当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。\n​        在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。\n1. 无符号整数的表示​        当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 28-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。\n2. 带符号数的表示​        最高位用来表示符号位，而不再表示数值位。\n（1）定点整数\n​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。\n​        约定小数点在有效数值部分最低位之后。数据 x = x0x1x2…xn （其中 x0 为符号位，x1 ~ xn 是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：\n\n（2）定点小数\n​        约定小数点在有效数值部分最高位之前。数据 x = x0.x1x2…xn（其中 x0 为符号位，x1~xn 是尾数，x1 是最高有效位），在计算中的表示形式如下图所示：\n\n3. 原码、补码、反码和移码\n原码表示法\n\n​        用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:\n\n式子中 x 为真值，[ x ]原 表示原码机器数。\n​        类似，纯整数的原码定义如下：\n\n​    原码的性质：\n\n由符号位与数的绝对值组成，符号位是0为正、1为负\n\n0有 ±0 两个编码，即 [+0]原 = 00000 和 [-0]原 = 10000 \n\n\n\n补码表示法\n\n​        纯整数的补码定义为：\n\n​    这里 n 为整数的位数，真值 x 和补码机器数 [ x ]原 互为以 2n+1 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2n ≤ x ≤ 2n - 1，比原码多表示了一个数 -2n。\n​        补码的性质：\n\n补码和其真值的关系：[x]补 = 符号位 × 2n+1 + x\n0的编码唯一，因此整数补码比原码多1个数，表示 -2n\n符号位参与补码加减运算，统一采用加法操作实现\n将 [x]补 的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能\n\n​        例如，当 x = + 1010 时（n = 4），\n​        [x]补 = 0, 1010\n​        而当 x = - 1010 时，\n​        [x]补 = 2n+1 + x = 100000 - 1010 = 1, 0110\n​        补码和真值的转换：\n\n真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。\n补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。\n\n​        变形补码是采用双符号位的补码表示法，其定义为\n\n​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。\n\n反码表示法\n\n​        负数的补码可采用“数值位各位取反，末位加1”的方法得到，如果数值位各位取反而末位不加1，那么就是负数的反码表示。正数的反码定义和相应的补码（或原码）表示相同。\n​        反码表示存在以下几个方面的不足：0的表示不唯一（即存在±0）；表示范围比补码少一个最小负 数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。\n​        原码、补码、反码三种编码表示总结如下：\n\n三种编码的符号位相同，正数的机器码相同。\n\n原码和反码的表示在数轴上对称，二者都存在 ±0 两个零。\n\n补码的表示在数轴上不对称，0的表示唯一，补码比原码和反码多表示一个数。\n\n负数的反码、补码末位相差1。\n\n\n\n原码很容易判断大小。而负数的补码和反码很难直接判断大小，可采用这条规则快速判断：对于一个负数，数值部分越大，它的绝对值就越小，所以真值就越大（更靠近0）。\n\n\n移码表示法\n\n​        移码是在真值 x 上加上偏置值 2n 构成的，相当于 x 在数轴上向正方向偏移了若干单位。\n\n​    移码定义为:\n\n移码的性质：\n\n0的表示唯一， [+0]移 =  2n + 0 = [-0]移 = 2n - 0 = 100…0 \n符号位“1”表示正，“0”表示负，这与其他机器数正好相反。\n一个真值的移码和补码仅差一个符号位，[x]补 的符号位取反即得 [x]移，反之亦然。\n移码全0时，对应真值的最小值- 2n ；移码全1时，对应真值的最大值 2n -1。\n保持了数据原有的大小顺序，移码大真值就大，便于进行比较操作。\n移码常用来表示浮点数的阶码。它只能表示整数。\n\n2.2.4  C 语言中的整型数据类型\nC 语言中的整型数据简介\n\n​        C 语言中的整型数据就是定点整数，一般用补码表示。根据位数的不同，可以分为 字符型(char)、短整型(short)、整型(int)、长整型(long)。\n​        C 语言中的整型数据，可以分为 无符号整型 和 有符号整型 两种类型，在定义时只要加上 signed/unsigned 就可以明确指定了。\n​        char 是整型数据中比较特殊的一种，其他如 short/int/long 等都默认是带符号整数，但 char 默认是无符号整数。无符号整数（unsigned short/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\n​        signed/unsigned 整型数据都是按补码形式存储的，在不溢出条件下的加减运算也是相同的，只是 signed 型的最高位代表符号位，而在 unsigned 型中表示数值位，而这两者体现在输出上则分别是％d 和％u。\n\n有符号数和无符号数的转换\n\n​        C 语言允许在不同的数据类型之间做类型转换。C 语言的强制类型转换格式为“TYPE b = (TYPE) a”, 强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。\n​        先看由 short 型转换到 unsigned short 型的情况。考虑如下代码片段：\n123short x = -4321;unsigned short y = (unsigned short)x;\n​        执行上述代码后，x = -4321, y = 61215，得到的 y 似乎与原来的 x 没有一点关系。不过将这两个数转化为二进制表示时，我们就会发现其中的规律。\n​        通过本例可知：强制类型转换的结果是保持每位的值不变，仅改变了解释这些位的方式。有符号数转化为等长的无符号数时，符号位解释为数据的一部分，负数转化为无符号数时数值将发生变化。同理，无符号数转化为有符号数时，最高位解释为符号位，也可能发生数值的变化。\n\n不同字长整数之间的转换\n\n​        另一种常见的运算是在不同字长的整数之间进行数值转换。\n​        先看长字长变量向短字长变量转换的情况。考虑如下代码片段：\n123int x = 165537, u = -34991;                      //int型占用4字节short y = ( short )x, v = ( short )u;            //short型占用2字节\n​        执行上述代码后，x= 165537, y=-31071, u =-34991, v = 30545。x、y、u、v 的十六进制表示分别 是0x000286a1 0x86a1 . 0xffff7751、0x7751。由本例可知：长字长整数向短字长整数转换时，系统把多余的高位部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。\n​        最后来看短字长变量向长字长变量转换的情况。考虑如下代码片段:\n1234567short x = -4321;int y = (int)x;unsigned short u = (unsigned short)x;unsigned int v = (unsigned int)u;\n​        执行上述代码后，x = -4321, y = -4321, u = 61215, v = 61215。x、y、u、v 的十六进制表示分别是0xef1f. 0xffffef1f、0xef1f、0x0000ef1f。所以，短字长整数向长字长整数转换时，仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。\n​        从位值与数值的角度看，前3个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换可以理解为保证数值的相等。\n\n2.3 运算方法2.3.1 定点数的移位运算​        移位运算根据操作对象的不同，可以分为算术移位和逻辑移位。算术移位针对的是有符号数，逻辑移位针对的是机器码，可以看作无符号数。\n1. 算术移位​        算术移位的对象是有符号数，有符号数在计算机中采用补码表示。算术移位的特点是，移位后符号位保持不变；空出的位置根据正负和左右移位的情况，决定补 0 还是 1。\n\n对于正数，由于 [ x ]原 = [ x ]补 = 真值，因此移位后的空位均补 0。\n对于负数，算术左移时，高位移出，低位补 0；算术右移时，低位移出，高位补 1。\n\n​        可见，不论是正数还是负数，移位后其符号位均不变。\n​        例如，假设机器字长为 8，[4]补 = 0000 0100，[-4]补 = 1111 1100；\n\n将 4 算术左移一位，就得到了 0000 1000 = [8]补；算术右移一位，就得到了 0000 0010 = [2]补；\n\n将 -4 算术左移一位，就得到了 1111 1000 = [-8]补；算术右移一位，就得到了 1111 1110 = [-2]补；\n\n\n​        对于有符号数，左移一位若不产生溢出，相当于乘以2 （与十进制数左移一位相当于乘以10类似）; 右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。\n2. 逻辑移位​        逻辑移位不考虑符号位。\n​        移位规则：逻辑左移时，高位移出，低位补 0；逻辑右移时，低位移岀，高位补 0 。\n2.3.3 定点数的加减运算​        加减法运算是计算机中最基本的运算，由于减法可以看成是负值的加法，因此计算机中使用补码表示有符号数之后，可以将减法运算和加法运算合并在一起讨论。\n1. 补码的加减运算​        补码加减运算的规则简单，易于实现。补码加减运算的公式如下（设机器字长为 n）：​                                                                [A + B]补 = [A]补 + [B]补  (mod 2n)​                                                                [A - B]补 = [A]补 + [-B]补  (mod 2n)\n​        补码运算的特点如下：\n\n按二进制运算规则运算，逢二进一。\n如果做加法，两数的补码直接相加；如果做减法，则将被减数加上减数的机器负数。\n符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。\n最终将运算结果的高位丢弃，保留 n 位，运算结果也是补码。\n\n​        例如，假设机器字长为 8 （n = 8），那么\n​        [5]补 = 0000 0101，[4]补 = 0000 0100；\n​        [-5]补 = 1111 1011，[-4]补 = 1111 1100；\n​        [5 + 4]补 = 0000 0101 + 0000 0100 = 0000 1001 = [9]补；\n​        [5 - 4]补 = [5 + (-4)]补 = 0000 0101 + 1111 1100 = 1 0000 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0000 0100 + 1111 1011 = 1111 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1111 1011 + 1111 1100 = 1 1111 0111 = [-9]补；\n2. 溢出判别方法​        溢出 是指运算结果超出了数的表示范围。通常，大于能表示的最大正数称为正上溢，小于能表示的最小负数称为负上溢。仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。\n​        在之前的例子中，如果假设机器字长为 4（n = 4），能表示的有符号数范围为 -8 ~ 7，那么就有：\n​        [5]补 = 0101，[4]补 = 0100；\n​        [-5]补 = 1011，[-4]补 = 1100；\n​        [5 + 4]补 = 0101 + 0100 = 1001 = [-7]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 0101 + 1100 = 1 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0100 + 1011 = 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1011 + 1100 = 1 0111 = [7]补；        （负溢出）\n​        补码加减运算的溢出判断方法有以下 3 种：\n（1）采用一位符号位。\n​        参加操作的两个数符号相同，结果又与原操作数符号不同，就表示结果溢出。\n​        一正一负相加必然不会溢出；两正数相加得到一个负数（符号位为1），则正溢出；两负数相加得到一个正数，则负溢出。\n（2）采用双符号位。\n​        运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位就代表真正的符号。也就是说，符号位 S1S2 = 00 表示结果为正数，无溢出； S1S2 = 11 表示结果为负数，无溢出。 S1S2= 01 表示结果正溢出； S1S2 = 10 表示结果负溢出。溢出标志 OF = S1 ㊉ S2。\n​        比如上例中，如果采用双符号位，机器字长就应该扩展为 5，那么：\n​        [5]补 = 00 101，[4]补 = 00 100；\n​        [-5]补 = 11 011，[-4]补 = 11 100；\n​        [5 + 4]补 = 00 101 + 00 100 = 01 001 = [1]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 00 101 + 11 100 = 1 00 001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 00 100 + 11 011 = 11 111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 11 011 + 11 100 = 1 10 111 = [-1]补；        （负溢出）\n2.2.4 定点数的乘法运算1. 原码一位乘法​        原码乘法运算的符号位与数值位分开计算。\n\n确定乘积的符号位。由两个乘数的符号进行异或运算得到。\n计算乘积的数值位。两个乘数的数值部分之积，可看作两个无符号数的乘积。\n\n​        原码一位乘法的基本思路，就是类似竖式乘法的做法，让被乘数 x 分别乘以乘数 y 的每一位，然后再做叠加。不过竖式乘法需要做连加运算，这在电路实现上会有一些困难；改进的做法是，借鉴进制转换的“重复相乘/除法”，对每一位进行迭代计算。\n​        回忆一下二进制数转换成十进制数的重复相乘/除法：\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n​        所以，两数相乘时，就可以把乘数 y 用这种方式按每一位拆开，并乘以 x 、再逐位叠加就可以了。由于每次乘以 2 就相当于左移一位、除以 2 就相当于右移一位，因此只需要反复迭代这样的 移位 和 加法 运算就可以很容易地实现乘法了。\n\n原码一位乘法的运算规则如下：\n\n被乘数和乘数均取绝对值|x| 和 |y|参加运算，看作无符号数，符号位为 x0 ㊉ y0。\n乘数的每一位 yi 乘以被乘数 |x| 得到 |x| · yi，将该结果与前面所得的结果相加，作为部分积；初始值为 0。\n从乘数的最低位 yn 开始判断：若 yn = 1，则部分积加上被乘数 |x|，然后右移一位；若 yn = 0，则部分积加上 0，然后右移一位。\n重复上一步骤，判断 n 次。\n\n​        由于参与运算的是两个数的绝对值，因此运算过程中的右移操作均为逻辑右移。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 0.1011 = (0.6875)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 0.1101 × 0.1011 =  0.10001111 = (0.55859375)10\n\n2. 补码一位乘法​        带符号数的乘法，采用相加/相减的校正操作，直接计算补码数据的乘积。\n​        补码乘法是直接对补码进行的。对于纯整数，补码表达为：\n\n而类似的，纯小数补码定义为：\n\n所以，当取不同的正负符号时，补码表达会有所不同，继而影响到逐位相乘叠加的效果。\n​        已知 [ x ]补 = x0 . x1x2…xn，[ y ]补 = y0 . y1y2…yn，那么需要分不同的情况讨论：\n​        ① 被乘数 x 和乘数 y 符号均为正，即 x0 = y0 = 0 时，\n​        [ x ]补 = x，[ y ]补 = y，所以就有：\n\n类似原码一位乘法，利用移位和加法的叠加，就可以计算出补码的乘积；这也就是最终计算结果的补码。\n​        ② 被乘数 x 为正，乘数 y 为负，即 x0 = 0，y0 = 1 时，\n​        [ y ]补 = 1. y1y2…yn = 2 + y，所以：\n\n那么两数的乘积就可以写成：\n\n这样一个计算结果，它的补码表示为：\n\n​    可以看到，当乘数为负时，可以把乘数补码 [ y ]补 直接去掉符号位，当成一个正数与 [ x ]补 相乘；得到的结果再加上 [ -x ]补 进行校正。所以这种方法也叫做“校正法”。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 1.1011 = (-0.3125)10 时，计算 x · y。\n​        我们可以直接计算 0.1101 × 0.1011 = 0.10001111，再加上 [ -x ]补 = 1. 0011，得到 ：\n​         0.10001111 + 1. 0011 = 1.10111111 =  ( -0.25390625 )10\n\n​        ③ 被乘数 x 为负，乘数 y 为正，即 x0 = 1，y0 = 0 时，\n​        我们可以交换被乘数和乘数，直接按情况②来处理；也可以仔细分析，发现乘数 y 为正数，可以写成\n[ y ]补 = 0. y1y2…yn 的形式，同样可以借鉴情况②中的分析和原码一位乘的方法。当两数的补码相乘时：\n\n观察可以发现，与原码一位乘完全类似，补码相乘也可以将乘数展开，逐位进行相乘、右移和叠加。不过需要注意的是，这时由于被乘数 x 是负数，右移时就需要在左侧高位补 1，也就是做算术右移、而不是逻辑右移。\n​        这样一来，算术右移就实现了对真值 x 的“除以 2”操作，最终叠加之后的结果，就是 x · y 的补码了。\n​        例如，当 x = 1.1 = (-0.5)10，y = 0.011 = (0.375)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1 × 0.011 =  1.1101 = ( - 0.1875 )10        \n​        ④ 被乘数 x 和乘数 y 符号均为负，即 x0 = y0 = 1 时，\n​        通过情况②和③的分析可以看出，当乘数 y 为正时，可以直接按照原码一位乘的方式进行补码乘法，注意需要进行算术右移；而当乘数 y 为负时，则可以先不考虑 y 的符号位，同样按照原码一位乘进行补码乘法，最后的结果要再加上 [ -x ]补 进行校正。\n​        例如，当 x = 1.1 = (-0.5)10，y = 1.011 = (-0.625)10 时，计算 x · y。\n​        我们可以直接计算 1.1 × 0.011 =  1.1101，再加上 [ -x ]补 = 0.1，得到 ：\n​        1.1101 + 0.1 = 1 0.0101 =  ( 0.3125 )10\n​        可以看出，如果使用双符号位来表示正负，会更加方便。\n​        ⑤  Booth算法\n​        以上的 4 种情况需要分别讨论，根据乘数的符号来决定是否需要进行校正。\n​        如果不考虑操作数的符号，直接用统一的规则来处理所有情况，可以采用 Booth 算法。\n​        当被乘数 x 和乘数 y 符号任意时，按照之前讨论的校正法规则，可以写出一个统一的计算公式：\n\n​    容易推出，对于纯小数，在 mod 2 的前提下，[ -x ]补 = - [ x ]补，所以可以进一步推导得到：\n\n​    令 yn+1 = 0，那么就可以得到一个通项系数： di = yi+1 - yi ，上式可以进一步化简为：\n\n这样一来，补码乘法的计算方式就跟原码一位乘完全一样了，只是被乘数每次乘的不再是乘数 y 的每一位 yi，而是变成了 di = yi+1 - yi 。这样就有 1、-1 和 0 三种情况，每一次计算都由 di 来决定部分积叠加的是 [ x ]补、[ -x ]补 还是 0；然后再做一位算术右移得到新的部分积。最后一步，需要由 d0 = y1 - y0 决定是否有叠加项，但不再做位移。\n​        Booth 算法的移位规则如下表所示：\n\nBooth 算法的具体运算规则如下：\n①    符号位参与运算，运算的数均以补码表示。\n②    被乘数一般取 双符号位 参与运算，部分积取 双符号位，初值为 0，乘数取单符号位。\n③    乘数末尾增加一个“附加位” yn+1，初始值为 0。\n④    根据（yi，yi+1）的取值来确定操作，如上表所示。\n⑤    移位按补码右移规则（算术右移）进行。\n⑥    按照上述算法进行 n + 1 步操作，但第 n + 1 步不再移位，仅根据 y0 （符号位）与 y1 （第一位数值位）的比较结果做相应的叠加运算。所以总共需要进行 n + 1 次累加和 n 次右移。\n\n​        例如，当 x = 1.1101 = (-0.1875)10，y = 1.1011 = (-0.3125)10  时，计算 x · y。\n​        首先得到 [x]补 = 11.1101，[-x]补 = 00.0011。具体计算步骤如下：\n\n同样，最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1101 × 1.1011 =  0.00001111 = (0.05859375)10\n2.2.5 定点数的除法运算1. 原码一位除法（1）恢复余数法\n​        恢复余数法的特点是：当余数为负时，需要加上除数的绝对值，将其恢复成原本的余数。\n​        由于每次得到的是商的高位，所以每轮计算可以将余数和商同时左移一位；余数加上 [- y]补 ，判断正负来决定下一位商是 1 还是 0；如果为负，还需要先加上 [y]补 恢复余数，然后再做左移。\n\n​        例如，当 x = (-0.1011)2  = (-0.6875)10，y = (-0.1101)2 = (-0.8125)10 时，计算 x / y。\n​        首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x = 0.1011，y= 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x/ y = 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n溢出判断：当该位为 1 时，表示当前除法溢出，不能进行；当该位为 0 时，当前除法合法，可以进行。\n（2）不恢复余数法（加减交替法）\n​        在恢复余数法中，每当余数为负时都需要恢复余数，这就增加了运算量，操作也不规则，电路实现会比较复杂。加减交替法就克服了这一缺点。\n​        加减交替法 又称 不恢复余数法，是对恢复余数法的一种改进。\n​        通过分析恢复余数法可以发现，如果把第 i 轮计算的余数记作 Ri，那么：\n\n如果 Ri &gt; 0，就上商 1，接下来需要将余数 Ri 左移一位，再减去除数绝对值 y，即 2Ri - y；\n如果 Ri &lt; 0，就上商 0，接下来先加上 y 恢复余数，再做左移和减法，即 2 (Ri + y) - y = 2Ri + y。\n\n​        这样一来，就不需要额外恢复余数了，每轮计算的规则完全统一起来，只是左移之后再加/减 y^*^ 就可以了；所以把这种方法叫做“加减交替法”，或者“不恢复余数法”。\n\n​        还是上面的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        同样的步骤，首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x= 0.1011，y = 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x / y= 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n2. 补码一位除法（加减交替法）\n补码一位除法的运算规则如下：\n\n符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。\n如被除数与除数同号，则被除数减去除数；如被除数与除数异号，则被除数加上除数。\n余数与除数同号，商上1，余数左移一位再减去除数；余数与除数异号， 商上 0，余数左移一位再加上除数。\n重复执行上一步操作，操作 n 次。\n如果对商的精度没有特殊要求，一般采用“末位恒置 1”法。\n\n​    同样的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        首先得到： [x]补 = 1.0101，[y]补 = 1.0011，[-y]补 = 0.1101\n​        具体计算过程如下：\n\n所以商值为\n​        x / y = 0.1101\n2.4 浮点数的表示和运算2.4.1 浮点数的表示浮点数 就是小数点的位置可以浮动的数。例如：\n​        365.242 = 3.65242 × 10^2^\n​                       = 365242.0 × 10^-3^\n​                       = 0.365242 × 10^3^\n1. 浮点数的表示格式​        在计算机中，浮点数的格式如下图所示。采用这种数据格式的机器称为 浮点机。\n\n​    浮点数由 阶码 j 和 尾数 S 两部分组成。\n\n阶码是纯整数，阶符和阶码值合起来决定了小数点的实际位置；阶码值的位数 m 再结合阶符，可以反映浮点数的表示范围。\n尾数是纯小数，数符 Sf代表了浮点数的正负，而尾数值则是有效数位，位数 n 反映了浮点数的精度。\n\n2. 浮点数的表示范围​        假设浮点数 N 的阶码 j 数值部分有 m 位，尾数 S 数值部分有 n 位。\n​        阶码是纯整数，尾数是纯小数，它们可以各自选择编码方式。对于非规格化的浮点数，如果阶码和尾数都用原码表达，各自的取值范围如下：\n\n​        那么阶码 j 和尾数 S 组合之后，能表示的浮点数最大范围就是：\n\n在数轴上表示出来，如下图所示：\n\n原码是关于原点对称的，所以浮点数的表示范围也是关于原点对称的。\n​        当运算结果大于能表示的最大正数时，称为正上溢；小于最小负数时。称为负上溢：两者统称 上溢。由于尾数的溢出可以通过移位、增加阶码来调整，因此上溢的本质就是 阶码大于最大阶码，这时机器会停止计算，进行中断溢出处理。\n​        当运算结果在 0 至最小正数之间时，称为正下溢；在 0 至最大负数之间时，称为负下溢，统称 下溢。同样道理，下溢的本质是 阶码小于最小阶码，这时溢出的数值绝对值非常小，通常可以将尾数各位直接强置为 0，按 ”机器零“ 来处理，机器可以继续正常运行。\n​        类似地，如果阶码和尾数都用补码表达，各自的取值范围如下：\n\n​    用移码来表示阶码方便进行阶数的比较和对齐，简称 “对阶”。这在进行浮点数加减运算时非常重要，尾数只有在阶数相同的时候才能做加减，采用移码直接比较两个阶码的二进制大小关系就可以了：\n\n3. 浮点数的规格化​        由于规格化数的精度最高，所以当一个非零的浮点数不是规格化数时，应该通过左右移动尾数、并同时修改阶码的方法，将它转换为规格化数。把一个非规格化数转换成规格化数的过程，叫做 规格化。\n​        规格化的本质类似于 “科学计数法” 的表达，通过保证尾数最高数位上是一个有效值，尽可能多地保留有效数字的尾数，从而提高精度。\n​        规格化可以分为 “左规” 和 “右规” 两种。以基数 r = 2 为例：\n\n左规：向左规格化。当运算结果尾数的最高数位不是有效位，即出现 0.0…01… 的形式时，需要向左规格化。左规时，尾数左移一位，阶码减 1；\n右规：向右规格化。当运算结果尾数的小数点左侧出现有效位，即整数部分不为 0 时，需要向右规格化。右规时，尾数右移一位，阶码加 1；需要右规时，只需进行一次。\n\n​        当基数不同时，规格化的原则会有相应的改变。比如，当基数 r = 4 时，阶码每次加/减 1，就相当于多乘/除以 4，也就是左/右移 2 位。所以左规就是尾数左移 2 位，阶码减 1；右规是尾数右移 2 位，阶码加 1。尾数的最高 2 位不全为 0 的数，就是规格化数。\n\n4. IEEE 754 标准浮点数​        在现代计算机中，浮点数的格式一般采用 IEEE 制定的国际标准。IEEE 754 标准规定的浮点数形式为：\n\n\nS 为数符，直接表示浮点数的正负，它与尾数所表示的有效数位是分开的。\n阶码 E 包含了阶符，用移码来表示，不过这里移码的偏移量不是 2 的整次幂，而是要再减去 1。 假设阶码 E 的位数为 m + 1，那么偏移量就是 2^m - 1。\n尾数 M 是原码表示的纯小数。\n\n​        浮点数的位数不同，可以表示不同的数值范围和精度。IEEE 标准中常用的浮点数有三种：短浮点数（单精度）、长浮点数（双精度）和临时浮点数（延伸双精度）。\n\n​    以 32 位的单精度浮点数为例，所有的机器码和对应的取值范围如下：\n\n\n​    例如，对于十进制数 178.125，把它写成 IEEE 标准的短浮点数。\n​        我们需要分整数部分和小数部分，首先转换成二进制数的表示；然后写成类似 “科学计数法” 的二进制浮点数表达。\n\n​    这是一个正数，符号位为 0；然后从二进制浮点表达中得到阶码和尾数。将 8 位二进制阶码加上偏移量 127，尾数隐藏整数位的 1 后补成 23 位，就是最终符合 IEEE 标准的 32 位短浮点数。\n\n​    \n2.4.2 浮点数的加/减运算​    （1）对阶\n​        对阶的目的是使两个操作数的小数点位置对齐，使两个数的阶码相等。先求阶差，然后以 “小阶向大阶看齐” 的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。\n​    （2）尾数求和\n​        将对阶后的尾数，按定点数加/减运算规则运算。\n​    （3）规格化\n​        IEEE 754 规格化尾数的形式为 ±1.×…×，所以当计算结果为非规格化数时，需要进行规格化处理。\n\n左规：当结果为 ±0.0…01x…x 时，需进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1移到小数点左边。\n右规：当结果为 ±1x.x…x 时，出现了尾数的溢出，需进行右规。尾数右移一位，阶码加 1。当尾数右移时，最高位 1 被移到小数点前一位作为隐藏位；当最后一位移出时，要考虑舍入。\n\n​        左规一次相当于乘以2，右规一次相当于除以2；需要右规时，只需进行一次。\n​    （4）舍入\n​        在对阶和尾数右规时，尾数右移可能会将低位丢失，影响精度，IEEE 754有以下4种舍入方式：\n\n就近舍入：舍入为最近的那个数，类似于 “四舍五入”，一般被叫做 “ 0 舍 1 入” 法；如果被舍入的值恰好是 100…0 形式，选择舍入为最近的偶数；\n正向舍入：向 +∞ 方向舍入，即取右边那个数，也叫 “向上舍入”；\n负向舍入：向 -∞ 方向舍入，即取左边那个数，也叫 “向下舍入”；\n截断：朝 0 方向舍入，即取绝对值较小的那个数。\n\n​    （5）溢出判断\n​        浮点数的溢出，并不是以尾数溢岀来判断的；尾数溢出可以通过右规操作得到纠正。运算结果是否溢出，主要看结果的指数是否发生了溢出，因此是由阶码来判断的。\n\n若一个正阶码超出了最大允许值（127 或 1023），则发生上溢，产生异常；\n若一个负阶码超出了最小允许值（-149 或 -1074），则发生下溢，通常把结果按机器零处理。\n\n\n​        例如，两个数 x = 29/32 × 210，y = 5/8 × 25，用浮点加法计算 x + y。假设浮点数的阶码和尾数均用补码表示，且阶码为 5 位（含 2 位阶符），尾数为 7 位（含 2 位数符）。\n​        首先，将浮点数写成下面的规格化二进制形式：\n​        x = 0.11101 × 2111，y = 0.101 × 2101\n​        具体计算过程如下：\n​        （1）对阶\n​        阶码相减 00, 111 - 00, 101 = 00, 010，说明 x 的阶码比 y 的大 2，需要将 y 的尾数右移两位，阶码加 2：\n​        y = 0.00101 × 2111\n​        （2）尾数求和\n​        尾数相加 00.11101 + 00.00101 = 01.00010\n​        （3）规格化\n​        运算结果的尾数出现溢出，需要进行右规：尾数右移一位，阶码加 1：\n​        1.00010 × 22111 = 0.100010 × 221000，即计算结果为 01, 000; 00, 10001\n​        （4）舍入\n​        结果的尾数用补码表示为：00 10001，不需要舍入。\n​        （5）溢出判断\n​        结果的阶码用补码表示为：01 000，由于阶符为 01，说明结果溢出。\n\n2.5 数据的存储和排列2.5.1 数据按“边界对齐”方式存储​        可以假设字长为 32 位，可按字节、半字、字寻址。在对准边界的 32 位计算机中，半字地址是 2 的整数 倍，字地址是 4 的整数倍，当所存数据不满足此要求时，可填充一个或多个空白字节。这种存储方式称为 “边界对齐” 。这样无论所存的数据是字节、半字还是字，均可一次访存取出。虽然浪费了一些存储空间，但可提高存取速度。\n​        数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能取得所需数据，从而影响系统的效率。\n\n\n在 C 语言的 struct 类型中，边界对齐方式存储有两个重要要求：\n​        （1）每个成员按其类型的方式对齐，比如 char 类型的对齐值为 1，short 为 2，int 为 4（单位为字节）。\n​        （2）struct 的长度必须是成员中最大对齐值的整数倍（不够就补空字节），以便在处理 struct 数组时保证每项都满足边界对齐的条件。\n​        例如，下面是两个成员完全一样的结构体：\n12345678910struct A &#123;\tint i;\tchar c;\tshort s;&#125;struct B &#123;\tchar c;\tint i;\tshort s;&#125;\n​        但两者在内存中占据的空间却不同。这是因为结构体成员是按定义的先后顺序排列的，编译器要使它们在空间上对齐，所以应该有：\n​        每个成员存储的起始地址 ％ 该成员的长度 = 0\n​        同时，还需要让结构体的长度是最大成员长度的整数倍。\n\n2.5.2 数据的“大端方式”和“小端方式”存储​        在存储数据时，通常用 最低有效字节（LSB）和 最高有效字节（MSB）来分别表示数据的低位和高位。例如，在 32 位机器中定义了一个 int 类型的变量 i，机器数为 18 0B C5 F3H，那么它的 MSB = 18H，LSB = F3H。\n​        现代计算机基本都采用字节编址，也就是每个地址编号对应存放 1 个字节。不同类型的数据占用的字节数不 同，而程序中对每个数据只给定一个地址。变量 i 占据连续的四个字节，它们各有一个内存地址，而变量 i 的地址就是开始的那个字节的地址。假设 i 的地址为 6C 00H，那么 i 具体存放的四个字节的地址就是：6C 00H、6C 01H、6C 02H、6C 03H。而具体每个字节存放什么内容，可以有不同的定义方式。\n​        多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，分为两种排列方式：大端方式（big endian）和 小端方式（little endian）。\n\n\n大端方式：先存储高位字节，后存储低位字节。高位字节存储在低位地址中，字中的字节顺序和原序列相同。\n\n\n小端方式：先存储低位字节，后存储高位字节。低位字节存储在低位地址中，字中的字节顺序和原序列相反。\n\n2.6 章节练习一、单项选择题​    1. 【2018真题】冯·诺伊曼结构计算机中的数据采用二进制编码表示，其主要原因是（  ）。\n​        I. 二进制的运算规则简单                II. 制造两个稳态的物理器件较容易\n​        III. 便于用逻辑门电路实现算术运算\n​        A. 仅 I、II                B. 仅 I、III                C. 仅 II、III                D. I、II 和 III\n​        答案： D\n\n【 2015真题】由 3个“1”和 5个“0”组成的8位二进制补码，能表示的最小整数是  （   ）。\n\n​        A． -126                B． -125                C． -32                D． -3\n​        答案：B\n\n【2022真题】32 位补码所能表示的整数范围是    （   ）。\n\n​        A. -232~231-1         B. -231~231-1         C. -232~232-1         D. -231~232-1 \n​        答案：B\n\n【2021真题】已知带符号整数用补码表示，变量 x、y、z 的机器数分别为 FFFDH、FFDFH、7FFCH，下列结论中，正确的是    （   ）。\n\n​        A. 若x、y和z为无符号整数,则z&lt;x&lt;y        B. 若x、y和z为无符号整数,则x&lt;y&lt;z\n​        C. 若x、y和z为带符号整数,则x&lt;y&lt;z        D. 若x、y和z为带符号整数,则y&lt;x&lt;z\n​        答案：D\n​    5. 【2016真题】有如下 C 语言程序段 \n12short si = -32767;unsigned short usi = si;\n​        执行上述两条语句后， usi 的值为     （   ）。\n​        A． -32767         B． 32767         C． 32768         D． 32769 \n​        答案：D\n​    6. 【2019真题】考虑以下 C 语言代码： \n12unsigned short usi = 65535;short si = usi;\n​        执行上述程序段后， si 的值是     （   ）。 \n​        A．-1         B．-32767         C．-32768         D．-65535 \n​        答案：A\n​    7. 【2012真题】假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，执行下列 C 语言语句： \n12unsigned short x=65530;unsigned int y=x;\n​        得到 y 的机器数为     （   ）。\n​        A． 0000 7FFAH       B． 0000 FFFAH         C． FFFF 7FFAH         D． FFFF FFFAH\n​        答案：B\n\n【2009真题】一个 C 语言程序在一台 32 位机器上运行。程序中定义了三个变量 x、 y 和 z，其中 x 和 z 为 int 型， y 为 short 型。当 x=127， y=-9 时，执行赋值语句 z=x+y 后， x、 y 和 z 的值分别是 （   ）。\n\n​    A． x=0000007FH， y=FFF9H， z=00000076H            B． x=0000007FH， y=FFF9H， z=FFFF0076H​    C． x=0000007FH， y=FFF7H， z=FFFF0076H            D． x=0000007FH， y=FFF7H， z=00000076H \n​    答案：D\n​    9. 【2018真题】整数x的机器数为1101 1000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各    是    （   ）。\n​    A.1110 1100、1110 1100                B. 0110 1100、1110 1100\n​    C.1110 1100、0110 1100                D. 0110 1100、 01101100\n​    答案：B\n\n【2013真题】某字长为 8 位的计算机中，已知整型变量 x、y的机器数分别为$[x]_补=1 {\\quad} 1110100，[y]补=1 {\\quad}0110000$。若整型变量 $z=2*x+y/2$，则 z 的机器数为    （   ）。\n\n​    A.  1 1000000            B.  0 0100100            C.  1 0101010            D.  溢出\n​    答案：A\n\n【2018真题】假定带符号整数采用补码表示，若 int 型变量 x 和 y 的机器数分别是 FFFF FFDFH 和 0000 0041H，则 x、y 的值以及 x-y 的机器数分别是    （   ）。\n\n​    A.x=-65，y=41，x-y 的机器数溢出                                B.x=-33，y=65，x-y 的机器数为FFFF FF9DH\n​    C.x=-33，y=65，x-y 的机器数为FFFF FF9EH                D. x = -65，y = 41，x-y 的机器数为FFFF FF96H \n​    答案：C\n\n【2016真题】某计算机字长为 32 位，按字节编址，采用小端（Little Endian）方式存放数据。假定有一个 double 型变量，其机器数表示为 1122 3344 5566 7788H，存放在 0000 8040H 开始的连续存储单元中，则存储单元 0000 8046H 中存放的是     （   ）。\n\n​    A． 22H                     B． 33H                     C． 66H                     D． 77H \n​    答案：A\n\n【2018真题】某32位计算机按字节编址，采用小端(Little Endian)方式。若语句 “inti=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00 00”，则语句 “int i = -64;” 对应指令的机器代码是    （   ）。\n\n​    A.C7 45 FC C0 FF FF FF        B.C7 45 FC 0C FF FF FF        C.C7 45 FC FF FF FF C0        D.C7 45 FC FF FF FF 0C\n​    答案：A\n\n【2012真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 型和 short型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下： \n\n123456struct&#123;\tint a;\tchar b;\tshort c;&#125; record;record.a=273;\n​        若 record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址分别为     （   ）。\n​    A. 0x00、 0xC00D         B. 0x00、 0xC00E        C. 0x11、 0xC00D         D. 0x11、 0xC00E \n​    答案：D\n\n【2020真题】在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C语言结构型变量a分配存储空间。\n\n1234Struct record&#123;\tshort   x1;\tint   x2;&#125; a;\n​        若a的首地址为 2020 FE00H，a的成员变量x2的机器数为1234  0000H，则其中34H所在存储单元的地址是    （   ）。\n​    A. 2020 FE03H                B. 2020 FE04H                C.2020 FE05H                D. 2020 FE06H\n​    答案：D\n\n【2012真题】 float 类型（即 IEEE754 单精度浮点数格式）能表示的最大正整数是     （   ）。\n\n​    A． 2126-2103               B． 2127-2104               C． 2127-2103               D． 2128-2104\n​    答案：D\n\n【2013真题】某数采用 IEEE 754 单精度浮点数格式表示为C640 0000H，则该数的值是    （   ）。\n\n​    A. $-1.5×2^{13}$                B. $-1.5 × 2^{12}$                C. $-0.5×2^{13}$                D. $-0.5×2^{12}$\n​    答案：A\n\n【2014真题】ﬂoat 型数据常用 IEEE 754 单精度浮点格式表示。 假设两个 ﬂoat 型变量 x 和 y 分别存放在32位寄存器 f1 和 f2 中，若(f1)=CC90 0000H, (f2)= B0C0 0000H, 则 x 和 y 之间的关系为    （   ）。\n\n​    A. xy且符号相同           D. x&gt;y且符号不同\n​    答案：A\n\n【2015真题】下列有关浮点数加减运算的叙述中，正确的是    （   ）。Ⅰ ．对阶操作不会引起阶码上溢或下溢Ⅱ ．右规和尾数舍入都可能引起阶码上溢Ⅲ．左规时可能引起阶码下溢Ⅳ．尾数溢出时结果不一定溢出\n\n​    A．仅Ⅱ 、 Ⅲ                 B． 仅Ⅰ 、 Ⅱ 、 Ⅳ                C．仅Ⅰ 、 Ⅲ、 Ⅳ                D． Ⅰ 、 Ⅱ 、 Ⅲ、 Ⅳ \n​    答案： D\n\n【2018真题】IEEE 754 单精度浮点格式表示的数中，最小的规格化正数是    （   ）。\n\n​    A.1.0x2-126                    B. 1.0x2-127                    C.1.0x2-128                    D.1.0x2-149\n​    答案：A\n\n【2020真题】已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H时，x 的值可能是    （   ）。\n\n​    A.-7x227                        B.-216                        C. 217                        D. 25x227\n​    答案：A\n\n【2021真题】下列数值中,不能用 IEEE 754 浮点格式精确表示的是    （   ）。\n\n​    A.1.2                                B.1.25                                C.2.0                                    D.2.5\n​    答案：A\n\n【2022真题】-0.4375 的 IEEE 754 单精度浮点数表示为（ ）。\n\n​    A. BEE0 0000H             B. BF60 0000H             C. BF70 0000H             D. C0E0 0000H \n​    答案：A\n二、综合应用题\n【2020真题】有实现 x*y 的两个 C 语言函数如下:\n\n12unsigned umul (unsigned x, unsigned y)&#123;return x*y; &#125;int imul (int x,int y) &#123;return x* y;&#125;\n​    假定某计算机 M 中 ALU 只能进行加运算和逻辑运算。请回答下列问题。\n​    （1）若 M 的指令系统中没有乘法指令，但有加法、减法和位移等指令，则在 M 上也能实现上述两个函数中的乘法运算，为什么?\n​    （2）若 M 的指令系统中有乘法指令，则基于 ALU、位移器、寄存器以及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么?\n​    （3）针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令；c）有使用阵列乘法器实现的乘法指令，函数 umul() 在哪种情况下执行时间最长？哪种情况下执行的时间最短？说明理由。\n​    （4）n 位整数乘法指令可保存 2n 位乘积，当仅取低 n 位作为乘积时，其结果可能会发生溢出。当 n=32、x=231-1、y=2 时，带符号整数乘法指令和无符号整数乘法指令得到的 x*y 的 2n 位乘积分别是什么（用十六进制表示）？此时函数 umul() 和 imul() 的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低 n 位作为乘法结果时，如何用 2n 位乘积进行溢出判断？\n​    答案：\n​    （1）编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法、移位等指令实现乘法运算。\n​    （2）控制逻辑的作用为： 控制循环次数，控制加法和移位操作。\n​    （3）a）最长， c）最短。\n​        对于 a）， 需要用循环代码段（软件）实现乘法操作，因而需反复执行很多条指令， 而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长； 对于 b）和 c）， 都只要用一条乘法指令实现乘法操作，不过， b）中的乘法指令需要多个时钟周期才能完成，而 c）中的乘法指令可以在一个时钟周期内完成， 所以 c）执行时间最短。\n​    （4）当 n=32、 x=231-1、 y=2 时，带符号整数和无符号整数乘法指令得到的 64 位乘积都为 0000 0000 FFFF FFFEH。\n​        函数 imul 的结果溢出，而函数 umul 结果不溢出。对于无符号整数乘法，若乘积高 n 位全为 0， 则不溢出，否则溢出。\n【2017真题】 已知\n\n计算 f(n) 的 C 语言函数 f1 如下： \n12345678int f1(unsigned n)&#123;\tint sum=1, power=1;\tfor(unsigned i=0;i&lt;=n-1;i++)&#123;\t\tpower *= 2;\t\tsum += power;\t&#125;\treturn sum;&#125;\n​        将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位， float 采用 IEEE 754 单精度标准。请回答下列问题。\n​    （1）当 n=0 时， f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为什么？\n​    （2）f1(23) 和 f2(23) 的返回值是否相等？机器数各是什么（用十六进制表示）？\n​    （3）f1(24)和 f2(24)的返回值分别为 33 554 431 和 33 554 432.0， 为什么不相等？\n​    （4）f(31)=232-1， 而 f1(31) 的返回值却为 -1，为什么？若使  f1(n) 的返回值与 f(n) 相等，则最大的 n 是多少？\n​    （5）f2(127) 的机器数为 7F80 0000H， 对应的值是什么？若使 f2(n) 的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？ \n​        答案：\n​    （1）由于 i 和 n 是 unsigned 型，故“i&lt;=n-1”是无符号数比较； n=0 时， n-1 的机器数为全1，值是 232-1，为 unsigned 型可表示的最大数，条件“i&lt;=n-1”永真，因此出现死循环。\n​        若 i 和 n 改为 int 类型，则不会出现死循环。因为“i&lt;=n-1”是带符号整数比较， n=0 时， n-1 的值是-1，当 i=0 时条件“i&lt;=n-1”不成立，此时退出 for 循环。\n​    （2）f1(23)与 f2(23)的返回值相等。\n​        f(23) = 223+1-1 = 224-1，它的二进制形式是 24 个1。 int 占 32 位，没有溢出。 float 有 1 个符号位， 8 个指数（阶码）位， 23 个底数（尾数）位， 23 个底数位可以表示 24 位的底数。所以两者返回值相等。\n​        f1(23)的机器数是 00FF FFFFH；f2(23)的机器数是 4B7F FFFFH。显而易见前者是 24 个 1，即 0000 0000 1111 1111 1111 1111 1111 1111（2），后者符号位是 0，指数位为 23+127(10) = 1001 0110（2），底数位是 111 1111 1111 1111 1111 1111（2）。\n​    （3）当 n=24 时， f(24) = 1 1111 1111 1111 1111 1111 1111 B，而 float 型数只有 24 位有效位，舍入后数值增大，所以 f2(24) 比 f1(24) 大 1。\n​    （4）f(31) 已超出了 int 型数据的表示范围，用 f1(31) 实现时得到的机器数为 32 个 1，作为 int 型数解释时其值为-1，所以 f1(31) 的返回值为-1。 \n​        因为 int 型最大可表示数是 0 后面加 31 个 1，故使 f1(n)的返回值与 f(n)相等的最大 n 值是 30。\n​    （5） f2 返回值为 float 型，7F80 0000H 中数符为0，阶码全为1，尾数为0。IEEE 754 标准用“阶码全 1、尾数全 0”表示无穷大。所以机器数 7F80 0000H 对应的值是+∞。\n​        当 n=126 时， f(126) = 2127-1 = 1.1…1×2126，对应阶码为 127+126=253，尾数部分舍入后阶码加 1，最终阶码为 254，是 IEEE 754 单精度格式表示的最大阶码。故使 f2 结果不溢出的最大 n 值为 126。\n​        当 n=23 时， f(23) 为 24 位 1， float 型数有 24 位有效位，所以不需舍入，结果精确。所以使 f2 获得精确结果的最大 n 值为 23。\n第三章 存储器3.1 本章大纲要求与核心考点3.1.1 大纲内容（一）存储器的分类\n（二）层次化存储器的基本结构\n（三）半导体随机存储器\n\nSRAM 存储器\nDRAM 存储器\nFlash 存储器\n\n（四）主存储器\n\nDRAM 芯片和内存条\n多模块存储器\n主存和CPU之间的连接\n\n（五）外部存储器\n\n磁盘存储器\n固态硬盘（SSD）\n\n（六）高速缓冲存储器（Cache）\n\nCache 的基本工作原理\nCache 和主存之间的映射方式\nCache 中主存块的替换算法\nCache 写策略\n\n（七）虚拟存储器\n\n虚拟存储器的基本概念\n\n页式虚拟存储器\n基本原理，页表，地址转换，TLB（快表）\n\n段式虚拟存储器\n\n段页式虚拟存储器\n\n\n3.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n半导体存储芯片的特性、工作原理、扩展技术及与 CPU 的连接，多模块存储器的原理。\n磁盘存储器的原理、特点、性能指标，RAID 的原理，固态硬盘的特点和原理。\n程序访问的局部性原理，Cache 的工作原理及性能计算，Cache 和主存的三种映射方式的原理、 特点、地址结构、访存过程，Cache 替换算法（常考 LRU） , Cache 写策略，Cache 块中的标记项。\n虚拟存储器的基本原理，页表机制（二级页表结合操作系统考查），快表的原理，具有快表和 Cache 的多级页式存储系统的工作原理（综合性较强），段式和段页式虚拟存储器的基本原理。\n\n3.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          高速缓冲存储器（Cache）\n          12\n          9\n      \n      \n          虚拟存储器\n          5\n          9\n      \n      \n          半导体存储器\n          6\n          1\n      \n      \n          主存的扩展及与 CPU 的连接\n          6\n          1\n      \n      \n          磁盘存储器\n          4\n          0\n           \n      \n          低位交叉存储器\n          2\n          1\n      \n  \n\n\n\n\n\n\n\n3.2 存储器概述3.2.1 存储器的分类​        \n\n1. 按存储介质分类​        存储介质是指能寄存“0”、“1”两种代码并能区别两种状态的物质或元器件。存储介质主要有半导体器件、磁性材料和光盘等。\n\n半导体存储器\n\n​        存储元件由半导体器件组成的存储器称为半导体存储器。现代半导体存储器都用超大规模集成电路工艺制成芯片，其优点是体积小、功耗低、存取时间短。\n​        半导体存储器又可按其材料的不同， 分为双极型（TTL）半导体存储器和 MOS 半导体存储器两种。前者具有高速的特点；后者具有高集成度的特点，并且制造简单，成本低廉，功耗小，所以 MOS 半导体存储器被广泛用。\n\n磁性材料存储器\n\n​        磁性材料存储器主要依靠磁性材料作为记录的介质，是不易失的永久记忆存储器。又可以分为磁表面存储器和磁芯存储器。\n​        磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。按载磁体形状的不同，可分为磁盘、磁带和磁鼓。\n​        磁芯是由硬磁材料做成的环状元件，在磁芯中穿有驱动线(通电流)和读出线，这样便可进行读/写操作，这种存储器称为磁芯存储器。磁芯属磁性材料，故它也。不过，磁芯存储器的体积过大、工艺复杂、功耗太大，目前几乎已不被采用。\n\n光盘存储器\n\n​        光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器，具有非易失性的特点。光盘具有记录密度高、耐用性好、可靠性高和可互换性强等特点。\n2. 按存取方式分类​        按存取方式可把存储器分为随机存储器、只读存储器、顺序存取存储器和直接存取存储器。\n\n随机存储器（Random Access Memory， RAM）\n\n​        RAM是一种可读/写存储器， 其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        由于存储信息原理的不同， RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充放电原理寄存信息）。\n\n只读存储器（Read Only Memory， ROM）\n\n​        只读存储器是能对其存储的内容读出，而不能对其重新写人的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写人新的信息去改变原始信息。\n​        所以 ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n\n串行访问存储器\n\n​        如果对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器，也称为顺序存取存储器。显然这种存储器由于信息所在位置不同，使得读/写时间均不相同，比如磁带存储器就是一种顺序存取存储器。\n\n直接存取存储器\n\n​        还有一种属于部分串行访问的存储器，比如磁盘。在对磁盘读/写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，称为直接存取存储器。\n3. 按在计算机中的作用分类​        按在计算机系统中的作用不同，存储器可以分为主存储器、辅助存储器、缓冲存储器。\n\n主存储器（简称主存）：用来存放程序和数据，可以和CPU直接交换信息。\n\n辅助存储器（简称辅存）：主存储器的后援存储器， 用来存放当前暂时不用的程序和数据， 它不能与CPU直接交换信息。两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。\n\n缓冲存储器（简称缓存，Cache） 用在两个速度不同的部件之中。\n\n\n\n3.2.2 存储器的性能指标1.存储速度​    （1）存取时间\n​        要想衡量存储速度，最直观的指标就是完成一次存储器读/写操作所需要的时间，这叫做 存取时间，又称为 访问时间（Memory Access Time）。\n​        存取时间又分为读出时间和写入时间。读出时间是从存储器接受到有效地址开始，到产生有效输出所需的全部时间；写入时间是从存储器接受到有效地址开始，到数据写入被选中存储单元为止的全部时间。\n​    （2）存储器周期\n​        存储器周期 （Memory Cycle Time）指连续进行两次独立的存储器操作（读或者写）需要的最小时间间隔，也叫 存取周期。需要注意的是，存储器周期并不等同于完成一次读写操作的时间，而是要更大；因为存储器经过一次读写操作后，并不能立即进行下一次读写，中间还需要一段时间来恢复内部状态。所以，\n​                                                            存储器周期 = 存取时间 + 恢复时间\n​    （3）存储器带宽\n​        一般来说，存储器周期越短，存储器的速度就越快；这前提是存储器的每次读写操作处理的数据位数相同。通常情况下，存储器每次读写的位数是跟存储字长相关的，字长越长，一个存取周期处理的数据就越多。\n​        所以可以用 数据传输率 来表示存储速度，而 存储器带宽 就是衡量数据传输率重要指标。存储器带宽指单位时间内存储器存取的数据量。单位为位/秒（b/s），或者字节/秒（B/s）、字/秒。\n​                                                            存储器带宽 = 数据宽度 / 存储周期\n​        例如，存储器周期为 500 ns，每个存取周期可以访问 16 位，那么带宽就是：\n​                                                                16 bit ÷ 500 ns = 32 Mb/s\n2. 存储容量​        存储容量指存储器能存放的数据总量，一般用二进制代码的总位数（bit）来表示。\n​                                                    存储容量 = 存储字数 × 存储字长\n​        存储字数代表了存储器地址空间的大小，由地址线的位数决定。容量一般也可以用字节总数（Byte）来表示，也就是：\n​                                            存储容量（字节数） = 存储字数 × 存储字长 / 8\n​        例如，某机器存储字长为 8 位，地址线有 28 位，那么它的主存最大存储容量为：\n​                                                        2^28^ × 8 / 8 = 2^28^ B = 256 MB\n3. 位价​        每位价格也就是存储器的单位成本。\n​                                                    位价 = 总成本 / 总容量\n​        一般来说，速度越高，位价就越高；容量越大，位价就越低；而且容量越大，速度也会越低。\n3.2.3 层次化存储器的基本结构​        \n\n\n寄存器通常都制作在 CPU 芯片内。寄存器中的数直接在 CPU 内部参与运算， CPU 内可以有十几个、几十个寄存器，它们的速度最快，位价最高，容量最小。\n主存用来存放将要参与运行的程序和数据，它与 CPU 速度差距较大。\n为了使主存和 CPU 之间速度更好地匹配， 需要在主存与 CPU 之间插入一种比主存速度更快、容量更小的高速缓冲存储器 Cache，其位价要高于主存。\n\n\n\n缓存-主存层次\n\n​        这一层次主要解决 CPU 和主存速度不匹配的问题。由于缓存的速度比主存的速度高， 只要将CPU近期要用的信息调人缓存， CPU 便可以直接从缓存中获取信息， 从而提高访存速度。但由于缓存的容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换掉。主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。\n\n主存-辅存层次\n\n​        这一层次主要解决存储系统的容量问题。辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息， 但它的容量比主存大得多， 可以存放大量暂时未用到的信息。当CPU需要用到这些信息时， 再将辅存的内容调人主存， 供CPU直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的。\n3.3 半导体存储器​        半导体存储器分为 随机存取存储器（RAM）和 只读存储器（ROM）。\n​        RAM 是一种可读/写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        RAM 按照存储信息的原理不同，又可以分为静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM），主存储器主要由 DRAM 实现，靠近处理器的那一层缓存 （Cache）则由 SRAM 实现，它们都是易失性存储器。ROM 是非易失性存储器。\n\n主存中各个存储单元的空间位置，是由一个地址号来表示的；通过地址总线可以给定一个存储单元的地址号，从而根据地址读出或者写入一个存储字。\n\n译码驱动：将地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作。\n读/写电路：包括读出放大器和写入电路，用来完成读/写操作。\n\n​        存储芯片通过地址总线、数据总线和控制总线与外部连接。地址线和数据共同反映了芯片的存储容量。比如，10 根地址线，4 根数据线，表示芯片的存储容量为：2^10^ × 4 = 4 Kb。\n\n地址线是单向输入的，其位数与芯片存储容量有关。\n数据线是双向输入的，其位数与芯片每次可读出或写入的数据位数有关，从而也影响到存储容量。\n控制线包括了读/写控制线和片选线。读/写控制线决定芯片进行的具体操作，片选线用来选择芯片。\n\n\n半导体存储芯片的译码驱动，主要有两种方式：线选法 和 重合法。\n\n线选法：是用一根字选择线（字线），直接选中一个存储单元的各位。这种方式结构比较简单，不过只适合用于容量不大的存储芯片。\n\n采用线选法译码驱动的存储芯片结构示意图。这个芯片有 8 位地址线和 8 位数据线，所以有 28 = 256 个存储字，需要 256 根字线来实现选中每个存储字。\n\n\n重合法：用两个方向的地址，共同决定选中存储矩阵中的一个存储单元。相比 “一维” 的线选法，重合法就升级到了 “二维”，可以用更少的选择线实现对所有存储单元的选择。\n\n使用 X、Y 两个方向的地址译码器分别对 4 位地址进行译码，只需要两个方向各 16 根选择线，就可以直接选中 16 × 16 存储矩阵中的每一位。\n\n3.3.1 SRAM​        通常把存放一个二进制位的物理器件称为存储元，它是存储器最基本的构件。地址码相同的多个存储元构成一个存储单元。存储单元的集合构成存储体。\n​        静态 RAM（Static RAM，SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此信息被读出后，它仍保持其原状态而不需要刷新；这种读特性被称为“非破坏性读出”。\n\n下面是 Intel 2114 RAM 芯片的存储矩阵结构示意图。2114 芯片有 10 根地址线，其中 6 根行地址线、4 根列地址线，存储矩阵由 64 × 64 个基本单元电路组成，总容量为 1K × 4 位。\n\nSRAM 使用触发器工作原理存储信息，因此在读出信息后，它仍会保持原来的状态，不需要刷新。不过如果电源掉电，存储的信息就会丢失，所以它属于易失性半导体存储器。\n​        SRAM 的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于 Cache。\n3.3.2 DRAM​        动态 RAM（Dynamic RAM，DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的。若电容上存有足够多的电荷表示存 “1”，电容上无电荷则表示存 “0”。\n​        常见的动态 RAM 基本单元电路有三管式和单管式两种。单管式只需要一个 MOS 管和一个电容，因此可以极大地提高集成度。\n\n可以看到，DRAM 的基本存储元可以只使用一个晶体管, 所以它比 SRAM 的密度要高很多。为了进一步提高集成度，DRAM 采用 地址复用技术，地址信号分行、列两次传送，这样地址线是原来的一半，地址引脚数也可以减少一半，就能够进一步减小芯片的体积。\nDRAM 通过DRAM 接口把地址一分为二，然后利用两个连续的时钟周期传输地址数据。这样就达到了芯片上使用一半的针脚实现同SRAM 同样的功能的目的，但内部地址线数实际不变，逻辑上减半。\n\n​      \n​       下面是 Intel 4116 RAM 芯片的整体结构和存储矩阵示意图。4116 芯片的存储矩阵为 128 × 128，共有 16 K 个单管 MOS 基本单元电路，容量为 16K × 1 位。本来芯片应该有 14 根地址线，不过为了减少芯片封装的引脚数，地址线只有 7 根。这就需要将完整的地址信息分成行地址、列地址两部分（各自 7 位），分两次传送。\n\n\n​        相对 SRAM 来说，DRAM 具有容易集成、价位低、容量大和功耗低等优点，但 DRAM 的存取速度比 SRAM慢，一般用于大容量的主存系统。\nDRAM 的刷新​        由于电容上的电荷一般只能维持1 ~2ms，因此即使电源不掉电，信息也会自动消失。为此，必须在 2ms 内对所有存储单元恢复一次原状态，这个过程称为 再生 或者 刷新。\n​        刷新的过程，实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。由于存储单元是被随机访问的，有些存储单元可能一直不会被访问，因此其存储的原信息将会慢慢消失。因此，必须进行定时刷新。一般要求在一定的时间内，对动态 RAM 的全部基本单元必须作一次刷新，这个时间称为 刷新周期，也叫 再生周期，一般取 2ms。\n​        通常有三种刷新方式：集中刷新、分散刷新和异步刷新。\n​    （1）集中刷新\n​        在规定的一个刷新周期内，对全部存储单元集中一段时间进行逐行刷新；刷新时必须停止读/写操作。\n​        例如，我们有一个芯片的存储矩阵为 128 × 128，它的存取周期为 0.5 μs，刷新周期为 2 ms（4000 个存取周期），那么对它的 128 行存储单元进行集中刷新需要：\n​                                                                        0.5 μs × 128 = 64 μs\n​        那剩余的 1936 μs（3872个存取周期）就可以用来读/写或者维持信息。由于在这 64 μs 内无法进行读/写操作，所以这段刷新时间被称为 “死时间”，也叫访存 “死区”。死时间占据存取周期的比例 64 μs / 2 ms × 100% = 3.2%，称为死时间率。\n\n2）分散刷新\n​        对每行存储单元的刷新，分散到每个存取周期内完成。这样，每个存储周期 tC 就分成了两段：前半段 tM用来读/写或者维持信息，后半段 tR 用来刷新。所以：\n​                                                                                    tM = tM + tR\n​        同样以 128 × 128 存储矩阵的芯片为例，读/写周期 tM = tR = 0.5 μs，那么存取周期 tC = 1 μs。逐行进行刷新，每隔 128 μs 就可以将存储芯片全部刷新一遍。\n\n这样的好处是不存在停止读/写操作的死时间，而且刷新间隔比要求的刷新周期 2ms 短得多；缺点在于存取周期 tC 变长了，使得整个系统速度变慢。 \n​    （3）异步刷新\n​        异步刷新是前两种方式的结合，它既可以缩短 “死时间”，又能充分利用最大的刷新间隔 2ms。\n​        还是之前的例子，对于 128 × 128 存储矩阵的芯片，存取周期 tC = 0.5 μs，可以让它把对 128 行的刷新平均分配到 2ms 的刷新周期内。也就是说，每隔 2ms ÷ 128 ≈ 15.6 μs 刷新一行，每次刷新的时间还是一个存取周期 tR = 0.5 μs。\n\n这样一来，2ms 内用于刷新的时间仍然是 128 tR = 64 μs，而由于分散到了整个刷新周期内，每次刷新一行只停了一个存取周期；所以对于每行来说，刷新的间隔还是 2ms，而 “死时间” 缩短为 0.5 μs。\n​        如果将 DRAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不会访问存储器，所以这样就完全避免了 “死时间” 的问题，从根本上提高了机器效率。\nDRAM 和 SRAM 的比较​        目前，随着 DRAM 的容量不断扩大，速度不断提高，它的应用要比 SRAM 更加广泛。DRAM 主要用在计算机的主存中，而 SRAM 通常用于容量不大的高速缓存（Cache）中。\n​        两者的特点可以比较如下：\n\n3.3.3 ROM​        ROM （Read Only Memory）最原始的定义是 “只读存储器”，一旦写入原始信息后就不能更改。所以ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n​        不过随着用户的需要和技术的发展，又出现了更多类型的 ROM，让用户拥有了修改数据的能力。\n​        根据制造工艺不同，ROM 可分为固定掩模型 ROM（MROM）、一次可改写 ROM （PROM）、紫外线擦除电可编程 ROM（EPROM）、电擦除电可编程 ROM （EEPROM）、快擦写（Flash）存储器。\n​    \n​        SRAM、DRAM 和 ROM 这 3 种存储器的特点可以总结如下。\n\n3.4 主存储器3.4.1 主存储器的基本组成​        主存储器简称主存或内存，是计算机中存储程序和数据的重要部件。主存内包含了存储体、各种逻辑部件以及控制电路等。\n​        主存是通过按地址访问的方式，对存储体内的存储单元进行读写操作的。因此主存首先需要从 MAR 中获取地址，由译码器进行地址译码、再经过驱动电路，进而通过选择线选中所需访问的单元。读出时，需要经过读出放大器才能将被选中存储单元的内容送到 MDR；写入时，MDR 中的数据也需要经过写入电路才能真正存入被选中的单元。所以主存实际结构的基本组成如下：\n\n译码器、驱动器和读写电路都集成在 DRAM 存储芯片中，而 MAR 和 MDR 则集成在 CPU 芯片内。存储芯片可以通过总线与 CPU 相连。\n\n当要从主存中读某个数据字时，首先由 CPU 将字的地址送到 MAR，通过地址总线送至主存，然后发出读命令；主存的译码器将地址总线送来的地址译码，导通对应存储单元的选择线，收到读信号后，便将该单元的内容送到数据总线上，进而交给 MDR。\n​        如果要向主存写入一个数据字，仍然需要 CPU 先把地址送到 MAR，并把要写的数据送到 MDR，然后发出写命令；主存译码器依然从地址总线读取地址进行译码，接到写命令后，就把数据线上的信息写入对应的存储单元。\n主存中地址的分配​        主存中各存储单元的空间位置，都是由存储单元的地址号表示的；地址总线的作用就是给出要访问的存储单元的地址。每次访问存储单元，可以读出或者写入一个存储字。\n​        存储字长必须是字节（8位）的整数倍，不同机器的存储字长不同。计算机一般既可以按字来寻址，也可以按字节寻址。例如，一台机器的存储字长为 32 位，并且可以按字节寻址，那么它的每个存储字都包含了 4 个具有独立地址的字节，地址的分配方式如下：\n\n如果这台机器的地址线为 24 位，那么按字节寻址的范围是 2^24^ = 16M，按字寻址的范围为 16M / 4 = 4 M。\n3.4.2 主存和 CPU 之间的连接1. 主存容量扩展​        单片存储芯片的容量有限，所以主存需要将多个存储芯片连在一起扩展成更大的存储器。这称为 存储容量的扩展，主要的方法有 位扩展 和 字扩展。\n（1）位扩展\n​        位扩展是指对字长进行扩展，也就是增加存储字长。这种情况下，系统地址线位数等于芯片地址线位数，而系统数据线位数多于芯片数据线位数。\n​        位扩展的连接方式：各芯片的地址线、片选线和读写控制线与系统总线相应 并联；各芯片的 数据线单独引出，分别连接系统数据线。各芯片同时工作。\n​        以之前介绍过的 SRAM 芯片 2114 为例，它的存储容量为 1K × 4，那么用 2 片 2114 采用位扩展的方式可以组成 1K × 8 的存储器。如下所示：        \n\n（2）字扩展  \n​        字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。这种情况下，系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。\n​        字扩展的连接方式：各芯片的地址线与系统地址线的 低位对应相连，芯片的数据线和读写控制线与系统总线相应 并联；由系统地址线的 高位译码 得到各芯片的片选信号。各芯片分时工作，同一时间只能有一个芯片被选中。\n​        例如，用 2 片容量为 1K × 4 的 2114 芯片，采用字扩展的方式可以组成 2K × 4 的存储器。如下所示：\n\n​    扩展之后的地址线为 11 位，共有 2^11^ = 2 K 个地址。其中：\n\n第一片 2114 的地址范围为 000 0000 0000 ~ 011 1111 1111；\n第二片 2114 的地址范围为 100 0000 0000 ~ 111 1111 1111。\n（3）字和位同时扩展\n\n\n​        字和位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。\n​        字和位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展相同；由系统地址线高位译码产生若干个片选信号，分别接到各组芯片的片选信号。\n​        例如，用 8 片容量为 1K × 4 的 2114 芯片，字和位同时扩展之后可以组成 4K × 8 的存储器。如下所示：\n\n扩展之后的地址线为 12 位，共有 2212 = 4 K 个地址。其中：\n\n第一、二片 2114 通过位扩展构成第一组，地址范围为 0000 0000 0000 ~ 0011 1111 1111；\n第三、四片 2114 通过位扩展构成第二组，地址范围为 0100 0000 0000 ~ 0111 1111 1111；\n第五、六片 2114 通过位扩展构成第三组，地址范围为 1000 0000 0000 ~ 1011 1111 1111；\n第七、八片 2114 通过位扩展构成第四组，地址范围为 1100 0000 0000 ~ 1111 1111 1111。\n\n2. 主存与CPU的连接（1）合理选择存储芯片。通常选用 ROM 存放系统程序，选用 RAM 组成用户区。\n（2）地址线的连接。CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）；CPU 地址线的高位在扩充存储芯片时用，以选择存储芯片（片选）。\n（3）数据线的连接。比较CPU的数据线数与存储芯片的数据位数。如果相等可以直接相连；如果不等，必须对存储芯片进行扩位，使其数据位数与 CPU 的数据线数量相等。\n（4）读/写命令线的连接。CPU 的读/写命令线一般可以直接与存储芯片的读/写控制端相连。\n（5）片选线的连接。片选信号一般由系统地址线高位译码，它是主存与 CPU 连接的关键。\n3.4.3 多模块存储器1. 单体多字存储器​        在主存中，程序和数据是连续存放的，所以 CPU 访存取出的信息也是连续的。如果将存储器的存储单元进行扩展，让它能够存储更多的字，那么就可以在一个存取周期内，从同一地址取出更多的指令。将多条指令逐条送至 CPU 执行，由于 CPU 的速度远高于主存，这样就相当于增大了主存的带宽，提高了速度。\n​        这种方式是对单独的存储器进行了扩展，类似于位扩展的思路，不过是将一个地址对应的数据扩展到了多个存储字。所以这种结构的存储器称为 单体多字存储器。\n​        例如，对于一个单体四字存储器，可以在一个存取周期取出四个字的信息。假设指令字长就是一个存储字，那么原先一个存取周期拿到一条指令，现在就可以拿到 4 条；逐条传给 CPU 进行处理，就相当于每隔 1/4 周期，主存就向 CPU 传送了一条指令，带宽变成了 4 倍。\n\n\n结构特点：存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。\n访问方式：一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。\n\n优点：宽度为单体单字存储器的近 m 倍（访问的内容在同一行时）。\n\n缺点：如果出现访问冲突（需要的内容不在同一行）或遇到转移指令，效率会显著降低。\n\n2. 多体并行系统​        另一种思路是采用多模块组成存储器，各个模块可以并行读写，这就是多体并行系统。每个模块有相同的容量和存取速度，各模块都有自己独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路和读/写电路，它们能并行工作，也能交叉工作。\n​        所谓的 “并行工作”，就是 CPU 可以同时访问 N 个模块，同时启动，同时读出；当然，由于总线是公共的，同时读出的 N 个字需要在总线上分时传送。\n​        根据对这 N 个模块中存储单元的不同编址方式，多体并行系统又可以分为 多体高位交叉存储器 和 多体低位交叉存储器。\n（1）多体高位交叉存储器\n​        多体高位交叉存储器中，各模块采用 高位交叉方式编址。\n​        高位交叉方式编址时，地址分为两部分，高位地址表示体号，低位地址为体内地址。这种编址方式下，一个模块（也就是 “体”）内的地址是连续的，程序存储时会按照体内地址的顺序存放，也就是先存一个模块，存满之后再存下一个；所以这种方式也叫 “顺序存储”。\n\n只要调动合理，使不同的请求源同时去访问不同的模块，就可以实现并行工作。比如，CPU 在访问一个模块的同时，外部设备可以以直接存储器访问（DMA）的方式访问另一个模块，这样两个体就是并行工作的。\n（2）多体低位交叉存储器\n​        多体低位交叉存储器中，各模块采用 低位交叉方式编址。\n​        低位交叉编址是指用主存地址的低位来指明存储器模块，高位指明模块内的字地址。这种编址方式下，连续的地址分布在相邻的模块中，同一模块内的地址是不连续的，因此也叫做 “交叉存储”。有 M 个模块的低位交叉编址，又叫 模 M 编址。\n\n​       上面是一个模 4 交叉编址的存储器，存储体模块个数为 4，所以第一个模块中所有存储单元的地址号，对 4 取模都为 0；同样道理，第二、三、四个模块的地址号，对 4 取模结果分别为 1、2、3。具体的编址地址号如下所示：\n\n​        程序按照地址连续存放在相邻模块中，采用低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用 流水线 方式并行存取，提高存储器的带宽。\n​        在一个存取周期 T 内，m 个模块按一定的顺序分时启动；如果分时启动的时间间隔为 t = T/m，那么在一个存取周期内，CPU 交叉访问各个模块，从而使各模块的读/写操作交错重叠进行，最终向 CPU 可以传送 m 个字。这样，存储器的带宽提升为 m 倍。\n​        由于各个模块传送取出的字共享总线，因此假设总线传输周期为 τ，当 t 小于等于 τ 时，就可以获得最大的存储器带宽。所以：\n​                                                                                t = T/m ≤ τ\n​        所以，对于一个存取周期为 T、总线传输周期为 τ 的机器，设计多体低位交叉存储器时应该有 m ≥ T / τ。一般取最小值即可，在采用流水线方式时应该满足 \n​                                                                                    T = m τ\n​        对于四体低位交叉编址存储器 T = 4 τ，按流水线方式工作时不同模块访问字的时间顺序如下：\n\n​    可以看出，对于流水线工作的低位交叉存储器，连续读取 n 个字所需的时间为：\n​                                                                            t1 = T + ( n - 1 ) τ \n​        而如果是高位交叉存储器，对应的时间为：\n​                                                                                    t2 = n T\n​        对于上面的四字低位交叉存储器，τ = T / 4，所以 t1 = ( n + 3 ) T / 4，明显要低于 t2；当 n 非常大时，t1 趋近于 T / 4，即速度提升了 4 倍。\n3.5 外部存储器​        外部存储器是主存的后援设备，也叫做辅助存储器，简称 外存 或 辅存，与主存一起构成了存储器系统的主存-辅存层次。与主存相比，外存容量大、速度慢、价格低，可以脱机保存信息，属于 非易失性存储器。\n​        用于计算机系统的外存主要有磁盘、磁带、光盘；磁盘和磁带都属于 磁表面存储器。而目前广泛应用的 固态硬盘（SSD）主体由闪存芯片构成，属于半导体存储器。\n3.5.1 磁盘存储器​        磁盘是应用最为广泛的外存设备。磁盘根据结构和盘片材质的不同，可以分为 硬磁盘 和 软磁盘，如今随着存储技术的发展，软磁盘存储器已渐渐不再使用，而硬磁盘存储器依然在外存中占据着重要的比例。\n​        磁盘存储器具有外存设备普遍的优缺点：\n\n优点：存储容量大，位价低；记录介质可重复使用；记录信息可长期保存而不丢失, 甚至可脱机存档；非破坏性读出，读出时不需要再生。\n缺点：存取速度慢，机械结构复杂。\n\n1. 磁表面存储器和磁记录原理​        磁表面存储器在不同形状（盘状、带状）的载体上涂有磁性材料层，这磁层就是记录信息的存储介质。存储器工作时，依靠载体的机械运动，由磁头在磁层上进行读/写操作；信息就记录在磁层上，这些信息的轨迹叫做 磁道。磁盘的磁道是一个个同心圆，磁带的磁道则是一条条直线。\n\n磁记录原理：磁表面存储器在磁头和磁性记录介质做相对运动时，通过电磁转换完成读/写操作。\n磁记录方式：又称为编码方法，就是按某种规律把一连串的二进制信息转换成磁表面相应的磁化状态。通常采用调频制（FM）和改进型调频制（MFM）的记录方式。    \n\n\n2. 硬磁盘的分类和基本结构（1）硬磁盘存储器的类型\n​        硬磁盘中的存储载体是盘片，它是由硬质铝合金材料制成的，其表面涂有一层硬磁特性材料，可以被磁化从而完成信息的存储。通过磁头和盘片的相对运动，就可以实现信息的读取和写入。\n\n根据能否更换盘片，硬磁盘可以分为 可换盘磁盘 和 固定盘磁盘。\n\n​        可换盘磁盘的盘片可以脱机保存，所以更换的时候可以只换单片，方便维护和扩容；固定盘磁盘的盘片则不能从驱动器中取下，更换的时候需要整体更换，可靠性更高。\n\n按照磁头的工作方式，硬磁盘可以分为 固定磁头磁盘 和 移动磁头磁盘。\n\n\n\n固定磁头的磁盘存储器，磁头位置是固定不动的，磁盘上的每一个磁道都对应着一个磁头，盘片也不可以更换；这样省去了磁头在盘片上移动寻找磁道的时间，存取速度更快。\n移动磁头的磁盘存储器，存取数据时磁头需要在盘面上做径向运动；这类存储器可以只有一个盘片，也可以有多个盘片。多个盘片会装在一个同心主轴上，每个记录面各有一个磁头。所有这些磁头连成一体，固定在支架上移动；任何时刻所有磁头和主轴的距离都相等，它们位于和圆心相等距离的一组磁道上，这组磁道称为一个 柱面。\n\n（2）硬磁盘存储器的组成\n​        硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。\n\n\n磁盘驱动器\n\n​        磁盘驱动器是主机之外的一个独立装置，又称作 磁盘机。驱动器主要包括主轴、定位驱动和数据控制 3 个部分。\n\n\n磁盘控制器\n\n​        磁盘控制器是磁盘存储器和主机的接口，通常就是一块电路板，插在主机总线插槽中。它的作用是接收由主机发来的命令，将其转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送，并且控制驱动器的读/写操作。一个磁盘控制器可以控制多台驱动器。\n​        将磁盘控制器的功能全部内置在磁盘设备中，主机和设备之间就可以采用标准的通用接口了。最初这种接口就称为 IDE（Integrated Drive Electronics）接口，同时期还有更高性能的 SCSI（Small Computer System Interface）接口；之后又发展出了采用串行传输技术的接口，这就是 SATA（Serial Advanced Technology Attachment）和 SAS（Serial Attached SCSI）。目前我们的个人电脑中，大多都是采用 SATA 接口的硬盘。\n\n盘片\n\n​        盘片是磁盘中存储信息的载体，由驱动器控制它的转动并读/写数据；有时也会直接把盘片当作驱动器的一部分。目前硬盘的盘片正朝着小体积大容量的方向发展，记录密度越来越高。\n3. 磁盘的工作原理（1）磁盘存储区域\n​        一块磁盘划分为若干个记录面，每个记录面划分为若干条 磁道，而每条磁道又划分为若干个 扇区，扇区（也称块、扇段）是磁盘读写的最小单位，即磁盘按块存取。一个具有多盘片的磁盘组，可将其 n 个面上所有同一半径的磁道看成一个圆柱面，称为 柱面；在移动磁头的组合盘中，多个磁头一次定位的磁道集合就是一个柱面。    \n\n\n\n磁头数：表示磁盘总共有几个磁头，一般来说一个记录面对应一个磁头，所以等于记录面数。\n\n柱面数：表示磁盘中柱面的个数，等于每个记录面上的磁道数。\n\n扇区数：表示每条磁道上有几个扇区。\n\n\n（2）磁盘地址\n​         一个磁盘存储器可以有多台驱动器，不同的驱动器可以用一个编号（驱动器号，或者台号）来区分。当驱动器号确定后，磁盘进行寻址定位时，首先需要整体移动磁头找到对应柱面（磁道）、再选定磁头，最后转动盘片找到扇区。所以寻址所需要的磁盘地址，一般由 驱动器号、柱面（磁道）号、盘面号、扇区号 组成。\n​        磁盘的地址格式如下所示:\n\n\n\n\n驱动器号\n柱面（磁道）号\n盘面号\n扇区号\n\n\n\n\n\n\n\n\n\n​        例如，系统中有 4 个驱动器，每个驱动器带一个磁盘组，其中有 11 个盘片（最外层上下侧为保护面），每个盘面有 203 个磁道、划分为 16 个扇区。则可以算出，驱动器号需要 2 位；柱面号需要 8 位（ 27 &lt; 203 &lt; 28 ）；而 11 个盘片有 20 个盘面，所以盘面号需要 5 位；扇区号需要 4 位。最终每个磁盘地址要 19 位二进制代码。\n\n\n\n\n驱动器号（2位）\n柱面（磁道）号（8位）\n盘面号（5位）\n扇区号（4位）\n\n\n\n\n\n\n\n\n\n（3）磁盘的工作过程\n​        磁盘的主要操作是寻址、读盘、写盘。磁盘属于机械式部件，其读/写操作是串行的，不可能在同一 时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。\n\n磁盘的性能指标\n\n（1）记录密度\n​        记录密度通常是指单位长度内所存储的二进制信息量。磁盘存储器用 道密度、位密度 和 面密度 来表示。\n（2）存储容量\n​        存储容量指磁盘能存储的二进制信息的总数量，一般以位或者字节为单位。磁盘存储容量 C 可以计算为：\n\n​        其中 n 为 盘面数，k 为每个盘面的磁道数，s 为每条磁道上记录的二进制代码数。\n（3）平均寻址时间\n​        磁盘的存取方式是直接存取，它的寻址时间分为两个部分：磁头寻找目标磁道的时间 t~s~；和找到磁道后，磁头等待要读写的磁道区段（扇区）旋转到磁头下方的时间 tw。由于寻找相邻磁道和不相邻磁道的时间不同，磁头等待不同扇区的时间也不同，所以应该取平均值，称为 平均寻址时间；它是 平均寻道时间 tsa 和 平均等待时间     twa之和。\n\n​        平均寻址时间再加上数据传输时间，就是磁盘的 平均访问时间。\n（4）数据传输率\n​        数据传输率是指单位时间内，磁盘向主机传送数据的位数或字节数。数据传输率 DR 与记录位密度 D~b~ 和磁道运动速度 V 有关；\n\n​        对于磁盘来说，“磁道运动速度” 一般用磁盘的转速 r （单位 转/s）表示，那么\n\n（5）误码率\n​        误码率是衡量磁盘出错概率的参数，等于从磁盘读出信息时，出错信息位数和读出信息总位数之比。为了减少出错率，磁盘一般采用循环冗余校验（CRC）码来发现和纠正错误。\n5. 冗余磁盘阵列 RAID​        冗余磁盘阵列（Redundant Array of Independent Disks，RAID）是将多个独立的物理磁盘组成一个磁盘阵列，引入并行处理技术，让数据在多个物理盘上分割交叉存储、并行访问。 \n​        根据不同的目的，可以采用不同的 RAID 方案；在 RAID1 ~ RAID5 的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。RAID 的分级如下所示：\n\nRAID0：无冗余和无校验的磁盘阵列。\n\nRAID1：镜像磁盘阵列，无校验。\n\nRAID2：采用纠错的海明码的磁盘阵列。\n\nRAID3：位交叉奇偶校验的磁盘阵列。\n\nRAID4：块交叉奇偶校验的磁盘阵列。\n\nRAID5：无独立校验的奇偶校验磁盘阵列。\n\n​        其中，RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。\n​        RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另 一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。\n​        总之，RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高吞吐量；通过镜像功能，提高了安全性、可靠性；通过数据校验，提供容错能力。\n3.5.2 固态硬盘（SSD）​        固态硬盘（Solid State Disk，SSD）是基于闪存（Flash）技术的半导体存储器，它与 U 盘并没有本质差别。SSD 由闪存芯片和闪存翻译层组成，闪存芯片代替了传统磁盘中的磁盘驱动器，闪存翻译层则将来自 CPU 的读写请求翻译成对芯片的读写控制信号，相当于磁盘中的磁盘控制器。    \n\n固态硬盘有很多优点。它由半导体存储器构成，没有机械部件，所以随机访问速度比磁盘快很多，也没有任何机械噪声和震动。另外，SSD 还具有能耗低、抗震性好、安全性高等优点。\n​        当然，固态硬盘也有缺点。它最大的问题是依然基于 EEPROM 的擦除原理，随机写入比较慢。\n​        固态硬盘的数据都存放在闪存芯片中。一个闪存芯片内包含了多个 “块”，每个块又由若干 “页” 组成。数据以页为单位进行读写，但是需要以块为单位进行擦除；所以只有一页所属的块整个被擦除之后，才能重新写这一页。一旦一个块被擦除了，块中的每一页都可以再写一次。一般某个块进行了数千次重复写之后，就会损坏。\n\n​    因此随机写很慢，有两个原因：首先，擦除块本身就比较慢；其次，如果试图写的页所在块已经有数据了，那么这个块中其它所有有数据的页都必须被复制到一个新块（擦除过的块），然后才能进行写操作。\n​        因此，闪存的擦写寿命是有限的，读/写数据通常会集中在 SSD 的一部分闪存，这部分闪存就会损坏得特别快；在磨损不均衡的情况下，数个闪存块的损坏，会导致整个 SSD 损坏。为弥补 SSD 的寿命缺陷，引入了 磨损均衡技术，SSD 磨损均衡技术大致分为两种：\n\n动态磨损均衡：写入数据时，自动选择较新的闪存块。\n静态磨损均衡：监测并自动进行数据分配，让旧的闪存块承担无须写数据的储存任务，同时让较新的闪存块空出来；平常的读/写操作都在较新的闪存块中进行，这样就使各闪存块的损耗更为均衡。\n\n​        有了磨损均衡技术，SSD 的寿命就比较可观了。例如，对于一个 256 GB 的 SSD，闪存的擦写寿命是 500 次的话，那么就需要写入125 TB 数据才可能损坏；而目前的 Flash 芯片已经做到至少可以擦写上万次了。\n3.6 高速缓冲存储器（Cache）​        为了解决 CPU 和主存之间速度不匹配的问题，计算机系统中引入了高速缓存（Cache）的概念。基本想法就是使用速度更快但容量更小、价格更高的 SRAM 制作一个缓冲存储器，用来存放经常用到的信息；这样一来，CPU 就可以直接与 Cache 交换数据，而不用访问主存了。\n​        这种方案之所以有效，是因为通过对大量典型程序分析发现，在一定时间内，CPU 要从主存取指令或者数据，只会访问主存局部的地址区域。这是由于指令和数据在内存中都是连续存放的，而且有些指令和数据会被多次调用（比如常用函数、循环代码段、数组和一些常数）；也就是说，指令和数据在主存中地址分布不是随机的，而是相对的簇聚。这使得 CPU 执行程序时，访存具有相对的局部性；这称为程序访问的 局部性原理。\n\n时间局部性：如果一个数据现在被访问了，那么以后很有可能也会被访问\n空间局部性：如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问\n\n​        局部性原理是 Cache 高效工作的理论基础。\n3.6.1 Cache 的基本工作原理​        为了便于 Cache 与主存交换信息，Cache 和主存都被划分为相等的块。Cache 块又称 Cache 行，每块由若干字节组成，块的长度称为块长。由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，Cache 中仅保存主存中最活跃的若干块的副本。\n1. Cache 工作原理​        假设主存按字节编址，地址用 n 位二进制码表示，那么主存容量为 2n B；块的大小为 16 个字节，那么主存中块的个数为：2n / 16 = 2n-4。那么如果对每个块也做一个编号，其实就对应着地址中的前 n - 4 位。\n\n这样，主存地址就分成了两部分：高 n - 4 位表示主存中的 “块地址”，低 4 位表示 “块内地址”，块内地址其实就是具体存储字在块内的 “偏移量”。类似，Cache 中地址也可以分成这样的两部分，由于 Cache 中块长与主存一致，所以低 4 位同样是块内地址；剩余的高位则为 Cache 的块号。Cache 的块号位数小于 n - 4。\n\n所以，可按照某种策略预测 CPU 在 未来一段时间内要访存的数据，将其装入 Cache。当 CPU 要读取主存中的某个字时，分为两种情况：\n\nCache 命中：需要的字已经在缓存中，就将其地址转换为缓存地址，直接访问 Cache，与主存无关；\nCache 未命中：需要的字不在缓存中，仍需访问主存，并将该字所在的块一次性地从主存调入 Cache。\n\n​        如果某个主存块已经调入 Cache，就称该主存块和 Cache 中的缓存块建立了对应关系。由于 Cache 容量有限，当 Cache 已满时，就需要根据某种替换算法，让需要调入 Cache 的块替换之前某个缓存块的内容。所以，一个缓存块不可能永远只对应一个主存块；需要给每个缓存块设置一个标记，写入当前对应的主存块号，表示它当前存放了哪个主存块。\n​        CPU 与 Cache 之间的数据交换，通常是以字为单位；而 Cache 与主存之间的数据交换则以块为单位。\n2. 命中率​        Cache 的效率，通常用 命中率 来衡量。命中率是指 CPU 要访问的信息已经在 Cache 中的比率。Cache 的容量和块长都是影响命中率的重要因素。\n​        假设一个程序执行期间，访问 Cache 的总命中次数为 NC，访问主存的总次数为 NM~，那么命中率为：\n\n​        设 tC 为命中时的 Cache 访问时间，tM~ 为未命中时的主存访问时间，那么 Cache - 主存系统的平均访问时间   ta 为：\n\n​        由于 tC 远小于 tM~，因此平均访问时间 ta 越接近 tC 就说明 Cache 效率越高。用 e 表示访问效率，则有：\n\n​        命中率 h 越接近 1，访问效率就高。一般来说，Cache 容量越大，命中率就越高；而块长与命中率的关系较为复杂，它取决于程序的局部特性，一般取每块 4 ~ 8 个可编址单位（字或字节）效果较好。\n3. Cache 的基本结构​        Cache 主要由 Cache 存储体、主存 - Cache 地址映射变换机构、Cache 替换机构几大模块组成。\n\n（1）Cache 存储体\n​        Cache 存储体以块为单位与主存交换信息，Cache 访存的优先级最高。\n​    （2）主存 - Cache 地址映射变换机构\n​        地址映射变换机构会将 CPU 送来的主存地址转换为 Cache 地址。由于主存和 Cache 块长相同，所以块内地址是不变的，地址变换主要就是主存的块号（高位地址）到 Cache 块号之间的转换。这涉及到一个函数的映射关系，被称为 地址映射。\n​    （3）Cache 替换机构\n​        地址转化之后，如果 Cache 命中，CPU 就直接访问 Cache 存储体；如果不命中，CPU 需要访问主存将需要的字取出，并把它所在的主存块调入 Cache。如果 Cache 已满，无法将主存块直接调入 Cache，就需要 Cache 内的替换机构执行替换策略。\n​        所谓替换策略，就是按一定的替换算法，确定从 Cache 中移出哪个块返回主存，并把新的主存块调入 Cache 进行替换。\n​        在执行写操作时，还需要考虑如何使 Cache 如何与主存的内容保持一致。这就需要用某种 Cache 写策略。\n4. Cache 的改进​        Cache 的改进，主要就是由一个缓存改为使用多个缓存。主要有两个方向：增加 Cache 级数；将统一的 Cache 变为分立的 Cache。\n​    （1）两级缓存\n​        最初在 CPU 和主存之间只设一个缓存，称为 单一缓存。随着集成电路密度的提高，这个缓存就直接与 CPU 集成在了一个芯片中，所以又称为 片内缓存（片载缓存）。\n​        由于片内缓存容量无法做到很大，所以可以考虑在片内缓存和主存之间再加一级缓存，称为 片外缓存，也由 SRAM 组成。这种由片外缓存和片内缓存构成的 Cache 系统被称为 “两级缓存”，片内缓存作为第一级（L1 Cache），片外缓存作为第二级（L2 Cache）。\n​    （2）分立缓存\n​        指令和数据都存放在同一缓存内的 Cache，称为 统一缓存；而 分立缓存 则将指令和数据分别存放在两个缓存中，一个叫指令 Cache，另一个叫数据 Cache。这两种缓存的选择主要考虑两个因素：\n\n主存结构。如果计算机主存中指令、数据是统一存储的，则相应的 Cache 采用统一缓存；如果主存指令、数据分开存储，则相应的 Cache 采用分立缓存。\n机器对指令执行的控制方式。如果采用了超前控制或者流水线控制方式，一般都采用分立缓存。所谓超前控制，是指在当前指令执行尚未结束时就提前把下一条准备执行的指令取出；而所谓流水线控制，就是多条指令同时分阶段执行。\n\n3.6.2 Cache 和主存之间的映射方式​        Cache 块中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，这相当于定义了一个函数：\n​                                                                    Cache 地址 = f ( 主存地址 )\n​        当然，由于 Cache 和主存块长一样，而块内地址只是字在当前块内的 “偏移量”，所以映射转换之后块内地址是不变的。我们需要的其实只是 Cache 块号和主存块号之间的函数关系：\n​                                                                    Cache 块号 = f ( 主存块号 )\n​        Cache 块远少于主存块，所以 Cache 块不可能永远对应唯一的主存块，需要在 Cache 中为每一个块加一个 标记，指明它是主存中哪一块的副本。这个标记的内容，应该能够唯一确定对应主存块的编号。另外，为了说明 Cache 行中的信息是否有效，每个 Cache 行还需要有一个 有效位，该位为 1 时，表示 Cache 中该映射的主存块数据有效；为 0 则无效。\n​        地址映射的方法有以下 3 种。\n1. 直接映射​        直接映射 的思路非常简单，就是 “挨个对应”，主存中的每一块只能装入 Cache 中的唯一位置。由于 Cache 容量很小，当主存中的块已经 “遍历” 完所有 Cache 地址后，下一个主存块的对应位置就又成了 Cache 中的第一行（第一个块）。\n​        很明显，这跟 “顺序存储” 的思路是一样的，用主存块号对 Cache 的总行数取模，就可以得到对应 Cache 的行号了：\n​                                                                Cache行号 = 主存块号  mod  Cache总行数\n​        例如，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 只有 4 行（4 个块），那么采用直接映射方式的对应关系如下：\n\n \n​      而在缓存（Cache）设计中，一行（line）通常等同于一块（block）。每一行缓存存储一个块的数据，这个块对应于主存中的一个相同大小的数据块。具体解释如下：\n\n缓存行（Cache Line）：\n一行缓存包含的数据单位，包含一个数据块、一个标记（tag）、有效位（valid bit）和可能的脏位（dirty bit）。\n在直接映射缓存中，每个缓存行唯一对应一个特定的主存块。\n\n\n块（Block）：\n块是从主存中提取的一组连续字节。主存中的块被映射到缓存中的行。\n缓存行的数据部分存储主存块的内容。\n\n\n\n假设我们有以下参数：\n\n主存地址位数：32位\n主存块大小：4个字，每字32位（即每块16字节）\n缓存数据容量：4K字（16KB）\n\n\n对于采用回写策略的缓存，每行缓存不仅存储数据块，还需要附加的元数据：\n\n数据位数：16字节（128位）\n标记位数：\n偏移位数（块内地址）：log2(16) =4 位\n索引位数（块数/行数）：log2(1024) =10 位\n标记位数（剩下的位数用于标记，以确定缓存行对应的具体主存块。将主存中所有228块全部映射到缓存的1024行中，则还需要18位来确定218中的哪个。）：32 - (10 + 4) = 18 位\n\n\n有效位（Valid Bit）：1位\n脏位（Dirty Bit）：1位\n\n主存至缓存的具体映射关系如下：\n\n\n主存中的每个块根据索引部分映射到缓存中的一个行。\n多个主存块可以具有相同的索引，从而映射到同一个缓存行，但它们的标记不同。\n\n采用回写策略的缓存行的总位数分解如下：\n\n每行的总位数：\n\n\n​           更加一般化，假设 Cache 共有 2c 行，主存有 2m 个块，那么 Cache 行号有 c 位，主存块号有 m 位。在直接映射方式中，主存块号为 0、2c、2c+1… 的块，都映射到 Cache 的第 0 行；而主存中块号为 1、2c + 1、2c+1 + 1… 的块，映射到 Cache 的第 1 行；以此类推。\n​        这样一来，主存块号的低 c 位就对应了 Cache 中的行号；当一个块存放在 Cache 中，只需要高 m - c 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - c 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        所以直接映射方式下，主存地址结构为：\n\n​        访存过程：\n​        ① 根据访存地址中间的 c 位，找到对应的 Cache 行。\n​        ② 将该 Cache 行中的标记和主存地址的高 t 位标记进行比较。\n​        ③ 若相等且有效位为1，则 Cache 命中，此时根据主存地址中低位的块内地址，在对应的 Cache 行中存取信息；若不相等或有效位为 0，则 Cache 未命中，此时 CPU 从主存中读出该地址所在的一块信息，并送至对应的 Cache 行中，将有效位置 1，并置标记为地址中的高 t 位。\n\n​    直接映射实现简单，但不够灵活，即使 Cache 的其他许多地址空着也不能占用，这使得直接映射的块冲突概率高，空间利用率低。\n2. 全相联映射​        直接映射的问题在于，我们找到的是从主存块到缓存行的一种 “多对一” 的关系，每一个主存块只能对应唯一的缓存行，从而导致冲突概率高。如果让一个主存块，可以映射到多个缓存块上，变成 “多对多” 的关系，明显就可以减少冲突了。\n​        最简单的情况，就是不加任何条件限制，让主存的每一个块都可以映射到 Cache 的任意位置；简单来说就是 “有空就填”，放在哪里都可以。这就是 全相联映射 方式。        \n\n由于没有任何规律，所以当一个块存放在 Cache 中，无法根据 Cache 行号推出它对应主存块的任何信息；因此必须在每行的标记中明确指出该行取自主存的哪一块，这样标记就需要完整的 m 位主存块号。CPU 访存时，需要与所有 Cache 行的标记进行比较。\n​        全相联映射方式下，主存的地址结构为：\n\n  全相联映射方式的优点是灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。\n3. 组相联映射​        把直接映射和全相联映射两种方式结合起来，就是 组相联映射 方式。\n​        组相联的思路是将 Cache 分成 Q 个大小相等的组，每个主存块可装入对应组的任意一行；它所在的组则按顺序依次排列得到。也就是 组间采用直接映射、而 组内采用全相联映射 的方式。当 Q=1 时，变为全相联映射；当 Q = Cache 行数时变为直接映射。\n​        假设每组有 R 个 Cache 行，则称之为 R 路组相联；例如每组有 2 个 Cache 行时称为 2 路组相联。\n​        类似的例子，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 有 8 行（8 个块），采用 2 路组相联映射方式，那么共有 Q = 8 / 2 = 4 组。对应关系如下：\n\n​    可以看出，现在的 “组号” 就相当于直接映射方式下的行号，可以由主存块号对组数 Q 取模得到：\n​                                                        Cache组号 = 主存块号  mod  Cache组数\n​        更加一般化，假设 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q ，行号的低 c - q 位就代表了 Cache 行在组内的序号。\n​        在 R 路组相联映射方式中，主存块号为 0、2q、2q+1… 的块，都映射到 Cache 的第 0 组，可以选择组内 2c-q 行的任一行；而主存中块号为 1、2q + 1、2q+1 + 1… 的块，映射到 Cache 的第 1 组，同样可以任选组内的 Cache 行；以此类推。\n​        这样一来，主存块号的低 q 位就对应了 Cache 中的组号；当一个块存放在 Cache 中，只需要高 m - q 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - q 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        可以将以上 3 中映射方式对比如下：\n\n3.6.3 Cache 中主存块的替换算法​        如果有新的主存块需要调入 Cache，而可用空间又已经占满，这时就需要替换掉某个旧块，这就产生了替换策略（替换算法）的问题。当采用直接映射时，替换的位置是固定的，无须考虑替换算法；而在采用全相联映射或组相联映射时，就需要使用替换算法来确定到底置换哪个 Cache 行。\n​        常用的替换算法有 随机（RAND）算法、先进先出（FIFO）算法、最近最少使用（LRU）算法 和 最不经常使用（LFU）算法。其中最常考查的是 LRU 算法。\n\n随机算法：随机地确定替换的 Cache 块。实现简单，但未依据局部性原理，命中率较低。\n先进先出算法（Fisrt In First Out，FIFO）：选择最早调入的行进行替换。实现简单，但也未依据局部性原理。\n最近最少使用算法（Least Recently Used，LRU）：依据局部性原理，选择近期最久未访问过的 Cache 行作为被替换的行。LRU 算法为每个 Cache 行设置一个计数器，用来记录每个块的使用情况，并根据计数值选择淘汰某个块。\n最不经常使用算法（Least Frequently Used，LFU）：将一段时间内访问次数最少的 Cache 行换出。与 LRU 类似，也设置一个计数器，Cache 行建立后从 0 开始计数，每访问一次计数器加 1，需要替换时将计数值最小的行换出。\n\n​        例如，假设一台机器 Cache 有 8 个行，初始值为空，采用 4 路组相联映射方式和 LRU 替换策略，当顺序访问主存块号为 0，4，8，3，0，6，12，0，4，8 时，缓存的命中和替换情况如下：\n\nLRU 算法中利用计数器来表示 Cache 行未被访问的时间。整体原则是：当 Cache 行有新的主存块调入时，计数器开始计数，初始值为 0，此后每遇到一次对 Cache（或 Cache 组）的访问就加 1；如果一次访问 Cache 命中了这一行，就将计数器清 0；每次有 Cache 行计数器清 0，其它行的计数器依然要加 1，不过只需要计数值比当前行更小的那些继续加 1 就可以了。\n​        需要替换时，直接选择计数值最大的行，调入新的块并将计数器置 0。这是由于不同的 Cache 行不会同时开始计数，且每次都同步加 1，所以所有 Cache 行的计数值都不会相同，每次发生替换时必然能够找到一个最大值；而一旦有计数器清 0，比它计数值更大的那些也是都不加 1，依然保持着原有的大小顺序。\n​        这样一来，如果当前 Cache 共有 2c 行，分为 Q = 2q 组，每组行数为 R = 2c / Q = 2c-q ，那么计数器的值就不会超过 R；只要用 c - q 位就可以表示计数器了，这被叫做 LRU 位。因此，计数值的位数与 Cache 组的大小有关。当为 2 路时有 1 位 LRU 位，4 路时有 2 位 LRU 位。LRU 位会同标记、有效位一同作为 Cache 的一部分。\n3.6.4 Cache 写策略​        因为 Cache 中的内容是主存块内容的副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache内容和主存内容保持一致。此时分两种情况：\n（1）Cache 写命中（要修改的单元在 Cache 中）\n​        这种情况有两种处理方法：\n\n写直达法\n\n​        也叫全写法、写穿透法。将数据同时写入 Cache 和主存。这种方法实现简单，一致性好。缺点是降低了速度，时间开销为访存时间。为了减少写入主存的开销，可以在 Cache 和主存之间加一个写缓冲。\n\n写回法\n\n​        也叫回写法、写返回法。数据只写入 Cache，而不立即写入主存，只有当此块被换出时才写回主存。这种方法效率很高，但一致性较差。在每个 Cache 行中设置一个修改位（脏位），若修改位为 1（“脏”），则说明对应 Cache 行中的块被修改过，替换时须写回主存；若修改位为 0（“净”），则替换时无须写回主存。\n（2） Cache 写未命中（要修改的单元不在 Cache中 ）\n​        这种情况也有两种处理方法：\n\n写分配法\n\n​        把数据写入主存，同时将该块调入Cache。这种方法依据了空间局部性原理。\n\n非写分配法\n\n​        只把数据写入主存，不进行调块。\n​        非写分配法通常与全写法合用，写分配法通常与回写法合用。\n​        这样，还是之前的机器，采用组相联映射的 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q  ，即采用 R 路组相联映射，假如还采用了 LRU 替换策略和回写法，那 Cache 行应该包含以下部分：\n\n​        现代计算机通常设立多级 Cache，一般两级 Cache 按离 CPU 的远近分别命名为 L1 Cache、L2 Cache，离 CPU 越近则速度越快、容量越小。指令 Cache 与数据 Cache 分离一般在 L1 级，LI Cache 对 L2 Cache 使用全写法，L2 Cache 对主存使用回写法。由于L2 Cache的存在，避免了因频繁写而造成写缓冲溢出的情况。\n3.7 虚拟存储器​        早期的计算机，CPU 是直接操作主存的，也就是运行程序时，直接给出要访问的实际主存地址。这种方式简单直接，但是会有一些问题：\n\n不同的程序之间需要共享内存，它们的内存地址空间很难隔离，从而导致程序运行的稳定性和安全性降低；\n主存容量有限，如果同时执行的程序太多、使用内存太大容易超出容量限制而崩溃。\n\n\n为了解决这些问题，在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统。\n​        主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。\n3.7.1 虚拟存储器的基本概念​        虚拟存储器将主存和辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存的实际存放位置。用户编程允许涉及的地址称为 虚地址 或 逻辑地址，虚地址对应的存储空间称为虚拟空间。实际的主存地址称为 实地址 或 物理地址，实地址对应的是主存地址空间。虚地址比实地址要大很多。\n​        使用虚拟存储器之后，程序中看到的地址都是逻辑地址。在访存时，逻辑地址首先会被转换成物理地址，然后再访问实际物理内存。\n\n这样一来，每一个程序都有独立的虚拟地址空间，不同进程的虚拟地址空间互相不干扰，提高了安全性。在每个进程看来，就像它自己独享了整个内存。当物理内存不够时，可以将一部分不常使用的内存块换出（Swap-out）到磁盘中，下次使用时再换入到内存中（Swap-in），这样程序就可以使用超过实际物理内存大小的地址空间了。\n\nCPU 使用逻辑地址时，先判断这个逻辑地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问。若主存已满，则采用 替换算法 置换主存中的页。\n​        虚拟存储器采用了和 Cache 类似的技术，将辅存中经常被访问的数据副本存放到主存中。但缺页 （或段）而访问辅存的代价很大，因此虚存机制采用 全相联映射，每个页可以存放到主存区域的任意一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而采用 回写法。    \n3.7.2 页式虚拟存储器​        页式虚拟存储器 以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为 实页 或 页框，虚存的页称为 虚页。这样，一个逻辑地址可以分为两段：虚页号 和 页内地址。\n\n虚页和实页之间采用全相联映射，所以从主存中依次查找要访问的虚页号比较困难。所以我们专门引入一个数据结构，用来保存虚页号和实页号的映射关系，这就是 页表。页表可以实现从逻辑地址到物理地址的转换。\n1. 页表​        页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。每个程序都有自己的页表，页表一般长久地保存在内存中。\n​        页表中的每一项，都包含以下几部分：\n\n有效位：也称 装入位，用来表示对应页面是否在主存，若为 1，则表示该虚页已从外存调入主存，此时页表项存放该页的物理页号；若为 0，则表示页面没有调入主存，此时页表项可以存放该页的磁盘地址。\n脏位：也称 修改位，用来表示页面是否被修改过，虚拟存储机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。\n引用位：也称 使用位，用来配合替换策略进行设置，例如是否使用先进先出（FIFO）或近期最少使用（LRU）策略等。\n\n\n​        CPU 执行指令时，需要先将逻辑地址转换为主存物理地址。每个进程都有一个 页表基址寄存器，存放该进程的页表首地址，然后根据逻辑地址高位部分的虚页号找到对应的页表项。若装入位为 1，则取出物理页号，和逻辑地址低位部分的页内地址拼接，形成物理地址；若装入位为 0，则说明缺页，需要操作系统进行 缺页处理。缺页时会由 CPU 的内存管理单元（MMU）发出中断，操作系统需要将相应的页从磁盘取回调入主存，并将物理页的地址填入页表中。\n​        页式虚拟存储器的优点是：页的长度固定，页表简单，调入方便。缺点是：最后一页的零头无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。\n2. 快表（TLB）​        有了虚拟存储器之后，CPU 在寻址时所生成的都是虚拟地址。于是 CPU 在取指或者执行访存指令的时候，都需要进行地址翻译，而每次地址翻译都要访问主存中的页表，会产生严重的开销。\n​        依据程序执行的局部性原理，当 CPU 在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在 Cache 中，就可以不访问主存直接进行地址翻译了；这样明显能提高效率。\n​        在 CPU 芯片中，加入一个专门存放最常访问的页表项的 Cache，就叫做 转址旁路缓存（Translation Lookaside Buffer，TLB），一般简称为 “快表”。TLB 实质上就是 “页表的 Cache”，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本；所以 TLB 又被称为 页表缓存。\n\n​        相应地，把放在主存中的页表称为 慢表（Page）。 在地址转换时，先查找快表，若命中，则无须再访问主存中的页表（慢表）。\n​        TLB 通常采用 全相联映射。每个 TLB 项由页表表项内容加上一个 TLB 标记字段以及有效位等标志位组成，TLB 标记用来表示该表项取自页表中哪个虚页号对应的页表项，其内容就是该页表项对应的虚页号。\n\n3. 具有 TLB 和 Cache 的多级存储系统​        TLB 和 Cache 都属于缓存，不过它们的用途不同：\n\nTLB 用来保存最近经常访问的页表项，是对 地址映射 的缓存。\nCache 用来保存最近经常访问的主存块，是对 数据内容 的缓存。\n\n​        所以对于一个有虚拟存储器的计算机系统，可以先通过 TLB 对逻辑地址的翻译进行加速，快速得到一个物理地址；然后再通过 Cache 的地址转换判断是否 Cache 命中，从而对数据的访问进行加速。\n​        这样就将 Cache 和 TLB 结合起来，构成了多级存储系统。下面就是一个具有 2 路组相联映射 Cache 和 TLB 的多级存储系统；CPU 给出的是一个 32 位的逻辑地址，TLB 采用全相联映射，每一项都有一个比较器。\n\n\n查找时将虚页号与每个 TLB 标记同时进行比较，若有某一项相等且对应有效位为 1，则 TLB 命中，此时可直接通过TLB进行地址转换；若未命中，则 TLB 缺失，需要访问主存去査页表。\n图中所示是 两级页表方式，虚页号被分成 页目录索引 和 页表索引 两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB。若 TLB 已满，则还需要采用替换策略。\n完成由逻辑地址到物理地址的转换后，Cache 机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的 Cache 行或组，将对应 Cache 行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则 Cache 命中，此时根据块内地址取岀对应的字送 CPU。\n\n​        查找时，快表和慢表也可以同步进行。若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器，但访问主存速度几乎没有下降。\n​        在一个具有 Cache 和 TLB 的虚拟存储系统中，CPU —次访存操作可能涉及对 TLB、页表（Page）、Cache、主存和磁盘的访问。CPU 在访存过程中存在 3 种缺失情况：\n​        ① TLB 缺失：要访问页面的页表项不在 TLB 中；\n​        ② Page 缺失：要访问的页面不在主存中。\n​        ③ Cache 缺失：要访问的主存块不在 Cache 中；\n​        需要注意，如果 TLB 命中，那么 Page 一定命中；如果 Page 缺失，那么 Cache 一定缺失。所以有如下一些组合情况：\n\n\n第 1 种情况下，无须访问主存，地址转换和访问数据都可以通过高速缓存完成；\n第 2 种和第 3 种情况都 需要访问一次主存，第 2 种是访问主存取数据，第 3 种是访问页表转换物理地址；\n第 4 种情况需要访问两次主存，访问页表转换物理地址一次、访存取数据一次；\n第 5 种情况就是 “缺页异常”，需要访问磁盘，并且至少访问两次主存。\n\n​        Cache 缺失处理由硬件完成；缺页处理由软件完成，操作系统通过 “缺页异常处理程序” 实现；而 TLB 缺失既可以用硬件也可以用软件来处理。\n3.7.3 段式虚拟存储器​        在段式虚拟存储器中，将虚拟空间用 “段” 进行分割；而段是按程序的逻辑结构划分的，各段的长度因程序而异。虚地址分为两部分：段号 和 段内地址。虚地址到实地址之间的变换是由 段表 来实现的。段表的每行记录与某个段对应的段号、 装入位和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。\n\n​        CPU 用逻辑地址访存时，先根据段号与段表基地址拼接成对应的段表项，再根据该段表项的装入位判断该段是否已调入主存（装入位为 “1”，表示该段已调入主存）。当已调入主存时，从段表读岀该段在主存的起始地址，与段内地址相加，得到对应的主存物理地址。\n​        段式虚拟存储器的优点是，段的分界与程序的逻辑分界相对应，这使得程序易于编译、修改和保护，也便于多道程序共享；缺点是因为段长度可变，分配空间不便，容易留下碎片，造成浪费。\n3.7.4 段页式虚拟存储器​        把程序按逻辑块分段，段内再分页，主存空间也划分为大小相等的页，程序对主存的调入调出仍以 页 为基本单位，这样的虚拟存储器称为 段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个 段表，每段对应一个 页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。\n\n​        虚地址分为 段号、段内页号、页内地址 3 部分。CPU 根据虚地址访存时，首先根据段号得到段表地址，然后从段表中取出该段的页表起始地址，与虚地址段内页号拼接，得到页表地址；最后从页表中取出实页号，与页内地址拼接成主存实地址。\n​        段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护；缺点是在地址变换过程中需要两次查表，系统开销较大。\n3.7.5 虚拟存储器与 Cache 的比较​        相同点：\n\n目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。\n都把数据划分为信息块，作为基本的传送单位，虚拟存储器系统的信息块更大。\n都有地址的映射算法、替换算法、更新策略等问题。\n依据局部性原理，应用“快速缓存”思想，将活跃的数据放在相对高速的部件中。\n\n​        不同点：\n\nCache主要是为了提高系统速度，而虚拟存储器是为了解决主存容量不足的问题。\nCache由硬件实现，对所有程序员透明；虚拟存储器由操作系统和硬件共同实现，对应用程序员透明。\n在不命中时对性能的影响不同。因为 CPU 的速度约为 Cache 的 10 倍，而主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统在不命中时对系统性能的影响更大。\nCPU 与 Cache 和主存有直接通路，而辅存与 CPU 没有直接通路。在 Cache 不命中时，CPU 能和主存直接通信；而虚拟存储器系统在不命中时，须先将数据从硬盘调入主存，CPU 才能访问。\n\n3.8 章节练习一、单项选择题\n【2010真题】下列有关 RAM 和 ROM 的叙述中，正确的是    （    ）。\n\n​        Ⅰ ． RAM 是易失性存储器， ROM 是非易失性存储器​        Ⅱ ． RAM 和 ROM 都采用随机存取方式进行信息访问​        Ⅲ． RAM 和 ROM 都可用作 Cache​        Ⅳ． RAM 和 ROM 都需要进行刷新\n​        A．仅Ⅰ 和Ⅱ                     B．仅Ⅱ 和Ⅲ                    C．仅Ⅰ 、 Ⅱ 和Ⅳ                     D．仅Ⅱ 、 Ⅲ和Ⅳ\n​        答案：A\n\n【2011真题】下列各类存储器中，不采用随机存取方式的是    （    ）。\n\n​        A． EPROM                       B． CDROM                       C． DRAM                           D． SRAM\n​        答案：B\n\n【2015真题】下列存储器中，在工作期间需要周期性刷新的是    （    ）。        \n\n​        A． SRAM                        B． SDRAM                            C． ROM                         D． FLASH \n​        答案：B\n\n【2012真题】下列关于闪存（Flash Memory）的叙述中，错误的是     （    ）。\n\n​        A． 信息可读可写，并且读、写速度一样快\n​        B． 存储元由 MOS 管组成，是一种半导体存储器\n​        C． 掉电后信息不丢失，是一种非易失性存储器\n​        D． 采用随机访问方式，可替代计算机外部存储器 \n​        答案：A\n\n【2011真题】某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4MB×8 位的 RAM芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是     （    ）。\n\n​        A． 22 位                       B． 23 位                       C． 25 位                       D． 26 位\n​        答案：D\n​        要点：MAR 的位数跟主存地址空间有关，与主存实际容量无关。\n\n【2010真题】假定用若干个 2K×4 位的芯片组成一个 8K×8 位的存储器，则地址 0B1FH 所在芯片的最小地址是    （   ）。\n\n​        A． 0000H                     B． 0600H                     C． 0700H                     D． 0800H\n​        答案：D\n\n【2014真题】某容量为 256MB 的存储器由若干 4Mx8 位的 DRAM 芯片构成， 该 DRAM 芯片的地址引脚和数据引脚总数是    （    ） 。\n\n​        A. 19                             B. 22                         C. 30                         D. 36 \n​        答案：A        \n​        要点：DRAM 采用地址复用技术，地址线为正常的一半。 \n\n【2016真题】某存储器容量为 64KB，按字节编址，地址 4000H~5FFFH 为 ROM 区，其余为 RAM 区。若采用 8K× 4 位的 SRAM 芯片进行设计，则需要该芯片的数量是     （    ）。\n\n​        A． 7                             B． 8                          C． 14                         D． 16 \n​        答案：C\n\n【2018真题】假定 DRAM 芯片中存储阵列的行数为 r、列数为 c，对于一个2Kx1 位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 r、c的取值分别是    （    ）。\n\n​        A. 2048、1                    B. 64、32                    C. 32、64                    D. 1、2048\n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，按行刷新。\n\n【2017真题】某计算机主存按字节编址，由 4 个 64M × 8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是    （    ）。\n\n​        A． 1                             B． 2                             C． 3                             D． 4 \n​        答案：C\n​        要点：多体低位交叉存储器可增大带宽，每个存储周期对所有芯片各读取一次；double 型变量占 8 个字节。\n\n【2021真题】某计算机的存储器总线中有 24 位地址线和 32 位数据线，按字编址，字长为 32 位。若 00 0000H~3F FFFFH 为 RAM 区，则需要 512K x 8 位的 RAM 芯片数为    （    ）。\n\n​        A.8                                B.16                                C.32                                D.64\n​        答案：C\n\n【2022真题】某内存条包含 8 个 8192 x 8192 x 8 位的 DRAM 芯片，按字节编址，支持突发 (burst) 传送方式，对应存储器总线宽度为 64 位，每个 DRAM 芯片内有一个行缓冲区 (row buﬀer)。 下列关于该内存条的叙述中，不正确的是    （   ）。\n\n​        A. 内存条的容量为 512 M                             B. 采用多模块交叉编址方式\n​        C. 芯片的地址引脚为 26 位                           D. 芯片内行缓冲有 8192 x 8 位 \n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，地址引脚为正常的一半；行缓冲区的大小就是一行的大小。\n\n【2013真题】下列选项中，用于提高 RAID 可靠性的措施有    （    ）。\n\n​        I.磁盘镜像        II. 条带化        III.奇偶校验        IV.增加 Cache机制\n​        A.仅I、II            B.仅I、III            C.仅I、III和IV            D.仅II、III和IV\n​        答案：B\n​        要点：RAID 通过条带化来实现并行读写；通过磁盘镜像和校验增加可靠性。\n\n【2013真题】某磁盘的转速为 10000 转/分，平均寻道时间是 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为    （    ）。\n\n​        A.9ms                    B.9.4 ms                    C.12 ms                    D. 12.4 ms\n​        答案：B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间 + 控制器延迟  。\n\n【2015真题】若磁盘转速为 7200 转/分，平均寻道时间为 8 ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是     （    ）。\n\n​        A． 8.1 ms                     B． 12.2 ms                 C． 16.3 ms                     D． 20.5 ms\n​        答案： B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间  。\n\n【2019真题】下列关于磁盘存储器的叙述中，错误的是     （    ）。\n\n​        A．磁盘的格式化容量比非格式化容量小                B．扇区中包含数据、地址和校验等信息\n​        C．磁盘存储器的最小读写单位为一字节                D．磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成 \n​        答案：C\n​        要点：磁盘最小读写单位为一个扇区。\n\n【2014真题】采用指令 Cache 与数据 Cache 分离的主要目的是    （    ） 。\n\n​        A. 降低 Cache 的缺失损失                 B. 提高 Cache 的命中率                \n​        C. 降低 CPU 平均访存时间                 D. 减少指令流水线资源冲突\n​        答案：D\n\n【2017真题】某C语言程序段如下：\n\n123456for(i=0; i&lt;=9; i++)&#123;     temp=1;    for(j=0； j&lt;=i； j++)temp * =a[j];    sum + =temp；&#125;\n​        下列关于数组 a 的访问局部性的描述中，正确的是     （    ）。\n​        A．时间局部性和空间局部性皆有\n​        B．无时间局部性，有空间局部性\n​        C．有时间局部性，无空间局部性\n​        D．时间局部性和空间局部性皆无 \n​        答案：A\n\n【2015真题】假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写（Write Back）方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是         （    ）。\n\n​        A． 146K                             B． 147K                        C． 148K                         D． 158K\n​        答案：C\n​        要点：直接映射方式下，主存块号位数 m = 标记位数 t + Cache 行号位数 c ；\n​                    回写策略下，每个 Cache 行需要另加 1 位修改位（脏位）；\n​                    Cache 行总位数 = 1位有效位 + 1位修改位 +（LRU位）+ 标记 + 数据。\n\n【2022真题】若计算机主存地址为 32 位，按字节编址，某 Cache 的数据区容量为 32KB, 主存块大小为 64B, 采用 8 路组相联映射方式，该 Cache 中比较器的个数和位数分别为     （    ）。\n\n​        A. 8, 20                     B. 8, 23                     C. 64, 20                     D. 64, 23 \n​        答案：A\n​        要点：Cache 中比较器的个数就是组相联的路数 R，比较器的位数就是标记 t 的位数。\n​                    组相联映射方式下，主存块号位数 m = 标记位数 t + Cache 组号位数 q\n\n【2016真题】有如下 C 语言程序段：\n\n12for(k=0; k&lt;1000; k++)    a[k] = a[k]+32;\n​        若数组 a 及变量 k 均为 int 型， int 型数据占 4B，数据 Cache 采用直接映射方式，数据区大小为 1KB、块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为     （    ）。\n​        A． 1.25%                     B． 2.5%                     C． 12.5%                     D． 25% \n​        答案：C\n​        要点：循环内语句需要对 a[k] 访问两次，第一次未命中，并将其所在块调入主存；第二次命中；在该块中的后面三个元素的 6 次访问也都命中。\n\n【2010真题】下列命中组合情况中，一次访存过程中不可能发生的是     （    ）。\n\n​        A． TLB 未命中， Cache 未命中， Page 未命中\n​        B． TLB 未命中， Cache 命中， Page 命中\n​        C． TLB 命中， Cache 未命中， Page 命中\n​        D． TLB 命中， Cache 命中， Page 未命中 \n​        答案：D\n​        要点：TLB 命中，Page 必命中；Page 缺失，Cache 必缺失。\n\n【2019真题】下列关于缺页处理的叙述中，错误的是     （    ）。A．缺页是在地址转换时 CPU 检测到的一种异常B．缺页处理由操作系统提供的缺页处理程序来完成C．缺页处理程序根据页故障地址从外存读入所缺失的页D．缺页处理完成后回到发生缺页的指令的下一条指令执行 \n\n​        答案：D\n​        要点：缺页处理完成后回到发生缺页的指令继续执行。\n\n【2020真题】下列关于 TLB 和 Cache 的叙述中，错误的是    （    ）。\n\n​        A.命中率都与程序局部性有关                            B.缺失后都需要去访问主存\n​        C.缺失处理都可以由硬件实现                            D.都由 DRAM 存储器组成\n​        答案：D\n\n【2015真题】假定编译器将赋值语句 “ x=x+3; ” 转换为指令 “add xaddr, 3”，其中， xaddr 是 x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是    （    ）。\n\n​        A． 0                                 B． 1                            C． 2                             D． 3 \n​        答案：B\n​        要点：直写方式下，每次写入都必须将数据同时写入 Cache 和主存。\n\n【2013真题】某计算机主存地址空间大小为256 MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB (快表)采用全相联映射，有 4 个页表项，内容如下表所示\n\n\n​        则对虚拟地址 03FF F180H 进行虚实地址变换的结果是    （   ）。\n​        A.015 3180H                    B.003 5180H                    C.TLB缺失                    D.缺页\n​        答案：A\n​        要点：虚页号的位数，可以由虚页的个数推出；TLB 中保存的标记就是虚页号。\n\n【2022真题】某计算机主存地址为 24 位，采用分页虚拟存储管理方式，虚拟地址空间大小为 4GB, 页大小为4KB, 按字节编址。 某进程的页表部分内容如下表所示。 \n\n\n​        当 CPU 访问虚拟地址 0008 2840H 时，虚－实地址转换的结果是     （    ）。\n​        A. 得到主存地址 02 4840H                         B. 得到主存地址 18 0840H \n​        C. 得到主存地址 01 8840H                         D. 检测到缺页异常 \n​        答案：C\n二、综合应用题\n【2016真题】某计算机采用页式虚拟存储管理方式，按字节编址，虚拟地址为 32 位，物理地址为 24 位，页大小为 8KB；TLB 采用全相联映射； Cache 数据区大小为 64KB，按 2 路组相联方式组织，主存块大小为 64B。存储访问过程的示意图如下。 \n\n\n​        请回答下列问题。\n​    （1）图中字段 A~G 的位数各是多少？ TLB 标记字段 B 中存放的是什么信息？\n​    （2）将块号为 4099 的主存块装入到 Cache 中时，所映射的 Cache 组号是多少？对应的 H 字段内容是什么？\n​    （3) Cache 缺失处理的时间开销大还是缺页处理的时间开销大？为什么？ \n​        答案：\n​    （1）页大小为 8KB，页内偏移地址为 13 位，故 A=B=32-13=19； D=13； C=24-13=11；\n​        主存块大小为 64B，故 G=6。 \n​        2 路组相联，每组数据区容量有 64 B×2=128B，共有 64KB/128B=512 组，故 F=9；\n​        E = 24-G-F = 24-6-9 = 9。\n​        因而  A=19， B=19， C=11， D=13， E=9， F=9， G=6。\n​        TLB 中标记字段 B 的内容是虚页号，表示该 TLB 项对应哪个虚页的页表项。\n​    （2）块号 4099=00 0001 0000 0000 0011B，因此，所映射的 Cache 组号为 0 0000 0011B=3，对应的 H 字段内容为 0 0000 1000B。 \n​    （3） Cache 缺失带来的开销小，而处理缺页的开销大。 因为缺页处理需要访问磁盘，而 Cache 缺失只要访问主存。\n\n【2018真题】某计算机采用页式虚拟存储管理方式，按字节编址。CPU 进行存储访问的过程如图所示。\n\n\n​        根据上图回答下列问题。\n​        (1) 主存物理地址占多少位？\n​        (2) TLB 采用什么映射方式？TLB 用 SRAM 还是 DRAM 实现?\n​        (3) Cache 采用什么映射方式？若 Cache 采用 LRU 替换算法和回写（Write Back）策略，则 Cache 每行中除数据（Data）、Tag 和有效位外，还应有哪些附加位？Cache 总容量是多少？Cache 中有效位的作用是什么？\n​        (4) 若 CPU 给出的虚拟地址为 0008 C040H，则对应的物理地址是多少？是否在 Cache 中命中？说明理由，若 CPU 给出的虚拟地址为 0007 C260H，则该地址所在主存块映射到的 Cache 组号是多少?\n​        答案：\n​    （1）物理地址由实页号和页内地址拼接，因此其位数为 16+12 = 28；或直接可得 20+3+5 = 28。\n​    （2） TLB 采用全相联映射，可以把页表内容调入任一块空 TLB 项中， TLB 中每项都有一个比较器，没有映射规则，只要空闲就行。 TLB 采用静态存储器 SRAM，读写速度快，但成本高，多用于容量较小的高速缓冲存器。\n​    （3）图中可以看到， Cache 中每组有两行，故采用 2 路组相联映射方式。\n​        因为是 2 路组相联并采用 LRU 替换算法，所以每行（或每组）需要 1 位 LRU 位；因为采用回写策略，所以每行有 1 位修改位（脏位），根据脏位判断数据是否被更新，如果脏位为 1 则需要写回内存。\n​        28 位物理地址中 Tag 字段占 20 位，组索引字段占 3 位，块内偏移地址占 5 位，故 Cache 共有 23 = 8组，每组 2 行，每行有 25 = 32B；故 Cache 总容量为 8×2×(20+1+1+1+32×8) = 4464 位 = 558 字节。\n​        Cache 中有效位用来指出所在 Cache 行中的信息是否有效。\n​    （4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。\n​        利用虚拟地址的虚页号部分去查找 TLB 表（缺失时从页表调入），将实页号取出后和虚拟地址的页内地址拼接，就形成了物理地址。\n​        虚页号 008CH 恰好在 TLB 表中对应实页号 0040H（有效位为 1，说明存在），虚拟地址的后 3 位为页内地址 040H，则对应的物理地址是 0040040H。物理地址为 0040040H，其中高 20 位 00400H 为标志字段，低 5 位 00000B 为块内偏移量，中间 3 位 010B 为组号 2，因此将 00400H 与 Cache 中的第 2 组两行中的标志字段同时比较，可以看出，虽然有一个 Cache 行中的标志字段与 00400H 相等，但对应的有效位为 0，而另一 Cache 行的标志字段与 00400H 不相等，故访问 Cache 不命中。\n​        因为物理地址的低 12 位与虚拟地址低 12 位相同，即为 0010 0110 0000B。根据物理地址的结构，物理地址的后八位 01100000B 的前三位 011B 是组号，因此该地址所在的主存映射到 Cache 组号为 3。 \n\n【2020真题】假定主存地址为 32 位，按字节编址，指令 Cache 和数据 Cache 与主存之间均采用 8 路组相联映射方式，直写（WriteThrough）写策略和 LRU 替换算法，主存块大小为 64B，数据区容量各为 32KB。开始时 Cache 均为空。请回答下列问题。(1) Cache 每一行中标记（Tag）、LRU 位各占几位？是否有修改位？(2) 有如下 C 语言程序段:\n\n12for (k=0; k&lt;1024 ;k++)    s[k]=2*s[k];\n​        若数组 s 及其变量 k 均为 int 型，int 型数据占 4B，变量 k 分配在寄存器中，数组 s 在主存中的起始地址为0080 00C0H，则该程序段执行过程中，访问数组 s 的数据 Cache 缺失次数为多少？\n​        (3) 若 CPU 最先开始的访问操作是选取主存单元 0001 0003H 中的指令，简要说明从 Cache 中访问该指令的过程，包括 Cache 缺失处理过程。\n​        答案：\n​    （1）主存块大小为 64B=26 字节，故主存地址低 6 位为块内地址， Cache 组数为 32KB/(64B×8) = 64=26， 故主存地址中间 6 位为 Cache 组号， 主存地址中高 32-6-6=20 位为标记；\n​        采用 8 路组相联映射， 故每行中 LRU 位占 3 位；\n​        采用直写方式，故没有修改位。\n​    （2）因为数组s的起始地址最后 6 位全为 0， 故 s 位于一个主存块开始处，共占 1024×4B/64B=64 个主存块；\n​        执行程序段过程中，每个主存块中的 64B/4B=16 个数组元素依次读、写 1 次， 因而对于每个主存块，总是第一次访问缺失，以后每次命中。\n​        综上， 数组 s 的数据 Cache 访问缺失次数为 64 次。（3） 0001 0003H = 0000 0000 0000 0001 0000  000000  000011B， 根据主存地址划分可知，组索引为 0， 故该地址所在主存块被映射到指令 Cache 第 0 组； \n​        因为 Cache 初始为空，所有 Cache 行的有效位均为 0， 所以 Cache 访问缺失。此时，将该主存块取出后存入指令 Cache 第 0 组的任意一行，并将主存地址高 20 位（00010H）填人该行标记字段，设置有效位，修改 LRU 位， 最后根据块内地址 000011B 从该行中取出相应内容。\n\n【2021真题】假设计算机 M 的主存地址为 24 位，按字节编址；采用分页存储管理方式，虚拟地址为 30 位,页大小为 4 KB；TLB 采用 2 路组相联方式和 LRU 替换策略，共 8 组。请回答下列问题。\n\n​        (1) 虚拟地址中哪几位表示虚页号？哪几位表示页内地址？\n​        (2) 已知访问 TLB 时虚页号高位部分用作 TLB 标记，低位部分用作 TLB 组号，M 的虚拟地址中哪几位是 TLB 标记？哪几位是 TLB 组号？\n​        (3) 假设 TLB 初始时为空，访问的虚页号依次为 10、12、16、7、26、4、12 和 20，在此过程中，哪一个虚页号对应的 TLB 表项被替换？说明理由。\n​        (4) 若将 M 中的虚拟地址位数增加到 32 位，则 TLB 表项的位数增加几位？\n​        答案：\n​        注意：对于本题的 TLB，需要采用处理 Cache 的方式求解。\n​    （1）按字节编址， 页面大小为 4 KB=212B，所以页内地址为 12 位。 虚拟地址中高 30-12=18 位表示虚页号， 虚拟地址中低 12 位表示页内地址。\n​    （2）TLB 采用 2 路组相联方式，共 8=23 组，用 3 位来 标记组号。 虚拟地址（或虚页号）中高18-3=15 位为 TLB 标记， 虚拟地址中随后 3 位（或虚页号中低 3 位）为 TLB 组号。\n​    （3）虚页号 4 对应的 TLB 表项被替换。 因为虚页号与 TLB 组号的映射关系为\n​                        TLB 组号＝虚页号 mod TLB 组数＝虚页号 mod 8, \n​        因此，虚页号 10,12,16, 7,26,4,12,20 映射到的 TLB 组号依次为 2,4,0,7,2,4,4,4。\n​        TLB 采用 2 路组相联方式， 从上述映射到的TLB 组号序列可以看出，只有映射到 4 号组的虚页号数量大于 2, 相应虚页号依次是 12,4,12 和 20。根据 LRU 替换策略， 当访问第 20 页时， 虚页号 4 对应的TLB 表项被替换出来。\n​    （4）虚拟地址位数增加到 32 位时， 虚页号增加了 32-30=2 位， 使得每个TLB 表项中的标记字段增加 2 位， 因此，每个TLB 表项的位数增加 2 位。\n第四章 指令系统4.1 本章大纲要求与核心考点4.1.1 大纲内容（一）指令系统的基本概念\n（二）指令格式\n（三）寻址方式\n（四）数据的对齐和大/小端存放方式\n（五）CISC 和 RISC 的基本概念\n（六）高级语言程序与机器级代码之间的对应\n\n编译器、汇编器和链接器的基本概念\n选择结构语句的机器级表示\n循环结构语句的机器级表示\n过程（函数）调用对应的机器级表示\n\n4.1.2 核心考点​        本章内容是也是考研考察的一个重点，一般会与第二章、第三章和第五章进行结合，往往以综合应用题的形式出现。而常见的寻址方式很容易以单项选择题的形式进行考察。\n​        需要重点掌握的内容包括：\n\n指令的格式及相关概念，定长与扩展操作码格式。\n常见的寻址方式、特点及有效地址的计算。\n常用的汇编指令，过程调用、选择语句和循环语句的机器级表示，标志位及其使用。\nCISC 和 RISC 的基本概念，CISC 和 RISC 的比较。\n\n4.1.3 真题分布        \n          考点\n          考查次数\n            \n          单项选择题\n          综合应用题\n            \n          常见寻址方式\n          9\n          5\n            \n          指令格式\n          4\n          6\n            \n          程序的机器级代码表示\n          0\n          2\n            \n          CISC 和 RISC\n          1\n          1 \n      \n4.2 指令和指令格式​        计算机是通过连续执行一条条机器语言语句，而实现自动工作的。习惯上就把每一条机器语言的语句称为 指令，而把全部机器指令的集合称为机器的 指令系统。\n\n指令（机器指令）是指计算机执行某种操作的机器语言命令。\n一台计算机的所有指令的集合构成该计算机的 指令系统，也称 指令集。\n\n​        指令系统是计算机的主要属性，位于硬件和软件的交界面上。\n4.2.1 指令的基本格式​        指令由 操作码 和 地址码（操作数地址） 两部分组成。\n\n\n操作码：指出指令执行什么操作和具有何种功能。例如，指出是算术加运算，还是减运算；是程序转移，还是返回操作。\n地址码：指岀被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。\n\n4.2.2 指令字长​        指令字长 是指一条指令中所包含的二进制代码的位数，它取决于操作码的长度、操作数地址的长度和操作数的个数。不同机器的指令字长是不同的，指令字长通常取 8 的整数倍。\n​        按照字长是否可变，又可以将指令系统分为 定长指令字结构 和 变长指令字结构。\n1. 定长指令字结构​        在一个指令系统中，若所有指令的长度都是相等的，称为 定长指令字结构（定字长指令）。\n​        早期的计算机都是定长指令字结构，而且指令字长、机器字长、存储字长全部相等；这样每次访问某个存储单元，就可以取出一个完整的指令或者数据。\n\n​        定字长指令的执行速度快，控制简单。精简指令系统计算机（Reduced Instruction Set Compter，RISC）采用定字长指令。\n2. 变长指令字结构​        随着计算机的发展，存储容量不断增大，要求处理的数据类型也越来越多，指令字长发生了很大变化。一台计算机的指令系统可以采用不同长度的指令，比如单字长指令、多字长指令。\n​        若指令系统中各种指令的长度随指令功能而异，就称为 变长指令字结构（变字长指令）。由于主存是按字节编址的，所以指令字长多为字节的整数倍。\n\n​        控制变长指令的电路会比较复杂，而且多字长指令需要多次访问主存才能取出一条完整指令，导致了 CPU 速度降低。\n​        原则上讲，短指令比长指令好，因为短指令能节省存储空间，提高取指令的速度，但也有很大的局限性。长指令占用更多的存储空间，取指令的时间也会更长，但其能扩大寻址范围或可带多个操作数。 如果长、短指令在同一机器中混合使用，就会给指令系统带来很大的灵活性。为了提高指令运行速度、节省存储空间，一般会尽可能地把常用的指令设计成单字长或者短字长的格式。\n​        复杂指令系统计算机 （Complex Instruction Set Compter，CISC）采用变字长指令。\n4.2.3 地址码​        地址码 用来指出指令操作涉及到的数据或指令具体保存的位置，可以包括：\n\n源操作数的地址（一个或两个）\n操作结果的地址\n下一条指令的地址\n\n​        这里的 “地址” 一般指主存地址，也可以是寄存器的地址，甚至可以是 I/O 设备的地址。\n​        我们以主存地址为例，分析一        其中 OP 是操作码；地址码 A1 为第一操作数地址，A2 为第二操作数地址，Am 为结果地址，A4 为下一条指令的地址。\n​        这一指令完成的操作可以写作：下地址码的分配。根据地址码字段的数量不同，可以把指令再做分类：\n1. 四地址指令​        地址码字段最多的指令，可以包含所有的信息，共有四个地址字段：\n\n​        其中 OP 是操作码；地址码 A1 为第一操作数地址，A2 为第二操作数地址，A3 为结果地址，A4 为下一条指令的地址。\n​        这一指令完成的操作可以写作：\n\n​        对 A1 和 A2 中存放的数据执行 OP 操作，得到的结果填入 A3 ，然后再跳转到 A4 位置执行下一条指令。后续指令地址可以任意填写。\n\n​        假设采用定字长指令结构，指令字长为 32 位，操作码 OP 固定为 8 位。这样，每个地址码就应该占据 6 位，那么能够寻址的地址范围为 2^6^ = 64。\n​        这里如果都是主存地址，那么完成这样的一条四地址指令，需要访问主存 4 次（取指令 → 取操作数 A1 → 取操作数 A2 → 结果写入 A3）。\n2. 三地址指令​        程序中大多数指令都是顺序执行的，而程序计数器 PC 存放了当前要执行指令的地址，每次执行完会自动计算下一条指令的地址（“加 1”）；所以一般并不需要在指令中直接给出下一条指令的地址，A4 可以省去，这样就得到了三地址指令。\n\n​        跟四地址指令一样，它也可以完成操作：\n\n(A_1)OP(A_2)→A_3​        后续的指令地址隐含在 PC 中。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码也可以占据 8 位，能够寻址的地址范围为 2^8^ = 256。当然，完成这样一条指令同样需要 4 次访存。\n3. 二地址指令​        如果将操作的结果直接保存在某个操作数地址对应的存储单元，就又可以在指令中节省一个地址 A3，这样就得到了二地址指令。\n\n它表示执行的操作为：\n\n​        这里 A1 既代表第一个源操作数的地址，也代表本次运算结果的存放地址。这种情况下，完成这一条指令同样需要 4 次访存（取指令 → 取操作数 A1 → 取操作数 A2 → 结果写入 A1）。\n​        由于访存开销比较大，计算机运行过程中，可以将中间计算结果暂存在 CPU 的寄存器（如 ACC）中，这样就节省了最后写入主存的过程。这时的二地址指令表示执行的操作为：\n\n​        这种情况下，完成指令只需要 3 次访存。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码可以占据 12 位，能够寻址的地址范围为 2^12^ = 4K。\n4. 一地址指令​        自然可以想到，如果把二地址指令的两种情况结合起来，把某个操作数放在寄存器中，同时计算结果也放在寄存器中，那么就又可以节省一个地址了；这就是一地址指令。\n\n它表示执行的操作为：\n\n​        这里第一个操作数存放在 ACC 中，第二个操作数地址为 A1，运算结果仍存放在 ACC 中。这样，完成指令只需要 2 次访存（取指令 → 取操作数 A1）。\n​        当然，上面所讨论的都是需要两个操作数的情况；一些特殊的操作，可能只需要一个操作数，比如按位取反、自增自减操作。这时表示执行的操作为：\n\n​        因为得到的结果还要再写回到对应地址中，所以需要 3 次访存（取指令 → 取操作数 A1 → 结果写入 A1）。如果指令字长仍为 32 位、操作码为 8 位，那么地址码可以占据 24 位，能够寻址的地址范围为 2^24^ = 16M。\n5. 零地址指令​        在指令系统中，还有一种指令是没有地址码的，这就是零地址指令。零地址指令中只有操作码也可以分两种情况：\n\n没有操作数的指令，比如空操作（NOP）、停机（HLT）；\n有一个隐含操作数的指令，比如子程序返回（RET）、中断返回（IRET），这类操作利用了栈数据结构，操作数的地址就隐含在堆栈指针（SP）中。\n\n4.2.4 操作码​        操作码的位数就代表了机器的操作种类，也就是机器指令集中的指令条数。操作码的长度可以是固定的，也可以是变化的。根据操作码长度是否可变，可以分为 定长操作码 和 变长操作码 两种指令格式。\n1. 定长操作码指令格式​        定长操作码指令，是在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般 n 位操作码字段的指令系统最大能够表示 2^n^ 条指令。\n\n​        这种指令格式便于计算机硬件设计，指令译码和识别时间短，广泛应用于字长较长的、大中型计算机和超级小型计算机以及 RISC（Reduced Instruction Set Compter，精简指令集计算机）中。当计算机字长为 32 位或更长时，这是常规做法。\n2. 扩展操作码指令格式​        可变长度操作码指令，是指全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。\n​        常见的可变长度操作码是 扩展操作码。在指令字长一定的条件下，操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码。\n​        在设计扩展操作码指令时，需要注意两点：\n\n不允许短操作码是长操作码的前缀；\n各指令的操作码一定不能重复。\n\n​        下面就是一种扩展操作码的示例。指令字长为 16 位，前 4 位为基本操作码字段 OP，另有 3 个 4 位的地址字段分别为 A1、A2、A3。\n\n​        4 位基本操作码若全部用于三地址指令，则有 16 条。如果考虑到需要扩展到较少地址的指令，则将三地址指令减为 15 条，1111 留作扩展操作码使用；二地址指令为 15 条，1111 1111留作扩展操作码使用；一地址指令为 15 条，1111 1111 1111 留作扩展操作码使用；零地址指令为 16 条。\n​        除了这种安排以外，还有其他多种扩展方法，如形成 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令；或者 12 条三地址指令、61 条二地址地址、47 条一地址指令和 16 条零地址指令。\n\n​        在通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n4.2.5 指令的操作数类型和操作类型1. 操作数类型​        计算机中常见的操作数类型有数字、地址、字符、逻辑数据等。\n\n数字：计算机中常见的数字有定点数、浮点数和十进制数，它们分别用不同格式的二进制编码来表达。\n地址：本质上也是一种数据，很多时候需要对操作数地址进行计算，可以认为是一个无符号整数。\n字符：文本或者字符串也是一种常见的数据形式。计算机不能直接存储和传送数据，需要按一定规则对字符进行编码；广泛使用的是 ASCII 编码。\n逻辑数据：除算术运算外，计算机还经常需要进行逻辑运算，此时二进制码中的 0 和 1 就应该被看作逻辑上的 “假” 和 “真”，参与逻辑与或非运算。这样的数据就是 “逻辑数据”。\n\n2. 指令的操作类型​        设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。\n​    （1）数据传送\n​        数据传送指令通常有寄存器之间的数据传送（MOV）、从内存单元读取数据到 CPU 寄存器 （LOAD）、从CPU 寄存器写数据到内存单元（STORE）等。\n​    （2）算术和逻辑运算\n​        这类指令主要有加（ADD）、减（SUB）、比较（CMP）、乘（MUL）、除（DIV）、加1 （INC）、减1 （DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等。\n​    （3）移位操作\n​        移位操作指令主要有算术移位指令、逻辑移位指令、循环移位指令等。移位操作经常被用来替代简单的乘/除法运算。\n​    （4）转移操作\n​        转移操作指令主要有无条件转移（JMP）指令、条件转移（BRANCH）指令、调用（CALL）指令、 返回（RET）指令、陷阱（TRAP）指令等。\n​        ① 无条件转移指令\n​        在任何情况下都执行转移操作，可以直接把程序转移到下一条要执行指令的地址。\n​        例如：“ JMP  X ”，就是无条件跳转到地址 X 去执行下一条指令。\n​        ② 条件转移指令\n​        条件转移指令仅在满足特定条件时才执行转移操作，转移条件一般是一个或几个标志位的值。这些标志位是某些操作的结果，也叫做 “条件码”。例如：\n\n零标志位（ZF），当结果为 0 时，ZF = 1；\n负标志位（SF），结果为负时，SF = 1；\n溢出标志位（OF），结果溢出时，OF = 1；\n进位标志位（CF），最高位有进位时，CF = 1；\n奇偶标志位（PF），结果为偶数时，PF = 1\n\n​        这样，\n​        “ JZ  X ”，就表示判断结果是否为 0：如果为 0 就跳转到 X，如果不为 0 则继续顺序执行；\n​        “ JO  Y ”，就表示判断结果是否溢出：如果溢出就跳转到 Y，如果没有溢出则继续顺序执行；\n​        “ JC  Z ”，就表示判断结果最高位是否有进位：如果有进位就跳转到 Z，如果没有则继续顺序执行。\n​        ③ 调用和返回指令\n​        调用指令可以实现从一个程序到另一个程序的转移操作。\n​        程序中，有些特定的程序段会被反复调用。为了避免重复编写，可以将这些程序段设定为 子程序；需要调用时，只需要执行子程序调用指令就可以了。还有一些子程序是系统提供的，用户也可以直接调用。\n​        调用指令（CALL）一般与 返回指令（RETURN）配合使用。CALL 用来从当前程序位置转移至子程序的入口，RETURN 则用于子程序执行完后重新返回到原程序的调用点。\n\n​        调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。\n​        ④ 陷阱（Trap）指令\n​        陷阱其实是一种意外事故引发的中断。比如，电压不稳定、I/O 设备发生故障、用户使用未定义的指令、除数为 0 等等各种意外事件，都会导致计算机不能继续正常工作。此时计算机就发出陷阱信号，暂定当前程序的执行，转入故障处理程序进行相应的处理。\n​        计算机的陷阱指令一般不提供给用户使用，而是作为隐指令，在出现故障时由 CPU 自动产生并执行。\n​    （5）输入输出操作\n​        对于 I/O 单独编址的计算机，通常设有 I/O 指令。这类指令用于 CPU 与外部设备交换数据或传送控制命令及状态信息。\n​    （6）其它操作\n​        计算机中还有一些通用的控制操作，比如等待（WAIT）、停机（HLT）、空操作（NOP）、开关中断、置条件码等，都有相应的指令来完成。\n4.3 寻址方式​        寻址方式是寻找指令或操作数有效地址的方式，也就是指确定本条指令的数据地址，以及下一条将要执行的指令地址的方法。\n​        寻址方式分为指令寻址和数据寻址两大类。\n4.3.1 指令寻址​        指令寻址是指寻找下一条将要执行的指令地址。指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。\n\n顺序寻址：可通过 程序计数器（PC）加1，自动形成下一条指令的地址。\n跳跃寻址：通过 转移类指令 实现。跳跃寻址是指下一条指令的地址码不是由 PC 给出的，而是本条指令给出的。\n\n\n​        注意：这里所说的 “ PC 加1 ” 并不是 PC 一定会加 “1” 这个数值，而是要加当前指令占据的地址长度，从而总能得到下一条指令的地址；例如，如果机器按字节编址，当前指令字长是 4 个字节，那么执行这条指令后 PC = PC + 4。\n4.3.2 数据寻址​        数据寻址是指确定本条指令中所有操作数的地址，即寻找指令要操作的数据的地址。        \n​        指令中的地址字段并不一定代表操作数的真实地址，称为形式地址（A）。结合形式地址和寻址方式，可计算出操作数在存储器中的真实存储地址，这一地址称为有效地址（EA）。\n​        由于地址字段表达的含义不同，可以有多种不同的寻址方式：比如 直接寻址、间接寻址、寄存器寻址 等。此外，如果通过将某个寄存器内容与一个形式地址相加而生成有效地址，这种方式称为 偏移寻址。偏移寻址又包括基址寻址、变址寻址 和 相对寻址。\n​        数据寻址方式的种类较多，通常在指令中设一个字段，用来指明属于哪种寻址方式。由此可得指令的格式如下：\n\n\n​        操作码的位数决定了指令的条数，寻址特征和形式地址共同决定了可寻址的范围。\n\n若为立即寻址，则形式地址的位数决定了数的范围。\n若为直接寻址，则形式地址的位数决定了可寻址的范围。\n若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。\n若为寄存器间接寻址，则寄存器字长决定了可寻址的范围。\n\n​        下面是常见数据寻址方式的详细介绍。\n1. 立即寻址​        指令的地址字段指出的不是操作数的地址，而是操作数本身，称为 立即寻址，又称为 立即数寻址。 数据采用补码形式存放。\n\n​        上面图中 # 表示立即寻址特征，A 就是操作数本身。\n\n优点：指令在执行阶段不访问主存，指令执行速度快。\n缺点：A的位数限制了立即数的范围，只适合操作数较小的情况。\n\n2. 直接寻址​        指令格式的地址字段中直接指出操作数在内存中的地址，就称为 直接寻址。即\n\n\n\n优点：指令简单，不需要专门计算操作数的地址，指令在执行阶段仅访问一次主存。\n\n缺点：A 的位数决定了操作数的寻址范围，操作数的地址不易修改。\n\n\n3. 间接寻址​        间接寻址 是相对于直接寻址而言的，是指指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址所在的存储单元地址；也就是 “地址的地址”，即 \n\n​        这里用（A）来表示地址为 A 的存储单元所存放的数据。\n\n​        间接寻址也可以分为多次进行，简称 多次间址。对于两次间接寻址，地址 A 存储的内容 A1 还不是有效地址 EA，地址 A1 对应的存储单元所存储的内容才是 EA。这时可以用存储字的首位来标记间接寻址是否结束：存储字首位为 “1” 时，说明还需要继续寻址；为 “0” 时，寻址结束，当前存储字存放的就是 EA。\n\n优点：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）；便于编制程序。\n缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次间址需多次访存)。\n\n4. 隐含寻址​        隐含寻址 是指指令字中不直接给出操作数的地址，而是隐含在某个寄存器中（通过操作码表示）。比如，一地址指令中，对于加法操作就可以只给出一个操作数的地址，而把另一个操作数放在 ACC 中；这时 ACC 就是另一个操作数的地址。\n\n​        因为隐含寻址可以省去指令字中的一个地址，所以这种方式可以缩短指令字长，在计算机的指令集中被广泛使用。\n5. 寄存器寻址​        寄存器寻址 的指令在执行时所需的操作数来自寄存器，运算结果也写回寄存器；地址码字段直接指出了寄存器的编号，即\n\nEA = R_i​        这样，指令执行期间不需要访问主存，减少了执行时间；而且计算机中寄存器数量是有限的，所以地址字段只需要用很少的二进制位指明寄存器编号即可，节省了存储空间。因此寄存器寻址在计算机被广泛应用。\n\n\n优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快。\n\n缺点：寄存器的价格昂贵，且数量有限。\n\n\n6. 寄存器间接寻址​        如果寄存器中不是直接给出操作数，而是操作数的内存地址，那么就称为 寄存器间接寻址。即 \n\n​        这是寄存器寻址和间接寻址的结合。跟寄存器寻址相比，指令的执行阶段还需要访问主存；跟间接寻址相比，则可以少一次对主存的访问。\n\n\n优点：获得操作数地址的速度较快；寄存器编号较短，可有效减少操作数字段的位数。\n\n缺点：寄存器数量有限；指令的执行阶段需要访问主存（因为操作数在主存中）。\n\n\n7. 基址寻址​        基址寻址 是一种偏移寻址的方式，需要设有基址寄存器 BR ；将基址寄存器 BR 的内容（基地址）加上指令中的形式地址，就可以形成操作数的有效地址。即\n\n​        其中基址寄存器既可采用专用寄存器，也可采用通用寄存器。采用专用基址寄存器 BR ，使用时不用明确指出，只需要指令中的寻址特征反映出是基址寻址即可，这是 隐式 基址寄存器；对应地，如果采用通用寄存器，则需要用户明确指出用哪个寄存器作为基址寄存器，这是 显式 基址寄存器。\n\n\n优点：可扩大寻址范围；有利于多道程序设计和浮动程序编制。\n\n缺点：偏移量（形式地址 A）的位数较短。\n\n\n8. 变址寻址​        变址寻址 和基址寻址极为相似，需要设有变址寄存器 IX；将变址寄存器 IX 的内容加上指令中的形式地址，就可以形成操作数的有效地址。即\n\n​        只要变址寄存器的位数足够，也可以扩大操作数的寻址范围。变址寄存器同样可以采用隐式和显式两种方式。\n\n​        不过从本质上讲，变址寻址和基址寻址还是有较大区别的。\n\n基址寄存器是面向 操作系统 的，主要用于为程序或数据分配存储空间，其内容由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的；\n变址寄存器的内容是由 用户设定 的，在程序执行过程中其值可变，而指令字中的 A 是不可变的。变址寻址主要用于处理数组问题。\n\n​        例如，某个数组 a 内有 N 个数据元素，在主存中存放的首地址为 D。那么如果要对数组所有元素求和，可以通过直接寻址的方式依次叠加得到结果，写成汇编语言程序如下：\n\n​        随着 N 的增大，程序的指令条数会越来越多，占据的存储空间也越来越大。\n​        而如果使用变址寻址，只需要将数组元素的索引下标放入变址寄存器中，每次改变变址寄存器的内容（加 1），就能用同样的指令 “ ADD X, D ” 处理所有所有数的相加了。\n\n​        利用一个条件转移指令（BNE），当变址寄存器 X 中内容还没有增大到 N 时，就跳转回 M 处再次执行相同的指令；当增大到 N 时就结束，得到最后结果。这样，不论 N 取多大，这段程序都只需用 7 条指令，所占存储单元大大减少。这其实就是 “循环” 的实现思路。\n\n优点：可扩大寻址范围；在循环体中将 A 设为数组初始地址，可实现数组功能；适合编制循环程序。\n\n9. 相对寻址​        相对寻址 也是偏移寻址的一种，它所基于的是 程序计数器 PC 。将 PC 的内容加上指令中的形式地址，就形成操作数的有效地址，即\n\n​        相对寻址通常用于转移类指令，转移后的的目标地址与当前指令有一段距离，称为 相对位移量；这里就是形式地址 A ，所以 A 也称为 位移量。A 的位数决定了操作数的寻址范围，可正可负，用补码表示。\n\n​        相对寻址的最大特点是转移的目标地址不固定，可以随 PC 的值变化；这样，无论程序加载到主存的哪段区域，都以正确运行，对于编写浮动程序非常有利。例如，之前计算数据和的程序，跳转的目标地址固定为 M；如果程序的首地址发生了改变，M 也会变化。可以将条件转移指令改为相对寻址：\n\n​        这样，无论程序浮动到哪一地址空间，都可以正常运行了。另外，相对寻址也可以和间接寻址结合使用。\n\n优点：便于程序浮动，广泛应用于转移指令。\n\n10. 堆栈寻址​        堆栈寻址 要求计算机中设有堆栈。堆栈既可以用寄存器组来实现，称为 硬堆栈；也可以利用主存的一部分空间作为堆栈，称为 软堆栈。\n​        以软堆栈为例，可以用一个 堆栈指针 SP （Stack Pointer）指出栈顶地址，也可以用 CPU 中的寄存器作为 SP。根据栈数据结构的特点，操作数只能在栈顶指针指向的存储单元里存取。\n\n\n​        可以看出，堆栈寻址也是一种 隐含寻址，操作数的地址被隐含在了 SP 中。而从本质上看，把 SP 看作存放有效地址的寄存器，堆栈寻址就是一种 寄存器间接寻址。\n​        堆栈有 进栈（PUSH）和 出栈（POP）两种操作：\n\n进栈（PUSH A）：（SP）- 1 → SP；（ACC）→ M [ (SP) ]\n出栈（POP A）： （M [ (SP) ]）→ ACC；（SP）+ 1 → SP\n\n​        上面讨论的，都是主存按字编址的情况。如果主存按字节编址，则每次进出栈时 SP 的变化 Δ 会受到存储字长的影响；如果存储字长为 2 字节（16 位）则 Δ = 2，为 4 字节则 Δ = 4。\n\n​        下表列出了所有寻址方式、有效地址及访存次数的简单总结（不含取本条指令的访存）。\n\n\n\n\n寻址方式\n有效地址 EA\n访存次数\n\n\n\n\n立即寻址\n不需要\n0\n\n\n直接寻址\nEA = A\n1\n\n\n间接寻址\nEA = (A)\n2（一次间址）\n\n\n隐含寻址\n隐含在寄存器中\n0\n\n\n寄存器寻址\nEA = Ri\n0\n\n\n寄存器间接寻址\nEA = (Ri)\n1\n\n\n基址寻址\nEA = (BR) + A\n1\n\n\n变址寻址\nEA = (IX) + A\n1\n\n\n相对寻址\nEA = (PC) + A\n1\n\n\n堆栈寻址\nEA = (SP) - 1  （入栈） 或  EA = (SP)  （出栈）\n0（硬堆栈）或 1（软堆栈）\n\n\n\n\n4.4 CISC 和 RISC 的基本概念​        指令集的不同会导致一个处理器的基础结构不同。\n​        最早的 CPU 出现在 20 世纪 70 年代，当时的集成电路技术制约了一块芯片上能实现什么，所以它们的指令集都非常有限；以 8 位 CPU 为主，Intel 8080、MOS 6502、MC 6800 就是其中的代表。之后随着超大规模集成电路技术的发展，微处理器发展得非常迅速，指令集也越来越复杂；并且出现了将处理器、RAM、ROM 和 I/O接口等计算机基本部件集成到一个芯片上的微控制器（MCU），这就是 单片机，Intel 的 MCS-51 系列就是其中的代表。\n​        现代计算机按照处理器的 指令集架构（Instruction Set Architecture，ISA）主要可以分为两种：\n\nCISC（Complex Instruction Set Computer，复杂指令集计算机）\nRISC（Reduced Instruction Set Computer，精简指令集计算机）        \n\n​        面对越来越多的需求，计算机需要完成的任务越来越重，对计算机性能的要求也越来越高。关于如何提升计算机性能，两种指令集架构代表了不同的思路。\n4.4.1 CISC​        CISC 通过设置更多、更复杂的指令来实现更多的功能，这样就可以减少运行程序所需的指令数，依靠硬件提升运行速度。\n​        这种架构的代表公司就是 Intel，它在 1978 年推出了著名的 16 位微处理器 8086，此后又推出了 80286 和 32 位的 80386、80486 以及 奔腾（Pentium）处理器，因而这一系列的处理器都被称为 “ x86 架构 ”。如今已经进入 64 位时代，这一家族采用的指令集架构称为 “ x86-64 ” 或简称 “ x64 ”，代表就是酷睿（Core）处理器。AMD 公司生产的 CPU 主要也是 x86/64 架构。\n​        CISC 的主要特点如下：\n\n指令数目庞大且复杂。Intel 描述全套指令的文档有 1200 多页；\n指令字长是可变的。x86-64 的指令长度可以是 1 ~ 15 个字节；\n每个指令可以执行若干简单操作，例如存储器读取、存储、计算操作等，因此很多指令都能进行访存操作，可以对内存中的操作数直接进行算术和逻辑运算；\n寻址方式丰富。内存中操作数的指示符可以有各种组合，包括偏移量、基址和变址寄存器以及伸缩因子；\n逻辑控制电路复杂，寄存器较少，使用主存中的软堆栈来实现堆栈寻址；\n对机器级程序来说，实现细节是不可见的，全部由硬件完成。\n\n​        因此，CISC 有着非常明显的优缺点。\n\n优点：\n\n运行程序所需的指令数少，有效提升性能；\n\n更加依赖硬件实现功能，编写软件代码较为简单。\n\n\n\n缺点：\n\n指令执行时间差异很大，复杂的指令需要若干时钟周期才可以实现；\n\n指令的使用频率差异很大，很多复杂指令的使用率并不高；\n\n有些指令非常复杂，以至于无法通过组合逻辑电路直接完成，所以需要采用 微程序控制；\n\n编译器能做的优化有限。  \n\n\n\n4.4.2 RISC​        庞大的指令系统设计起来非常复杂，研制周期变得很长，成本耗费巨大。而且对传统 CISC 的测试发现，典型程序中 80% 的语句只用到了系统中 20% 的指令，这被称为 80 - 20 规律。\n​        于是人们开始了对指令系统合理性的研究，试图通过 “做减法” 来从另一个角度提升效率，这样就产生了 RISC。 \n​        RISC 的主要思路是减少指令种类、简化指令功能，通过降低单个指令的执行周期数（CPI）来提高 MIPS，从而提升运行速度。\n​        由于简化了指令集，CPU 芯片就不需要太大的空间来制作逻辑控制电路，而可以加入更多的寄存器，这样就可以让数据运算更快。基于这样的想法，IBM 公司开发出了第一代 RISC 架构计算机；与此同时，斯坦福大学的 RISC 研究课题 MIPS，考虑到了对处理器流水线的优化，研究结果转化成了后来 MIPS 公司的 R 系列产品。\n​        1985 年，Acom 公司设计出了基于 RISC 指令集的 32 位计算机，简称 ARM（Acorn RISC Machine）。1990 年，Acom 改组为 ARM 公司，专门研发芯片架构、出售芯片技术授权，它的指令集架构就被称为 “ ARM 架构 ”。由于 ARM 架构低功耗、低成本的特点，在嵌入式处理器中得到了非常广泛的应用：智能手机、智能汽车、智能家居等各种领域都可以看到 ARM 架构处理器的身影。\n​        如今 RISC 架构已经发展到第五代，称为 RISC-V，这是一个完全开源的指令集架构，采用宽松的 BSD 协议，企业可以完全自由免费使用，同时也容许企业添加自有指令集进行拓展。\n​        RISC 的主要特点有:  \n\n指令数量比 CISC 要少得多；只使用频度较高的简单指令，通过简单指令的组合实现复杂指令功能。早期的 RISC 指令通常少于 100 个；\n\n指令字长是固定的。早期的 RISC 通常将所有的指令都编码为 4 个字节；\n\n允许访存的指令只有 load 和 store，这被称为 load / store 体系结构。因此只能对寄存器中的操作数进行算术和逻辑运算，不能直接对内存中的操作数进行运算；\n\n寻址方式简单，一般所有的 load / store 都通过寄存器中的内容和指令字段中的偏移量来实现；\n\n逻辑控制电路比较简单，有大量的通用寄存器，可以使用硬堆栈来实现堆栈寻址。\n\n对机器级程序来说，实现细节是可见的。因此编译器需要在一些约束条件下进行性能优化；\n因此，RISC 的优缺点和 CISC 相比也是非常明显的。\n\n优点：\n\nCPI 大大降低，并且通过大量寄存器减少了访存次数，有效提升性能；\n采用流水线技术，大部分指令在一个时钟周期完成；采用超标量和超流水线技术，可以使每条指令的平均执行时间小于一个时钟周期；\n控制器便于设计和实现，采用组合逻辑控制（硬布线），不用微程序控制；\n\n可以利用编译器对程序性能进行优化。\n\n低功耗、低成本\n\n\n缺点：\n\n指令的种类和寻址方式都比较少，编写软件比较麻烦；有些早期的 RISC 机器甚至没有乘法指令，需要用一系列加法来实现；\n对编译器的要求比较高，编译器采用不同的优化策略可以显著改变运行性能；\n\n不同指令系统间兼容性差。\n\n\n\n\n4.4.3 CISC 和 RISC 的比较​        下表中详细列出了 CISC 和 RISC 的特点对比：\n\n\n\n\n对比项目\nCISC\nRISC\n\n\n\n\n指令数量\n多\n较少\n\n\n指令字长\n不固定\n固定\n\n\n可访存指令\n无限制\nLoad / Store\n\n\n各种指令使用频率\n相差很大\n相差不大\n\n\n各种指令执行时间\n相差较大\n绝大多数在一个时钟周期内完成\n\n\n寻址方式\n多\n少\n\n\n通用寄存器数量\n较少\n多\n\n\n堆栈寻址\n软堆栈\n硬堆栈\n\n\n控制方式\n微程序控制\n组合逻辑控制（硬布线）\n\n\n机器级程序实现细节\n不可见\n可见\n\n\n编译器\n难以优化\n需要优化\n\n\n指令流水线\n可以通过一定的方式实现\n必须实现\n\n\n功耗\n较高\n较低\n\n\n兼容性\n较好\n较差\n\n\n主要应用领域\nPC 和服务器\n嵌入式设备\n\n\n\n\n​        如今，RISC 机器在发展进化的过程中，逐渐引入了更多的指令；而 CISC 机器也会充分利用高性能的流水线结构。商品化的计算机一般都会将 RISC 和 CISC 结合起来，取长补短。\n4.5 高级语言程序与机器级代码4.5.1 x86 汇编指令基础1. 相关寄存器（1）通用寄存器\n​        x86 架构的 CPU 中会设置一组 通用寄存器，用来存储整数数据和指针（地址）。\n​        最初的 8086 有 8 个 16 位的寄存器，分别叫做 ax、bx、cx、dx、si、di、bp、sp，每个寄存器都有各自特殊的用途，这都体现在它们的名字中。当扩展到 32 位架构（标准名称为 IA32）时，这些寄存器也都扩展为 32 位，名称前加上了 ’‘e“ 表示扩展（extended）。\n​        每个 32 位的通用寄存器，都可以将低 16 位当作一个 16 位寄存器独立使用，最低 8 位当作一个 8 位寄存器使用；而 ax、bx、cx、dx 的高低字节都可以分别作为两个 8 位寄存器，称为 ah、bh、ch、dh 和 al、bl、cl、dl。\n\n​        这里用途最为特殊的，就是堆栈指针 ebp 和 esp，它们配合可以很容易地实现子过程的调用和返回；另外，一般也经常用 ebp + 偏移量 的形式来定位存放在栈中的局部变量。\n​        扩展为 64 位的 x86-64 架构后，原先的 8 个 32 位寄存器全部扩展到 64 位，标号以 r 开头；此外还新增了 8 个通用寄存器，标号为 r8 ~ r15。\n\n\n（2）指令指针寄存器\n​        除通用寄存器外，x86 架构的 CPU 还会设置一系列特殊功能的寄存器。其中最为重要的就是 指令指针寄存器 IP（Instruction Pointer），它存放了下一条要执行的指令的地址；很明显，这其实就是我们之前介绍的 程序计数器 PC。\n​        最初的 ip 也是 16 位的；到了 IA32 架构下，指令指针寄存器也扩展为 32 位，称为 eip；而到了 x86-64 时代，对应也扩展成了 64 位的指令寄存器，称为 rip。\n（3）标志寄存器\n​        标志寄存器 flags  里面有众多标志位，记录了 CPU 执行指令过程中的一系列状态，大都由 CPU 自动设置和修改。\n\nZF 零标志\nCF 进位标志\nSF 符号标志\nOF 溢出标志\nPF 奇偶标志\nTF 跟踪标志\nIF 中断标志\n…\n\n​        很显然，标志寄存器其实就是之前提到的 程序状态字 PSW。IA32 架构下标志寄存器为 32 位，称为 efl（eflags），除去一些不使用的保留位外，每一位都对应着一个状态标志；x86-64 架构下扩展为 64 位，不过扩展的高位都没有使用，相当于还是 32 位。\n2. 汇编指令格式​        对于 x86 指令集的汇编代码，也有两种不同的指令格式。\n\nATT 格式：由 AT&amp;T 公司而得名，这是 GCC 等常用工具的默认格式。\nIntel 格式：Intel 文档中和 Microsoft 编程工具采用的汇编格式。\n\n​        这两种格式整体风格相似，但也有很多不同：\n\n​        x86 是复杂指令集架构，支持多种寻址方式，两种格式的各种寻址方式如下：\n\n​        下面是 mov 指令的一些示例。mov 指令用于移动数据，可以将立即数、寄存器和内存中的操作数，移动到寄存器或者内存中。需要注意，ATT 格式的数据传输方向是从左向右，而 Intel 格式恰好相反。\n\n​        mov 指令不能将一个内存中的操作数，移动到另一个内存地址。\n​        下面我们主要以 Intel 格式为例，来详细介绍 C 语言和汇编指令的对应关系。\n3. 常用汇编指令（1）数据传输指令\n\nmov：在寄存器和内存之间移动数据；\nlea：load effective address，加载有效地址，将一个内存地址加载到目的寄存器；\npush：将数据压入栈，同时 esp 减去数据长度；\npop：将栈顶数据弹出栈，同时 esp 加上数据长度；\n\n（2）算术和逻辑运算指令\n​        主要可以按照操作数的个数分为两类：\n\n双操作数 —— add（加）、sub（减）、mul（无符号乘）、imul（有符号乘）、and（逻辑与）、or（或）、xor（异或）、sal/shl（左移）、sar（算术右移）、shl（逻辑右移）\n\n​        格式为：  op  D, S\n​        表示计算 D (op) S 的值，结果存入 D 中。\n\n单操作数 ——  inc（自增）、dec（自减）、neg（取负）、not（取反）\n\n​        计算的结果仍然存入操作数所在位置。\n\n​        比较特别的是除法指令，它们都只有一个操作数，表示除数，被除数则放在 edx : eax 中；得到的结果商放在 eax 中，余数放在 edx 中：\n\ndiv：无符号除\nidiv：有符号除\n\n（3）转移指令\n\n无条件转移：jmp\n\n​        jmp 指令后面一般跟一个 “标签”（label），用来指明可以直接跳转到的目的地。它的底层编码一般都是 PC 相对的，也就是相对寻址。\n\n有条件转移\n\n​        标志寄存器 efl 中有很多标志状态，也称为 “条件码”，它们记录了最近的算术逻辑操作的结果属性。通过检测这些寄存器中的条件码，就可以执行条件转移指令了。最常用的条件码有：ZF（零标志）、CF（进位标志）、SF（符号标志）、OF（溢出标志）；一般会对它们进行组合，用来表示更加容易理解的控制条件。\n\n​        上面的条件跳转指令，需要先做一个算术或逻辑运算、更改条件码；而很多时候我们只需要做一个简单比较即可，并不需要将运算结果保存。有两类特殊指令可以只改变条件码、而不改变其它任何的寄存器：\n\n​        这两种指令，特别是 cmp 经常和条件转移指令配合使用，用来实现条件分支（选择）和循环结构的程序。\n\n调用和返回\n进行子过程（函数）调用时，使用 call 指令；返回原函数时使用 ret 指令。\n\n\n4.5.2 从 C 语言程序到汇编程序1.  编译器、汇编器和链接器​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用 C 语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用 GCC 编译器可以将它翻译成一个可执行目标程序 hello。具体的过程如下图所示：\n\n​        第二步编译的结果，生成了汇编程序 hello.s，这就是汇编语言描述的机器指令；汇编程序再经过汇编就可以得到二进制的机器语言程序。\n​        在一些集成开发环境（比如 Visual Studio）中，可以在调试（Debug）模式下对机器码进行 ”反汇编“，得到相应的汇编语言代码。\n2. 进程的地址空间​        C 语言程序运行之后，对应的进程都会有自己独立的地址空间；这就是操作系统为每个进程提供的 虚拟地址空间。对于 32 位系统，进程虚拟地址空间的大小就是 2^32^ B = 4 GB。\n​        整个虚拟空间需要操作系统统一管理，因此进程的虚拟地址空间中必须保留一部分给操作系统内核使用。对于 Linux 系统（32 位），内核区大小为 1GB，地址从 0xc0000000 ~ 0xffffffff；而 Windows 系统默认情况下内核区大小为 2GB，地址从 0x80000000 ~ 0xffffffff。其余低地址部分则为用户区。\n​        下面是一个 x86 Linux 进程的虚拟地址空间。\n\n​    用户区主要包括这样几部分：\n\n程序代码和数据：主要包括 只读代码段 和 读写段（.data 和 .bss）。对所有进程来说，代码都是从固定地址开始，紧接着就是 C 语言中的全局和静态数据。其中 .data 中是已初始化的全局和静态 C 变量，而 .bss 中是未初始化的全局和静态变量。\n堆（Heap）：用于运行时的动态内存分配，向上（高地址）生长。代码和数据区，在进程开始运行时就被指定了大小；而通过调用 malloc 和 free 这样的 C 标准库函数，可以让堆区动态地扩展和收缩。\n共享库的内存映射区：用户区的中间部分是一块内存映射区域，用来存放像 C 标准库这样的共享库。\n用户栈（Stack）：位于虚拟地址空间用户区顶部，向下（低地址）生长。一般用来存储局部变量和函数参数，结合堆栈指针可以方便地实现函数的调用和返回。\n\n3. 利用栈实现函数调用​        C 语言中的函数是一种重要的抽象，它将代码按功能封装起来，让程序结构更加清晰、可重用性更高。\n​        每个函数内部可以定义局部变量，这些变量只具有局部作用域。所以，嵌套函数调用时（例如，在函数 P 中调用函数 Q），就可以利用栈数据结构 ” 后进先出 “（LIFO）的特点，在栈内依次保存函数 P 和 Q 的相关内容。\n​        这样，进程中的每一个函数，都会在栈上有一块自己的空间，就叫做 ” 栈帧 “（stack frame）；当前正在执行的函数的栈帧总是在栈顶。这样 esp 的内容就是栈顶地址，而 ebp 的内容就保存当前栈顶栈帧的 “底部” 地址。\n\n​        于是，在调用一个函数 Q（子过程）时，可以在栈上继续给 Q 中的局部变量分配内存空间（入栈）。当 Q 调用结束，就将 Q 的所有局部变量释放（出栈）。\n​        想要用机器级代码实现函数调用，还需要考虑下面几个问题：\n​        ① 参数传递：函数 Q 应该能获取到 P 传入的参数；这可以通过指定参数存放的位置（写入寄存器或者入栈）来实现。\n\n​        ② 转移控制：调用 Q 时，需要跳转到函数 Q 入口处执行指令，这可以用 call 指令实现；调用结束，还应返回到 P 中的调用点继续执行，这需要保存之前调用点的信息，将下一条指令地址入栈。\n\n​        等到调用结束时，执行 ret 指令返回，就执行出栈操作，将栈中保存的地址交给 eip，继续执行 P 中的下一条指令。\n\n​        ③ 保存上下文：原函数 P 使用的寄存器的内容，应该进行保存；调用结束后，还应该进行恢复。\n​        调用 Q 后，可以先将原函数 P 的上下文（寄存器值）做一个入栈保存；然后再分配内存给 Q 的局部变量。待 Q 调用结束后，先释放 Q 的局部变量，然后继续弹栈恢复 P 的上下文。\n\n​        比较特殊的是栈基指针 ebp，在调用 Q 之后，它应该指向 Q 的栈帧的底部；所以应该先将之前的 ebp（P 的栈帧底部）入栈，然后将 ebp 移向 esp 的位置。之后再保存 P 其它寄存器的值、分配空间给 Q 的局部变量。\n12push  ebpmov   ebp, esp\n​        当 Q 调用结束返回时，只要反向执行，让 esp 移向 ebp 的位置；再将原先保存的 ebp 的值弹出，并放入 ebp 中就可以了：\n12mov   esp, ebppop   ebp\n​        对于函数调用开始时（call 之后）两条对 ebp 的处理指令，可以用一条 enter 指令来代替；函数结束时（ret 之前）的两条指令，则可以用 leave 来代替。\n​        ④ 返回值传递：函数 Q 调用结束，执行 ret 指令，此时应该能将返回值传回原函数 P；可以通过指定某个寄存器（eax）接收返回值来实现。\n​        这样，我们可以将完整的栈帧结果表示如下：\n\n​        栈帧中主要由 4 部分构成：上一层函数的上下文（主要是寄存器的值）、当前函数的局部变量、调用下一层函数所需的参数，以及返回地址。对于当前执行的函数 Q，没有参数构造区和返回地址两部分。\n4.5.3 选择结构语句的机器级表示​        除顺序结构外，高级语言程序中一般还会有选择结构和循环结构。\n​        选择结构 又称为 分支（branch）结构。C 语言中的选择语句主要有 if … else 和 switch … case，此外三目运算符 ? : 也可以实现选择结构。\n​        很显然，通过设置条件码（标志位）、结合各类转移指令，就可以很容易地实现程序中的选择语句。\n​        下面一段 C 语言代码使用 if - else 语句实现了选择结构：\n12345678910int a = 23;int b = 31;if (a &gt; b)&#123;\ta++;&#125;else &#123;\ta--;&#125;printf(&quot; a = %d\\n&quot;, a);\n​        可以发现它等效于使用 2 个 goto，分别跳过 if 后面的分支和 else 后面的分支：\n12345678\tif (a &lt;= b)\t\tgoto L1;\ta++;\tgoto L2;L1:\ta--;L2:\tprintf(&quot; a = %d\\n&quot;, a);\n​        这样，很容易得到对应的汇编代码：\n\n4.5.4 循环结构语句的机器级表示​        C 语言中的循环语句有 do - while、while 和 for 三种。汇编语言中，同样可以用条件测试和跳转指令的组合来实现循环的效果。在循环结构中，通常使用条件转移指令来判断循环的结束。\n1. do - while 循环​        下面是一段使用了 do - while 循环的 C 语言代码：\n12345int a = 0;do &#123;\ta++;&#125; while (a &lt; 5);printf(&quot; a = %d \\n &quot;, a);\n​        很明显，循环部分可以利用 if 判断和 goto 语言来实现：\n123456\tint a = 0;L1:\ta++;\tif (a &lt; 5)\t\tgoto L1;\tprintf(&quot; a = %d \\n &quot;, a);\n​        这样，类比之前选择结构，可以得到对应的汇编表示如下：\n\n2. while 循环​        while 循环与 do - while 类似，区别在于第一次执行循环体之前就要先做条件判断。下面是一段 while 循环的 C 语言代码：\n12345int a = 0;while (a &lt; 5) &#123;\ta++;&#125;printf(&quot; a = %d \\n &quot;, a);\n​        如果用 goto 进行改写，可以参考 if - else 的实现，使用两个 goto 分别进行满足、不满足循环条件时的跳转：\n12345678\tint a = 0;L1:\tif (a &gt;= 5)\t\tgoto L2;\ta++;\tgoto L1;L2:\tprintf(&quot; a = %d \\n &quot;, a);\n​        于是对应的汇编程序如下：\n\n3. for 循环​        for 循环可以将循环变量和循环条件统一列出，因此对程序员来说是最友好的；但它直接转换成汇编语言会有一定的难度。for 循环的基本形式如下：\n12for( 初始化循环变量; 判断循环条件; 更新循环变量)    循环体\n​        可以把它先改写成 while 循环的形式：\n123456初始化循环变量;while( 判断循环条件 )&#123;    循环体;    更新循环变量;&#125;\n​        这样，就可以用 goto 改写如下：\n123456789\t初始化循环变量;L1:\tif（循环条件不成立）    \tgoto L2;    循环体;    更新循环变量;\tgoto L1;L2:\t循环外语句;\n​        当然，如果不改写成 while、完全按照 for 循环的执行顺序来处理，就会麻烦很多。比如下面是一段 for 循环的 C 语言代码：\n123456int a = 10;for (int i = 0; i &lt; 5; i++)&#123;\ta--;&#125;printf(&quot; a = %d \\n &quot;, a);\n​        对应的汇编代码如下：\n\n​        很明显，本质上三种循环都是等效的，而比较之下 do-while 循环的汇编指令最简洁。因此，大多数编译器会进行优化，将另两种循环语句转换为 do-while 语句形式来生成机器代码。\n​        另外，x86 架构指令集还提供了一个 loop 指令专门用于循环的实现。它默认使用 ecx 寄存器作为循环计数器，每次执行到 loop 指令都会先对 ecx 做减 1 操作；然后判断 ecx 是否为 0，如果不为 0 则跳转到 loop 后面标号对应的位置，如果为 0 则循环结束继续向下执行。\n123456mov ecx, 10.L1:mov eax, dword ptr [a]sub eax, 1mov dword ptr [a], eaxloop .L1\n​        上面的 loop 指令相当于：\n123dec ecxcmp ecx, 0jne .L1\n​        这样减少了指令数，汇编代码的可读性更高了。除 loop 外，还有类似的 loopz 和 loopnz 指令，它们判断循环继续的条件除了 ecx != 0 外，还有对 ZF 的要求。\n4.5.5 过程（函数）调用对应的机器级表示​        下面是一段 C 语言的函数调用过程。我们在 main 函数中调用了 add 函数，进行两个整数的求和。\n123456789101112131415int add(int x, int y);int main() &#123;\tint a = 23;\tint b = 31;\tint sum = add(a, b);\tprintf(&quot; sum = %d\\n&quot;, sum);&#125;int add(int x, int y) &#123;\tint sum = x + y;\treturn sum;&#125;\n​        函数调用时，首先应该跳转之前，将需要的参数进行保存；然后执行 call 指令，同时将下一条指令地址入栈。主程序 main 对应的汇编代码如下：\n\n4.6 章节练习一、单项选择题\n【2010真题】下列寄存器中，汇编语言程序员可见的是    （    ）A．存储器地址寄存器（MAR） B．程序计数器（PC）C．存储器数据寄存器（MDR） D．指令寄存器（IR）\n\n​        答案：B\n\n【2021真题】下列寄存器中，汇编语言程序员可见的是    （    ）\n\n​        Ⅰ.指令寄存器                Ⅱ.微指令寄存器                Ⅲ.基址寄存器                Ⅳ.标志/状态寄存器\n​        A.仅Ⅰ、Ⅱ                        B.仅Ⅰ、Ⅳ                        C.仅Ⅱ、Ⅳ                        D.仅Ⅲ、Ⅳ\n​        答案：D\n​        要点：汇编程序员可见的寄存器有基址寄存器、变址寄存器、状态/标志寄存器（PSW）、程序计数器 PC 和通用寄存器组；而 MAR、MDR、IR 是 CPU 内部工作寄存器， 对汇编程序员不可见。微指令寄存器属于微程序控制器的组成部分， 它是硬件设计者的任务，对汇编程序员是透明的。\n\n【2022真题】下列选项中，属于指令集体系结构（ISA）规定的内容是     （    ）\n\n​        I. 指令字格式和指令类型         II. CPU 的时钟周期         III. 通用寄存器个数和位数         IV. 加法器的进位方式 \n​        A. 仅 I、 II                         B. 仅I、 III                     C. 仅 II、 IV                     D. 仅 I、 III、 IV \n​        答案：B\n​        要点：指令集处于软硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由 ISA 规定。两个 CPU 可以有不同的时钟周期，但指令集可以相同，CPU 的时钟周期不由 ISA 规定。 加法器的进位方式涉及电路设计， 也不由指令集规定。\n\n【2009真题】下列关于 RISC 的叙述中， 错误的是     （    ）A． RISC 普遍采用微程序控制器B． RISC 大多数指令在一个时钟周期内完成C． RISC 的内部通用寄存器数量相对 CISC 多D． RISC 的指令数、寻址方式和指令格式种类相对 CISC 少 \n\n​        答案：A\n​        要点：相对于 CISC ， RISC 的特点是以硬布线逻辑为主，不用或者少用微程序控制。\n\n【2011真题】下列给出的指令系统特点中，有利于实现指令流水线的是     （    ）\n\n​        Ⅰ ．指令格式规整且长度一致 \n​        Ⅱ ．指令和数据按边界对齐存放 \n​        Ⅲ．只有 Load/Store 指令才能对操作数进行存储访问 \n​        A．仅Ⅰ 、 Ⅱ                     B．仅Ⅱ 、 Ⅲ                     C．仅Ⅰ 、 Ⅲ                     D． Ⅰ 、 Ⅱ 、 Ⅲ \n​        答案：D\n​        要点：以上三点都是 RISC 的特点，都可以有效简化指令流水线的复杂度。\n\n【2016真题】某计算机主存空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是     （    ）\n\n​        A． 30、 30     B． 30、 32     C． 32、 30     D． 32、 32 \n​        答案：B\n​        要点：程序计数器（PC）给出下一条指令字的访存地址，取决于存储器的字数；指令寄存器（IR）用于存放取得的指令，取决于指令字长。\n\n【2017真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条，二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是    （    ）\n\n​        A． 24位     B． 26位     C． 28位     D． 32位 \n​        答案：A\n​        要点：指令字长应是字节的整数倍。\n\n【2022真题】设计某指令系统时，假设采用 16 位定长指令字格式，操作码使用扩展编码方式，地址码为 6位，包含零地址、 一地址和二地址 3 种格式的指令。 若二地址指令有 12 条，一地址指令有254 条，则零地址指令的条数最多为     （    ）\n\n​        A. 0     B. 2     C. 64     D. 128 \n​        答案：D\n\n【2011真题】偏移寻址通过将某个寄存器内容与一个形式地址相加而生成有效地址。下列寻址方式中， 不属于偏移寻址方式的是    （    ）\n\n​        A．间接寻址   B．基址寻址   C．相对寻址   D．变址寻址\n​        答案：A\n\n【2017真题】下列寻址方式中，最适合按下标顺序访问一维数组元素的是    （    ）\n\n​        A．相对寻址     B．寄存器寻址     C．直接寻址     D．变址寻址\n​        答案：D\n\n【2020真题】某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对 4 种寻址方式。单地址指令中，直接寻址方式的可寻址范围是    （    ）\n\n​        A. 0 ~ 255                B. 0 ~ 1023                C. -128 ~ 127                D. -512 ~ 511\n​        答案：A\n​        要点：4 种寻址方式需要有 2 位寻址特征位。\n\n【2009真题】某机器字长为 16 位，主存按字节编址，转移指令采用相对寻址，由两个字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节 PC 自动加 1。若某转移指令所在主存地址为 2000H，相对位移量字段的内容为 06H，则该转移指令成功转移后的目标地址是  （    ）\n\n​        A． 2006H     B． 2007H     C． 2008H     D． 2009H\n​        答案：C\n\n【2013真题】假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000H；地址 1000H 中的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000H中的内容为 4000H，则变址寻址方式下访问到的操作数是    （    ）。\n\n​        A.1000H                        B.2000H                        C.3000H                        D.4000H\n​        答案：D\n\n【2014真题】某计算机有 16 个通用寄存器，采用 32 位定长指令字， 操作码字段（含寻址方式位）为 8 位，Store 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器， 且偏移量用补码表示， 则 Store 指令中偏移量的取值范围是    （    ）\n\n​        A. -32768-+32767                 B. -32767-+32768                 C. -65536-+65535                 D. -65535-+65536 \n​        答案：A\n​        要点：16 个寄存器需要 4 位地址码表示。\n\n【2016真题】某指令格式如下所示 \n\n其中 M 为寻址方式， I 为变址寄存器编号， D 为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是     （    ）\nA． I + D     B． ( I ) + D      C． ( ( I ) + D )     D． ( ( I ) ) + D \n答案：C\n要点：变址寻址中 EA = ( I ) + D；间接寻址中 EA = （ D ）。\n\n【2018真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1 。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是     （    ）。\n\n\n​        A.25                                B.32                                C.64                                D.100\n​        答案：B\n​        要点：数组首地址就是形式地址 D，变址寄存器中存放的是数组下标。\n\n【2018真题】减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)→R3”，该指令执行后将生成进位/借位标志CF 和溢出标志 OF。若(R1)=FFFF FFFFH，(R2)=FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为    （    ）。\n\n​        A. CF = 0, OF = 0                    B. CF = 1 , OF = 0                    C. CF = 0, OF = 1                    D. CF = 1, OF = 1\n​        答案：A\n​        要点：减法操作只需判断借位标志；当最高位进位和符号位进位的值不相同时才产生溢出。\n\n【2019真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H，则该操作数的 LSB（最低有效字节）所在的地址是     （    ）\n\n​        A． F000 FF12H     B． F000 FF15H     C． EFFF FF12H     D． EFFF FF15H \n​        答案：D\n​        要点：基址寻址方式， EA = (BR) + A；大端方式编址，低位字节存放在字的高地址处。\n二、综合应用题\n【2017真题】在按字节编址的计算机 M 上，上题中 f1 的部分源程序（阴影部分）与对应的机器级代码（包括指令的虚拟地址）如下：\n\n12345678int f1(unsigned n)&#123;\tint sum=1, power=1;\tfor(unsigned i=0;i&lt;=n-1;i++)&#123;\t\tpower *= 2;\t\tsum += power;\t&#125;\treturn sum;&#125; \n1234567891011121314\t\tint f1(unsigned n)1\t\t00401020\t55\t\t\t\tpush ebp\t\t...\t\t\t...\t\t\t\t...\t\t\tfor(unsigned i=0;i&lt;=n-1;i++)\t\t...\t\t\t...\t\t\t\t...20\t\t0040105E\t39 4D F4\t\tcmp dword ptr [ebp-0Ch], ecx\t\t...\t\t\t...\t\t\t\t...\t\t\t&#123;\tpower *= 2;\t\t...\t\t\t...\t\t\t\t...23\t\t00401066\tD1 E2\t\t\tshl edx, 1\t\t...\t\t\t...\t\t\t\t...\t\t\treturn sum;\t\t...\t\t\t...\t\t\t\t...35\t\t0040107F\tC3\t\t\t\tret\n​        其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。请回答下列问题。\n​    （1）计算机 M 是 RISC 还是 CISC？ 为什么？ \n​    （2）f1 的机器指令代码共占多少字节？要求给出计算过程。\n​    （3）第 20 条指令 cmp 通过 i 减 n-1 实现对 i 和 n-1 的比较。执行 f1(0) 过程中当 i=0 时， cmp 指令执行后，进/借位标志 CF 的内容是什么？要求给出计算过程。\n​    （4）第 23 条指令 shl 通过左移操作实现了 power 2 运算，在 f2 中能否也用 shl 指令实现 power 2？ 为什么？ （注：将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。）\n​        答案：\n​    （1）M 为 CISC。 因为 M 的指令长短不一，不符合 RISC 指令系统特点。\n​    （2）f1 的机器代码占 96 B。\n​        因为 f1 的第一条指令 “push ebp” 所在的虚拟地址为 0040 1020H，最后一条指令 “ret” 所在的虚拟地址为 0040 107FH，所以， f1 的机器指令代码长度为 0040 107FH - 0040 1020H + 1 = 60H = 96 个字节。  \n​    （3）CF = 1。\n​        cmp 指令实现 i 与 n-1 的比较功能，进行的是减法运算。在执行 f1(0) 过程中， n=0，当 i=0 时，i = 0000 0000H，n-1 = FFFF FFFFH。因此，当执行第 20 条指令时，在补码加/减运算器中执行 “0 减 FFFF FFFFH” 的操作，即 0000 0000H+0000 0000H+1=0000 0001H，此时，进位输出 C=0，减法运算时的借位标志 CF=C⊕1=1。 \n​    （4）f2 中不能用 shl 指令实现 power*2。\n​        因为 shl 指令用来将一个整数的所有有效数位作为一个整体左移；而 f2 中的变量 power 是 float 型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现 “乘 2” 的功能，因而 f2 中不能用 shl 指令实现 power*2。\n\n\n【2019真题】已知 $f(n) = n! = n(n-1)(n-2)…2*1$ ，计算 f(n) 的 C 语言函数 f1 的源程序（阴影部分）及其在 32 位计算机 M 上的部分机器级代码如下：  \n\n\n​        其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址， int 型数据占 32 位。请回答下列问题：\n​    （1）计算 f(10) 需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？\n​    （2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？\n​    （3）根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？已知第 16 行的 call 指令采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第 16 行的 call 指令的后 4 字节为偏移量， M 是采用大端方式还是采用小端方式？\n​    （4） f(13) = 6227020800，但 f1(13) 的返回值为 1932053504，为什么两者不相等？要使 f1(13) 能返回正确的结果，应如何修改 f1 的源程序？\n​    （5）第 19 行的 imul 指令（带符号整数乘）的功能是 R[eax]←R[eax]×R[ecx]，当乘法器输出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF = 1？要使 CPU 在发生溢出时转异常处理，编译器应在 imul 指令后应加一条什么指令？ \n​        答案：\n​    （1）计算 f(10) 需要调用函数 f1 共 10 次，执行第 16 行的 call 指令会递归调用 f1。​    （2）第 12 行的 jle 指令是条件转移指令，其含义为小于等于时转移，本行代码的意义为：当 n≤1 时，跳转至地址 0040 1035H。\n​        第 16 行的 call 指令为函数调用指令，第 20 行的 jmp 指令为无条件转移指令，第 30 行的 ret 指令为子程序的返回指令，这三条指令一定会使程序跳转执行。\n​    （3）其长度计算机 M 上按字节编址，第 16 行的 call 指令的虚拟地址为 0040 1025H，长度为 5 字节，故第 17 行的指令的虚拟地址为 0040 1025H + 5 = 0040 102AH 。第 16 行的 call 指令采用相对寻址方式，即目标地址= (PC) +偏移量， call 指令的目标地址为 0040 1000H，所以偏移量=目标地址- (PC) = 0040 1000H - 0040 102AH = FFFF FFD6H。\n​        根据第 16 行的 call 指令的偏移量字段为 D6 FF FF FF，可以确定 M 采用小端方式。\n​    （4）因为 f(13) = 6227020800，其结果超出了 32 位 int 型数据可表示的最大范围，因此 f(13) 的返回值是一个发生了溢出的错误结果。为使 f1(13) 能返回正确结果，可将函数 f1 的返回值类型改为 double（或 long long，或 long double，或 float）类型。\n​    （5）imul 指令最终结果放在 32 位的 eax 中，所以若乘积的高 33 位为非全 0 或非全 1，则 OF = 1。编译器应在 imul 指令后加一条 “溢出自陷指令”，使得  CPU 自动查询溢出标志 OF，当 OF=1 时调出“溢出异常处理程序”。\n\n\n【2021真题】假定计算机 M 字长为 16 位，按字节编址，连接 CPU 和主存的系统总线中地址线为 20 位、数据线为 8 位，采用 16 位定长指令字，指令格式及其说明如下：\n\n\n​        其中，op1 ~ op3 为操作码，rs、rt 和 rd 为通用寄存器编号，R[r] 表示寄存器 r 的内容，imm 为立即数，target 为转移目标的形式地址。请回答下列问题。\n​    （1）ALU 的宽度是多少位？可寻址主存空间大小为多少字节？指令寄存器、主存地址寄存器（MAR）和主存数据寄存器（MDR）分别应有多少位?\n​    （2）R 型格式最多可定义多少种操作？I 型和 J 型格式总共最多可定义多少种操作？通用寄存器最多有多少个？\n​    （3）假定 op1 为 0010 和 0011 时，分别表示带符号整数减法和带符号整数乘法指令，则指令 01B2H 的功能是什么（参考上述指令功能说明的格式进行描述）？\n​        若 1、2、3 号通用寄存器当前内容分别为 B052H、 0008H、0020H，则分别执行指令 01B2H 和 01B3H 后，3 号通用寄存器内容各是什么？各自结果是否溢出？\n​    （4）若采用 l 型格式的访存指令中 imm（偏移量）为带符号整数，则地址计算时应对 imm 进行零扩展还是符号扩展？\n​    （5）无条件转移指令可以采用上述哪种指令格式？\n​        答案：\n​    （1）ALU 的宽度为 16 位，ALU 的宽度即 ALU 运算对象的宽度，通常与字长相同。\n​        地址线为 20 位，按字节编址，可寻址主存空间大小为 220 字节（或 1MB)。\n​        指令寄存器有 16 位， 和单条指令长度相同。\n​        MAR 有 20 位，和地址线位数相同。MDR 有 8 位，和数据线宽度相同。\n​    （2）R 型格式的操作码有 4 位， 最多有 24 = 16 种操作。\n​        I 型和 J 型格式的操作码有 6 位，因为它们的操作码部分重叠，所以共享这 6 位的操作码空间，且前 6 位全 0  的编码已被 R 型格式占用， 因此 I 和 J 型格式最多有 26 -1 = 63 种操作。\n​        从 R 型和 I 型格式的寄存器编号部分可知， 只用 2 位对寄存器编码， 因此通用寄存器最多有 2^2^ = 4 个。\n​    （3）指令 01B2H = 000000 01 10 11 0010B 为一条 R 型指令，操作码 0010 表示带符号整数减法指令，其功能为 R[3] $\\leftarrow$ R[1] - R[2]。\n​        执行指令 01B2H 后，R[3] = B052H-0008H = B04AH，结果未溢出。\n​        指令 01B3H = 000000 01 10 11 0011B，操作码 0011 表示带符号整数乘法指令。执行指令 01B3H 后，R[3] = R[1] x R(2] = B052H x 0008H = 8290H，结果溢出。\n​    （4）在进行指令的跳转时，可能向前跳转，也可能向后跳转。偏移量是一个带符号整数， 因此在地址计算时，应对 imm 进行符号扩展。\n​    （5）无条件转移指令可以采用 J 型格式， 将 taget 部分写入 PC 的低 10 位，完成跳转。 \n第五章 中央处理器（CPU）5.1 本章大纲要求与核心考点5.1.1 大纲内容（一）CPU 的功能和基本结构\n（二）指令执行过程\n（三）数据通路的功能和基本结构\n（四）控制器的功能和工作原理\n（五）异常和中断机制\n\n异常和中断的基本概念\n异常和中断的分类\n异常和中断的检测与响应\n\n（六）指令流水线\n\n指令流水线的基本概念\n指令流水线的基本实现\n结构冒险、数据冒险和控制冒险的处理\n超标量和动态流水线的基本概念\n\n（七）多处理器基本概念\n\nSISD、SIMD、MIMD、向量处理器的基本概念\n硬件多线程的基本概念\n多核处理器（multi-core）的基本概念\n共享内存多处理器（SMP）的基本概念\n\n5.1.2 核心考点​          本章知识点较多，综合性比较强。其中，指令流水线是历年考查的一个重点，数据通路、控制器原理出现的频率也很高，单项选择和综合应用题都有可能出现。本章单独出题一般以概念和原理为主，计算较少；往往会与第四章结合进行综合考查，有时也会结合第二章、第三章的内容。\n​        需要掌握的内容包括：\n\nCPU 的基本结构，运算器和控制器的组成，各种寄存器的功能和特性。\n指令周期的概念，指令执行的过程和方案。\n数据通路的结构，数据通路中的数据传送流程和控制信号。\n硬布线控制器的概念和原理；微程序控制器的概念和原理，微指令的编码方式及特点；两种控制器的比较。\n异常和中断的概念和分类；异常和中断的响应过程。\n指令流水线的概念、分类和原理；流水线冒险与处理方法；流水线的性能指标；超标量流水线。\n多处理器的基本概念和分类。\n\n5.1.3 真题分布        \n          考点\n          考查次数\n            \n          单项选择题\n          综合应用题\n            \n          指令流水线\n          10\n          2\n            \n          控制器的功能和工作原理\n          6\n          5\n            \n          CPU的功能和基本结构\n          5\n          4\n            \n          数据通路的功能和基本结构\n          3\n          4\n            \n          指令执行过程\n          2\n          2\n            \n          多处理器的基本概念\n          1\n          0\n      \n5.2 CPU 的功能和基本结构5.2.1 CPU 的功能​        中央处理器（CPU）由 运算器 和 控制器 组成。\n​        运算器负责数据加工，也就是对数据进行算术和逻辑运算；而控制器则需要完成计算机各部件之间的协调和控制，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n​        计算机核心的功能就是自动执行一系列指令，这项工作主要由 CPU 中的控制器来完成。具体来说，指令的执行过程包括了 取指令、分析指令 和 执行指令 三个步骤。\n\n\n取指令：控制器能够自动地从存储器中取出指令，并且按预定的顺序依次取下一条指令。这要求控制器可以自动形成要执行的指令地址，并发出取指命令将对应的指令从主存取到控制器中。\n\n分析指令：首先，控制器需要分析指令需要完成什么操作，从而发出对应的操作命令；其次，控制器需要分析操作数的地址，计算出有效地址。\n\n执行指令：根据分析出的 “操作命令” 和 “操作数地址”，控制器就可以形成操作控制信号序列， 通过对运算器、主存以及 I/O 设备的操作，执行每条指令。\n\n​        除此之外，控制器还必须能控制程序的输入和运算结果的输出，以及对总线（Bus）的控制，甚至需要处理一些运行中的异常情况和特殊请求。\n​        所以总结起来，CPU 的功能包括：\n\n数据加工：对数据进行算术和逻辑运算。\n\n指令控制：控制程序的顺序执行，完成取指令、分析指令和执行指令的操作。\n\n操作控制：产生完成每条指令的一系列操作命令，把各种控制信号送往相应的部件，使这些部件按指令的要求进行工作。\n时间控制：对各种操作加以时间上的控制，为每条指令按时间顺序提供应有的控制信号。 \n中断处理：对计算机运行中出现的异常情况和特殊请求进行处理。\n\n5.2.2 CPU 的基本结构​        根据 CPU 的功能可以看出，数据的运算需要由运算器来完成，剩下的功能则由控制器完成。\n\n1. 运算器​        运算器需要对数据进行运算，所以核心部件是 算术逻辑单元（ALU），此外还有一系列的 寄存器 用来缓存数据、运算结果和状态。\n​        运算器中的寄存器主要有暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）、程序状态字寄存器（PSW）等。\n\n暂存寄存器：用于暂存从主存读来的数据。\n\n累加寄存器（ACC）：用于暂存 ALU 的运算结果，可以作为加法运算的一个操作数再次输入 ALU。\n\n通用寄存器组：通用功能的一组寄存器，主要用于存放操作数和地址信息。\n\n程序状态字寄存器（PSW）：对于算术/逻辑运算指令或测试指令的运行结果，专门用一个寄存器 PSW 来保存各种状态信息，也叫 条件码寄存器。典型的条件码有溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。\n\n\n​        这些寄存器对于程序员来说，除了暂存寄存器一般是透明的，其它都是可见的。\n2. 控制器​        控制器是计算机中负责协调控制的部件，主要功能就是取指令、分析指令、执行指令。\n​        控制器需要根据指令中操作码、指令的执行步骤以及当前状态字信息，来生成一系列对计算机各部件的控制信号（也叫做 “微操作”），这个专门的部分就叫做 “控制单元”（CU）。\n​        为了准确地取出指令，需要一个寄存器来保存下一条指令的地址，这就是 程序计数器（PC）；取出的指令同样也需要先保存下来再做分析，存放指令的寄存器就是 指令寄存器（IR），另外还需要一个 指令译码器（ID）来对指令操作码进行译码。最后，还需要有 中断系统 来处理异常情况和特殊请求。\n​        MAR 和 MDR 一般也会集成在控制器中。因此控制器内的寄存器主要有：\n\n程序计数器（PC）：存放下一条指令的主存地址。\n\n指令寄存器（IR）：存放取出的指令。\n\n主存地址寄存器（MAR）：存放要访问的主存单元的地址。\n\n主存数据寄存器（MDR）：存放要向主存写入或从主存读出的信息。\n\n\n​        这些寄存器的功能主要是控制指令的执行过程，因此大多数情况下对用户是透明（不可见）的。不过一般情况下计算机允许汇编程序员访问程序计数器（比如 x86 架构下的 IP），因此 PC 可以认为对汇编程序员来说是可见的。\n​        除此之外，CPU 中一般还会包含 高速缓存（Cache）和 内存管理单元（MMU），以及用于数据传输的内部数据总线和产生时序信号的时序电路。\n5.3 指令周期5.3.1 指令周期的概念​        计算机取出并执行完一条指令所需的全部时间，就叫做 指令周期。\n​        我们已经知道，一条指令的执行过程可以分为 取指令、分析指令 和 执行指令 三个步骤，因此一个指令周期也应该包含这三部操作需要的时间。由于分析指令时可以用硬件实现操作码的译码，因此这步操作用时很短，一般可以将取指令和分析指令合并为一个阶段，对应的时间称为 取指周期；而执行指令阶段所需的时间就称为 执行周期。\n\n​        很明显，各种指令的取指周期是一样的，但由于具体的执行操作不同，执行周期各不相同；因此指令周期是可以不同的。\n​        前面我们将 ”分析指令“ 这一步合并入了取指周期，是因为操作码的译码非常简单；但分析指令不仅仅要对操作码进行译码，还需要根据形式地址得到有效地址。在间接寻址的方式下，指令字中给出的是 ”地址的地址“，所以需要先访问主存一次、取出有效地址，然后再次访问主存取出操作数。这个阶段称为 间址周期。\n\n​        此外，计算机在执行过程中，可能会出现异常情况或者特殊请求，这时需要进行中断处理。所以 CPU 会在每条指令执行阶段结束前，发出 ”中断查询信号“，检测是否有某个 I/O 设备提出了中断请求；如果有，则 CPU 进入中断响应阶段，称为 中断周期。中断周期中 CPU 需要将程序断点保存到存储器中。\n\n​        所以，一个完整的指令周期应该包括 取指、间址、执行 和 中断 4 个部分。间址和中断周期不一定会包含在指令周期中。这 4 个周期内都会有访存操作，又可称为 CPU 的 ”工作周期“。\n\n取指：访问主存取出指令\n间址：访问主存获取有效地址\n执行：从主存中取操作数，或将结果写入主存\n中断：将程序断点保存到主存\n\n​        在 CPU 的硬件底层，为了区分不同的工作周期、更方便地设计控制单元 CU，往往会设置一组 CPU 工作周期的 ”标志触发器“。\n\n​        上面的 4 个 D 触发器 FE、IND、EX 和 INT 就对应了指令周期的取指（fetch）、间址（indirect addressing）、执行（execute）、中断（interrupt） 4 个阶段，以 ”1“ 状态来表示有效。在取指阶段，只要设置 FE 为 1，就可以由它控制取指阶段的各步操作；当取指结束、进入间址周期时，只要将 FE 置 0、IND 置 1 就可以了。\n5.3.2 时钟周期和机器周期1. 时钟周期​        计算机是由 时钟信号 来控制时间顺序的。\n​        时钟信号是由机器中的主振电路（比如晶体振荡器）发出脉冲信号后，经整型或分频后产生。时钟信号的宽度称为 时钟周期，时钟信号的频率就是 CPU 的 主频，时钟周期和机器主频互为倒数。时钟周期是 CPU 工作的最小时间单位。\n\n​    用时钟信号控制节拍发生器，可以产生 节拍；每个节拍的宽度就对应着一个时钟周期。在一个节拍内，机器可以完成一个最小的操作（微操作），或者是几个需要同时执行的操作。\n2. 机器周期​        每条指令都可以包含四个不同的阶段，每个阶段都至少会访问一次主存。\n​        由于访问主存占据了大部分时间，需要一次访存的操作耗时都差不多，因此我们可以设置一个统一的 ”基准时间“，在这个基准时间内，所有阶段的操作都可以完成；这个基准时间就被称为 机器周期。\n\n​        可以看到，一个指令周期包含了若干个机器周期，而一个机器周期又包含若干时钟周期。\n​        上面的例子中，每个机器周期都是相等的，包含 4 个节拍（时钟周期），这是定长的机器周期；如果每个机器周期中包含的节拍数不等，就是不定长的机器周期：\n\n​        不定长的机器周期更适合比较简单的指令，它可以跳过一些不需要的时钟周期，从而让整个指令周期变短。我们可以默认给一个较短的机器周期，对于比较复杂的操作，则通过增加节拍、通过延长机器周期来解决。\n5.3.3 处理器的设计方式​        针对指令周期采用不同的方式，可以设计出不同类型的 CPU。\n1. 单周期处理器​        单周期处理器中，指令周期固定为 一个时钟周期。\n​        在这种方式下，所有的指令都在相同的时间内执行完成，把这个时间就设置为时钟周期，因此 CPI 为 1。因为指令是串行执行的，这样，时钟周期就会以最慢的指令的执行时间为准，从而导致 CPU 主频较低、运行速度较慢。\n​        单周期处理器实现比较简单，但性能较差，不能充分利用硬件资源。\n2. 多周期处理器​        多周期处理器，则是指每条指令需要若干个时钟周期来完成。\n​        一般来说，多周期处理器会将整个 CPU 的指令执行过程分成几个阶段，每个阶段又用若干个时钟周期去完成，然后开始下一条指令的执行。这样，各种指令执行需要的时钟周期数就可能不同。\n​        多周期 CPU 可以更加充分地利用硬件资源，提升执行效率。不过由于每种指令的执行时间不同，需要对指令进行分类，实现起来较为复杂。\n3.  流水线处理器​        流水线处理器同样会将 CPU 执行指令的过程分为几个阶段，而每个阶段都占用相同的时间（机器周期）；在同一时间，在计算机的各个部件上可以依次执行每条指令的不同阶段，就像在流水作业线上处理指令一样。\n​        这样的方式使得指令可以并行执行，大大提升了系统运行效率。每个机器周期，CPU 都会取出一条新的指令；如果以机器周期作为时钟周期，那么理想情况下，流水线的执行效率可以做到接近于每个时钟周期处理 1 条指令，即 CPI 为 1。\n5.4 指令流水线​        对于计算机系统而言，提升器件性能和改进系统结构，是提高整体性能的两大途径。指令流水线 就是改进处理器架构的一项并行处理技术，可以极大地提高 CPU 的工作效率。\n​        计算机中的并行性体现在不同的级别上。通常可以分为以下 4 个级别：\n\n作业级/程序级\n任务级/进程级\n指令之间级\n指令内部级\n\n​        前两个级别是粗粒度的，又称为 过程级，一般用软件算法实现；而后两个级别是细粒度的，又称为 指令级，一般用硬件实现。指令流水线就是一项实现指令级并行的技术。\n5.4.1 指令流水线的基本概念和原理1. 流水线的概念和原理​        类似于工厂中流水装配线的思想，指令的执行过程也可以分成不同的阶段，每个阶段需要的 CPU 部件是不同的；所以 CPU 各个部件可以同时对不同的指令进行处理，这就是指令流水线。\n​        如果只把指令处理过程分成两个阶段：取指令和执行指令，那么没有采用流水线的计算机会串行处理每条指令：\n\n​        取指令的操作可以由取指部件完成，执行指令的操作则可以由执行部件完成。所以这种顺序执行的方式尽管实现简单，但是对硬件的利用率不高。\n​        如果采用流水线，则可以在时间上将不同指令的执行 ”重叠“ 起来，实现并行的效果：\n\n​        划分两个阶段，可以同时有两条指令重叠，这称为指令的 二级流水。\n​        理论上讲，二级流水线同时有两条指令执行，相当于可以将指令周期减半、速度提升一倍。\n2. 六级流水线​        为了进一步提升处理速度，可以将指令的处理过程划分成更为细致的几个阶段：\n\n取指（FI）：从主存取出一条指令，并暂存在缓冲区（IR）中。\n指令译码（DI）：确定操作方式和操作数的寻址方式。\n计算操作数地址（CO）：根据寻址方式，计算操作数的有效地址。\n取操作数（FO）：从主存中取出操作数（如果在寄存器中，则可以跳过这个阶段）。\n执行指令（EI）：执行指令的具体操作，将结果存放在目的位置（寄存器）。\n写操作数（WO）：将结果写入主存。\n\n​        共有 6 个阶段，所以可以构建出六级流水线。流水线中各阶段应该有相同的机器周期，这里我们可以假设以上各段时间相同。对应的指令六级流水时序图如下：\n\n​        这样的流水线处理器中，应该设计 6 个操作部件，可以同时处理 6 条指令，从而大大提高了程序的运行速度。假设机器周期就等于时钟周期，也就是每个阶段用时是 1 个时钟周期，那么流水线可以做到 CPI 接近于1。\n​        当然，实际的流水线远远达不到这样的性能。流水线也有很多问题：\n\n实际处理器中，每条指令不一定包含了完整的 6 个阶段；\n实际的处理器中，指令处理的各个阶段时间不会相同；\n这里需要假设不存在同时访存的冲突，所以所有指令都可以同时并行；实际情况下，指令可能存在冲突；\n当遇到条件转移指令时，下一条指令是无法提前确定的，只能根据前一条指令的执行结果来判断，时间上会有损失。\n\n3. 流水线处理器的设计原则​        流水线处理器设计的基本原则，就是：\n\n机器周期应该是定长的，并且以用时最长的处理阶段为准；它对应着每个流水线阶段（简称 ”流水段“ ）的时间长度。\n流水段的个数，应该以最复杂指令的处理阶段数量为准；\n\n​        很明显，如果 CPU 采用的指令集比较复杂，流水线的效率就会大打折扣。所以更有利于实现流水线的指令集架构，应该满足：\n\n尽量采用定长指令字；\n尽量简化指令的功能，每条指令只完成最基本的功能；\n简化寻址方式，每条指令都可以在较短的时间内得到需要的有效地址；\n使用 load / store 体系结构，只有 load / store 指令可以进行访存操作；\n使用大量寄存器，尽量减少访存操作。\n\n​        可以看出，这些都是 RISC 的特点。所以说，RISC 更加有利于实现流水线；而具体实现中，一般会将每个阶段的机器周期设为一个时钟周期，这样大部分指令都可以在一个时钟周期完成完成。\n5.4.2 流水线冒险​        在指令流水线中，往往会出现一些造成 ”断流“ 的情况，导致流水线无法正确处理指令，这就是 流水线冒险。\n​        流水线冒险主要有三种：结构冒险、数据冒险 和 控制冒险。\n​        我们可以先考虑一个具体的案例。假设现在有一个五级流水线，5个阶段设计分别为：取指令（FI）、指令译码/读寄存器（ID）、执行/计算有效地址（EX）、访存（MEM）、结果写回寄存器（WB）。那么不同类型的指令，在各流水段的操作也有所不同：\n\n​        接下来考虑三种不同的流水线冒险。\n1. 结构冒险​        当流水线中多条指令重叠执行时，不同指令可能会争用同一功能部件而产生资源冲突，这就是 结构冒险，也称为资源相关。\n​        例如，取指阶段 IF 和访存阶段 MEM 都需要访问主存，而冯诺依曼架构的计算机大多会把指令和数据保存在同一个存储器中、且只有唯一的访问口。那么如果在某个时钟周期内，流水线上某一条指令处在 IF 阶段、另一条指令处在 MEM 阶段，就会发生访存冲突。\n\n​        上表中，在第 4 个时钟周期，第 i 条指令 LOAD 处于 MEM 段，正在访问主存；而同时第 i + 3 条指令处于 IF 段，也需要访问主存取指：于是产生了冲突。\n​        解决方案是可以让后一条指令暂停一个时钟周期，等前一条指令完成访存操作后，再开始取指。\n\n​        另一种方案是，可以设置两个独立的存储器，分别存放指令和数据，这样就可以从根本上避免冲突。另外也可以采用 ”指令预取“ 技术，在 CPU 中设置指令队列，将指令预先取出来放到队列中排队。\n2. 数据冒险​        在流水线中，指令之间可能会有数据的关联。如果一条指令的执行，需要用到之前指令的计算结果；那么当之前的指令尚未执行结束时，下一条指令就直接开始读取数据，就会产生冲突。这种情况被称为 数据冒险。\n​        例如，流水线中有下面两条连续的指令：\n​        ADD    R1，R2，R3                                （R2）+（R3）→ R1\n​        SUB     R5，R1，R4                                （R1）-（R4）→ R5\n​        这里，第一条指令将 R2 和 R3 中的数据相加，结果放入 R1；然后第二条指令又将 R1 中的数据取出，跟 R4 的值做减法，结果写入 R5。\n​        在不采用流水线时，按照顺序执行是完全没有问题的；但当采用了流水线结构后，这种 ”先写后读“ 的顺序就发生了变化：\n\n​        在第 3 个时钟周期，SUB 指令就开进入指令译码、读取寄存器 R1 的数据了；而要到第 5 个时钟周期，ADD 指令才会将真正的计算结果写回。”先写后读“ 就变成了 ”先读后写“，产生了数据相关的冲突。\n​        根据指令间对数据读写操作的先后顺序，数据冒险可以分成三类：\n\n写后读（Read After Write，RAW）：也就是先写后读，如果试图写入前就读取，就会读出错误的 旧 内容；\n读后写（Write After Read，WAR）：也就是先读后写，如果试图读取前就写入，就会读出错误的 新 内容；\n写后写（Write After Write，WAW）：两次连续的写入，如果改变了写入顺序，最后保存的数据就是先写入的值；\n\n​        如果只考虑按顺序流动的流水线，那其实只会出现 RAW 相关的情况；而假如是非按序流动的流水线，允许后面的指令超过前面的指令、先流出流水线，那就还可能发生 WAR 和 WAW 的情况。\n​        解决数据冒险可以采用下面的方法：\n（1）后推法\n​        要想解决数据冒险，最简单的解决方案，还是先将后面的指令暂停，等前面指令完成、生成所需的结果之后再继续进行。这种方法称为 后推法。\n​        例如，我们再增加几个指令，构成一个指令序列：\n​        ADD    R1，R2，R3                                （R2）+（R3）→ R1\n​        SUB     R5，R1，R4                                （R1）-（R4）→ R5\n​        AND    R7，R1，R6                                （R1）AND（R6）→ R7\n​        OR       R9，R1，R8                                （R1）OR（R8）→ R9\n​        XOR     R11，R1，R10                            （R1）AND（R10）→ R11\n​        第一条 ADD 指令将 R2 和 R3 相加的结果写入 R1，之后的 4 条指令 SUB、AND、OR、XOR 都要使用 R1 中的值作为一个源操作数。这里就出现了 RAW 数据冒险。\n\n​        如果采用后推法，将后续指令延迟到 ADD 指令完成写回 WB 阶段之后，就可以解决数据冒险：\n\n（2）专用通路技术（数据旁路技术）\n​        另一种解决方案是采用定向技术，也叫 专用通路技术 或 旁路技术。\n​        基本思想是，上一条指令的运行结果，在 EX 阶段就已经产生；那就不必等到上一条指令后续阶段全部完成（写回寄存器），可以直接将结果送到后续指令需要的地方。这样流水线就可以不发生停顿。\n​        由于需要对后续指令进行数据的定向传送操作，所以应该加入另外的部件。\n\n​        上图就是一个带有旁路技术的 ALU 部件。ADD 指令执行的结果，会存入 暂存器 中；而暂存器的结果又会通过旁路通道，经多路开关直接送回 ALU 参与后续的计算。这里的定向传送，只发生在 ALU 内部。\n3. 控制冒险​        控制冒险 主要是由 转移指令 引起的。当遇到条件转移指令（分支指令）时，由于只有上一条指令执行结束才能知道是否跳转，因此一般我们只能采用猜测法，默认不发生跳转、继续取下一条指令；如果真的发生了跳转，这时之前的操作全部作废，需要重新按照 PC 跳转的位置取指执行。这就破坏了流水线的连续流动。\n​        还是用之前的六级流水线的例子，假设指令 3 是一条条件转移指令。\n\n​        指令 3 是条件转移指令，所以只有在第 7 个时钟周期（时间单元）、指令 2 执行完毕之后才能判断是否进行跳转：如果不跳转，则继续执行指令 4；如果跳转，则执行指令 15。\n​        采用猜测法，默认不跳转，所以流水线继续取指令 4，并正常向前流动；但当到第 7 个时钟周期时，发现结果满足条件，需要进行跳转，则之前第 4、5、6、7 个时钟周期所做的操作全部作废，第 8 个时钟周期重新取指令 15，继续流水线的流动。在第 9 ~12 个时钟周期内，没有指令完成，这是预测失败带来的转移损失。\n​        据统计，转移指令大约占到了程序总指令数的 1/4，所以控制冒险会严重影响流水线的性能。为了解决控制冒险，可以采用下面的方法：\n\n尽早判别转移是否发生，尽早生成转移目标地址。\n\n预取转移成功和不成功两个控制流方向上的目标指令。\n\n加快和提前形成条件码。\n\n提高转移方向的猜测率。\n\n\n5.4.3 流水线的性能指标​        流水线的性能，一般用三项指标来衡量：吞吐率、加速比、效率。\n\n​        流水线只有在达到稳定、连续流动的时候，才能获得最大吞吐率。实际上，流水线在开始时有一段建立时间，结束时又有一段排空时间；另外还有各种冒险因素使流水线无法连续流动，所以实际吞吐率总是小于最大吞吐率。\n（2）实际吞吐率\n​        假设流水线中总共有 n 条指令，完成 n 条指令的总时间为 t，那么实际吞吐率就是 n / t。同样，对于 m 段指令流水线，若各段时间为 Δt，那么连续处理 n 条指令时，除了第 1 条指令需要 m · Δt 时间，其它 n - 1 条指令都是每隔 Δt 就会完成一条。所以：\n\n\n2. 加速比​        流水线的加速比，指的是采用流水线处理指令的速度，和同样功能的非流水线的速度之比。\n​        如果流水线每段时间均为 Δt，那么同样是完成 n 条指令，使用 m 段流水线需要的时间为：\n\n\n​        可以看出，当 n → +∞ 时，Sp 趋近于 m，也就是流水线的最大加速比等于流水线的段数。\n3. 效率​        流水线的效率，是指流水线中各功能段的利用率。\n​        因为流水线有建立时间和排空时间，所以各功能段设备不会一直处于工作状态，会有一段空闲时间。假设 m 段流水线各段时间均为 Δt，我们可以将每个功能段（空间）在每个 Δt（时间）内的工作状态画出来，这就是流水线的 “时空图”：\n\n​        上图是一个 4 段流水线（m = 4）的时空图，那么处理 n 条指令一共需要时间为 m · Δt + (n-1) · Δt，在时空图上总的时空区域为：m · (m+n-1) · Δt ；而各段真正处于工作的时空区域为：m · n · Δt。\n​        一般就用流水线各段处于工作的时空区域，和总时空区域的比值，来衡量流水线的效率。计算公式为：\n\n5.4.4 流水线的多发技术​        流水线技术大大提升了 CPU 的处理效率，给计算机系统结构带来了重大改进。通过开发流水线的多发技术，又可以进一步地对流水线进行改进和提升。\n​        所谓的多发技术，就是设法提升流水线的并行效果，尽量在一个时钟周期内可以完成更多的指令。常见的多发技术有 超标量技术、超流水线技术 和 超长指令字技术。\n1. 超标量技术​        超标量（SuperScalar）流水线技术也叫做动态多发射技术，它是指在每个时钟周期内，可以同时并发多条独立的指令；也就是以并行操作的方式，将两条或两条以上的指令编译执行。\n\n​        上图是普通流水线和超标量流水线的对比。这里是一条四级流水线，处理一条指令分为 4 个阶段：取指（IF）、译码（ID）、执行（EX）和 写回（WR）。假设每段时间就是一个时钟周期。\n​        可以看到，普通流水线每个时钟可以产生一条指令的结果；而超标量流水线每个时钟周期都可以产生多条指令的结果。\n​        要实现超标量技术，CPU 中要配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能够实现同时执行多个相同阶段的操作。另外，还需要编译器采用编译优化技术，找到能并行执行的指令进行调配。\n2. 超流水线技术​        超流水线（SuperPipeline）技术是将一些流水线寄存器插入到流水线段中，相当于把每个阶段再进行细分。\n\n​        上图中原来的一个时钟周期又分成了三段。这样超流水线的处理器可以在一个时钟周期内，让功能部件处理 3 条指令；相当于流水线是以 3 倍于原时钟频率的速度运行。\n3. 超长指令字技术​        超长指令字技术（VLIW）也称静态多发射技术，它和超标量技术有共同特点，都是采用多条指令在多个部件中并行处理的架构，从而在一个时钟周期内能够流出多条指令。\n\n​        跟超标量技术的区别在于：超标量的指令来自同一标准的指令流；而超长指令字则是由编译器挖掘出指令间潜在的并行性，然后把多条能并行的指令直接组合成一条指令——这是一条具有多个操作码字段的超长指令。这条超长指令可以控制机器中的多个独立的功能部件同时操作，相当于同时执行了多条指令。\n​        超长指令字技术比超标量有更高的并行处理能力，但对编译器优化的要求更高，对 Cache 容量的要求更大。\n5.5 数据通路和控制信号5.5.1 数据通路的概念和功能​        计算机中，将各个功能部件连接起来、可以进行数据传送的路径称为 数据通路。\n\n​        数据通路的主要功能，就是实现计算机中不同部件间的信息传送和数据交换。在这里我们主要讨论 CPU  内部的数据通路，它描述了信息在 CPU 内各部件之间传递的路径，也包括了路径上流经的部件，比如 ALU、寄存器、中断系统等。\n5.5.2 指令周期中的数据流​        CPU 的指令周期可以分为取指、间址、执行和中断四个阶段，在不同的阶段，控制器应该产生不同的控制信号。我们可以先来分析一下每个阶段中数据的流动方向，这就是指令周期中的 数据流。\n1. 取指周期​        这里我们只讨论 CPU 中最重要的 4 个寄存器 PC、IR、MAR 和 MDR。MAR 与地址总线相连，存放要访问的存储单元地址；MDR 与数据总线相连，存放从主存中读出的或者要写入主存的数据；PC 存放要执行的指令地址，有 “自动加 1” 的计数功能；IR 存放正在执行的指令。\n\n​        ① 将 PC 中存放的当前指令的地址，送到 MAR；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出读命令，经控制总线到达主存；\n​        ④ 主存中对应存储单元的内容（指令）经数据总线，传送给 MDR；\n​        ⑤ MDR 中的内容送至 IR，并将操作码交给 CU 进行译码；\n​        ⑥ CU 控制 PC 内容加 1，形成下一条指令的地址。\n2. 间址周期​        取指周期结束后，CU 就会检查 IR 中的内容，判断寻址方式；如果有间接寻址，就执行间址周期中的操作。\n\n​        ① 取 MDR（或 IR）中的地址码，记作 Ad (MDR)，送至 MAR；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出读命令，经控制总线到达主存；\n​        ④ 主存中对应存储单元的内容（地址）经数据总线，传送给 MDR；\n​        ⑤ 将有效地址传送到 IR 的地址字段（在一些机器中，这一步可以省略）。\n3. 执行周期​        在执行周期，可能会涉及到对 ALU 的操作、寄存器之间的数据传递，以及对主存的读写操作。因为不同的指令在执行周期会有不同的操作，对应的数据流也会有所不同，所以不能用同一的数据流图来表示。\n4. 中断周期​        CPU 进入中断周期后，会进行一系列的操作；核心部分就是要将当前程序执行的状态保存下来，等到中断服务程序执行完毕后再返回继续执行。\n\n​        ① CU 将一个特殊地址（比如 0 地址）送至 MAR，这个地址对应的存储单元保存程序的断点信息，主要就是 PC 的值；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出写命令，经控制总线到达主存；\n​        ④ 将 PC 的内容（程序断点位置）传送给 MDR；\n​        ⑤ 将 MDR 中的断点信息经数据总线，存入主存中；\n​        ⑥ CU 将中断服务程序的入口地址送至 PC，准备执行中断服务程序。\n5.5.3 指令周期的微操作​        CPU 的控制器可以根据每条指令的具体操作，生成一系列的控制信号，控制数据通路上每个三态门在不同时钟周期的 “开” 和 “关”，从而起到控制指令执行的过程。这样的控制信号，就被称为 “微操作” 或者 “微指令”。\n​        下面我们依然根据指令周期的 4 个阶段，分别分析对应的微操作命令。\n1. 取指周期​        对应上一小节分析的取指令过程，可以归纳为以下几个微操作：\n\n2. 间址周期\n\n3. 执行周期​        在执行周期，不同指令的微操作是不同的。这里我们将指令按照功能分为非访存指令、访存指令和转移指令来进行分析。\n（1）非访存指令\n​        这类指令一般只是执行一步简单的操作，在执行周期不访问主存。\n\n（2）访存指令\n​        这类指令在执行阶段需要访问存储器，例如一个操作数在主存中的加法指令，以及从主存中存取数据的指令。简单起见，我们这里只讨论直接寻址的情况。\n\n（3）转移指令\n​        转移指令只是通过对 PC 的更改，实现指令执行的跳转，因此执行阶段也不需要访问主存。\n\n4. 中断周期\n\n5.5.3 数据通路的基本结构和控制信号​        CPU 外部和主存、I/O 设备的连接，一般采用总线方式。而 CPU 内部数据通路的结构，其实就是 CPU 内部的连线方式。根据 CPU 内是否采用总线方式进行连接，数据通路可以分为两种结构。\n1. 不采用 CPU 内部总线​        如果不采用 CPU 内部总线的方式，就需要将 CPU 内的所有需要进行数据传递的部件单独连接起来，相当于为两者之间搭建了一条 “专线”，所以这种方式也叫做 专用数据通路 方式。\n​        这种专用数据通路中所有的路径都是 “专线专用”，不存在冲突，因此性能更好；但所有部件之间都需要进行线路连接，布线比较复杂，硬件成本较高，可扩展性比较差。\n\n​        上图就是未采用总线方式时的数据通路和控制信号。为了简便这里没有画出每个部件输入输出通路的控制门，只用一个小圆圈代替，上面用箭头标出了每个门电路的控制信号 Ci 。\n\n​        接下来以一条采用了间接寻址的加法指令为例：\n1ADD @ X\n​        这条指令中 @ 是间接寻址标志，X 是存放操作数地址的存储单元地址。需要间接寻址取出操作数，与寄存器 ACC 的值相加，得到的结果再写回 ACC 中。我们依然按照指令周期的不同阶段来进行分析：\n（1）取指周期\n\n​        ① 控制信号 C0 有效，打开 PC 送往 MAR 的控制门：（PC）→ MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门：M (MAR) → DB → MDR；\n​        ⑤ C3 有效，打开 MDR 和 IR 之间的控制门，将指令传送至 IR：（MDR）→ IR；\n​        ⑥ C4 有效，打开指令的操作码送往 CU 的输出门：OP(IR) → CU；\n​            CU 在指令操作码和时钟信号的控制下，就可以进一步产生各种控制信号了。\n​        ⑦ PC 内容加 1： （PC）+ 1 → PC \n（2）间址周期\n\n​        ① C5 有效，打开 MDR 和 MAR 之间的控制门，将指令中的形式地址送至 MAR：Ad (MDR) → MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门，将有效地址写入 MDR：M (MAR) → DB → MDR\n​            至此，就获取到了指令操作数的有效地址。\n（3）执行周期\n\n​        ① C5 有效，打开 MDR 和 MAR 之间的控制门，将有效地址送至 MAR： (MDR) → MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门，将操作数存入 MDR：M (MAR) → DB → MDR\n​            至此，就获取到了指令需要的操作数。\n​        ⑤ C6、C7 同时有效，打开寄存器 ACC 和 MDR 连接 ALU 的控制门；\n​        ⑥ 通过 CPU 内部控制线对 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；\n​        ⑦ C8 有效，打开 ALU 通往 ACC 的控制门，将计算结果存入 ACC：（ACC）+（MDR）→ （ACC）\n​            至此，就完成了加法运算的执行过程。\n\n​        还有一些控制信号这条指令没有涉及到：C9 和 C10 分别是控制 PC 的输出和输入的控制信号；C11 和 C~12~ 分别是控制 ACC 的输出和输入的控制信号。\n2. 采用 CPU 内部总线​        类似于系统总线，CPU 内部也可以采用总线方式连接，这种总线也叫做 片内总线。片内总线就是 CPU 内部所有部件的公共数据通路，寄存器之间、寄存器与 ALU 之间都由片内总线连接。\n​        如果只有一条片内总线，这样的结构称为 CPU 内部单总线。这种结构比较简单，硬件容易实现和进行扩展，但存在数据冲突的情况，性能较差。\n\n​        上图中就是采用了 CPU 内部总线方式（单总线）的数据通路和控制信号。每个寄存器都与总线直接相连，这里同样省略了控制门的符号，用一个小圆圈代替，上面用箭头标出了对应的控制信号。控制信号的下标为 i 表示这是输入端的控制，下标为 o 表示输出端的控制。\n​        这里的 ALU 增加了两个寄存器 Y 和 Z，主要是因为 ALU 是组合逻辑电路，本身没有存储数据的功能，运算时必须要求两个输入端同时有效；而单总线上同一时刻（一个时钟周期）只能传送一个数据。因此我们可以设置一个输入寄存器 Y 保存其中一个操作数，让它保持不变，另一个操作数则从总线上获得。同样道理，ALU 的输出也不能直接连接总线输出，否则会影响总线上的输入数据，只能先在输出寄存器 Z 中暂存，等到下个时钟周期再输出。\n\n​        接下来我们依然以加法指令 “ADD @ X” 为例，按指令周期的不同阶段来分析 CU 发出的控制信号。\n（1）取指周期\n\n​        ① PC~o~ 和 MARi 有效，PC 中的内容经内部总线送往 MAR：（PC）→ MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（指令）送至 MDR：M (MAR)  → MDR；\n​        ④ MDR~o~ 和 IRi 有效，将 MDR 的内容送至 IR：（MDR）→ IR；\n​            至此，指令送至 IR，操作码字段交给 CU，就可以进一步产生各种控制信号了。\n​        ⑤ PC 内容加 1： （PC）+ 1 → PC \n（2）间址周期\n\n​        ① MDR~o~ 和 MARi 有效，将指令的形式地址经内部总线送至 MAR：Ad (MDR) → MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（有效地址）送至 MDR：M (MAR)  → MDR；\n​            至此，就获取到了指令操作数的有效地址。\n（3）执行周期\n\n​        ① MDR~o~ 和 MARi 有效，将有效地址经内部总线送至 MAR：（MDR）→ MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（数据）送至 MDR：M (MAR)  → MDR；\n​            至此，就获取到了操作数。\n​        ④ MDR~o~ 和 Yi 有效，将操作数送至寄存器 Y，直接作为 ALU 的一个输入：（MDR）→ Y；\n​        ⑤ ACC~o~ 和 ALUi 有效，同时 CU 向 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；得到的结果直接送往寄存器 Z：（ACC）+（Y）→ Z；\n​        ⑥ Z~o~ 和 ACCi 有效，将运算结果写入 ACC：（Z）→ ACC\n​            至此，就完成了加法运算的执行过程。\n\n​        现代计算机的 CPU 都集成在一个芯片内，所以采用片内总线的方式可以极大地节省连线，使芯片密度更高、布局更为合理，也更加容易扩展。\n​        而为了提升性能，解决单总线结构的数据冲突问题，可以增加总线的数量，这就是 CPU 内部多总线方式。这种结构的 CPU 内部有多条公共通路；相比单总线一个时钟内只允许传送一个数据，多总线可以同时传送多个数据，效率更高。\n5.6 控制器的原理和设计​        控制单元 CU 控制一条指令执行的过程，实质上就是发出控制信号、依次执行一个微操作序列的过程。很明显，不同的指令中包含的微操作数量不等，每个微操作的复杂程度也不同，所以每条指令的执行时间都是不同的。\n​        在 CPU 内，可以通过时钟信号产生节拍，来控制每个微操作的执行。一个指令周期可以包含多个机器周期，每个机器周期又可以包含多个节拍，这样就构成了 多级时序系统。\n​        控制不同的微操作序列，需要产生不同的时序控制信号。至于如何形成这些控制信号，可以采用不同的时序控制方式，这就被称为 CU 的 控制方式。\n5.6.1 CU 的控制方式​        CU 的控制方式，主要有 同步控制、异步控制、联合控制 和 人工控制 四种。\n1. 同步控制​        最常见的控制方式就是 同步控制。这种方式下 CPU 有一个统一的时钟，所有指令的每一个微操作，执行顺序都是事先确定好的，根据时钟信号在不同的时钟周期依次执行。\n​        根据机器周期的不同设置方式，同步控制又有三种不同的方案：\n​    （1）采用定长的机器周期\n​        这是最简单的方式，不论指令对应的微操作有多少、也不管微操作有多复杂，一律采用统一的机器周期来执行各种不同的指令，每个机器周期包含相同的节拍数，每个节拍的宽度完全一致。\n\n​        这样的话，机器周期的选择必须要以执行最慢的指令和微操作为准，对于比较简单的指令就会有时间上的浪费。\n​    （2）采用不定长的机器周期\n​        采用不定长的机器周期时，每个机器周期内的节拍数可以不等，这样就可以解决微操作执行时间不统一的问题了。\n\n​        一般会把大多数微操作安排在一个较短的机器周期内完成，而对于比较复杂的微操作，则通过延长机器周期来解决。\n​    （3）中央控制和局部控制相结合\n​        这种方式相当于是定长和不定长机器周期的结合。将机器的大部分指令安排在统一的机器周期内完成，称为 中央控制，这个机器周期一般比较短；而将少数复杂指令中的一些操作，通过插入一些额外的节拍来进行处理，这称为 局部控制。\n\n​        局部控制的每个节拍跟中央控制的节拍宽度相同，个数则是不确定的。\n2. 异步控制​        异步控制方式不存在统一的时钟信号，没有固定的周期节拍和时钟同步；每条指令和每个微操作耗费的时间都以它们在电路中完成为准。\n​        这种控制方式 CPU 没有空闲时间，利用率更高；但微操作的时序就需要有专门的 “应答线路” 来进行控制，结构会更加复杂。\n3. 联合控制​        联合控制方式就是同步控制和异步控制的结合。这种方式下，对于指令中大部分一致的微操作，采用同步控制；而对于小部分特殊的、时间难以确定的操作，则采用异步控制。\n4. 人工控制​        为了调试机器和软件开发的需要，可以在机器面板或者内部设置一些开关或者按键，由人工进行操作控制。例如，一些机器设有 Reset（复位）键，可以人工恢复初始状态。\n\n​        确定了 CU 的控制方式，就可以设计具体的控制单元了。根据产生微操作控制信号的方式不同，控制器又可以分为 组合逻辑控制器 和 微程序控制器。\n5.6.1 组合逻辑控制器​        组合逻辑控制器直接通过组合逻辑电路的设计，根据当前的指令操作码、工作周期标志以及时钟信号生成对应的控制信号（微操作）序列，实现控制器的各种功能。也叫做 硬布线控制器。\n1. 基本原理和结构框图​        组合逻辑控制器的控制信号，都是由控制单元（CU）产生的。它的输入是时钟信号、操作码译码之后的信号以及条件码标志位。\n\n​        存放在 IR 中的 n 位操作码可以经过一个译码器，产生 2n 个输出；于是每种操作码都会对应一个输出信号送至 CU。\n​        CU 的时钟信号就是一个脉冲序列，让它通过一个节拍发生器（计数器）就可以产生一个宽度等于时钟周期的节拍序列。在每个节拍内，可以保证完成一次微操作，数据信息能够完成数据通路中的流动。这样，CU 就可以按照节拍来发出控制信号的序列了。\n2. 微操作的节拍安排​        接下来就可以将每个工作周期中的微操作，安排到对应的节拍中了。\n​        安排微操作的节拍应该遵循以下基本原则：\n​        ① 微操作的先后顺序不能发生改变；\n​        ② 如果是控制不同部件的微操作，可以同时执行的话，应该尽可能安排在同一个节拍内；\n​        ③ 如果有些微操作耗时不长，那可以将多个这样的微操作安排在一个节拍内完成，并且允许它们有先后次序。\n​        现在我们假设采用定长机器周期的同步控制方式，每个机器周期包含 3 个节拍。以上一节讨论的 10 条不同指令为例，可以安排微操作的节拍如下：\n（1）取指周期\n\n（2）间址周期\n\n（3）执行周期\n​        同样，还是针对不同类型的指令，分别分析微操作的节拍安排。\n​        1）非访存指令\n​        非访存指令一般都只有很简单的操作，因此可以直接把微操作安排在一个节拍内。可以选择 T0 ~ T2 的任一节拍，其余节拍空闲。\n​        这里以 CLA 指令为例，把它的微操作安排在 T2 节拍内：\n\n​        2）访存指令\n​        访存指令中需要进行访问主存操作，微操作的节拍安排可以跟取指、间址周期类似。\n\n​        3）转移指令\n​        同样，转移指令微操作比较简单，可以在 T0 ~ T2 任选一个节拍进行安排。\n\n（4）中断周期\n​        在指令周期的最后阶段，CPU 会向所有中断源发出中断查询信号，若检测到有中断请求，在允许中断的条件下就会进入中断周期。中断周期的微操作节拍安排如下：\n\n5.6.2 微程序控制器​        组合逻辑控制器线路庞杂，为了克服这个缺点，可以采用类似 “存储程序” 的方法，来形成具体的微操作序列；这被叫做 “微程序”，采用这种技术的控制器就被称为 微程序控制器。\n1. 基本原理和结构框图​        微程序控制器的基本思想是，将每条机器指令编写成一个 微程序，每一个微程序包含若干条 微指令，每一条微指令对应一个或几个微操作命令。然后把这些微程序存入一个 控制存储器（简称控存，CM）中，用读取指令的方式将它们读出依次执行就可以了。\n\n​        这样，每一条机器指令都可以对应着一个微程序。对于取指、间址、中断周期，所有指令的操作都是相同的，因此可以统一编制成一个微程序；而每条指令执行阶段的操作则单独对应一个微程序。这样，控制存储器中微程序的个数，就是机器指令的数量，再加上对应取指、间址、中断周期的 3 个微程序。\n​        微指令的基本格式，应该包含两个字段，前面是操作控制字段，对应着微操作命令，可以发出各种控制信号；后面是顺序控制字段，可以指出下条微指令的地址（简称 下地址），从而控制微指令序列的顺序执行。\n\n​    微程序控制单元的结构如下所示：\n\n\n控制存储器：微程序控制单元的核心部件，存放着全部的微程序；显然控存可以采用 ROM 实现。\nCMAR：控存地址寄存器，用来存放准备读取的微指令地址；\nCMDR：控存数据寄存器，用来存放从控存读出的指令；\n顺序逻辑：用来形成下一条微指令的地址，用来控制微指令序列的执行顺序。\n\n2. 微程序控制器的工作过程​        我们可以结合一个具体的例子，来说明微程序控制器的工作过程。假设一段用户程序，有下面的两条汇编指令：\n123LDA  XADD  Y...\n​        当执行到第一条指令 LDA X 时，PC 的值为这条指令在主存中存放的地址。控制单元 CU 将执行以下的操作。\n​    （1）取指阶段\n​        首先进入取指周期，微程序控制单元将执行取指阶段的每一个微操作。\n\n​        ① 将取指周期的微程序首地址 M 送至 CMAR：M → CMAR；\n​        ② 取微指令，将控存 M 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 (PC) → MAR，1 → R；\n​        ④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 1，所以将 M + 1 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑤ 取下一条微指令，将控存 M + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR，（PC）+ 1 → PC；\n​        ⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 2，所以将 M + 2 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑧ 取下一条微指令，将控存 M + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ IR，\nOP (IR) → CU。\n​        至此，第一条指令 “LDA X” 已经取出并保存到了 IR 中。\n​    （2）执行阶段\n​        简单起见，我们假设这条指令采用了直接寻址，因此跳过间址周期，直接进入执行周期。\n\n​        ① 根据指令的操作码，形成取数指令的微程序首地址 Q，并送至 CMAR：OP (IR) → 微地址形成部件 → CMAR；\n​        ② 取微指令，将控存 Q 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 Ad (IR) → MAR，1 → R；\n​        ④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 1，所以将 Q + 1 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑤ 取下一条微指令，将控存 Q + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR；\n​        ⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 2，所以将 Q + 2 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑧ 取下一条微指令，将控存 Q + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ ACC。\n​        至此，就完成了取数指令 LDA X 的全部操作。\n​        最后一条微指令的顺序控制字段为 M，所以接下来 CPU 又将进入下一条指令 ADD Y 的取指周期，从控存中依次读出微程序的每条微指令、发出一系列的控制信号。\n​        微程序控制单元设计的过程中，关键问题是微指令的操作控制字段怎样去发出控制信号，以及如何具体产生下一条微指令的地址。这跟 微指令的编码方式 和 微地址的形成方式 有关。\n3. 微指令的编码方式​        微指令的编码方式，主要是指怎样对微指令的操作控制字段进行编码，进而发出对应的控制信号。所以也称为 微指令的控制方式。\n​        微指令的编码方式主要有以下几种。\n​    （1）直接编码（直接控制）\n​        最简单的方案，就是让微指令的操作控制字段中，每一位都对应着一个微操作命令；这种编码方式就称为 直接编码方式。\n\n​        当控制字段的某位为 “1” 时，就表示控制信号有效，进而打开对应数据通路的控制门；为 “0” 时则表示控制信号无效，控制门关闭。\n​        这种方式实现简单、含义清晰，而且只要微指令从控存中读取出来就立刻可以发出对应的控制信号，速度非常快。不过由于微操作数量众多，因此控制字段的位数也会非常多，可能达到几百位，造成控存容量过大。\n​    （2）字段直接编码\n​        想要减少控制字段的位数，可以通过加一个译码器来解决。不过由于可能会有多个微操作命令同时有效（并行）的情况，因此可以根据并行发出的微命令个数将控制字段再做 “分段”，每段内分别进行译码、对应一个微操作命令。\n​        这种方式由字段直接译码发出微命令，所以叫做 字段直接编码方式，也称为 显式编码。\n\n​        这里所谓的 “微命令” 就是 CU 发出的控制信号，而 “微操作” 就是微命令生效后执行的过程，它们是一一对应的关系，所以一般我们不再过多区分。\n​        指令执行过程中，有一些微命令可以同时产生，我们称它们是 “相容” 的；而如果一组微命令不能同时发生，则称它们是 “互斥” 的。字段直接编码时，应该将互斥的一组微命令放在一个字段内；而不同字段的微命令，则是相容的。每个字段的长度可以不同。此外，每个字段还应该留出一种状态，表示不发出这一组中的任何微命令。\n\n​        例如，某机器的微指令格式中，有 8 个控制字段，每个字段可以分别发出 5、8、3、16、1、7、25、4 种控制信号。那么采用直接编码和字段直接编码方式设计微指令，需要的操作控制字段至少是多少位？\n​    （1）直接编码\n​        微指令操作控制字段的位数，就是总的控制信号数：\n5+8+3+16+1+7+25+4=69\n​    （2）字段直接编码\n​        每个字段需要保留一个编码，表示不做任何操作；因此 8 个字段分别需要表示 6、9、4、17、2、8、26、5 种情况。对应的编码位数应该是：3、4、2、5、1、3、5、3，因此总位数为：\n3+4+2+5+1+3+5+3=26\n​        很明显，使用字段直接编码可以有效地减少控制字段的位数。\n\n​    （3）字段间接编码\n​        这种方式在字段直接编码的基础上，又增加了一步转换，即一个字段的某些微命令，还需要受到另一字段译码输出的控制，因此被称为 字段间接编码，也叫 隐式编码。\n\n​        这种方式可以进一步减少控制字段位数，但电路更加复杂、而且削弱了微指令的并行控制能力，因此一般只是作为字段直接编码的辅助手段。\n​    （4）混合编码\n​        将直接编码和字段编码（直接或者间接）混合使用，就成了 混合编码方式。这种方式主要是综合考虑微指令字长、灵活性和执行速度各方面的要求。\n4. 微指令格式​        微指令的格式跟微指令的编码方式有关，通常可以分为水平型微指令和垂直型微指令。\n​    （1）水平型微指令\n​        水平型微指令的主要特点，就是一次能定义并执行多个并行操作的微命令。从编码方式看，前面介绍的直接编码、字段直接编码、字段间接编码以及混合编码都属于水平型微指令。\n​    （2）垂直型微指令\n​        垂直型微指令不强调并行控制的功能，而是采用了类似机器指令中操作码的方式，在操作控制字段中用 “微操作码” 来规定微指令的功能。通常一条微指令中，只有 1 ~ 2 个微命令，控制 1 ~ 2 种操作。\n\n​        相比而言，水平型微指令并行操作能力更强、速度更快、效率更高、灵活性强；而垂直型微指令与机器指令更加类似，语义更加清晰。水平型微指令用较长的微指令结构，换取较短的微程序；而垂直型微指令是以较长的微程序结构，换取较短的微指令结构。\n5. 微指令序列地址的形成​        微指令执行过程中，在不同阶段，需要采用不同的方式形成后续微指令的地址。\n​    （1）直接由当前微指令的下地址字段给出\n​        大部分微指令都会在下地址字段直接指出下一条微指令的地址，在每一段微程序内部一般都是这种方式。也被称为 断定方式。\n​    （2）根据指令的操作码形成\n​         取指周期结束、机器指令被存放入 IR 后，接下来执行阶段微指令的地址，会由微地址形成部件根据操作码产生。\n​        所谓的微地址形成部件，其实也就是一个编码器，它的输入是指令操作码，输出是对应微程序执行阶段的首地址。它可以用 PROM 来实现，以指令的操作码作为 PROM 的地址，相应的存储单元存放微程序首地址。\n​        对于不同的方式，可以用一个 多路选择器，通过对当前一些状态标志的判断来进行选择。\n\n​        除了上面最基本的两种方式，还可以采用以下方法形成微指令序列地址。\n​    （3）增量计数器法\n​        可以发现，大多数情况下后续微指令的地址都是连续的，所以可以借鉴 PC 的功能，采用 “增量计数法” 形成后续微指令的地址：(CMAR) + 1 → CMAR。\n​    （4）分支转移\n​        当遇到转移指令时，微指令也会出现分支，这时必须根据转移方式指明的判别条件，根据各种标志决定下一条微指令的地址。\n​    （5）通过测试网络形成\n​        这种方式微指令的地址码分两部分，高段为非测试地址，需要直接保留；低段则为测试地址，需要结合测试源的信号、通过测试网络来生成。\n​    （6）由硬件生成微程序入口地址\n​        电源接电后，程序第一条微指令的地址（入口地址），可以由专门的硬件电路产生。\n​        另外，当有中断请求且条件满足时，CPU 进入中断周期，这时也可以由硬件产生中断周期微程序的入口地址。同理，当有间接寻址时，也可以由硬件产生间址周期微程序的入口地址。\n6. 微程序设计​        设计微程序控制器，主要任务其实就是编写各条指令的微程序。\n​        具体步骤也可以分为三步：首先写出所有指令的全部微操作以及节拍安排；其次确定微指令格式；最后编写出每条微指令的二进制代码（称为 微指令码点）。\n​    （1）写出机器指令的微操作以及节拍安排\n​        这里我们用跟组合逻辑设计相同的案例，只考虑 10 条机器指令。简单起见，我们这里不考虑间接寻址和中断的情况，只讨论取指和执行周期。\n​        1）取指阶段\n​        跟组合逻辑设计类似，取指阶段的微操作可以安排在三个节拍内：\n\n​        如果一个节拍内的微操作，都对应一条微指令，那么上面的取指微程序对应着 3 条微指令。\n​        不过我们发现，微程序控制器的所有控制信号都来自于微指令，而微指令都存放在控制存储器中。所以每条微指令执行之前，必须有一个将微指令地址送至 CMAR 的过程。或者说，每条微指令执行结束，应该形成后续地址，交给 CMAR；这必须额外耗费一个时钟周期（节拍）。\n\n​        这样，取指操作就需要 6 条微指令来完成。所有微指令都会由时钟信号的上升沿打入 CMDR 中。\n​        2）执行阶段\n​        同样，执行阶段的微操作是由指令操作码决定的；每条微指令完成之后同样要考虑后续指令地址的形成。\n​        a）非访存指令\n\n​        b）访存指令\n\n​        c）转移指令\n\n​        以上总共有微指令 38 条，不同的微操作有 20 个。\n​    （2）确定微指令格式\n​        确定微指令格式，主要是确定微指令的编码方式、后续微指令地址的形成方式，以及微指令字长 3 个方面。\n\n微指令编码方式：微操作不多，可以采用直接编码方式；\n后续地址形成方式：根据指令操作码和微指令的下地址，确定后续微指令地址的形成；\n微指令字长：20 个微操作，对应 20 位操作控制字段；38 条微指令，需要 6 位下地址字段。微指令字长至少取 26 位。\n\n​        进一步分析可以发现，38 条微指令中，19 条都是将后续地址送入 CMAR 的操作。这不仅在微指令上有所浪费，而且相当于每两个时钟周期，才能取出并执行一条微指令。\n​        我们可以将 CMDR 的下地址字段 Ad (CMDR) 直接接到控制存储器的地址线上，在下一个时钟信号的上升沿，就将对应地址的内容（下一条微指令）读取到 CMDR 中。这样就省去了 CMAR，直接用 Ad (CMDR) 取代，而且做到了每一个时钟周期完成一条微指令，大大提升了运行速度。\n​        同样，指令操作码 OP (IR) 通过微地址形成部件产生的后续地址，也可以直接送到控制存储器的地址线上。\n\n​        通过这样的化简，我们就省去了 19 条微指令，并同时省去了 Ad (CMDR) → CMAR 和 OP (IR) → 微地址形成部件 → CMAR 两个微操作。于是总共只需要 38 - 19 = 19 条微指令和 20 - 2 = 18 个微操作。\n​        这样，最少只需要 18 位控制字段和  5 位地址字段。不过为了便于以后扩展，我们可以取 24 位操作控制字段和 6 位下地址字段。微指令格式如下：\n\n​    操作控制字段的第 0 ~ 17 位分别控制的微操作为：\n\n​    （3）编写微程序码点\n​        根据每条微指令的操作控制字段和下地址，就可以得到每一条微指令对应的二进制代码（码点）了。这里我们省略了码点中所有的 0。\n\n7. 其它微程序设计技术​        微程序控制器中，控制信号是以二进制代码的形式出现，因此不需要像组合逻辑那样考虑逻辑表达式的化简，因此设计更加简便，更容易调试和修改。当然，由于执行每个微操作都要访问控制存储器，所以对控制存储器的速度要求较高。微程序控制器通常应用在 CISC 架构中，目前大多数计算机都会采用微程序设计技术。\n​        微程序设计技术也可以有其它一些方式的扩展。\n​    （1）静态微程序设计\n​        通常指令系统是固定的，对应每一条机器指令的微程序，都是计算机的设计者预先编写好的，这种微程序设计技术称为 静态微程序设计，其控制存储器一般采用 ROM。\n​    （2）动态微程序设计\n​        如果可以通过改变微指令和微程序，来改变机器的指令系统，这种微程序设计技术称为 动态微程序设计。这种方式可以在一台机器上实现不同类型的指令系统，有利于仿真和研究测试，其控制存储器需要采用 EPROM。\n​    （3）毫微程序设计\n​        如果采用两级微程序的设计方法，用第一级微程序来解释机器指令，再用第二级微程序（称为 “毫微程序”）来解释第一级微程序，这样的设计方式就称为 毫微程序设计。组成毫微程序的 毫微指令 是用来解释微指令的。\n​        采用毫微程序设计计算机的优点是，可以用更少的控制存储器空间来达到高度的并行；不过同时运行速度会受到一定程度的影响。\n5.7 中断和异常5.7.1 基本概念和分类​        计算机在执行程序的过程中，有时会遇到一些异常情况或者特殊请求；这时就需要计算机暂停正在运行的程序，转而先去处理这些异常或特殊请求，处理结束之后再返回程序的断点处继续执行。这种处理方式就被称为 “中断”，计算机的这种功能就称为 中断处理；实现这种功能所需的软硬件技术统称为 中断技术。\n​        很显然，对于一些突发情况和实时传来的外部信号，相比时刻查询的方式，使用中断技术可以大大地提高计算机的整体效率。\n​        能够引发中断的因素有很多，比如电源掉电、打印机请求、运算溢出、缺页等等。通常将能够引起中断的各种因素称为 中断源。根据各种中断源的类型，可以对中断进行不同的分类。\n1. 中断和异常​        从中断的来源看，直观上可以分成两类：一类是由外部设备向 CPU 发出的请求（比如打印），或者突发的外部事件或环境对计算机造成了影响（比如电源掉电），在 CPU 外部产生；另一类是 CPU 在执行指令时遇到的异常情况，在 CPU 内部产生。\n​        通常将 CPU 内部产生的中断称为 异常（Exception），也称作 内中断。异常一般是 CPU 的控制单元（CU）在执行指令时遇到了意外情况、因而必须暂停处理；由于一定会在一条指令执行结束后才发出中断，因此也被叫做 同步中断。\n​        与之对应，来自于 CPU 外部其它硬件设备的中断，就被称为 外中断，或者直接叫做（狭义的） 中断（Interrupt）。它们通常是外部设备依照 CPU 时钟随机产生的，因此也被叫做 异步中断。\n\n​        事实上，对于中断（狭义）和异常，CPU 的处理流程都是先中止当前正在执行的程序、转而去执行相应的中断处理程序（称为 “中断服务程序”），完成中断响应之后，再回到断点处继续执行。因此，一般可以把它们统称为（广义的）中断。\n2. 中断和异常的分类​        中断请求并不一定都非常急迫、必须立刻响应。CPU 可以对中断进行判别、选择，屏蔽某些中断源的请求；根据是否可以被屏蔽，中断（狭义）又可以分成两类：\n\n可屏蔽中断：可屏蔽中断有 “屏蔽” 和 “非屏蔽” 两种状态；处在屏蔽状态的中断，CPU 将不予以响应。I/O 设备的中断请求都属于可屏蔽中断。\n\n不可屏蔽中断：一些急迫事件 CPU 必须予以响应，发出的中断不能屏蔽。例如电源掉电就属于不可屏蔽中断。\n\n\n\n​        而对于异常，由于它跟指令的执行有关，因此根据中断处理完成后、接下来指令执行的情况，可以进一步进行分类：\n\n故障（Fault）：通常可以纠正，一旦纠正则程序可以重新执行原先产生中断的那条指令；也称为 “程序性事故”。例如运算溢出、缺页异常。\n陷阱（Trap）：这种异常是人为设置的，表示自愿停止现行程序、转入中断处理，因此也叫 “自愿中断”、“自陷”。一般计算机中都会设置陷阱指令，执行到它就会转至别处做特殊处理，完成之后就返回到陷阱指令的下一条指令继续执行。例如调试程序时的断点设置、执行系统调用等。\n异常中止（Abort）：如果发生了严重的错误，程序无法继续执行，那么就只能把控制权交给异常中止处理程序；而现行程序只能强制停止运行。例如硬件故障、系统表中无效的值等。\n\n3. 中断系统​        中断改变了计算机执行程序的顺序，因此需要 CPU 进行特别的处理。为了实现中断处理的功能，CPU 中一般会设置专门的处理机构，这就是 中断系统。\n​        中断系统主要需要解决以下一些问题：\n\n中断源怎样向 CPU 发出中断请求；\n\n当有多个中断源同时发出请求时，怎样确定响应顺序；\n\nCPU 怎样响应中断请求；\n\nCPU 响应中断之后，怎样保护现场；\n\nCPU 响应中断后，怎样暂停原程序的执行、找到中断服务程序的入口地址；\n\n中断处理结束后，CPU 如何恢复现场、返回原程序的断点处；\n\n如果中断处理时又有新的中断请求，应该怎样处理。\n接下来我们就通过学习中断系统，来解决这些问题。\n\n\n5.7.2 中断的检测​        在 CPU 的指令周期中，最后一个阶段就是 中断周期。在一条指令执行阶段的最后时刻，CPU 会发出 中断查询信号，检测是否有中断请求。如果有，则进入中断周期进行中断处理。\n1. 中断请求标记​        不同的中断源都可以向 CPU 发出中断请求，为了区分中断源，中断系统中会专门设置一个 中断请求标记触发器，简称 中断请求触发器，用 INTR 表示。当某个中断源的触发器 INTRi 为 “1” 时，就表示该中断源发来了请求。\n​        这些触发器可以分散在各个中断源的接口电路中，也可以集成在 CPU 中，组成一个 中断请求标记寄存器。\n\n​        寄存器里的每一位就对应着一个中断源的请求触发器。任意一个触发器为 1，就表示对应的中断源发出了中断请求。\n2. 中断判优​        在中断系统中，同一时刻只能响应一个中断源的请求。如果有多个中断源同时发出了请求，那就需要中断系统按照设定好的优先顺序来依次响应；这被称为 中断判优。中断源的优先级是依据重要性和急迫性而定的。\n​        中断判优就是要对一组中断请求按优先级进行 “排队”，可以用硬件和软件两种方式实现。\n​    （1）硬件排队\n​        硬件排队是直接用硬件电路实现中断请求的排队，具体方法很多，主要有两种：一种是在 CPU 内统一设置一个 “排队器”；另一种是在中断源设备的接口电路中分别设置排队器。\n\n在 CPU 内设置排队器：各中断源的请求触发器按优先级依次排列，高优先级的请求信号通过接入一个多输入的与非门，来 “封住” 低优先级的中断请求。\n\n\n在接口电路中设置排队器：每个接口电路中都设置一个反相器和一个与非门，与非门的输出接入下一级，就可以实现对更低优先级中断请求的封锁。它们彼此之间直接连成链状，因此也称为 “链式排队器”。\n\n​    （2）软件排队\n​        软件排队，就是直接通过编写查询程序实现中断请求的排队。\n\n​        程序按照中断源的优先级，从高到低依次判断是否有中断请求，这样就保证了中断响应的顺序。\n5.7.3 中断的响应1. 中断响应的条件​        由于在处理中断时，CPU 不应受到新中断请求的打扰，因此需要有 “开关中断” 的功能。在中断系统中，这是由 允许中断触发器 EINT 和专门的指令来实现的。\n​        EINT 可以被 开中断指令 置 “1”，这时表示 CPU 打开了中断功能，允许响应中断源的请求；EINT 也可以被 关中断指令 置 “0”，这意味着 CPU 关闭中断功能，禁止响应中断。\n​        在 x86 架构的 CPU 中，EINT 就对应着 标志寄存器（程序状态字）efl 中的一位，用 IF 表示。\n\n​        因此可以总结，当 EINT = 1 且有中断请求（INTRi = 1）时，CPU 就可以响应中断。\n2. 中断响应的时间​        很多情况下中断请求的产生是随机的，为了不影响 CPU 的正常工作，需要周期性地在统一的时刻由 CPU 发出中断查询信号，判断当前是否有中断请求。\n\n​        因此 CPU 响应中断的时间，一定是在每条指令执行阶段的结束时刻；相当于在指令周期最后又加入了一个阶段，这就是 中断周期。执行周期结束后，如果有中断请求，则 CPU 进入中断周期；如果没有则直接进入下一条指令的取指周期。\n3. 中断响应的过程​        CPU 响应中断之后，就会进入中断周期。在中断周期 CPU 会执行一系列的操作，这些操作都是由一条 中断隐指令 完成的。所谓的隐指令，指的是指令系统中本身没有这条指令，它是由硬件自动完成的。具体操作如下：\n​    （1）保护程序断点\n​        将当前 PC 的内容（程序断点位置）保存到主存中。可以存入特定的某个地址（比如 0 地址），也可以存入堆栈中。\n​    （2）寻找中断服务程序的入口地址\n​        在中断周期内，可以用两种方法寻找中断服务程序的入口地址：硬件向量法和软件查询法，分别对应着硬件和软件实现。\n​    （3）关中断\n​        为了在响应中断后，不受到新的中断请求的干扰，在中断周期需要自动做 “关中断” 的操作，禁止 CPU 再次响应中断请求。关中断的具体操作就是将允许中断触发器 EINT 置 “0”，一般直接由硬件电路实现。\n​        对应的微操作如下：\n\n5.7.4 中断服务程序1. 中断服务程序的入口地址​        不同的中断请求，需要执行不同的中断服务程序。寻找中断服务程序的入口地址，通常可以采用两种方法：硬件向量法 和 软件查询法。\n​    （1）硬件向量法\n​        所谓硬件向量法，就是使用硬件直接产生一个 向量地址，再用这个向量地址找到中断服务程序的入口地址。向量地址由中断向量地址形成部件产生。\n​        中断向量地址形成部件的输入，是来自排队器的输出 INTPi ，它的输出则是一个二进制的 中断向量。一般可以让一个中断源对应一个向量地址，因此这个部件本质上就是一个编码器。\n\n​        通过向量地址寻找中断服务程序入口地址可以采用两种方法。\n\n\n在向量地址对应内存单元放一条 无条件转移指令。这样 CPU 响应中断时，只要将向量地址交给 PC，然后执行这条指令，就可以跳转到中断服务程序入口地址了。\n设置 向量地址表。向量地址表存放在主存中，向量地址就是对应存储单元的地址，而存放的内容就是中断服务程序的入口地址。\n\n​        硬件向量法寻找入口地址速度快，现代计算机中普遍使用这种方法。\n​    （2）软件查询法\n​        用软件寻找中断服务程序入口地址的方法，就叫做软件查询法。各个中断源对应的入口地址，是由程序员（或系统）预先定好、写入程序的；可以结合软件排队的中断判优，确定要响应某个中断请求时，直接跟上一条转移指令、跳转至定义好的入口地址就可以了。\n​        软件查询法不涉及硬件，更加容易维护和扩展，但查询的时间更长。\n2. 中断服务程序的流程​        不同的中断请求对应的中断服务程序不同，不过它们的处理流程是类似的，一般包括 保护现场、中断服务、恢复现场 和 中断返回 4 个部分。\n​    （1）保护现场\n​        保护现场通常包含两层含义：一是保存程序的断点，这由中断隐指令完成；二是保存通用寄存器和状态寄存器的内容，这需要中断服务程序完成。\n​        具体操作就是在中断服务程序的起始部分，安排几条存数（Store）指令，将寄存器的内容全部保存到主存中；或者直接用入栈（Push）指令将寄存器内容推入栈中。\n​    （2）中断服务\n​        中断服务是中断服务程序的主体部分，针对不同的中断源，需要做出对应的操作内容。\n​    （3）恢复现场\n​        中断服务程序的结尾部分，还需要恢复现场。对应着之前的保护现场，这一步可以用取数（Load）指令或者出栈（Pop）指令，将保存在主存中的信息恢复到寄存器中。\n​    （4）中断返回\n​        中断服务程序的最后一条指令，通常是一条 中断返回指令，从而返回到原程序的断点处继续执行。\n\n​        如果在 CPU 执行中断服务程序时，又来了一个新的中断请求，这时有两种处理方式：一种是直接不予响应，即 CPU 在响应中断的过程中保持 “关中断” 状态，直到中断服务程序执行结束、返回之前才开中断；另一种则是 CPU 立即响应新的中断请求，这需要在中断服务程序的开始阶段 “开中断”。 \n5.7.5 中断屏蔽技术1. 多重中断​        如果 CPU 在响应某个中断请求的时候，另一个中断源又提出了一个新的中断请求；而 CPU 立即响应这个请求，暂停正在运行的中断服务程序、转而去运行新的中断服务程序，这就是 中断嵌套，也称为 多重中断。 与之对应，如果 CPU 在响应中断时不去响应新的中断请求，则称为 单重中断。\n\n​        实现多重中断，需要满足两个基本条件：\n\n提前设置 “开中断” 指令\n\n​        由于进入中断周期后，中断隐指令会自动将 EINT 置为 0，因此默认会关中断、不再响应新的中断请求；这时如果希望处理多重中断，就必须在中断服务程序的开始阶段设置 “开中断” 指令来打开中断。\n\n优先级高的中断源有权中断优先级低的中断源\n\n​        只有优先级别更高的中断源，才能打断正在执行的中断服务程序、优先被响应。\n\n​        例如，有 A、B、C、D 四个不同的中断源，优先级为 A &gt; B &gt; C &gt; D。在 CPU 执行程序时，在某个指令周期，同时查询到了 B、C 发来的中断请求；之后在执行中断服务程序的过程中，又先后查询到了 D、A 的请求。那么如果允许多重中断，中断处理的时间顺序如下：\n\n\n​        中断请求如果同时到来（比如上例中的 B、C），我们可以进行中断判优、利用排队器决定它们的先后顺序。但对于多重循环，还需要在中断响应过程中继续判断优先级、决定是否可以打断当前的中断服务程序。这是通过 中断屏蔽技术 来实现的。\n2. 中断屏蔽触发器​        为了实现对每个中断源的屏蔽，可以在中断请求触发器 INTR 之前增设一个 中断屏蔽触发器 MASK。当 MASK 为 “1” 时，表示该中断源被屏蔽，中断请求不被响应。\n​        屏蔽触发器同样既可以设置在接口电路中、也可以直接集成在 CPU 内。以 I/O 设备作为中断源为例，I/O 设备的接口电路中会有一个 完成触发器 D，它为 “1” 则表示设备已经处于就绪状态、要向 CPU 发出中断请求了。一般情况下，D 的输出可以直接接到中断请求触发器 INTR 的输入；现在则可以与 MASK 的输出经与非门之后、再交给 INTR。\n\n​        这样，当设备已经准备就绪（D = 1），且设备未被屏蔽（MASK = 0）时，来自 CPU 的中断查询信号就会将 INTR 置 “1”，表示该设备发出了中断请求信号。\n​        同样，排队器内也可以加上屏蔽条件，就组成了具有屏蔽功能的排队器。例如集成在 CPU 内的排队器如果加上屏蔽功能，只需要另外将屏蔽信号也接入与非门就可以了：\n\n3. 屏蔽字和屏蔽技术​        显然，对于每个中断源，中断请求触发器 INTR 和 中断屏蔽触发器 MASK 都是成对出现的。如果将所有屏蔽触发器组合在一起，也可以构成一个 屏蔽寄存器。屏蔽寄存器的内容就称为 屏蔽字。\n​        屏蔽字可以在中断服务程序中进行设置，屏蔽字和中断源的优先级是一一对应的。以 16 个中断源 I1 ~ I16 的屏蔽字为例，每个屏蔽字都是 16 位：\n\n​        在不同中断源的中断服务程序中，可以设置适当的屏蔽字，就能对优先级不同的中断源进行屏蔽。\n​        例如，在   I1 的服务程序中，将屏蔽字设为全 1，就表示它的优先级最高：在响应 I1 中断请求的过程中，不会再去响应任何新的请求（包括 I1 自己发来的）；这相当于就是单重中断。而对于 I3 ，在服务程序中将屏蔽字前两位设为 0、后面为 1，表示 I1、I2 优先级更高、不被屏蔽，而后面的中断源（包括自己）被屏蔽；于是开中断之后，I1、I2 发来的新中断请求就可以打断当前 I3 的中断服务程序，实现了多重中断。\n4. 改变处理优先级​        使用屏蔽技术还可以改变中断源的优先等级。中断源的优先级，包括两层含义：响应优先级 和 处理优先级。\n\n响应优先级：CPU 响应各中断源请求的先后次序，跟排队器有关，一般是硬件线路设定好的，不易改动；\n处理优先级：CPU 实际执行中断服务程序的先后次序，可以通过屏蔽技术进行改动。\n\n​        如果不采用屏蔽技术，那么处理的优先顺序就是按照响应优先级来的。例如，A、B、C、D 四个中断源，优先级别为 A &gt; B &gt; C &gt; D，根据这一次序设计出排队器之后，当它们同时发来中断请求时，处理顺序就是响应顺序：\n\n​        如果采用了屏蔽技术，就可以在不改变响应顺序的前提下，改变 CPU 处理中断的顺序。假如我们希望将它们的处理次序改为 A → D → C → B，那么每个中断源的中断服务程序中应该重新设置屏蔽字：\n\n​        这样，同样还是 A、B、C、D 同时发出中断请求，这时的处理顺序就会变为：\n\n​        显然，采用屏蔽技术改变处理优先级，需要在中断服务程序中重置屏蔽字。这样，中断服务程序的处理流程就会变为：\n\n​        跟之前相比，增加了 置屏蔽字 和 恢复屏蔽字 两步操作。而为了防止在恢复阶段又出现新的中断，需要先关中断、等到恢复现场和屏蔽字之后再次开中断。\n5.8 多处理器基本概念5.8.1 SISD、SIMD、MIMD 和向量处理器​        通过改进系统结构，可以有效地提升计算机的性能，一个方向就是 并行处理。指令流水线就是一种典型的并行处理技术，它提供的是 指令 的并行；而另一种思路则是考虑让 数据 的处理并行起来。\n1. 费林分类法​        美国计算机科学家迈克尔 · 费林（Michael Flynn）根据指令和数据是否并行，将计算机体系结构分为四类：\n\n\nSISD（Single Instruction stream, Single Data stream）：单指令流单数据流。普通的串行执行结构，CPU 同时只能执行一条指令，处理一条数据；\nSIMD（Single Instruction stream,  Multiple Data streams）：单指令流多数据流。单条指令可以同时对应处理多个数据，从而实现了数据的并行处理；\nMISD（Multiple Instruction streams, Single Data stream）：多指令流单数据流。多条指令同时执行，但只处理一条数据，这种架构非常罕见，只是作为一种理论模型；\nMIMD（Multiple Instruction streams, Multiple Data streams）：多指令流多数据流。同时执行多条不同的指令，它们分别处理不同的数据；这种方式实现了线程、指令和数据的全方位并行处理。\n\n2. SIMD 和向量处理器​        SIMD 的特点是，设置了多个并行的执行单元，而所有的执行单元都是同步的，执行的指令从同一个 PC 中取出，由同一个控制单元来进行调度管理。SIMD 对应的程序设计风格可以跟 SISD 非常相近，但要求程序中必须存在大量同构的数据，以便实现 数据级并行。\n​        向量处理器是 SIMD 架构的一种具体实现，可以并行执行一组数据（向量）的计算任务。\n​        向量处理器的基本原理是，从主存中收集数据，将它们按照顺序放到一组 向量寄存器 中，使用流水线式的执行单元在寄存器中依次进行操作，然后将结果写回主存。\n5.8.2 硬件多线程​        相比 SIMD，MIMD 提高了更高的并行程度。MIMD 需要同时执行不同的指令流，这就要依赖多个 进程（process） 或者 线程（thread） 同时执行，让处理器时刻保持忙碌状态。\n​        对于一个处理器，可以允许多个线程以重叠的方式，共享处理器的功能部件；当一个线程停顿时，就切换到另一个线程，从而更加充分地利用了硬件资源。这种技术就称为 硬件多线程（hardware multithreading）。\n​        在支持硬件多线程的 CPU 中，需要为每个线程提供单独的寄存器堆和 PC 等资源，这样就可以在共享资源的同时保持线程的独立状态。\n​        硬件多线程主要有两种实现方法。\n\n细粒度多线程\n\n​        每条指令执行后就进行线程切换，从而实现多线程在时间上的交叉执行。这种交叉执行是轮转进行的，并且会跳过停顿的任何线程。\n\n粗粒度多线程\n\n​        仅在发生高开销的停顿时（例如末级 cache 失效），才进行线程切换。对于流水线中的停顿，需要清空或者冻结流水线，因此流水线的重启开销比较大。\n​        除此之外，硬件多线程还可以结合流水线多发技术，进一步降低成本、提高并行效率，这就是 同时多线程（Simultaneous Multithreading，SMT）。同时多线程是硬件多线程的一种变体，它结合使用多发射、动态调度流水线的处理器资源，来实现 线程级 和 指令级 并行。\n​        英特尔（Intel）公司的 “ 超线程 “（Hyper-Threading）技术，就是一种在单个 CPU 上实现硬件多线程的方式。\n5.8.3 多核处理器和 SMP1. 多核处理器​        另一种实现线程级并行的方式，就是在一个处理器芯片上，集成多个处理单元。为了区分不同的概念，每个处理单元就称为一个 ” 核 “（core），有多个核的处理器就被称为 多核处理器。\n​        要想充分利用多核处理器的性能，应该采用多线程的方式执行程序。这样，多个线程可以在不同的核上并行执行，大大提升运行效率。\n​        多核处理器一般也采用硬件多线程技术，为了进行区分，有时会将单个核心上同时运行多个线程称为有多个 ”逻辑内核“，而对应的真正的核心则称为 ”物理内核“。\n\n​        在多核处理器中，一般所有内核会有自己独立的寄存器和 L1、L2 缓存，而共享更低级的 cache（L3）和主存。\n\n​        如果不对处理单元进行集成，也可以用同样的架构将多个处理器联合在一起，这就是所谓的 多处理器。广义上讲，多核处理器也是一种多处理器。\n2. 共享内存多处理器（SMP）​        编写运行在多处理器上的并行程序会更加复杂。在架构上，一个很重要的影响因素是，是否为所有处理器提供一个共享的统一物理地址空间；换句话说，所有处理器（核心）是否可以访问同一个主存储器。于是多处理器又可以划分为两种架构。\n​        共享内存多处理器（Shared Memory Processor，SMP）为所有处理器提供统一的物理地址空间。处理器通过存储器中的 共享变量 进行通信，所有处理器都能通过加载（Load）和存储（Store）指令访问任意的主存位置。\n\n​        尽管物理地址空间是统一的、共享的，但如果存储器本身也采取了并行架构（例如多模块存储器），不同的处理器对存储器不同部分的访问可能就会有区分。因此 SMP 又可以有两种类型。\n\n统一内存访问（Unified Memory Access，UMA）多处理器\n\n​        不管是来自哪个处理器的访存指令，延迟都是一致的。这样，每个处理器对所有存储单元的访问时间都大致相同，是对称的系统架构。\n\n非统一内存访问（Non-Unified Memory Access，NUMA）多处理器\n\n​        访存指令的延迟不一致，取决于哪个处理器去访问哪个存储单元。一般架构中，每个处理器（CPU）会单独直接连接一部分主存，称为 本地内存；其它主存部分则通过总线进行访问，称为 远程内存。\n3. MPP 和集群​        如果不采用共享内存的方式，而是让每个处理器都拥有私有的地址空间，这样就可以让各个处理器更加独立、获得更好的并行性和可扩展性。这种架构被称为 大规模并行处理（Massive Parallel Processing，MPP）。\n\n​        采用 MPP 架构的多处理器，必须通过显式的 消息传递 进行通信，因此传统上也把这种类型的计算机称为 显式消息传递计算机。\n​        更进一步，我们可以通过标准网络交换机上的 I/O 接口进行连接，用一组计算机的集合来构建出消息传递多处理器，这种形式就被称为 集群（Cluster）。集群是一种分布式系统，已经成为如今并行处理计算机最典型的架构，也是大数据领域的技术基础。\n5.9 章节练习一、单项选择题\n【2011真题】假定不采用 Cache 和指令预取技术，且机器处于“开中断” 状态，则在下列有关指令执行的叙述中， 错误的是     （    ）\n\n​        A．每个指令周期中 CPU 都至少访问内存一次\n​        B．每个指令周期一定大于或等于一个 CPU 时钟周期\n​        C．空操作指令的指令周期中任何寄存器的内容都不会被改变\n​        D．当前程序在每条指令执行结束时都可能被外部中断打断 \n​        答案：C\n​        要点：每个指令执行完成后，PC的值都会改变，从而可以继续执行下一条指令；即使是空操作也会执行 PC + 1 的动作。\n\n【2016真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是    （    ）\n\n​        A．可以采用单总线结构数据通路\n​        B．处理器时钟频率较低\n​        C．在指令执行过程中控制信号不变\n​        D．每条指令的 CPI 为 1 \n​        答案：A\n​        要点：单总线结构下，所有部件需要争用唯一的总线，不支持并发传送操作；因此单周期处理器不可以采用单总线结构数据通路。\n\n【2019真题】下列有关处理器时钟脉冲信号的叙述中，错误的是    （    ）\n\n​        A．时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成\n​        B．时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频\n​        C．时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定\n​        D．处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令 \n​        答案：D\n​        要点：CPU 从内存中取出并执行一条指令所需的全部时间称为指令周期，指令周期又由若干机器周期组成，一个机器周期又包含若干时钟周期。\n\n【2020真题】下列给出的处理器类型中，理想情况下，CPI 为 1 的是    （    ）\nⅠ.单周期 CPU        Ⅱ.多周期 CPU        Ⅲ.基本流水线 CPU        Ⅳ.超标量流水线 CPU\nA. 仅Ⅰ、Ⅱ                B. 仅Ⅰ、Ⅲ                C. 仅Ⅱ、Ⅳ                D. 仅Ⅲ、Ⅳ\n答案：B\n\n\n​        要点：多周期 CPU 指的是将整个 CPU 的执行过程分成几个阶段，每个阶段用一个时钟周期去完成，然后开始下一条指令的执行，而每种指令执行时所用的时钟数可以不同。基本流水线理想情况下 CPI 为 1；而超标量流水线可以通过增加功能部件实现并行，CPI 可以小于1。\n\n【2009真题】某计算机的指令流水线由四个功能段组成，指令流经各功能段的时间（忽略各功能段之间的缓存时间）分别为 90ns、 80ns、 70ns 和 60ns，则该计算机的 CPU 时钟周期至少是     （    ）\n\n​        A． 90ns     B． 80ns     C． 70ns     D． 60ns\n​        答案：A\n\n【2010真题】下列选项中， 不会引起指令流水线阻塞的是    （    ）\n\n​        A．数据旁路（转发）            B．数据相关            C．条件转移             D．资源冲突\n​        答案：A\n​        要点：数据旁路技术是解决数据冒险的一种方法。\n\n【2016真题】在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令序列存在数据冒险的指令对是    （    ） \n\n1234I1： add R1， R2， R3; （R2） +（R3） → R1I2： add R5， R2， R4; （R2） +（R4） → R5I3： add R4， R5， R3; （R5） +（R3） → R4I4： add R5， R2， R6; （R2） +（R6） → R5  \n​        A． I1 和 I2                     B． I2 和 I3                     C． I2 和 I4                     D． I3 和 I4 \n​        答案：B\n​        要点：数据冒险也叫数据相关，指在程序中存在必须等前条指令执行完才能执行后一条指令的情况。\n\n【2017真题】下列关于超标量流水线特性的叙述中，正确的是    （    ）\n\n​        Ⅰ . 能缩短流水线功能段的处理时间\n​        Ⅱ．能在一个时钟周期内同时发射多条指令\n​        Ⅲ．能结合动态调度技术提高指令执行并行性\n​        A．仅Ⅱ                 B．仅Ⅰ、Ⅲ                 C．仅Ⅱ、Ⅲ                 D．Ⅰ、Ⅱ和Ⅲ \n​        答案：C\n​        要点：超标量流水线每个时钟周期可以并行完成一条以上的指令，但不能缩短功能段的处理时间。\n\n【2018真题】若某计算机最复杂指令的执行需要完成 5 个子功能，分别由功能部件 A~E 实现，各功能部件所需时间分别为 80ps、50ps、50ps、70ps 和 50ps，采用流水线方式执行指令，流水段寄存器延时为 20ps，则CPU 时钟周期至少为    （    ）\n\n​        A.60 ps                        B.70 ps                            C.80 ps                        D.100 ps\n​        答案：D\n​        要点：流水线上每个流水段的时间相同，应该取最大的功能部件运行时间，并且加上寄存器的延时。\n\n【2019真题】在采用 “取指、译码/取数、执行、访存、写回”  5 段流水线的处理器中，执行如下指令序列，其中 s0、 s1、 s2、 s3 和 t2 表示寄存器编号。 \n\n1234I1： add s2,s1,s0 \t// R[s2] ← R[s1] + R[s0]I2： load s3,0(t2) \t// R[s3] ← M[R[t2]+0]I3： add s2,s2,s3 \t// R[s2] ← R[s2] + R[s3]I4： store s2,0(t2) \t// M[R[t2]+0] ← R[s2]\n​        下列指令对中，不存在数据冒险的是     （    ）\n​        A．I1和 I3                 B． I2 和 I3                 C． I2 和 I4                 D． I3 和 I4 \n​        答案：C\n​        要点：A、B、D 选项的指令对都发生了 “写后读” 的情况，存在数据冒险。\n\n【2021真题】下列关于数据通路的叙述中，错误的是    （    ）\n\n​        A.数据通路包含 ALU 等组合逻辑（操作）元件\n​        B.数据通路包含寄存器等时序逻辑（状态）元件\n​        C.数据通路不包含用于异常事件检测及响应的电路\n​        D.数据通路中的数据流动路径由控制信号进行控制\n​        答案：C\n​        要点：指令执行过程中数据所经过的路径， 包括路径上的部件， 称为数据通路。 ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等， 都是指令执行过程中数据流经的部件， 都属于数据通路的一部分。 \n\n【2009真题】相对于微程序控制器，硬布线控制器的特点是    （    ） \n\n​        A．指令执行速度慢，指令功能的修改和扩展容易 \n​        B．指令执行速度慢，指令功能的修改和扩展难\n​        C．指令执行速度快，指令功能的修改和扩展容易\n​        D．指令执行速度快，指令功能的修改和扩展难 \n​        答案：D\n\n【2017真题】下列关于主存储器（MM）和控制存储器（CS）的叙述中，错误的是    （    ）\n\n​        A． MM 在 CPU 外， CS 在 CPU 内\n​        B． MM 按地址访问， CS 按内容访问\n​        C． MM 存储指令和数据， CS 存储微指令\n​        D． MM 用 RAM 和 ROM 实现， CS 用 ROM 实现\n​        答案：B\n​        要点：控制存储器按照微指令的地址访问。\n\n【2012真题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有 33 个微命令，构成 5 个互斥类，分别包含 7、 3、 12、 5 和 6 个微命令，则操作控制字段至少有     （    ）\n\n​        A. 5 位                 B. 6 位                 C. 15 位                 D. 33 位 \n​        答案：C\n\n【2014真题】某计算机采用微程序控制器，共有 32 条指令， 公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（下地址字段法）确定下条微指令地址， 则微指令中下地址字段的位数至少是    （    ）\n\n​        A. 5                         B. 6                         C. 8                         D. 9 \n​        答案：C\n​        要点：微指令下地址字段的位数，与微指令的条数有关。总共有 4 × 32 + 2 = 130 条微指令。\n\n【2020真题】下列关于“自陷”(Trap，也称陷阱)的叙述中，错误的是    （    ）\n\n​        A.自陷是通过陷阱指令预先设定的一类外部中断事件\n​        B.自陷可用于实现程序调试时的断点设置和单步跟踪\n​        C.自陷发生后CPU将转去执行操作系统内核相应程序\n​        D.自陷处理完成后返回到陷阱指令的下一条指令执行\n​        答案：A\n​        要点：自陷产生于 CPU 内部，属于内中断。\n\n【2009真题】下列选项中，能引起外部中断的事件是    （    ）  \n\n​        A．键盘输入                      B．除数为 0                 C．浮点运算下溢                   D．访存缺页\n​        答案：A\n\n【2015真题】内部异常（内中断）可分为故障（fault）、陷阱（trap）和终止（abort）三类。下列有关内部异常的叙述中，错误的是    （    ）\n\n​        A．内部异常的产生与当前执行指令相关                        B．内部异常的检测由CPU内部逻辑实现\n​        C．内部异常的响应发生在指令执行过程中                    D．内部异常处理后返回到发生异常的指令继续执行 \n​        答案：D\n\n【2017真题】下列关于多重中断系统的叙述中， 错误的是    （    ）\n\n​        A．在一条指令执行结束时响应中断                        B．中断处理期间 CPU 处于关中断状态\n​        C．中断请求的产生与当前指令的执行无关            D． CPU通过采样中断请求信号检测中断请求 \n​        答案：B\n​        要点：实现多重中断，中断处理期间必须开中断。\n\n【2022真题】下列关于并行处理技术的叙述中，不正确的是    （    ） \n\n​        A. 多核处理器属于 MIMD 结构                            B. 向量处理器属于 SIMD 结构\n​        C. 硬件多线程技术只可用于多核处理器                D. SMP 中所有处理器共享单一物理地址空间 \n​        答案：C\n二、综合应用题\n【2014真题】某程序中有如下循环代码段P: \n\n1for(int i = 0; i &lt; N; i++) sum+=A[i];\n​        假设编译时变量 sum 和 i 分别分配在寄存器 R1 和 R2 中。常量 N 在寄存器 R6 中，数组 A 的首地址在寄存器 R3 中 。 程序段 P 起始地址为 0804 8100H，对应的汇编代码和机器代码如下表所示。 \n\n​        执行上述代码的计算机 M 采用 32 位定长指令字， 其中分支指令 bne 采用如下格式： \n\n​        OP 为操作码；Rs 和 Rd 为寄存器编号；OFFSET 为偏移量，用补码表示。 请回答下列问题，并说明理由。\n​        1）M 的存储器编址单位是什么？\n​        2）已知 sll 指令实现左移功能， 数组 A 中每个元素占多少位？\n​        3）表中 bne 指令的 OFFSET 字段的值是多少？已知 bne 指令采用相对寻址方式， 当前 PC 内容为 bne 指令地址， 通过分析表中指令地址和 bne 指令内容 ， 推断出 bne 指令的转移目标地址计算公式。\n​        4）若 M 采用如下 “按序发射、按序完成” 的 5级指令流水线： IF (取值 ）、ID (译码及取数）、 EXE (执行）、 MEM (访存）、 WB (写回寄存器 ），且硬件不采取任何转发措施， 分支指令的执行均引起 3个时钟周期的阻塞， 则 P 中哪些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令 1 的执行不会因为与指令 5 的数据相关而发生阻塞？ \n​        答案：\n​        1）M 的存储器编址单位为字节。因为 M 采用 32 位定长指令字，每个指令占 4 个字节；而指令间的地址差为 4，所以每个地址对应 1 个字节。\n​        2）A 中每个元素占 32 位。左移 2 位相当于乘以 4，所以每个元素占 4 个字节。\n​        3）bne 指令 OFFSET 字段的机器补码为 FFFAH，真值为 -6。正常情况下，OFFSET 乘以指令字长就应该是偏移的地址差：\n\n​        不过在这里，bne 指令地址和要跳转到的 loop 地址差为\n\n​        所以很明显，发生跳转的时候，应该基于 bne 下一条指令的地址 0804 8118H ，再加上 OFFSET × 4，就是转移的目标地址。相当于 PC 先做了 +1 操作（对应地址 +4）：\n\n​        4）由于数据相关而发生阻塞的指令为第 2、 3、 4、 6 条，因为第 2、 3、 4、 6 条指令都与各自前一条指令发生数据相关。\n​        第 6 条指令会发生控制冒险。\n\n​        当前循环的第 5 条指令与下次循环的第 1 条指令虽然有数据相关，但由于第 6 条指令后有 3 个时钟周期的阻塞，因而消除了该数据相关。\n\n\n【2022真题】某 CPU 中部分数据通路如图所示， 其中， GPRs 为通用寄存器组；FR 为标志寄存器，用于存放 ALU 产生的标志信息；带箭头虚线表示控制信号，如控制信号 Read、Write 分别表示主存读、 主存写， MDRin表示内部总线上数据写入MDR，MDRout 表示 MDR 的内容送内部总线。\n\n\n​        请回答下列问题。\n​        1）设 ALU 的输入端 A、 B 及输出端 F 的最高位分别为 A15 、 B15 及 F15 ,  FR 中的符号标志和溢出标志分别为 SF 和 OF，则 SF 的逻辑表达式是什么？A 加 B、 A 减 B 时 OF 的逻辑表达式分别是什么？要求逻辑表达式的输入变量为 A15 、 B15 及 F15。\n​        2）为什么要设置暂存器 Y 和 Z?\n​        3）若 GPRs 的输入端 rs、 rd 分别为所读、 写的通用寄存器的编号， 则 GPRs 中最多有多少个通用寄存器？rs 和 rd 来自图中的哪个寄存器？已知 GPRs 内部有一个地址译码器和一个多路选择器， rd 应连接地址译码器还是多路选择器？\n​        4）取指令阶段（不考虑 PC 增量操作） 的控制信号序列是什么？若从发出主存读命令到主存读出数据并传送到 MDR 共需5个时钟周期， 则取指令阶段至少需要几个时钟周期？\n​        5）图中控制信号由什么部件产生？图中哪些寄存器的输出信号会连到该部件的输入端？ \n​        答案：\n​        1）SF 表示运算结果的正负性，所以  SF = F~15~\n​            A 加 B 时，A + B → F。若 A 和 B 都为负且 F 为正；或者，若 A 和 B 都为正且 F 为负，则溢出。所以溢出标志逻辑表达式为：\n\n​            A 减 B 时，A - B → F。若 A 为负、B 为正，同时 F 为正，则溢出；或者，若 A 为正、B 为负，同时 F 为负，则溢出。所以溢出标志逻辑表达式为：\n\n​        2）因为在单总线结构中，每个时刻总线上只有一个数据有效，而 ALU 有两个输入端和一个输出端。因此，当 ALU 运算时，首先需要用暂存器 Y 缓存其中一个输入端的数据，在通过总线传送另一个输入端的数据。当ALU的输出端产生运算结果，但由于该节拍总线被占用，因此需要暂存器 Z，用来缓存 ALU 的输出端数据。\n​        3）可以看到 rs 和 rd 的编号都为 4 位，那么 GPRs 中最多有 2^4^ = 16 个通用寄存器。\n​            寄存器编号用于在指令中表示寄存器寻址的地址，指令寄存器 IR 中存储指令，所以 rs 和 rd 来自指令寄存器IR。\n​            rd 是寄存器编号，应该连接地址译码器。多路选择器用于从多个输入信号中选择一个输出，它的输出信号取决于控制信号。\n​        4）取指阶段微操作：\n\n​            对应的控制信号序列如下：\n​            ① PCout, MARin 有效，将指令的地址写入 MAR\n​            ② Read 信号有效，读取主存数据（经系统总线写入MDR）\n​            ③ MDRout，IRin 有效，将 MDR 的内容写入指令寄存器 IR\n​            其它步骤省略。\n​            步骤 ① 需要1个时钟周期，步骤 ② 需要 5 个时钟周期，步骤 ③ 需要1个时钟周期，因此取指令阶段至少需要7 个时钟周期。\n​        5）图中控制信号由控制单元CU产生。\n​            指令寄存器 IR 和标志寄存器 FR 的输出信号会连接到控制部件的输入端。\n","slug":"计算机组成原理","date":"2024-05-31T16:00:00.000Z","categories_index":"理论","tags_index":"","author_index":"Gueason"}]