[{"id":"eebf5774c100175fb47d65de16ffd14d","title":"个人搭建方法","content":"简介主要用于知识整理与分享，希望有用\n\n2^2^\n","slug":"intro","date":"2024-05-29T09:41:59.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"},{"id":"56c491e94a7396878a3a1e31f971413b","title":"计算机组成原理","content":"第一章 计算机系统概述1.1 本章大纲要求与核心考点1.1.1 大纲内容(一) 计算机系统层次结构\n\n计算机系统的基本组成\n\n计算机硬件的基本结构\n\n计算机软件和硬件的关系\n\n计算机系统的工作原理\n“存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。\n\n\n(二) 计算机性能指标\n​\t\t吞吐量、响应时间；\n​\t\tCPU时钟周期、主频、CPI、CPU执行时间；\n​\t\tMIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。\n真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          计算机系统层次结构\n          6\n          0\n      \n      \n          计算机性能指标\n          9\n          2\n      \n  \n\n\n\n1.2 计算机系统简介1.2.1 计算机系统的概念和分类​        计算机系统由“硬件”和“软件”两大部分组成。\n\n“硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。\n\n“软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。\n\n\n​        计算机的软件通常又可以分为两大类：系统软件和应用软件。\n\n系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。\n应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。\n\n1.2.2 计算机的发展硬件的发展\n​\t\t1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是”用电子管组成的电子数字积分机和计算机”。\n​\t\t从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。\n硬件技术对计算机更新换代的影响\n\n\n\n\n代\n时间\n硬件技术\n速度（次&#x2F;秒）\n\n\n\n一\n1946~1957\n电子管\n40, 000\n\n\n二\n1958~1964\n晶体管\n200, 000\n\n\n三\n1965~1971\n中、小规模集成电路\n1, 000, 000\n\n\n四\n1972~1977\n大规模集成电路\n10, 000, 000\n\n\n五\n1978~现在\n超大规模集成电路\n100, 000, 000\n\n\n摩尔定律\n​\t\t集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。\n​\t\t微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。\n​\t\t摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。\n1.3 计算机系统的层次结构1.3.1 计算机系统的基本组成（一） 计算机硬件\n\n冯·诺依曼计算机\n\n​        冯·诺依曼在研究EDVAC计算机时提出了 “存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯•诺依曼计算机，其特点如下：\n\n采用“存储程序”的工作方式。\n\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。\n\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n\n指令和数据均用二进制代码表示。\n\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n\n\n\n\n计算机的功能部件\n\n\n存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。\n运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。\n控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n输入设备：用来输入原始数据和程序，如键盘、鼠标。\n输岀设备：用来输出计算机的处理结果，如显示器和打印机。\n\n​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I&#x2F;O设备等)统称为外部设备，简称外设。\n（二） 计算机软件\n\n软件的分类\n\n​        软件按其功能分类，可分为系统软件和应用软件。\n\n三个级别的计算机语言\n\n（1） 机器语言\n​\t\t机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。\n（2） 汇编语言           \n​\t\t汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。\n（3） 高级语言\n​\t\t高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。\n​\t\t由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。\n\n1.3.2 计算机硬件的基本结构​\t\t典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。\n\n现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。\n\n图中各部件的功能是：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；\n存储器用来存放数据和程序；\n控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；\n输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。\n\n​\t\t由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I&#x2F;O设备(Input&#x2F;Output equipment) 。\n​\t\t这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I&#x2F;O设备叫作外部设备。\n\n\n主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。\nALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。\nCU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。\n\n​\t\tALU和CU是CPU的核心部件。I&#x2F;O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。\n1.3.3 计算机系统的多级层次结构​\t\t从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：\n\n​\t从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​\t\t相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软&#x2F;硬件交界面的划分也不是绝对的。\n1.3.4 计算机系统的工作原理1. 从源程序得到可执行程序​\t\t用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​\t\t相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软&#x2F;硬件交界面的划分也不是绝对的。\n1.3.5 计算机系统的工作原理1. 从源程序得到可执行程序​\t\t用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。\n​\t（2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。\n​\t（3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。\n​\t（4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。\n2. 存储程序的基本思想​\t\t“存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。\n\n\n程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；\n将PC的内容作为地址访问主存，取出指令；\n在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；\n当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。\n\n​\t\t这样，计算机就可以周而复始地自动执行程序中的每一条指令了。\n3. 计算机硬件组成的细化说明\n​\t（1）主存储器\n​\t\t主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”存储字长“。\n​\t\t主存中的每个存储单元有一个唯一的编号，叫做存储单元的”地址“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。\n​\t\t为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。\n\nMAR（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。\nMDR（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。\n\n​\t（2）运算器\n​\t\t运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。\n\nACC： Accumulator，累加器；\nMQ： Multiplier-Quotient Register，乘商寄存器；\nX： 操作数寄存器\n\n​\t\t这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：\n\n\n\n\n加法\n减法\n乘法\n除法\n\n\n\nACC\n被加数及和\n被减数及差\n乘积高位\n被除数及余数\n\n\nMQ\n——\n——\n乘数及乘积低位\n商\n\n\nX\n加数\n减数\n被乘数\n除数\n\n\n​\t\t不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。\n​\t（3）控制器\n​\t\t控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。\nPC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。\nIR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。\n​\t\tCU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。\n​\t（4）I&#x2F;O\n​\t\tI&#x2F;O 系统包括各种 I&#x2F;O 设备及其相应的接口。每一种 I&#x2F;O 设备都由 I&#x2F;O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。\n4. 计算机硬件的工作过程​\t\t总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：\n\n把程序和数据装入主存储器；\n从程序的起始地址运行程序；\n按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；\n用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。\n\n​\t\t我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：\n​\t（1）取指令： PC → MAR → M → MDR → IR\n​\t\t根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读&#x2F;写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。\n​\t（2）分析指令： OP（IR） → CU\n​\t\t指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。\n​\t（3）执行指令：Ad（IR） → MAR → M → MDR → ACC\n​\t\t取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读&#x2F;写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。\n​\t（4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC\n1.4 计算机性能指标1.4.1 主要性能指标\n机器字长\n\n​\t\t机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。\n​\t\t字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。\n\n指令字长：一条指令中包含的二进制代码的位数。\n存储字长：一个存储单元中存储的二进制代码的长度。\n\n​\t\t指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。\n\n数据通路带宽\n\n​\t\t数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。\n\n存储容量\n\n​\t\t存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。\n​\t\t主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。\n​\t\t\t\t\t\t\t\t\t\t\t\t存储容量 &#x3D; 存储单元个数 × 存储字长\n​\t\t在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 216 &#x3D; 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K&#x3D;1024）；而如果 MDR 为32位， 那么主存的存储容量为 216 × 32 &#x3D; 221 &#x3D; 2Ｍ 位（1Ｍ&#x3D;220）。\n​\t\t现代计算机中常以字节的个数来描述容量的大小，一个字节（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 218 字节（Byte，简写为 B）表示，记作 218 B 或 256KB。\n​\t\t同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G &#x3D; 1KM &#x3D; 230 ）。\n\n运算速度\n\n​\t\t计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。\n1.5.2 专业术语解释​\t吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n​\t响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作等的时间）。\n​\t主频（CPU 时钟频率）：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。\n​\tCPU 时钟周期：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tCPU 时钟周期 &#x3D; 1 &#x2F; 主频\n​\tCPI：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。\n​\tCPU 执行时间：运行一个程序所花费的时间。\n​\t\t\t\t\t\t\t\t\t\t\t\tCPU 执行时间 &#x3D; （指令数 × CPI）&#x2F; 主频\n​\t\t对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。\n​\t\t现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。\n​\t\tMIPS：Million Instructions Per Second，每秒执行百万条指令的数目。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tMIPS &#x3D; 主频 &#x2F;（CPI × 106）\n​\t\tFLOPS：FLoating-point Operations Per Second，每秒执行浮点运算的次数。\n​\t\tMFLOPS：百万次浮点运算每秒。 MFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 106）\n​\t\tGFLOPS：十亿次浮点运算每秒。 GFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 109）\n​\t\tTFLOPS：万亿次浮点运算每秒。 TFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 1012）\n​\t\tPFLOPS：千万亿次浮点运算每秒。 PFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 1015）\n​\t\tEFLOPS：百京次浮点运算每秒。 EFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 1018）\n​\t\tZFLOPS：十万京次浮点运算每秒。 ZFLOPS &#x3D; 浮点操作次数 &#x2F;（执行时间 * 1021）\n​\t\t需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB &#x3D;  210 B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb&#x2F;s &#x3D; 103 b&#x2F;s。\n1.5 章节练习一、单项选择题\n【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。\n\n​\t\tA. 指令操作码的译码结果\t\t\t\tB. 指令和数据的寻址方式\n​\t\tC. 指令周期的不同阶段\t\t\t\t\tD. 指令和数据所在的数据单元\n​\t答案： C\n\n【2015真题】计算机硬件能够直接执行的是 （  ）。\n\n​\t\tI. 机器语言程序\tII. 汇编语言程序\tIII. 硬件描述语言程序\n​\t\tA. 仅 I \t\t\tB. 仅 I、II\t\t\tC. 仅 I、III\t\t\tD. I、II、III\n​\t答案： A\n\n【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。\n\n​\t\tA. 汇编程序\t\t\tB. 链接程序\t\t\tC. 编译程序\t\t\tD. 解释程序\n​\t答案： C\n\n【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。\n\n​\t\tA. 程序的功能都通过中央处理器执行指令实现\t\t\tB. 指令和数据都用二进制表示，形式上无差别\n​\t\tC. 指令按地址访问，数据都在指令中直接给出\t\t\tD. 程序执行前，指令和数据需预先存放在存储器中\n​\t答案： C\n\n【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。\n\n​\t\tI. ALU\t\tII. 指令寄存器\t\tIII. 通用寄存器\t\tIV. 浮点寄存器\n​\t\tA. 仅 I、II\t\t\tB. 仅 I、III\t\t\tC. 仅 II、III\t\t\tD. 仅 II、III、IV\n​\t答案： B\n\n【2010真题】下列选项中，能缩短程序执行时间的是（  ）。\n\n​\t\tI. 提高 CPU 时钟频率\tII. 优化数据通路结构\tIII. 对程序进行编译优化\n​\t\tA. 仅 I 和 II\t\t\tB. 仅 I 和 III\t\t\tC. 仅 II 和 III\t\t\tD. I、II、III\n​\t答案： D\n\n【2011真题】下列选项中，描述浮点数操作速度的是（  ）。\n\n​\t\tA. MIPS\t\t\t\t\tB. CPI\t\t\t\t\tC. IPC\t\t\t\t\tD. MFLOPS\n​\t答案： D\n\n【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I&#x2F;O 时间。若 CPU 速度提高 50%，I&#x2F;O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。\n\n​\t\tA. 55s\t\t\t\tB. 60s\t\t\t\tC. 65s\t\t\t\tD. 70s\n​\t答案： D\n\n【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。\n\n\n\n\n指令类型\n所占比例\nCPI\n\n\n\nA\n50%\n2\n\n\nB\n20%\n3\n\n\nC\n10%\n4\n\n\nD\n20%\n5\n\n\n​\t\t该机的 MIPS 是 （  ）。\n​\t\tA. 100\t\t\t\tB. 200\t\t\t\tC. 400\t\t\t\tD. 600\n​\t答案： C\n\n【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。\n\n​\t\tA. 8.4s\t\t\t\tB. 11.7s\t\t\t\tC. 14s\t\t\t\tD. 16.8s\n​\t答案： D\n\n【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。\n\n​\t\tA. 0.4\t\t\t\tB. 0.625\t\t\t\tC. 1.6\t\t\t\tD. 2.5\n​\t答案： C\n二、综合应用题\n说明机器字长、指令字长、存储字长的区别和联系。\n\n​\t答案：\n​\t\t机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。\n​\t\t指令字长：一个指令字中包含二进制代码的位数。\n​\t\t存储字长：一个存储单元存储二进制代码的长度。\n​\t\t它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。\n\n用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 I）。\n\n\n\n指令类型\nCPI\n指令混合比\n\n\n\n算术和逻辑\n1\n60%\n\n\n转移\n4\n12%\n\n\n高速缓存命中的访存\n2\n18%\n\n\n高速缓存失效的访存\n8\n10%\n\n\n\n\n​\t答案：\n​\t\tCPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：\n​\t\t\t\t\t\tCPI &#x3D; 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% &#x3D; 0.6 + 0.48 + 0.36 +0.8 &#x3D; 2.24\n​\t\tMIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：\n​\t\t\t\t\t\t\t\t\t\t\t\t\tMIPS &#x3D; 40 × 106 &#x2F;（2.24 × 106 ）≈ 17.9\n​\t\t程序的执行时间 T &#x3D; 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：\n​\t\t\t\t\t\tT &#x3D; CPI × 时钟周期 × 指令条数 &#x3D; 2.24 ×（1 &#x2F; 40MHz）× I &#x3D; 5.6 × 10-8 × I  秒\n​\t\t\n\n第二章 数据的表示和运算2.1 本章大纲要求与核心考点2.1.1 大纲内容（一）数制与编码\n\n进位计数制及其数据之间的相互转换\n定点数的表示和运算\n\n（二）运算方法和运算电路\n\n基本运算部件：加法器、算数逻辑部件（ALU）\n加&#x2F;减运算：补码加&#x2F;减运算器，标志位的生成\n乘&#x2F;除运算：乘&#x2F;除运算的基本原理，乘法电路和除法电路的基本结构\n\n（三）整数的表示和运算\n\n无符号整数的表示和运算\n有符号整数的表示和运算\n\n（四）浮点数的表示和运算\n\n浮点数的表示：IEEE 754标准\n浮点数的加&#x2F;减运算\n\n2.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n真值、机器数，定点数的表示及原理\nC 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换\nALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法\nIEEE 754标准浮点数的表示和特点，浮点数的加&#x2F;减运算方法\nC 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换\n数据按边界对齐方式的存储，数据按大端和小端方式存储\n\n2.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          定点数的表示与运算\n          10\n          8\n      \n      \n          IEEE 754标准浮点数，浮点数的运算\n          10\n          3\n      \n      \n          C语言中各种数据的转换\n          3\n          2\n      \n      \n          数据按边界对齐方式的存储，数据按大小端方式存储\n          4\n          0\n      \n  \n\n\n\n\n\n\n2.2 数制与编码2.2.1 进位计数制及其相互转换（一）进位计数制\n​\t\t进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为基数；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。\n​\t\t下表是十进制数、二进制数、十六进制数对照表。\n​\t\t书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)16；八进制数后面加上“O”，如372O或(372)8；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)2。\n​\t\t\t\t\t\t\t\t\t\t十进制数、二进制数、八进制数、十六进制数对照表\n\n\n\n十进制数\n二进制数\n八进制数\n十六进制数\n十进制数\n二进制数\n八进制数\n十六进制数\n\n\n\n0\n00000\n0\n0\n16\n10000\n20\n10\n\n\n1\n00001\n1\n1\n17\n10001\n21\n11\n\n\n2\n00010\n2\n2\n18\n10010\n22\n12\n\n\n3\n00011\n3\n3\n19\n10011\n23\n13\n\n\n4\n00100\n4\n4\n20\n10100\n24\n14\n\n\n5\n00101\n5\n5\n21\n10101\n25\n15\n\n\n6\n00110\n6\n6\n22\n10110\n26\n16\n\n\n7\n00111\n7\n7\n23\n10111\n27\n17\n\n\n8\n01000\n10\n8\n24\n11000\n30\n18\n\n\n9\n01001\n11\n9\n25\n11001\n31\n19\n\n\n10\n01010\n12\nA\n26\n11010\n32\n1A\n\n\n11\n01011\n13\nB\n27\n11011\n33\n1B\n\n\n12\n01100\n14\nC\n28\n11100\n34\n1C\n\n\n13\n01101\n15\nD\n29\n11101\n35\n1D\n\n\n14\n01110\n16\nE\n30\n11110\n36\n1E\n\n\n15\n01111\n17\nF\n31\n11111\n37\n1F\n\n\n​\t\t计算机系统为什么要采用二进制？\n\n使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。\n二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。\n二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。\n\n\n（二）不同进制数的相互转换\n​\t\t任意一个数 N，可以用 r 进制表示成下面的形式：\n​\t\t\t\t\t\t\t\t\t\t\tN &#x3D;（dn-1dn-2 … d1d0.d-1d-2 … d-m）\n​\t\t\t\t\t\t\t\t\t\t\t\t&#x3D; dn-1rn-1 + dn-2rn-2 + … + d1r1 + d0r0 + d-1r-1 + d-2r-2 + … + d-mr-m\n​\t\t\t\t\t\t\t\t\t\t\t\t&#x3D; ∑ diri\n​\t\t其中，r 为基数；d 为系数，di 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；ri 叫做第 i 位上的权值。n、m 分别代表 N 的整数部分和小数部分的位数。\n（1）二进制和八进制、十六进制间的转换\n​\t\t将二进制数1110011101.0010111转换为八进制数为：\n​\t\t\t\t\t\t\t\t\t\t\t\t左侧补0                  分界点                右侧补0\n​\t\t\t\t\t \t\t\t\t\t\t\t  ↓                         ↓                   ↓\n​\t\t\t\t\t\t\t\t\t\t\t\t001 110 011 101 .  001 011 100\n​\t\t\t\t\t\t\t\t\t\t\t\t 1       6     3      5  .    1      3      4\n​\t\t所以 (1110011101.0010111)2 &#x3D; (1635.134)8 ；\n​\t\t同样道理，转换为十六进制数为：\n​\t\t\t\t\t\t\t\t\t\t\t\t0011 1001 1101 .  0010 1110\n​\t\t\t\t\t\t\t\t\t\t\t\t\t3        9        D   .     2        E\n​\t\t所以 (1110011101.0010111)2 &#x3D; (39D.2E)16 ；\n\n二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。\n二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。\n八进制转换为二进制：每位都转换成对应的3位二进制数。\n十六进制转换为二进制：每位都转换成对应的4位二进制数。\n\n（2）任意进制数转换为十进制数\n​\t\t任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 按权展开法。\n​\t\t例如，将二进制数 11011.101 转换为十进制数为：\n​\t\t(11011.101)2  &#x3D; 1 × 24 + 1 × 23 + 0 × 22 + 1 × 21 + 1 × 20 + 1 × 2-1 + 0 × 2-2 + 1 × 2-3\n​\t\t\t\t\t\t\t&#x3D; 27.625\n​\t\t另一种方法是“按基数重复相乘&#x2F;除法”，需要分整数部分和小数部分分别转换。\n​\t\t整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​\t\t(11011)2  &#x3D;  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 &#x3D; 27\n​\t\t小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​\t\t(0.101)2  &#x3D;  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 &#x3D; 0.625\n（3）十进制数转换为二进制数\n​\t\t将十进制数转换为二进制数，一般采用 基数乘除法。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。\n\n整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）\n\n小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）\n\n\n​\t\t例如，将十进制数 123.6875 转换为二进制数。\n​\t\t整数部分：\n​\t\t  除2得商\t\t\t\t\t\t\t余数\n​\t\t2 |123\t\t\t\t…\t\t\t\t1\t\t\t\t最低位\n​\t\t  2  |61\t\t\t   …\t\t\t\t1\n​\t\t   2 |30\t\t\t   …\t\t\t\t0\n​\t\t   2 |15\t\t\t   …\t\t\t\t1\n​\t\t    2  |7\t\t\t   …\t\t\t\t1\n​\t\t    2  |3\t\t\t   …\t\t\t\t1\n​\t\t    2  |1\t\t\t   …\t\t\t\t1\t\t\t\t最高位\n​\t\t    2  |0\n​\t\t所以 (123)10 &#x3D; (1111011)2\n​\t\t小数部分：\n​\t\t  乘积取小数\t\t\t\t\t\t\t\t乘2得积\t\t\t\t取整数部分\n​\t\t\t0.6875\t\t\t\t× 2\t\t\t\t&#x3D; 1.375\t\t\t\t\t\t1\t\t\t\t\t\t最高位\n​\t\t\t0.375\t\t\t\t  × 2\t\t\t\t&#x3D; 0.75\t\t\t\t\t\t   0\t\t\n​\t\t\t0.75\t\t\t\t    × 2\t\t\t\t&#x3D; 1.5\t\t\t\t\t\t     1\t\n​\t\t\t0.5\t\t\t\t      × 2\t\t\t\t &#x3D; 1\t\t\t\t\t\t\t\t1\t\t\t\t\t\t最低位\t\n​\t\t所以 (0.6875)10 &#x3D; (0.1011)2\n​\t\t综合整数和小数部分，得到 (123.6875)10 &#x3D; (1111011.1011)2\n​\t\t另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：\n​\t\t十进制数\t\t\t\t位权\t\t\t\t转换后的结果\n​\t\t\t123\t\t\t\t\t\t\t\t\t\t\t26\t25\t24\t23\t22\t21\t20\n​\t\t➖ 64\t\t\t\t\t\t26\t\t\t\t1\n​\t\t\t  59\n​\t\t➖ 32\t\t\t\t\t\t25\t\t\t\t\t\t1\n​\t\t\t  27\n​\t\t➖ 16\t\t\t\t\t\t24\t\t\t\t\t\t\t\t1\n​\t\t\t  11\n​\t\t➖   8\t\t\t\t\t\t23\t\t\t\t\t\t\t\t\t\t1\n​\t\t\t    3\n​\t\t➖   2\t\t\t\t\t\t21\t\t\t\t\t\t\t\t\t\t\t\t\t\t1\n​\t\t\t\t1\n​\t\t➖   1\t\t\t\t\t\t20\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1\n​\t\t\t\t0\n​\t\t所以 (123)10 &#x3D; (1111011)2 \n​\t\t这种方法一般在转换很大的十进制数时比较方便。\n2.2.2 真值和机器数​\t\t在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。\n​\t\t对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。\n例如，一个有符号的小数：\n​\t\t\t\t+ 0.1011\t\t\t\t在机器中表示为\t\t0\t1 0 1 1\n​\t\t\t\t-  0.1011\t\t\t\t在机器中表示为\t\t1\t1 0 1 1\n再比如，一个有符号的整数：\n​\t\t\t\t+ 1100\t\t\t\t\t在机器中表示为\t\t0\t1 1 0 0\n​\t\t\t\t-  1100\t\t\t\t\t在机器中表示为\t\t1\t1 1 0 0\n​\t\t把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。\n\n真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。\n机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。\n\n​\t\t在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即定点表示和浮点表示。\n​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。\n​\t\t在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。\n2.2.3 定点数及其编码表示​\t\t小数点固定在某一位置的数为定点数，有以下两种格式。\n\n当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。\n​\t\t在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。\n1. 无符号整数的表示​\t\t当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 28-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。\n2. 带符号数的表示​\t\t最高位用来表示符号位，而不再表示数值位。\n（1）定点整数\n​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。\n​\t\t约定小数点在有效数值部分最低位之后。数据 x &#x3D; x0x1x2…xn （其中 x0 为符号位，x1 ~ xn 是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：\n\n（2）定点小数\n​\t\t约定小数点在有效数值部分最高位之前。数据 x &#x3D; x0.x1x2…xn（其中 x0 为符号位，x1~xn 是尾数，x1 是最高有效位），在计算中的表示形式如下图所示：\n\n3. 原码、补码、反码和移码\n原码表示法\n\n​\t\t用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:\n\n式子中 x 为真值，[ x ]原 表示原码机器数。\n​\t\t类似，纯整数的原码定义如下：\n\n​\t原码的性质：\n\n由符号位与数的绝对值组成，符号位是0为正、1为负\n\n0有 ±0 两个编码，即 [+0]原 &#x3D; 00000 和 [-0]原 &#x3D; 10000\n\n\n\n补码表示法\n\n​\t\t纯整数的补码定义为：\n\n​\t这里 n 为整数的位数，真值 x 和补码机器数 [ x ]原 互为以 2n+1 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2n ≤ x ≤ 2n - 1，比原码多表示了一个数 -2n。\n​\t\t补码的性质：\n\n补码和其真值的关系：[x]补 &#x3D; 符号位 × 2n+1 + x\n0的编码唯一，因此整数补码比原码多1个数，表示 -2n\n符号位参与补码加减运算，统一采用加法操作实现\n将 [x]补 的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能\n\n​\t\t例如，当 x &#x3D; + 1010 时（n &#x3D; 4），\n​\t\t[x]补 &#x3D; 0, 1010\n​\t\t而当 x &#x3D; - 1010 时，\n​\t\t[x]补 &#x3D; 2n+1 + x &#x3D; 100000 - 1010 &#x3D; 1, 0110\n​\t\t补码和真值的转换：\n\n真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。\n补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。\n\n​\t\t变形补码是采用双符号位的补码表示法，其定义为\n\n​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。\n\n反码表示法\n\n​\t\t负数的补码可采用“数值位各位取反，末位加1”的方法得到，如果数值位各位取反而末位不加1，那么就是负数的反码表示。正数的反码定义和相应的补码（或原码）表示相同。\n​\t\t反码表示存在以下几个方面的不足：0的表示不唯一（即存在±0）；表示范围比补码少一个最小负 数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。\n​\t\t原码、补码、反码三种编码表示总结如下：\n\n三种编码的符号位相同，正数的机器码相同。\n\n原码和反码的表示在数轴上对称，二者都存在 ±0 两个零。\n\n补码的表示在数轴上不对称，0的表示唯一，补码比原码和反码多表示一个数。\n\n负数的反码、补码末位相差1。\n\n原码很容易判断大小。而负数的补码和反码很难直接判断大小，可采用这条规则快速判断：对于一个负数，数值部分越大，它的绝对值就越小，所以真值就越大（更靠近0）。\n\n\n\n移码表示法\n\n​\t\t移码是在真值 x 上加上偏置值 2n 构成的，相当于 x 在数轴上向正方向偏移了若干单位。\n\n​\t移码定义为:\n\n移码的性质：\n\n0的表示唯一， [+0]移 &#x3D;  2n + 0 &#x3D; [-0]移 &#x3D; 2n - 0 &#x3D; 100…0 \n符号位“1”表示正，“0”表示负，这与其他机器数正好相反。\n一个真值的移码和补码仅差一个符号位，[x]补 的符号位取反即得 [x]移，反之亦然。\n移码全0时，对应真值的最小值- 2n ；移码全1时，对应真值的最大值 2n -1。\n保持了数据原有的大小顺序，移码大真值就大，便于进行比较操作。\n移码常用来表示浮点数的阶码。它只能表示整数。\n\n2.2.4  C 语言中的整型数据类型\nC 语言中的整型数据简介\n\n​\t\tC 语言中的整型数据就是定点整数，一般用补码表示。根据位数的不同，可以分为 **字符型(char)、短整型(short)、整型(int)、长整型(long)**。\n​\t\tC 语言中的整型数据，可以分为 无符号整型 和 有符号整型 两种类型，在定义时只要加上 signed&#x2F;unsigned 就可以明确指定了。\n​\t\tchar 是整型数据中比较特殊的一种，其他如 short&#x2F;int&#x2F;long 等都默认是带符号整数，但 char 默认是无符号整数。无符号整数（unsigned short&#x2F;int&#x2F;long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\n​\t\tsigned&#x2F;unsigned 整型数据都是按补码形式存储的，在不溢出条件下的加减运算也是相同的，只是 signed 型的最高位代表符号位，而在 unsigned 型中表示数值位，而这两者体现在输出上则分别是％d 和％u。\n\n有符号数和无符号数的转换\n\n​\t\tC 语言允许在不同的数据类型之间做类型转换。C 语言的强制类型转换格式为“TYPE b &#x3D; (TYPE) a”, 强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。\n​\t\t先看由 short 型转换到 unsigned short 型的情况。考虑如下代码片段：\n123short x = -4321;unsigned short y = (unsigned short)x;\n\n​\t\t执行上述代码后，x &#x3D; -4321, y &#x3D; 61215，得到的 y 似乎与原来的 x 没有一点关系。不过将这两个数转化为二进制表示时，我们就会发现其中的规律。\n​\t\t通过本例可知：强制类型转换的结果是保持每位的值不变，仅改变了解释这些位的方式。有符号数转化为等长的无符号数时，符号位解释为数据的一部分，负数转化为无符号数时数值将发生变化。同理，无符号数转化为有符号数时，最高位解释为符号位，也可能发生数值的变化。\n\n不同字长整数之间的转换\n\n​\t\t另一种常见的运算是在不同字长的整数之间进行数值转换。\n​\t\t先看长字长变量向短字长变量转换的情况。考虑如下代码片段：\n123int x = 165537, u = -34991;                      //int型占用4字节short y = ( short )x, v = ( short )u;            //short型占用2字节\n\n​\t\t执行上述代码后，x&#x3D; 165537, y&#x3D;-31071, u &#x3D;-34991, v &#x3D; 30545。x、y、u、v 的十六进制表示分别 是0x000286a1 0x86a1 . 0xffff7751、0x7751。由本例可知：长字长整数向短字长整数转换时，系统把多余的高位部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。\n​\t\t最后来看短字长变量向长字长变量转换的情况。考虑如下代码片段:\n1234567short x = -4321;int y = (int)x;unsigned short u = (unsigned short)x;unsigned int v = (unsigned int)u;\n\n​\t\t执行上述代码后，x &#x3D; -4321, y &#x3D; -4321, u &#x3D; 61215, v &#x3D; 61215。x、y、u、v 的十六进制表示分别是0xef1f. 0xffffef1f、0xef1f、0x0000ef1f。所以，短字长整数向长字长整数转换时，仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。\n​\t\t从位值与数值的角度看，前3个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换可以理解为保证数值的相等。\n\n2.3 运算方法2.3.1 定点数的移位运算​\t\t移位运算根据操作对象的不同，可以分为算术移位和逻辑移位。算术移位针对的是有符号数，逻辑移位针对的是机器码，可以看作无符号数。\n1. 算术移位​\t\t算术移位的对象是有符号数，有符号数在计算机中采用补码表示。算术移位的特点是，移位后符号位保持不变；空出的位置根据正负和左右移位的情况，决定补 0 还是 1。\n\n对于正数，由于 [ x ]原 &#x3D; [ x ]补 &#x3D; 真值，因此移位后的空位均补 0。\n对于负数，算术左移时，高位移出，低位补 0；算术右移时，低位移出，高位补 1。\n\n​\t\t可见，不论是正数还是负数，移位后其符号位均不变。\n​\t\t例如，假设机器字长为 8，[4]补 &#x3D; 0000 0100，[-4]补 &#x3D; 1111 1100；\n\n将 4 算术左移一位，就得到了 0000 1000 &#x3D; [8]补；算术右移一位，就得到了 0000 0010 &#x3D; [2]补；\n\n将 -4 算术左移一位，就得到了 1111 1000 &#x3D; [-8]补；算术右移一位，就得到了 1111 1110 &#x3D; [-2]补；\n\n\n​\t\t对于有符号数，左移一位若不产生溢出，相当于乘以2 （与十进制数左移一位相当于乘以10类似）; 右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。\n2. 逻辑移位​\t\t逻辑移位不考虑符号位。\n​\t\t移位规则：逻辑左移时，高位移出，低位补 0；逻辑右移时，低位移岀，高位补 0 。\n2.3.3 定点数的加减运算​\t\t加减法运算是计算机中最基本的运算，由于减法可以看成是负值的加法，因此计算机中使用补码表示有符号数之后，可以将减法运算和加法运算合并在一起讨论。\n1. 补码的加减运算​\t\t补码加减运算的规则简单，易于实现。补码加减运算的公式如下（设机器字长为 n）：​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[A + B]补 &#x3D; [A]补 + [B]补  (mod 2n)​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[A - B]补 &#x3D; [A]补 + [-B]补  (mod 2n)\n​\t\t补码运算的特点如下：\n\n按二进制运算规则运算，逢二进一。\n如果做加法，两数的补码直接相加；如果做减法，则将被减数加上减数的机器负数。\n符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。\n最终将运算结果的高位丢弃，保留 n 位，运算结果也是补码。\n\n​\t\t例如，假设机器字长为 8 （n &#x3D; 8），那么\n​\t\t[5]补 &#x3D; 0000 0101，[4]补 &#x3D; 0000 0100；\n​\t\t[-5]补 &#x3D; 1111 1011，[-4]补 &#x3D; 1111 1100；\n​\t\t[5 + 4]补 &#x3D; 0000 0101 + 0000 0100 &#x3D; 0000 1001 &#x3D; [9]补；\n​\t\t[5 - 4]补 &#x3D; [5 + (-4)]补 &#x3D; 0000 0101 + 1111 1100 &#x3D; 1 0000 0001 &#x3D; [1]补；\n​\t\t[4 - 5]补 &#x3D; [4 + (-5)]补 &#x3D; 0000 0100 + 1111 1011 &#x3D; 1111 1111 &#x3D; [-1]补；\n​\t\t[-5 - 4]补 &#x3D; [-5 + (-4)]补 &#x3D; 1111 1011 + 1111 1100 &#x3D; 1 1111 0111 &#x3D; [-9]补；\n2. 溢出判别方法​\t\t溢出 是指运算结果超出了数的表示范围。通常，大于能表示的最大正数称为正上溢，小于能表示的最小负数称为负上溢。仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。\n​\t\t在之前的例子中，如果假设机器字长为 4（n &#x3D; 4），能表示的有符号数范围为 -8 ~ 7，那么就有：\n​\t\t[5]补 &#x3D; 0101，[4]补 &#x3D; 0100；\n​\t\t[-5]补 &#x3D; 1011，[-4]补 &#x3D; 1100；\n​\t\t[5 + 4]补 &#x3D; 0101 + 0100 &#x3D; 1001 &#x3D; [-7]补；\t\t（正溢出）\n​\t\t[5 - 4]补 &#x3D; [5 + (-4)]补 &#x3D; 0101 + 1100 &#x3D; 1 0001 &#x3D; [1]补；\n​\t\t[4 - 5]补 &#x3D; [4 + (-5)]补 &#x3D; 0100 + 1011 &#x3D; 1111 &#x3D; [-1]补；\n​\t\t[-5 - 4]补 &#x3D; [-5 + (-4)]补 &#x3D; 1011 + 1100 &#x3D; 1 0111 &#x3D; [7]补；\t\t（负溢出）\n​\t\t补码加减运算的溢出判断方法有以下 3 种：\n（1）采用一位符号位。\n​\t\t参加操作的两个数符号相同，结果又与原操作数符号不同，就表示结果溢出。\n​\t\t一正一负相加必然不会溢出；两正数相加得到一个负数（符号位为1），则正溢出；两负数相加得到一个正数，则负溢出。\n（2）采用双符号位。\n​\t\t运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位就代表真正的符号。也就是说，符号位 S1S2 &#x3D; 00 表示结果为正数，无溢出； S1S2 &#x3D; 11 表示结果为负数，无溢出。 S1S2&#x3D; 01 表示结果正溢出； S1S2 &#x3D; 10 表示结果负溢出。溢出标志 OF &#x3D; S1 ㊉ S2。\n​\t\t比如上例中，如果采用双符号位，机器字长就应该扩展为 5，那么：\n​\t\t[5]补 &#x3D; 00 101，[4]补 &#x3D; 00 100；\n​\t\t[-5]补 &#x3D; 11 011，[-4]补 &#x3D; 11 100；\n​\t\t[5 + 4]补 &#x3D; 00 101 + 00 100 &#x3D; 01 001 &#x3D; [1]补；\t\t（正溢出）\n​\t\t[5 - 4]补 &#x3D; [5 + (-4)]补 &#x3D; 00 101 + 11 100 &#x3D; 1 00 001 &#x3D; [1]补；\n​\t\t[4 - 5]补 &#x3D; [4 + (-5)]补 &#x3D; 00 100 + 11 011 &#x3D; 11 111 &#x3D; [-1]补；\n​\t\t[-5 - 4]补 &#x3D; [-5 + (-4)]补 &#x3D; 11 011 + 11 100 &#x3D; 1 10 111 &#x3D; [-1]补；\t\t（负溢出）\n2.2.4 定点数的乘法运算1. 原码一位乘法​\t\t原码乘法运算的符号位与数值位分开计算。\n\n确定乘积的符号位。由两个乘数的符号进行异或运算得到。\n计算乘积的数值位。两个乘数的数值部分之积，可看作两个无符号数的乘积。\n\n​\t\t原码一位乘法的基本思路，就是类似竖式乘法的做法，让被乘数 x 分别乘以乘数 y 的每一位，然后再做叠加。不过竖式乘法需要做连加运算，这在电路实现上会有一些困难；改进的做法是，借鉴进制转换的“重复相乘&#x2F;除法”，对每一位进行迭代计算。\n​\t\t回忆一下二进制数转换成十进制数的重复相乘&#x2F;除法：\n​\t\t整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​\t\t(11011)2  &#x3D;  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 &#x3D; 27\n​\t\t小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​\t\t(0.101)2  &#x3D;  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 &#x3D; 0.625\n​\t\t所以，两数相乘时，就可以把乘数 y 用这种方式按每一位拆开，并乘以 x 、再逐位叠加就可以了。由于每次乘以 2 就相当于左移一位、除以 2 就相当于右移一位，因此只需要反复迭代这样的 移位 和 加法 运算就可以很容易地实现乘法了。\n\n原码一位乘法的运算规则如下：\n\n被乘数和乘数均取绝对值|x| 和 |y|参加运算，看作无符号数，符号位为 x0 ㊉ y0。\n乘数的每一位 yi 乘以被乘数 |x| 得到 |x| · yi，将该结果与前面所得的结果相加，作为部分积；初始值为 0。\n从乘数的最低位 yn 开始判断：若 yn &#x3D; 1，则部分积加上被乘数 |x|，然后右移一位；若 yn &#x3D; 0，则部分积加上 0，然后右移一位。\n重复上一步骤，判断 n 次。\n\n​\t\t由于参与运算的是两个数的绝对值，因此运算过程中的右移操作均为逻辑右移。\n\n​\t\t例如，当 x &#x3D; 0.1101 &#x3D; (0.8125)10，y &#x3D; 0.1011 &#x3D; (0.6875)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​\t\t x · y &#x3D; 0.1101 × 0.1011 &#x3D;  0.10001111 &#x3D; (0.55859375)10\n\n2. 补码一位乘法​\t\t带符号数的乘法，采用相加&#x2F;相减的校正操作，直接计算补码数据的乘积。\n​\t\t补码乘法是直接对补码进行的。对于纯整数，补码表达为：\n\n而类似的，纯小数补码定义为：\n\n所以，当取不同的正负符号时，补码表达会有所不同，继而影响到逐位相乘叠加的效果。\n​\t\t已知 [ x ]补 &#x3D; x0 . x1x2…xn，[ y ]补 &#x3D; y0 . y1y2…yn，那么需要分不同的情况讨论：\n​\t\t① 被乘数 x 和乘数 y 符号均为正，即 x0 &#x3D; y0 &#x3D; 0 时，\n​\t\t[ x ]补 &#x3D; x，[ y ]补 &#x3D; y，所以就有：\n\n类似原码一位乘法，利用移位和加法的叠加，就可以计算出补码的乘积；这也就是最终计算结果的补码。\n​\t\t② 被乘数 x 为正，乘数 y 为负，即 x0 &#x3D; 0，y0 &#x3D; 1 时，\n​\t\t[ y ]补 &#x3D; 1. y1y2…yn &#x3D; 2 + y，所以：\n\n那么两数的乘积就可以写成：\n\n这样一个计算结果，它的补码表示为：\n\n​\t可以看到，当乘数为负时，可以把乘数补码 [ y ]补 直接去掉符号位，当成一个正数与 [ x ]补 相乘；得到的结果再加上 [ -x ]补 进行校正。所以这种方法也叫做“校正法”。\n\n​\t\t例如，当 x &#x3D; 0.1101 &#x3D; (0.8125)10，y &#x3D; 1.1011 &#x3D; (-0.3125)10 时，计算 x · y。\n​\t\t我们可以直接计算 0.1101 × 0.1011 &#x3D; 0.10001111，再加上 [ -x ]补 &#x3D; 1. 0011，得到 ：\n​\t\t 0.10001111 + 1. 0011 &#x3D; 1.10111111 &#x3D;  ( -0.25390625 )10\n\n​\t\t③ 被乘数 x 为负，乘数 y 为正，即 x0 &#x3D; 1，y0 &#x3D; 0 时，\n​\t\t我们可以交换被乘数和乘数，直接按情况②来处理；也可以仔细分析，发现乘数 y 为正数，可以写成\n[ y ]补 &#x3D; 0. y1y2…yn 的形式，同样可以借鉴情况②中的分析和原码一位乘的方法。当两数的补码相乘时：\n\n观察可以发现，与原码一位乘完全类似，补码相乘也可以将乘数展开，逐位进行相乘、右移和叠加。不过需要注意的是，这时由于被乘数 x 是负数，右移时就需要在左侧高位补 1，也就是做算术右移、而不是逻辑右移。\n​\t\t这样一来，算术右移就实现了对真值 x 的“除以 2”操作，最终叠加之后的结果，就是 x · y 的补码了。\n​\t\t例如，当 x &#x3D; 1.1 &#x3D; (-0.5)10，y &#x3D; 0.011 &#x3D; (0.375)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​\t\t x · y &#x3D; 1.1 × 0.011 &#x3D;  1.1101 &#x3D; ( - 0.1875 )10\t\t\n​\t\t④ 被乘数 x 和乘数 y 符号均为负，即 x0 &#x3D; y0 &#x3D; 1 时，\n​\t\t通过情况②和③的分析可以看出，当乘数 y 为正时，可以直接按照原码一位乘的方式进行补码乘法，注意需要进行算术右移；而当乘数 y 为负时，则可以先不考虑 y 的符号位，同样按照原码一位乘进行补码乘法，最后的结果要再加上 [ -x ]补 进行校正。\n​\t\t例如，当 x &#x3D; 1.1 &#x3D; (-0.5)10，y &#x3D; 1.011 &#x3D; (-0.625)10 时，计算 x · y。\n​\t\t我们可以直接计算 1.1 × 0.011 &#x3D;  1.1101，再加上 [ -x ]补 &#x3D; 0.1，得到 ：\n​\t\t1.1101 + 0.1 &#x3D; 1 0.0101 &#x3D;  ( 0.3125 )10\n​\t\t可以看出，如果使用双符号位来表示正负，会更加方便。\n​\t\t⑤  Booth算法\n​\t\t以上的 4 种情况需要分别讨论，根据乘数的符号来决定是否需要进行校正。\n​\t\t如果不考虑操作数的符号，直接用统一的规则来处理所有情况，可以采用 Booth 算法。\n​\t\t当被乘数 x 和乘数 y 符号任意时，按照之前讨论的校正法规则，可以写出一个统一的计算公式：\n\n​\t容易推出，对于纯小数，在 mod 2 的前提下，[ -x ]补 &#x3D; - [ x ]补，所以可以进一步推导得到：\n\n​\t令 yn+1 &#x3D; 0，那么就可以得到一个通项系数： di &#x3D; yi+1 - yi ，上式可以进一步化简为：\n\n这样一来，补码乘法的计算方式就跟原码一位乘完全一样了，只是被乘数每次乘的不再是乘数 y 的每一位 yi，而是变成了 di &#x3D; yi+1 - yi 。这样就有 1、-1 和 0 三种情况，每一次计算都由 di 来决定部分积叠加的是 [ x ]补、[ -x ]补 还是 0；然后再做一位算术右移得到新的部分积。最后一步，需要由 d0 &#x3D; y1 - y0 决定是否有叠加项，但不再做位移。\n​\t\tBooth 算法的移位规则如下表所示：\n\nBooth 算法的具体运算规则如下：\n①\t符号位参与运算，运算的数均以补码表示。\n②\t被乘数一般取 双符号位 参与运算，部分积取 双符号位，初值为 0，乘数取单符号位。\n③\t乘数末尾增加一个“附加位” yn+l，初始值为 0。\n④\t根据（yi，yi+1）的取值来确定操作，如上表所示。\n⑤\t移位按补码右移规则（算术右移）进行。\n⑥\t按照上述算法进行 n + 1 步操作，但第 n + 1 步不再移位，仅根据 y0 （符号位）与 y1 （第一位数值位）的比较结果做相应的叠加运算。所以总共需要进行 n + 1 次累加和 n 次右移。\n\n​\t\t例如，当 x &#x3D; 1.1101 &#x3D; (-0.1875)10，y &#x3D; 1.1011 &#x3D; (-0.3125)10  时，计算 x · y。\n​\t\t首先得到 [x]补 &#x3D; 11.1101，[-x]补 &#x3D; 00.0011。具体计算步骤如下：\n\n同样，最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​\t\t x · y &#x3D; 1.1101 × 1.1011 &#x3D;  0.00001111 &#x3D; (0.05859375)10\n2.2.5 定点数的除法运算1. 原码一位除法（1）恢复余数法\n​\t\t恢复余数法的特点是：当余数为负时，需要加上除数的绝对值，将其恢复成原本的余数。\n​\t\t由于每次得到的是商的高位，所以每轮计算可以将余数和商同时左移一位；余数加上 [- y]补 ，判断正负来决定下一位商是 1 还是 0；如果为负，还需要先加上 [y]补 恢复余数，然后再做左移。\n\n​\t\t例如，当 x &#x3D; (-0.1011)2  &#x3D; (-0.6875)10，y &#x3D; (-0.1101)2 &#x3D; (-0.8125)10 时，计算 x &#x2F; y。\n​\t\t首先看出，商的符号为正，余数的符号为负。并且得到：\n​\t\tx &#x3D; 0.1011，y&#x3D; 0.1101，[y]补 &#x3D; 0.1101，[-y]补 &#x3D; 1.0011\n​\t\t具体计算过程如下：\n\n所以商值为 x&#x2F; y &#x3D; 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2^-4 &#x3D; 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​\t\tx &#x2F; y &#x3D; 0.1101（商）… - 0.00000111（余数）\n溢出判断：当该位为 1 时，表示当前除法溢出，不能进行；当该位为 0 时，当前除法合法，可以进行。\n（2）不恢复余数法（加减交替法）\n​\t\t在恢复余数法中，每当余数为负时都需要恢复余数，这就增加了运算量，操作也不规则，电路实现会比较复杂。加减交替法就克服了这一缺点。\n​\t\t加减交替法 又称 不恢复余数法，是对恢复余数法的一种改进。\n​\t\t通过分析恢复余数法可以发现，如果把第 i 轮计算的余数记作 Ri，那么：\n\n如果 Ri &gt; 0，就上商 1，接下来需要将余数 Ri 左移一位，再减去除数绝对值 y，即 2Ri - y；\n如果 Ri &lt; 0，就上商 0，接下来先加上 y 恢复余数，再做左移和减法，即 2 (Ri + y) - y &#x3D; 2Ri + y。\n\n​\t\t这样一来，就不需要额外恢复余数了，每轮计算的规则完全统一起来，只是左移之后再加&#x2F;减 y^*^ 就可以了；所以把这种方法叫做“加减交替法”，或者“不恢复余数法”。\n\n​\t\t还是上面的例子，当 x &#x3D; (-0.1011)2  ，y &#x3D; (-0.1101)2 时，计算 x &#x2F; y。\n​\t\t同样的步骤，首先看出，商的符号为正，余数的符号为负。并且得到：\n​\t\tx&#x3D; 0.1011，y &#x3D; 0.1101，[y]补 &#x3D; 0.1101，[-y]补 &#x3D; 1.0011\n​\t\t具体计算过程如下：\n\n所以商值为 x &#x2F; y&#x3D; 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2^-4 &#x3D; 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​\t\tx &#x2F; y &#x3D; 0.1101（商）… - 0.00000111（余数）\n2. 补码一位除法（加减交替法）\n补码一位除法的运算规则如下：\n\n符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。\n如被除数与除数同号，则被除数减去除数；如被除数与除数异号，则被除数加上除数。\n余数与除数同号，商上1，余数左移一位再减去除数；余数与除数异号， 商上 0，余数左移一位再加上除数。\n重复执行上一步操作，操作 n 次。\n如果对商的精度没有特殊要求，一般采用“末位恒置 1”法。\n\n​\t同样的例子，当 x &#x3D; (-0.1011)2  ，y &#x3D; (-0.1101)2 时，计算 x &#x2F; y。\n​\t\t首先得到： [x]补 &#x3D; 1.0101，[y]补 &#x3D; 1.0011，[-y]补 &#x3D; 0.1101\n​\t\t具体计算过程如下：\n\n所以商值为\n​\t\tx &#x2F; y &#x3D; 0.1101\n2.4 浮点数的表示和运算2.4.1 浮点数的表示浮点数 就是小数点的位置可以浮动的数。例如：\n​\t\t365.242 &#x3D; 3.65242 × 10^2^\n​\t\t\t\t\t   &#x3D; 365242.0 × 10^-3^\n​\t\t\t\t\t   &#x3D; 0.365242 × 10^3^\n1. 浮点数的表示格式​\t\t在计算机中，浮点数的格式如下图所示。采用这种数据格式的机器称为 浮点机。\n\n​\t浮点数由 阶码 j 和 尾数 S 两部分组成。\n\n阶码是纯整数，阶符和阶码值合起来决定了小数点的实际位置；阶码值的位数 m 再结合阶符，可以反映浮点数的表示范围。\n尾数是纯小数，数符 Sf代表了浮点数的正负，而尾数值则是有效数位，位数 n 反映了浮点数的精度。\n\n2. 浮点数的表示范围​\t\t假设浮点数 N 的阶码 j 数值部分有 m 位，尾数 S 数值部分有 n 位。\n​\t\t阶码是纯整数，尾数是纯小数，它们可以各自选择编码方式。对于非规格化的浮点数，如果阶码和尾数都用原码表达，各自的取值范围如下：\n\n​        那么阶码 j 和尾数 S 组合之后，能表示的浮点数最大范围就是：\n\n在数轴上表示出来，如下图所示：\n\n原码是关于原点对称的，所以浮点数的表示范围也是关于原点对称的。\n​\t\t当运算结果大于能表示的最大正数时，称为正上溢；小于最小负数时。称为负上溢：两者统称 上溢。由于尾数的溢出可以通过移位、增加阶码来调整，因此上溢的本质就是 阶码大于最大阶码，这时机器会停止计算，进行中断溢出处理。\n​\t\t当运算结果在 0 至最小正数之间时，称为正下溢；在 0 至最大负数之间时，称为负下溢，统称 下溢。同样道理，下溢的本质是 阶码小于最小阶码，这时溢出的数值绝对值非常小，通常可以将尾数各位直接强置为 0，按 ”机器零“ 来处理，机器可以继续正常运行。\n​\t\t类似地，如果阶码和尾数都用补码表达，各自的取值范围如下：\n\n​\t用移码来表示阶码方便进行阶数的比较和对齐，简称 “对阶”。这在进行浮点数加减运算时非常重要，尾数只有在阶数相同的时候才能做加减，采用移码直接比较两个阶码的二进制大小关系就可以了：\n\n3. 浮点数的规格化​\t\t由于规格化数的精度最高，所以当一个非零的浮点数不是规格化数时，应该通过左右移动尾数、并同时修改阶码的方法，将它转换为规格化数。把一个非规格化数转换成规格化数的过程，叫做 规格化。\n​\t\t规格化的本质类似于 “科学计数法” 的表达，通过保证尾数最高数位上是一个有效值，尽可能多地保留有效数字的尾数，从而提高精度。\n​\t\t规格化可以分为 “左规” 和 “右规” 两种。以基数 r &#x3D; 2 为例：\n\n左规：向左规格化。当运算结果尾数的最高数位不是有效位，即出现 0.0…01… 的形式时，需要向左规格化。左规时，尾数左移一位，阶码减 1；\n右规：向右规格化。当运算结果尾数的小数点左侧出现有效位，即整数部分不为 0 时，需要向右规格化。右规时，尾数右移一位，阶码加 1；需要右规时，只需进行一次。\n\n​\t\t当基数不同时，规格化的原则会有相应的改变。比如，当基数 r &#x3D; 4 时，阶码每次加&#x2F;减 1，就相当于多乘&#x2F;除以 4，也就是左&#x2F;右移 2 位。所以左规就是尾数左移 2 位，阶码减 1；右规是尾数右移 2 位，阶码加 1。尾数的最高 2 位不全为 0 的数，就是规格化数。\n\n4. IEEE 754 标准浮点数​\t\t在现代计算机中，浮点数的格式一般采用 IEEE 制定的国际标准。IEEE 754 标准规定的浮点数形式为：\n![2_58_IEEE 浮点数形式](..&#x2F;img&#x2F;2_58_IEEE 浮点数形式-17170735321978.png)\n\nS 为数符，直接表示浮点数的正负，它与尾数所表示的有效数位是分开的。\n阶码 E 包含了阶符，用移码来表示，不过这里移码的偏移量不是 2 的整次幂，而是要再减去 1。 假设阶码 E 的位数为 m + 1，那么偏移量就是 2^m - 1。\n尾数 M 是原码表示的纯小数。\n\n​\t\t浮点数的位数不同，可以表示不同的数值范围和精度。IEEE 标准中常用的浮点数有三种：短浮点数（单精度）、长浮点数（双精度）和临时浮点数（延伸双精度）。\n![2_59_IEEE 三种浮点数格式](..&#x2F;img&#x2F;2_59_IEEE 三种浮点数格式.png)\n​\t以 32 位的单精度浮点数为例，所有的机器码和对应的取值范围如下：\n![2_60_IEEE 单精度32位浮点数表示范围](..&#x2F;img&#x2F;2_60_IEEE 单精度32位浮点数表示范围.png)\n\n​\t例如，对于十进制数 178.125，把它写成 IEEE 标准的短浮点数。\n​\t\t我们需要分整数部分和小数部分，首先转换成二进制数的表示；然后写成类似 “科学计数法” 的二进制浮点数表达。\n![2_61_IEEE 浮点数示例（一）_数的二进制浮点表达](..&#x2F;img&#x2F;2_61_IEEE 浮点数示例（一）_数的二进制浮点表达-17170736230759.png)\n​\t这是一个正数，符号位为 0；然后从二进制浮点表达中得到阶码和尾数。将 8 位二进制阶码加上偏移量 127，尾数隐藏整数位的 1 后补成 23 位，就是最终符合 IEEE 标准的 32 位短浮点数。\n![2_62_IEEE 浮点数示例（二）_IEEE标准短浮点数](..&#x2F;img&#x2F;2_62_IEEE 浮点数示例（二）_IEEE标准短浮点数.png)\n​\t\n2.4.2 浮点数的加&#x2F;减运算​\t（1）对阶\n​\t\t对阶的目的是使两个操作数的小数点位置对齐，使两个数的阶码相等。先求阶差，然后以 “小阶向大阶看齐” 的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。\n​\t（2）尾数求和\n​\t\t将对阶后的尾数，按定点数加&#x2F;减运算规则运算。\n​\t（3）规格化\n​\t\tIEEE 754 规格化尾数的形式为 ±1.×…×，所以当计算结果为非规格化数时，需要进行规格化处理。\n\n左规：当结果为 ±0.0…01x…x 时，需进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1移到小数点左边。\n右规：当结果为 ±1x.x…x 时，出现了尾数的溢出，需进行右规。尾数右移一位，阶码加 1。当尾数右移时，最高位 1 被移到小数点前一位作为隐藏位；当最后一位移出时，要考虑舍入。\n\n​\t\t左规一次相当于乘以2，右规一次相当于除以2；需要右规时，只需进行一次。\n​\t（4）舍入\n​\t\t在对阶和尾数右规时，尾数右移可能会将低位丢失，影响精度，IEEE 754有以下4种舍入方式：\n\n就近舍入：舍入为最近的那个数，类似于 “四舍五入”，一般被叫做 “ 0 舍 1 入” 法；如果被舍入的值恰好是 100…0 形式，选择舍入为最近的偶数；\n正向舍入：向 +∞ 方向舍入，即取右边那个数，也叫 “向上舍入”；\n负向舍入：向 -∞ 方向舍入，即取左边那个数，也叫 “向下舍入”；\n截断：朝 0 方向舍入，即取绝对值较小的那个数。\n\n​\t（5）溢出判断\n​\t\t浮点数的溢出，并不是以尾数溢岀来判断的；尾数溢出可以通过右规操作得到纠正。运算结果是否溢出，主要看结果的指数是否发生了溢出，因此是由阶码来判断的。\n\n若一个正阶码超出了最大允许值（127 或 1023），则发生上溢，产生异常；\n若一个负阶码超出了最小允许值（-149 或 -1074），则发生下溢，通常把结果按机器零处理。\n\n\n​\t\t例如，两个数 x &#x3D; 29&#x2F;32 × 2^7^，y &#x3D; 5&#x2F;8 × 2^5^，用浮点加法计算 x + y。假设浮点数的阶码和尾数均用补码表示，且阶码为 5 位（含 2 位阶符），尾数为 7 位（含 2 位数符）。\n​\t\t首先，将浮点数写成下面的规格化二进制形式：\n​\t\tx &#x3D; 0.11101 × 2^111^，y &#x3D; 0.101 × 2^101^\n​\t\t具体计算过程如下：\n​\t\t（1）对阶\n​\t\t阶码相减 00, 111 - 00, 101 &#x3D; 00, 010，说明 x 的阶码比 y 的大 2，需要将 y 的尾数右移两位，阶码加 2：\n​\t\ty &#x3D; 0.00101 × 2^111^\n​\t\t（2）尾数求和\n​\t\t尾数相加 00.11101 + 00.00101 &#x3D; 01.00010\n​\t\t（3）规格化\n​\t\t运算结果的尾数出现溢出，需要进行右规：尾数右移一位，阶码加 1：\n​\t\t1.00010 × 2^111^ &#x3D; 0.100010 × 2^1000^，即计算结果为 01, 000; 00, 10001\n​\t\t（4）舍入\n​\t\t结果的尾数用补码表示为：00 10001，不需要舍入。\n​\t\t（5）溢出判断\n​\t\t结果的阶码用补码表示为：01 000，由于阶符为 01，说明结果溢出。\n\n2.5 数据的存储和排列2.5.1 数据按“边界对齐”方式存储​\t\t可以假设字长为 32 位，可按字节、半字、字寻址。在对准边界的 32 位计算机中，半字地址是 2 的整数 倍，字地址是 4 的整数倍，当所存数据不满足此要求时，可填充一个或多个空白字节。这种存储方式称为 “边界对齐” 。这样无论所存的数据是字节、半字还是字，均可一次访存取出。虽然浪费了一些存储空间，但可提高存取速度。\n​\t\t数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能取得所需数据，从而影响系统的效率。\n","slug":"计算机组成原理","date":"2024-05-29T09:41:59.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"}]