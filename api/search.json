[{"id":"aa511ac4879771de2733384acfc7e52f","title":"Linux操作系统（搬运）","content":"Linux操作系统一、简史UNIX1970年，美国贝尔实验室的 Ken Thompson，以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且他用B语言写了第一个UNIX操作系统。因为B语言的跨平台性较差，为了能够在其他的电脑上也能够运行这个非常棒的Unix操作系统，Dennis Ritchie和Ken Thompson 从B语言的基础上准备研究一个更好的语言1972年，美国贝尔实验室的 Dennis Ritchie在B语言的基础上最终设计出了一种新的语言，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言1973年初，C语言的主体完成。Thompson和Ritchie迫不及待地开始用它完全重写了Unix操作系统\nMINUX因为AT&amp;T(通用电气)的政策改变，在Version 7 Unix推出之后，发布新的使用条款，将UNIX源代码私有化，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(塔能鲍姆)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。\nLINUXLinus Torvalds利用GNU的bash当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件\n1991年的10月5日，林纳斯·托瓦兹在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核的诞生（Freeminix-likekernel sources for 386-AT）。\n1993年，大约有100余名程序员参与了Linux内核代码编写/修改工作，其中核心组由5人组成，此时Linux 0.99的代码大约有十万行，用户大约有10万左右。\n1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议。\n二、简介1.Linux内核版本内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。\nLinux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：\n稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。开发版：由于要试验各种解决方案，所以变化很快。\n内核源码网址：http://www.kernel.org \n2.Linux发行版本GNU/Linux 发行版 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。\n一类是商业公司维护的发行版本    如RedHat（RHEL）一类是社区组织维护的发行版本    如Debian\nRedHatRedhat（小红帽），应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多 的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非 常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管 理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用， 但是Fedora Core的稳定性较差，最好只用于桌面应用。\n红帽 | Red Hat 企业开源技术领导者\nCentOSCentOS是一款企业级Linux发行版,它使用红帽企业级Linux中的免费源代码重新构建而成。这款重构版完全去掉了注册商标以及Binary程序包方面一个非常细微的变化。有些人不想支付一大笔钱,又能领略红帽企业级Linux;对他们来说,CentOS值得一试。此外,CentOS的外观和行为似乎与母发行版红帽企业级Linux如出一辙。 CentOS使用YUM来管理软件包。\nThe CentOS Project\nFedora小巧的Fedora适合那些人:想尝试最先进的技术,等不及程序的稳定版出来。其实,Fedora就是红帽公司的一个测试平台;产品在成为企业级发行版之前,在该平台上进行开发和测试。Fedora是一款非常好的发行版,有庞大的用户论坛,软件库中还有为数不少的软件包。Fedora同样使用YUM来管理软件包。\nFedora Linux | The Fedora Project\nDebianDebian运行起来极其稳定,这使得它非常适合用于服务器。Debian平时维护三套正式的软件库和一套非免费软件库,这给另外几款发行版(比如Ubuntu和Kali等)带来了灵感。Debian这款操作系统派生出了多个Linux发行版。它有37500多个软件包,这方面唯一胜过Debian的其他发行版只有Gentoo。Debian使用apt或aptitude来安装和更新软件。\nDebian — 通用操作系统\nUbuntuUbuntu是Debian的一款衍生版,也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应用,在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。作为Debian Gnu Linux的一款衍生版,Ubuntu的进程、外观和感觉大多数仍然与Debian一样。它使用apt软件管理工具来安装和更新软件。它也是如今市面上用起来最容易的发行版之一。Ubuntu使用基于apt的程序包管理器。\nUbuntu系统下载 | Ubuntu\nGentoo与Debian一样,Gentoo这款操作系统也包含数量众多的软件包。Gentoo并非以预编译的形式出现,而是每次需要针对每个系统进行编译。连Gentoo社区都觉得Gentoo安装和使用起来很困难;不过它被认为是最佳学习对象,可以进而了解Linux操作系统的内部运作原理。提到Gentoo总有人这么说:”如果你要学用Linux发行版,那就学用该发行版吧;如果你学会了Gentoo,也就学会了Linux。”Gentoo使用portage来安装和更新软件。\nhttp://www.gentoo.org/main/en/where.xml\nOpenSuseOpenSuse这款Linux发行版是免费的,并不供商业用途使用,仍然供个人使用。OpenSuse的真正竞争对手是红帽企业级Linux。它使用Yast来管理软件包。有了Yast,使用和管理服务器应用程序就非常容易。此外,Yast安装向导程序可以配置电子邮件服务器、LDAP服务器、文件服务器或Web服务器,没有任何不必要的麻烦。它随带snapper快照管理工具,因而可以恢复或使用旧版的文件、更新和配置。由于让滚动发行版本成为可能的Tumbleweed,可将已安装的操作系统更新到最新版本,不需要任何的新发行版。\nopenSUSE - Linux OS. 桌面用户、开发者以及系统管理员的匠之所选。\nKali LinuxKali Linux是Debian的一款衍生版。Kali旨在用于渗透测试。它大概在三个月前才发行。Kali的前身是Backtrack。用于Debian的所有Binary软件包都可以安装到Kali Linux上,而Kali的魅力或威力就来自于此。此外,支持Debian的用户论坛为Kali加分不少。Kali随带许多的渗透测试工具,无论是Wifi、数据库还是其他任何工具,都设计成立马可以使用。Kali使用APT来管理软件包。\nKali Linux | Penetration Testing and Ethical Hacking Linux Distribution\nArch LinuxArch是一款采用滚动发行方式的操作系统:只要安装一次就够了;每当发行了某个新版本,就可以升级发行版,不需要重新安装。Pacman是Arch Linux的软件包管理器。Arch Linux既支持X86处理器架构,又支持X86_64架构,安装程序可以从光盘或U盘来运行。Arch旨在从开发者的角度而不是从用户的角度做到力求简单。Arch配置和安装起来超容易。\nArch Linux\n\n3.Linux系统目录\n/：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。\n/bin: Binary的缩写, 这个目录存放着可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。\n/boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。\n/dev：Device(设备)的缩写，存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。\n/dev/console: 系统控制台，也就是直接和系统连接的监视器。\n/dev/sda:硬盘驱动程序接口。如：/dev/sda指的是第一个硬盘，sda1则是指/dev/sda的第一个分区。如系统中有其他的硬盘，则依次为/dev/sdb /dev/sdc\n/dev/fd: 软驱设备驱动程序。如： /dev/fd0指系统的第一个软盘，也就是通常所说的a：盘，/dev/fd1指第二个软盘.\n/dev/stscsi:磁带驱动器驱动程序。\n/dev/tty: 提供虚拟控制台支持。如:/dev/tty1指的是系统的第一个虚拟控制台， /dev/tty2则是系统的第二个虚拟控制台。\n/dev/pty: 提供远程登陆伪终端支持。在进行telnet登录时就要用到/dev/pty设备。\n/dev/ttys: 计算机串行接口，对于windows来说就是com1口。 9. /dev/cua 计算机串行接口，与调制解调器一起使用的设备。\n/dev/null: “黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输出到/dev/null中即可。\n/etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。\n/etc/rc或/etc/rc.d：启动、或改变运行级时运行的脚本或脚本的目录。\n/etc/passwd:用户数据库，其中的域给出了用户名、用户描述、用户起始目录、加密口令和用户的其他信息。\n/etc/group: 类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。\n/etc/fdprm: 软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见setfdprm的帮助页。\n/etc/fstab:指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的swap区的信息。\n/etc/inittab: init 的配置文件。\n/etc/issue: 包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。\n/etc/magic: file的配置文件。包含不同文件格式的说明，file基于它猜测文件类型。\n/etc/motdmotd:是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。\n/etc/mtab: 当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。\n/etc/shadow: 在安装了影子( shadow)口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd文件中的加密口令移动到/etc/shadow中，而后者只对超级用户(root)可读。这使破译口令更困难，以此增加系统的安全性。\n/etc/login.defs: login命令的配置文件。\n/etc/printcap: 类似/etc/termcap ，但针对打印机。语法不同。\n/etc/profile 、/ etc/csh.login、/etc/csh.cshrc: 登录或启动时bourne或cshells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。\n/etc/securetty: 确认安全终端，即哪个终端允许超级用户(root)登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过调制解调器(modem )或网络闯入系统并得到超级用户特权。\n/etc/shells: 列出可以使用的shell。chsh 命令允许用户在本文件指定范围内改变登录的shell。提供一台机器f t p服务的服务进程ftpd 检查用户shell是否列在/etc/shells 文件中，如果不是，将不允许该用户登录。\n/etc/termcap: 终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。\n/home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，表示当前用户的家目录，edu 表示用户 edu 的家目录。\n/lib: Library的缩写，系统使用的函数库（动态连接共享库）的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。\n/lost+found：系统异常产生错误时，会将一些遗失的片段放置于此目录下。\n/media：linux系统自动识别设备，例如U盘、光驱并挂载到这个目录下。\n/mnt:光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。\n/opt：给主机额外安装软件所摆放的目录。\n/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。\n/root：系统管理员root的家目录。\n/sbin: 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。\n/tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。\n/srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。\n/usr：可记为Unix Software Resource。应用程序存放目录，类似于windows下的program files目录。\n/usr/bin :存放应用程序。\n/usr/share: 存放共享数据。\n/usr/lib: 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。\n/usr/src：内核源代码默认的放置目录。\n/usr/local: 存放软件升级包。\n/usr/share/doc: 系统说明文件存放目录。\n/usr/share/man: 程序说明文件存放目录。\n/var：放置系统执行过程中经常变化的文件\n/var/log/message：所有的登录文件存放目录。\n/var/spool/mail：邮件存放的目录。\n/var/run:程序或服务启动后，其PID存放在该目录下。\n/var 包括系统一般运行时要改变的数据.每个系统是特定的，即不通过网络与其他计算机共享。\n/var/catman: 当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man 中；有些man页可能有预格式化的版本，存在/usr/man/cat 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.)\n/var/lib: 系统正常运行时要改变的文件。\n/var/local:/usr/local 中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。\n/var/lock: 锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件。\n/var/log: 各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除。\n/var/run: 保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息。\n/var/spool，/var/mail, /var/news 打印队列和其他队列工作的目录.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中。\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n三、Gnome下的快捷键Alt + F1：类似Windows下的Win键，在GNOME中打开”应用程序”菜单(Applications) （在KDE下同样适用。）\nAlt + F9：最小化窗口 Alt + F10：最大化窗口Alt + space：打开窗口的控制菜单 (点击窗口左上角图标出现的菜单)单击鼠标滚轮：当您选中一段文字后，按下鼠标滚轮键，可以将选中的文字复制到鼠标所指的位置，在中端中也有效。 （KDE中未测试。）Atl+单击鼠标拖动：移动窗口的位置。 （在KDE和Compiz中同样有效。）\nShift+Ctrl+N - 新建文件夹, 很有用\nAlt + Enter - 查看选择文件/文件夹的属性，代替单击右键选择属性\nCtrl + 1/2 - 改变文件夹视图查看方式，图标视图/列表视图\nCtrl + W - 关闭当前Nautilus窗口\nCtrl + Shift + W - 关闭所有Nautilus窗口\nCtrl+T - 在Nautilus中新建一个标签\nAlt + Up/Down Arrow - 移动到父文件夹/选择的文件夹\nAlt + Left/Right Arrow - 后退/前进\nAlt + Home -直接移动到主文件夹\nF9 - 开关显示Nautilus侧边栏\nCtrl + H -开关显示隐藏文件夹\n\n四、VIM编辑器vi概述vi（visual editor）编辑器通常被简称为vi，它是Linux和Unix系统上最基本的文本编辑器，类似于Windows 系统下的notepad（记事本）编辑器。\nvim编辑器Vim(Vi improved)是vi编辑器的加强版，比vi更容易使用。vi的命令几乎全部都可以在vim上使用。\nvim编辑器的四种模式命令模式使用VIM编辑器时，默认处于命令模式。在该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作。\n编辑模式或输入模式在命令模式下输入小写字母a或小写字母i即可进入编辑模式，在该模式下可以对文件的内容进行编辑\n末行模式在命令模式下输入冒号:即可进入末行模式，可以在末行输入命令来对文件进行查找、替换、保存、退出等操作\n可视化模式可以做一些列选操作（通过方向键选择某些列的内容,类似于Windows鼠标刷黑）\n\n模式间切换方法：（1）命令模式下，输入:后，进入末行模式（2）末行模式下，按esc慢退、按两次esc快退、或者删除所有命令，可以回到命令模式（3）命令模式下，按下i、a等键，可以计入编辑模式（4）编辑模式下，按下esc，可以回到命令模式\nVIM编辑器的使用1.使用vim打开文件基本语法：\n1vim  文件名称\n① 如果文件已存在，则直接打开\n② 如果文件不存在，则vim编辑器会自动在内存中创建一个新文件\n案例：使用vim命令打开readme.txt文件\n1vim readme.txt\n\n\n\n\nVi 使用的选项\n说 明\n\n\n\n\nvim filename\n打开或新建一个文件，并将光标置于第一行的首部\n\n\nvim -r filename\n恢复上次 vim 打开时崩溃的文件\n\n\nvim -R filename\n把指定的文件以只读方式放入 Vim 编辑器中\n\n\nvim + filename\n打开文件，并将光标置于最后一行的首部\n\n\nvi +n filename\n打开文件，并将光标置于第 n 行的首部\n\n\nvi +/pattern filename\n打幵文件，并将光标置于第一个与 pattern 匹配的位置\n\n\nvi -c command filename\n在对文件进行编辑前，先执行指定的命令\n\n\n\n\n2.vim编辑器保存文件在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号:，进入到末行模式，输入wq，代表保存并退出。\n\n建议使用:x：使用效果等同于wq，如果文件有改动则先保存后退出；但是如果文件没有做修改，会直接退出，不会修改文件更新时间，避免用户混淆文件的修改时间\n\n3.vim编辑器强制退出（不保存）在任何模式下，连续按两次Esc键，即可返回到命令模式。然后按冒号：，进入到末行模式，输入q!，代表强制退出但是不保存文件。\n\n4.命令模式下的相关操作如何进入命令模式\n在Linux操作系统中，当我们使用vim命令直接打开某个文件时，默认进入的就是命令模式。如果我们处于其他模式（编辑模式、可视化模式以及末行模式）可以连续按两次Esc键也可以返回命令模式\n1.光标移动\n\n\n\n快捷键\n功能描述\n\n\n\n\njkhl\n基本上下左右\n\n\ngg\n光标移动到文档首行\n\n\nG\n光标移动到文档尾行\n\n\n^或_\n光标移动到行首第一个非空字符\n\n\nhome键或0或者g0\n光标移动到行首第一个字符\n\n\ng_\n光标移动到行尾最后一个非空字符\n\n\nend或者 g\n光标移动到行尾最后一个字符\n\n\ngm\n光标移动到当前行中间处\n\n\nb/B\n光标向前移动一个单词（大写忽略/-等等特殊字符）\n\n\nw/W\n光标向后移动一个单词（大写忽略/-等等特殊字符）\n\n\ne/E\n移到单词结尾（大写忽略/-等等特殊字符）\n\n\nctrl+b或pageUp键\n翻屏操作，向上翻\n\n\nctrl+f或pageDn键\n翻屏操作，向下翻\n\n\n行号+G\n快速将光标移动到指定行\n\n\n`.\n移动到上次编辑处\n\n\n数字+上下方向键\n以当前光标为准，向上/下移动n行\n\n\n数字+左右方向键\n以当前光标为准，向左/右移动n个字符\n\n\nH\n移动到屏幕顶部\n\n\nM\n移动到屏幕中间\n\n\nL\n移动到屏幕尾部\n\n\nz+Enter键\n当前行在屏幕顶部\n\n\nz+ .\n当前行在屏幕中间\n\n\nz+ -\n当前行在屏幕底部\n\n\nshift+6\n光标移动到行首\n\n\nshift+4\n光标移动到行尾\n\n\n-\n移动到上一行第一个非空字符\n\n\n+\n移动到下一行第一个非空字符\n\n\n)\n向前移动一个句子\n\n\n(\n向后移动一个句子\n\n\n}\n向前移动一个段落\n\n\n{\n向前移动一个段落\n\n\ncount l\n移动到count 列\n\n\ncounth\n向左移动count 字符\n\n\ncountl\n向右移动count字符\n\n\ncountgo\n移动到count字符\n\n\n\n\n2.选中内容\n\n\n\n快捷键\n功能描述\n\n\n\n\nv\n进行字符选中\n\n\nV 或shift+v\n进行行选中\n\n\ngv\n选中上一次选择的内容\n\n\no\n光标移动到选中内容另一处结尾\n\n\nO\n光标移动到选中内容另一处角落\n\n\nctr + V\n进行块选中\n\n\n\n\n3.复制（配合粘贴命令p使用）\n\n\n\n快捷键\n功能描述\n\n\n\n\ny\n复制已选中的文本到剪贴板\n\n\nn+yy\n复制光标所在行，此命令前可以加数字 n，可复制多行\n\n\nyw\n复制光标位置的单词\n\n\nctrl+v + 方向键+yy\nctrl+v，并按方向键选中区块，按下yy复制\n\n\n\n\n4.剪切\n\n\n\n快捷键\n功能描述\n\n\n\n\ndd\n剪切光标所在行\n\n\n数字+dd\n以光标所在行为准（包含当前行），向下剪切指定行数\n\n\nD\n剪切光标所在行\n\n\n\n\n5.粘贴\n\n\n\n快捷键\n功能描述\n\n\n\n\np\n将剪贴板中的内容粘贴到光标后\n\n\nP（大写）\n将剪贴板中的内容粘贴到光标前\n\n\n\n\n6.删除\n\n\n\n快捷键\n功能描述\n\n\n\n\nx\n删除光标所在位置的字符\n\n\nX(大写)\n删除光标前一个字符\n\n\ndd\n删除光标所在行，删除之后，下一行上移\n\n\nD\n删除光标位置到行尾的内容，删除之后，下一行不上移\n\n\nndd\n删除当前行（包括此行）后 n 行文本\n\n\ndw\n移动光标到单词的开头以删除该单词\n\n\ndG\n删除光标所在行一直到文件末尾的所有内容\n\n\n:a1,a2d\n删除从 a1 行到 a2 行的文本内容\n\n\n\n\n7.撤销/恢复\n\n\n\n快捷键\n功能描述\n\n\n\n\nu\n撤销最近修改\n\n\nctrl+r\n恢复\n\n\nU(大写)\n撤销当前行所有编辑\n\n\n\n\n8.字符转换\n\n\n\n快捷键\n功能描述\n\n\n\n\n~\n转换大小写\n\n\nu\n变成小写\n\n\nU\n变成大写\n\n\n\n\n9.编辑命令的快捷键\n\n\n\n快捷键\n功能描述\n\n\n\n\n↑或ctr + p\n上一条命令\n\n\n↓或ctr + n\n下一条命令\n\n\nctr + b\n移动到命令行开头\n\n\nctr + e\n移动到命令行结尾\n\n\nctr + ←\n向左一个单词\n\n\nctr + →\n向右一个单词\n\n\n\n\n5.末行模式下的相关操作在命令模式下使用冒号：的方式进入\n1.保存/退出文件操作\n\n\n\n命令\n功能描述\n\n\n\n\n:wq\n保存并退出 Vim 编辑器\n\n\n:wq!\n保存并强制退出 Vim 编辑器\n\n\n:q\n不保存就退出 Vim 编辑器\n\n\n:q!\n不保存，且强制退出 Vim 编辑器\n\n\n:w\n保存但是不退出 Vim 编辑器\n\n\n:w!\n强制保存文本\n\n\n:w filename\n另存到 filename 文件\n\n\nx！\n保存文本，并退出 Vim 编辑器\n\n\nZZ\n直接退出 Vim 编辑器\n\n\n\n\n2.查找：“/关键词”在查找结果中，用N、n可以切换上下结果；输入nohl，可以取消高亮\n\n\n\n\n快捷键\n功能描述\n\n\n\n\n/abc\n从光标所在位置向前查找字符串 abc\n\n\n/^abc\n查找以 abc 为行首的行\n\n\n/abc$\n查找以 abc 为行尾的行\n\n\n?abc\n从光标所在位置向后查找字符串 abc\n\n\nn或；\n向同一方向重复上次的查找指令\n\n\nN或,\n向相反方向重复上次的查找指定\n\n\n\n\n3.替换\n\n\n\n快捷键\n功能描述\n\n\n\n\nr\n替换光标所在位置的字符\n\n\nR\n从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束\n\n\n:s/a1/a2\n替换当前光标所在行第一处符合条件的内容\n\n\n:s/a1/a2/g\n替换当前光标所在行所有的 a1 都用 a2 替换\n\n\n:%s/a1/a2\n替换所有行中，第一处符合条件的内容\n\n\n:%s/a1/a2/g\n替换所有行中，所有符合条件的内容\n\n\n:n1,n2 s/a1/a2\n将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换\n\n\n:n1,n2 s/a1/a2/g\n将文件中 n1 到 n2 行中所有 a1 都用 a2 替换\n\n\n\n\n4.行号显示：“: set nu”;\n行号显示:set nu\n取消行号显示：:set nonu\n\n5.文件切换使用vim打开多个文件后，在末行模式下可以进行切换。\n查看当前已经打开的所有文件：:files(%a表示激活状态，#表示上一个打开的文件)切换到指定文件：:open 文件名切换到上一个文(back previous)：:bp切换到下一个文件(back next)：:bn\n6.编辑模式下的相关操作\n\n\n\n快捷键\n功能描述\n\n\n\n\ni\n在当前光标所在位置插入，光标后的文本相应向右移动\n\n\nI\n在光标所在行的行首插入，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令\n\n\no\n在光标所在行的下插入新的一行。光标停在空行首，等待输入文本\n\n\nO（大写）\n在光标所在行的上插入新的一行。光标停在空行的行首，等待输入文本\n\n\na\n在当前光标所在位置之后插入\n\n\nA\n在光标所在行的行尾插入，相当于光标移动到行尾再执行 a 命令\n\n\nesc键\n退出编辑模式\n\n\n\n\n7.扩展1.代码颜色显示：“：syntax on/off”2.vim内置计算器：a.进入编辑模式b.按“ctrl+r，光标变成引号，，输入=，光标转到最后一行c.输入需要计算的内容，按下enter后，计算结果回替代上一步中的引号，光标恢复\n3.vim的配置a.文件打开时，末行模式下输入的配置为临时配置，关闭文件后配置无效b.修改个人配置文件，可以永久保存个人配置（~/.vimrc，如果没有可以自行创建）c.修改全局配置文件，对每个用户生效（vim自带，/etc/vimrc）\n注：个人配置文件优先级更高，当个人配置和全局配置发生冲突时，系统以当前用户的个人配置文件为准\n4.异常退出在编辑文件后，未正常保存退出时，会产生异常退出交换文件（.原文件名.swp）将交换文件删除后，再次打开文件时，无提示：“#rm -f .原文件名.swp”\n5.别名机制：自定义指令Linux中，存在一个别名映射文件： ~/.bashrc修改文件内容，可以自定义指令，重新登录账号后生效\n6.文件快捷方式对于深层文件，可以创建文件快捷方式，便于后续操作：#ln -s 源路径 新路径\n\n五、Shell命令解释器快捷键编辑命令Ctrl + a ：移到命令行首Ctrl + e ：移到命令行尾Ctrl + f ：按字符前移（右向）Ctrl + b ：按字符后移（左向）Alt + f ：按单词前移（右向）Alt + b ：按单词后移（左向）Ctrl + xx：在命令行首和光标之间移动Ctrl + u ：从光标处删除至命令行首Ctrl + k ：从光标处删除至命令行尾Ctrl + w ：从光标处删除至字首Alt + d ：从光标处删除至字尾Ctrl + d ：删除光标处的字符Ctrl + h ：删除光标前的字符Ctrl + y ：粘贴至光标后（主要针对CTRL+U或CTRL+W）Alt + c ：从光标处更改为首字母大写的单词Alt + u ：从光标处更改为全部大写的单词Alt + l ：从光标处更改为全部小写的单词Ctrl + t ：交换光标处和之前的字符Alt + t ：交换光标处和之前的单词Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别\n搜索命令Ctrl + r：逆向搜索命令历史Ctrl + g：从历史搜索模式退出Ctrl + p：历史中的上一条命令Ctrl + n：历史中的下一条命令Alt + .：打印之前执行过的命令的最后一部分 以空格为分隔符\n控制命令Ctrl + l：清屏Ctrl + o：执行当前命令，并选择上一条命令Ctrl + s：阻止屏幕输出Ctrl + q：允许屏幕输出Ctrl + c：终止命令Ctrl + z：挂起命令ESC + .：自动补全最近的命令TAB：自动补全Ctrl + m：换行Ctrl + L：撤销操作\n其它!!                      – 执行上一条命令\n**!ifconfig     – 执行最近运行过的以ifconfig开头的命令\n!ifconfig:p      – 打印!ifconfig要执行的命令（并将其作为最后一条命令加入到命令历史中）\n!$                    – 上一条命令的最后一个单词 (等同于Alt + .)\n!:p                  – 打印!指代的单词\n!*                    – 上一条命令除最后一个词的部分\n\n六、命令行基本操作1.Linux终端命令格式命令提示符命令提示符解析：\n1[deng@localhost ~]$ \n[]：这是提示符的分隔符号，没有特殊含义。\ndeng：显示的是当前的登录用户\n@：分隔符号，没有特殊含义。\nlocalhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。\n~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。\n：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是$。用户家目录Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家：主目录超级用户的家目录：/root。普通用户的家目录：/home/用户名。\n用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。\n123[deng@localhost ~]$ cd /usr/local/src[deng@localhost src]$ \n如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 /usr/ local/src，只显示最后一个目录 src)。\n命令的基本格式格式：\n12命令 [选项] [参数]command [-options] [parameter]\n命令： 可执行文件\n选项：用于调整命令的功能。命令不同，选项的个数和内容会有所不同；要实现的命令功能不同，选项的个数和内容也会有所不同。\n参数：是命令处理的对象，通常情况可以是文件名、目录、或用户名。\n温馨提示：命令格式中的 [] 代表可选项，也就是有些命令可以不写选项或参数，也能执行。\n选项的作用选项的作用就是调整命令的功能。\nls 命令之后不加选项和参数也能执行，不过只能执行最基本的功能，即显示当前目录下的文件名。\n123[deng@localhost local]$ lsbin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n如果加一个”-l”选项，则可以看到显示的内容明显增多了。”-l”是长格式（long list）的意思，也就是显示文件的详细信息。至于 “-l” 选项的具体含义，我们稍后再详细讲解。可以看到选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。\n1234567891011121314[deng@localhost local]$ ls -l总用量 0drwxr-xr-x. 2 root root  92 7月   4 16:19 bindrwxr-xr-x. 2 root root   6 4月  11 2018 etcdrwxr-xr-x. 2 root root   6 4月  11 2018 gamesdrwxr-xr-x. 3 root root  33 2月  21 11:36 includedrwxr-xr-x. 2 root root   6 4月  11 2018 libdrwxr-xr-x. 4 root root 159 7月   4 16:19 lib64drwxr-xr-x. 2 root root   6 4月  11 2018 libexecdrwxr-xr-x. 2 root root   6 4月  11 2018 sbindrwxr-xr-x. 6 root root  60 11月 14 2018 sharedrwxr-xr-x. 2 root root   6 4月  11 2018 srcdrwxr-xr-x  5 root root 140 7月   4 16:19 ssl[deng@localhost local]$ \nLinux 的选项又分为短格式选项（-l）和长格式选项（–all）。\n短格式选项是英文的简写，前面有一个-号。\n123[deng@localhost local]$ ls -a.  ..  bin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n而长格式选项是英文完整单词，前面用两个-号\n123[deng@localhost local]$ ls --all.  ..  bin  etc  games  include  lib  lib64  libexec  sbin  share  src  ssl[deng@localhost local]$ \n一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。\n参数的作用参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。\n123456789101112[itcast@localhost ~]$ ls -l /home/itcast/总用量 0drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 公共drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 模板drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 视频drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 图片drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 文档drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 下载drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 音乐drwxr-xr-x 2 itcast itcast 6 7月  12 17:34 桌面[itcast@localhost ~]$ \n命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。\n123[itcast@localhost ~]$ ls公共  模板  视频  图片  文档  下载  音乐  桌面[itcast@localhost ~]$ \n这个 ls 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。\n\n注意事项命令、命令选项、命令参数之间用空格隔开。\n\n123456[itcast@localhost ~]$ ls -a .              .bash_profile  .dbus          .local    视频  音乐..             .bashrc        .esd_auth      .mozilla  图片  桌面.bash_history  .cache         .ICEauthority  公共      文档.bash_logout   .config        .kshrc         模板      下载[itcast@localhost ~]$ \n当有多个命令选项时，可以进行合并。例如，可以将 ls -a / 和 ls -l / 合并为\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[itcast@localhost ~]$ ls -l -a总用量 28drwx------  15 itcast itcast 319 7月  12 17:34 .drwxr-xr-x.  5 root   root    46 7月  12 17:32 ..-rw-------   1 itcast itcast  36 7月  12 17:36 .bash_history-rw-r--r--   1 itcast itcast  18 4月  11 2018 .bash_logout-rw-r--r--   1 itcast itcast 193 4月  11 2018 .bash_profile-rw-r--r--   1 itcast itcast 231 4月  11 2018 .bashrcdrwxrwxr-x  13 itcast itcast 275 7月  12 17:36 .cachedrwxrwxr-x  14 itcast itcast 261 7月  12 17:36 .configdrwx------   3 itcast itcast  25 7月  12 17:34 .dbus-rw-------   1 itcast itcast  16 7月  12 17:34 .esd_auth-rw-------   1 itcast itcast 314 7月  12 17:34 .ICEauthority-rw-r--r--   1 itcast itcast 172 4月  11 2018 .kshrcdrwx------   3 itcast itcast  19 7月  12 17:34 .localdrwxr-xr-x   4 itcast itcast  39 11月  8 2018 .mozilladrwxr-xr-x   2 itcast itcast   6 7月  12 17:34 公共drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 模板drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 视频drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 图片drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 文档drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 下载drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 音乐drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 桌面[itcast@localhost ~]$ ls -al总用量 28drwx------  15 itcast itcast 319 7月  12 17:34 .drwxr-xr-x.  5 root   root    46 7月  12 17:32 ..-rw-------   1 itcast itcast  36 7月  12 17:36 .bash_history-rw-r--r--   1 itcast itcast  18 4月  11 2018 .bash_logout-rw-r--r--   1 itcast itcast 193 4月  11 2018 .bash_profile-rw-r--r--   1 itcast itcast 231 4月  11 2018 .bashrcdrwxrwxr-x  13 itcast itcast 275 7月  12 17:36 .cachedrwxrwxr-x  14 itcast itcast 261 7月  12 17:36 .configdrwx------   3 itcast itcast  25 7月  12 17:34 .dbus-rw-------   1 itcast itcast  16 7月  12 17:34 .esd_auth-rw-------   1 itcast itcast 314 7月  12 17:34 .ICEauthority-rw-r--r--   1 itcast itcast 172 4月  11 2018 .kshrcdrwx------   3 itcast itcast  19 7月  12 17:34 .localdrwxr-xr-x   4 itcast itcast  39 11月  8 2018 .mozilladrwxr-xr-x   2 itcast itcast   6 7月  12 17:34 公共drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 模板drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 视频drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 图片drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 文档drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 下载drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 音乐drwxr-xr-x   2 itcast itcast   6 7月  12 17:34 桌面[itcast@localhost ~]$ \n2.Linux文件类型\n\n\n\n前缀\n描述\n\n\n\n\n-\n普通文件。如文本文件、二进制可执行文件、源代码等。\n\n\nb\n块设备文件。硬盘可以使用块设备文件。\n\n\nc\n字符设备文件。硬盘也可以使用字符设备文件。\n\n\nd\n目录文件。目录可以包含文件和其他目录。\n\n\nl\n符号链接（软链接）。可以链接任何普通文件，类似于 Windows 中的快捷方式。\n\n\np\n具名管道。管道是进程间的一种通信机制。\n\n\ns\n用于进程间通信的套接字。\n\n\n\n\n普通文件\n我们用 ls -l 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具… … 或 cp工具等。这类文件的删除方式是用rm 命令。\n依照文件的内容，又大略可以分为：\n纯文本档(ASCII)\nLinux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的文件都属于这一种文件类型。 举例来说，你可以用命令： cat ~/.bashrc 来看到该文件的内容。\n 二进制文件(binary)\nLinux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。常用的一些命令几乎都是二进制文件。\n数据格式文件(data)\n有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个数据文件，他能够通过last这个指令读出来。 但是使用cat时，会读出乱码，因为该文件是一种特殊格式的文件。\n1234[deng@localhost ~]$ ls -l /etc/bashrc -rw-r--r--. 1 root root 2853 4月  11 2018 /etc/bashrc[deng@localhost ~]$ \n目录文件\n当我们查看文件的详细信息的时候，看到有类似 drwxr-xr-x ，这样的文件就是目录。目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。\n123[deng@localhost ~]$ ls -ld /homedrwxr-xr-x. 5 root root 46 7月  12 17:32 /home[deng@localhost ~]$ \n字符设备\n字符设备是指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等。在UNIX系统中，字符设备以特别文件方式在文件目录树中占据位置并拥有相应的结点。\n字符设备可以使用与普通文件相同的文件操作命令对字符设备文件进行操作，例如打开、关闭、读、写等。\n123[deng@localhost ~]$ ls -l /dev/input/mouse1crw-rw---- 1 root input 13, 33 7月  12 09:45 /dev/input/mouse1[deng@localhost ~]$\n我们看到/dev/input/mouse1的属性是crw-rw—— ，注意前面第一个字符是 c ，这表示字符设备文件。\n字符设备文件可以使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。\n块设备\n块设备将信息存储在固定大小的块中，每个块都有自己的地址。数据块的大小通常在512字节到32768字节之间。块设备的基本特征是每个块都能独立于其它块而读写。磁盘是最常见的块设备。\n123[deng@localhost ~]$ ls -l /dev/sda1brw-rw---- 1 root disk 8, 1 7月  12 09:45 /dev/sda1[deng@localhost ~]$\n/dev/sda1 的属性是 brw-rw—— ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。\n套接字\n套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。\n1[root@localhost ~]*# ls -l /var/lib/mysql/mysql.sock* srwxrwxrwx 1 mysql mysql 0 7月  12 09:45 /var/lib/mysql/mysql.sock [root@localhost ~]*#* \n注意这个文件的属性的第一个字符是 s。\n符号链接\n符号链接（软链接）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。今天POSIX操作系统标准、大多数类Unix系统、Windows Vista、Windows 7都支持符号链接。Windows 2000与Windows XP在某种程度上也支持符号链接。\n符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。某些需要特别处理符号链接的程序（如备份程序）可能会识别并直接对其进行操作。\n一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。\n123[root@localhost ~]# ls -l /bin/cclrwxrwxrwx. 1 root root 3 11月  8 2018 /bin/cc -&gt; gcc[root@localhost ~]# \n当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。Windows操作系统中的快捷方式有点相似。\n管道文件\n它是一种文件类型，在文件系统中可以看到。程序中可以查看文件stat结构中st_mode成员的值来判断文件是否是FIFO文件。创建一个FIFO文件类似于创建文件，FIFO文件就像普通文件一样。\nFIFO中可以很好地解决在无关进程间数据交换的要求，并且由于它们是存在于文件系统中的，这也提供了一种比匿名管道更持久稳定的通信办法。\nFIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据。在shell中mkfifo命令可以建立有名管道，下面通过一个实例来帮助读者理解FIFO。\n123[root@localhost ~]# ls -l fifo prw-r--r-- 1 root root 0 7月  12 19:30 fifo[root@localhost ~]# \n查看文件属性时，第一个字符是p，就表示是管道文件。\n文件扩展名和文件名\n实际上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关， 与扩展名根本一点关系也没有。这个观念跟Windows的情况不相同喔！在Windows底下， 能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。\n不过，可以被执行跟可以执行成功是不一样的～举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行～因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容.\n不过我们仍然希望可以使用扩展名来了解该文件是什么东西，所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。Linux平台有以下常用的扩展名：\n*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh\nZ, .tar, .tar.gz, .zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！\n.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。\n基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。\n3.Linux帮助命令-man查阅 command 命令的使用手册man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明\n使用 man 时的操作键\n\n常用选项12345678910111213141516171819202122232425262728293031323334353637383940Usage: man [OPTION...] [章节] 手册页...  -a, --all                  寻找所有匹配的手册页  -d, --debug                输出调试信息   -D, --default              将所有选项都重置为默认值      --warnings[=警告]    开启 groff 的警告   -f, --whatis               等同于 whatis  -h     显示man的语法和参数说明，执行完成后退出程序。  -k, --apropos              等同于 apropos将搜索whatis数据库，模糊查找关键字    -S, -s, --sections=列表  使用以半角冒号分隔的章节列表  -t, --troff                使用 groff 对手册页排版  -w, --where, --path, --location                             输出手册页的物理位置  -W, --where-cat, --location-cat                             输出 cat 文件的物理位置    -c, --catman               由 catman 使用，用来对过时的 cat                             页重新排版     -C, --config-file=文件   使用该用户设置文件  -K, --global-apropos       search for text in all pages  -M, --manpath=路径       设置搜索手册页的路径为“路径”  -?, --help                 give this help list      --usage                give a short usage message  -V, --version              print program version  -R, --recode=编码        output source page encoded in ENCODING 寻找手册页：  -L, --locale=区域                             定义本次手册页搜索所采用的区域设置  -m, --systems=系统       use manual pages from other systems  -e, --extension=扩展                             将搜索限制在扩展类型为“扩展”的手册页之内  -i, --ignore-case          查找手册页时不区分大小写字母                             (默认)  -I, --match-case           查找手册页时区分大小写字母。      --regex                show all pages matching regex      --wildcard             show all pages matching wildcard      --names-only           make --regex and --wildcard match page names only,                             not descriptions\n\n相关描述man命令帮助信息的结构以及意义\n\n man对应的章节概述\n123456789101112131415-S 区段清单    该清单是一组用冒号分隔的欲查找的手册清单。此选项将覆盖      MANSECT     环境变量。    有些指令或程序可能有一个以上的主题，它们位于不同的区段中。因此，要查看较后的区    段，你可以在此指定 man 查找区段的顺序。具体区段划分如下所示：    区段1：用户指令    区段2：系统调用    区段3：程序库调用    区段4：设备    区段5：文件格式    区段6：游戏    区段7：杂项    区段8：系统指令    区段9：内核内部指令    区段n：Tcl或Tk指令\n-help说明：\n显示 command 命令的帮助信息\n命令格式：help [参数] 内部命令\n查看外部命令的用法\n命令格式：命令 —help\n\n4.tab键自动补全在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键\n如果输入的没有歧义，系统会自动补全如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令小技巧按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c\n5.find查找文件\n\n1.搜索桌面目录下，文件名包含 1 的文件\n\n1find -name &quot;*1*&quot;\n\n2.搜索桌面目录下，所有以 .txt 为扩展名的文件\n\n1find -name &quot;*.txt&quot;\n\n3.搜索桌面目录下，以数字 1 开头的文件\n\n1find -name &quot;1*&quot;\n12345678910111213141516171819202122232425262728293031323334353637命令参数：    pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。     -print： find命令将匹配的文件输出到标准输出。     -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;command&#x27; &#123;  &#125; \\;，注意&#123;   &#125;和\\；之间的空格。     -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。命令选项：    -name   按照文件名查找文件。    -perm   按照文件权限来查找文件。    -prune  使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。    -user   按照文件属主来查找文件。    -group  按照文件所属的组来查找文件。    -mtime -n +n  按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。    -nogroup  查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。    -nouser   查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。    -newer file1 ! file2  查找更改时间比文件file1新但比文件file2旧的文件。    -type  查找某一类型的文件，诸如：        b - 块设备文件。        d - 目录。        c - 字符设备文件。        p - 管道文件。        l - 符号链接文件。        f - 普通文件。    -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。    -fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。    -mount：在查找文件时不跨越文件系统mount点。    -follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。    -cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。    另外,下面三个的区别:    -amin n   查找系统中最后N分钟访问的文件    -atime n  查找系统中最后n*24小时访问的文件    -cmin n   查找系统中最后N分钟被改变文件状态的文件    -ctime n  查找系统中最后n*24小时被改变文件状态的文件    -mmin n   查找系统中最后N分钟被改变文件数据的文件    -mtime n  查找系统中最后n*24小时被改变文件数据的文件\n6.history游览历史123history N\t\t显示最近N条命令history -c\t\t清除所有的历史记录history -w  xxx.txt\t保存历史记录到文本xxx.txt\n\n七、Linux文件管理和磁盘管理相关命令1.pwdpwd命令是print working directory中每个单词的首字母缩写，其功能正如所示单词一样，为打印工作目录，即显示当前工作目录的绝对路径。\n1pwd [选项]\n1234567891011显示出 完整的 当前 活动目录 名称.   -L              \t打印 $PWD 变量的值，如果它命名了当前的工作目录   -P           \t\t打印当前的物理路径，不带有任何的符号链接    \t默认情况下，pwd 的行为和带 -L 选项一致\t--help \t\t显示 帮助 信息, 然后 退出\t--version \t\t显示 版本 信息, 然后 退出\n2.cdcd命令是”change directory”中单词的首字母缩写，其英文释义是改变目录，所以该命令的功能是从当前目录切换到指定目录。\n其中目录的路径可分为绝对路径和相对路径。若目录名称省略，则切换至使用者的用户目录(也就是刚登录时所在的目录)。\n另外，“~”也表示为用户目录的意思，“.”则是表示目前所在的目录，“…”则表示当前目录位置的上一级目录。\ncd 为最常用的命令，与 DOS 下的 cd 命令类似。\n1cd [选项] [目录名]\n1234567-p \t如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录-L \t如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。-  \t当仅实用&quot;-&quot;一个选项时，当前工作目录将被切换到环境变量&quot;OLDPWD&quot;所表示的目录。\n3.lsls 命令是Linux下最常用的指令之一。ls命令为英文单词 list 的缩写，正如英文单词 list 的意思，其功能是列出指定目录下的内容及其相关属性信息。通过 ls 命令，不仅可以查看 Linux 文件夹包含的文件，而且可以查看文件的权限（包括：目录、文件权限）、查看目录信息等。\n1ls [选项]… [文件]…\n12345678910111213141516171819202122232425262728293031323334选项\t说明-a\t列出目录下所有文件，包括以 . 开头的隐藏文件-b\t把文件名中不可输出的字符用反斜杠加字符编号（就像 C 语言一样）的形式列出-c\t输出文件的 i 节点的修改时间，并以此排序-d\t将目录像文件一样显示，而不是显示其下的文件-e\t输出时间的全部信息，而不是输出简略信息-f -U\t对输出的文件不排序-i\t输出文件的 i 节点的索引信息-k\t以 k 字节的形式表示文件的大小-l\t列出文件的详细信息-m\t横向输出文件名，并以 , 作为分隔符-n\t用数字 UID、GID 代替名称-o\t显示文件除组信息外的详细信息-r\t对目录反向排序-s\t对每个文件名后输出该文件的大小-t\t以时间排序-u\t以文件上次被访问的时间排序-v\t根据版本进行排序-x\t按列排序，横向排序-A\t显示除 . 和 .. 外的所有文件-B\t不输出以 ~ 结尾的备份文件-C\t按列输出，纵向排序-G\t列出文件的组的信息-L\t列出链接文件名，而不是链接到的文件-N\t不限制文件长度-Q\t把输出的文件名用双引号扩起来-R\t列出所有子目录下的文件-S\t以文件大小排序-X\t以文件的扩展名（最后一个 . 后的字符）排序-1\t一行只输出一个文件-color=no\t不显示彩色文件名--help\t在标准输出上显示帮助信息并退出--version\t在标准输出上显示版本信息并退出\n4.mkdirmkdir命令是”make directories”的缩写，若指定目录不存在则创建目录。。\n注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录。 所以在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。\n要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。\n1mkdir [选项] 目录…\n12345678长选项必须使用的参数对于短选项时也是必需使用的。  -m, --mode=模式       设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask  -p, --parents         需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理  -v, --verbose         每次创建新目录都显示信息  -Z, --context=CTX     将每个创建的目录的SELinux 安全环境设置为CTX      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n5.rmdir英文全称：“remove directory”, rmdir命令作用是删除空的目录。\n注意：rmdir命令只能删除空目录。当要删除非空目录时，就要使用带有“-R”选项的rm命令。\nrmdir命令的“-p”参数可以递归删除指定的多级目录，但是要求每个目录也必须是空目录。\n1rmdir [选项]… 目录…\n12345678\t  --ignore-fail-on-non-empty                      忽略仅由目录非空产生的所有错误-p, --parents         删除指定目录及其上级文件夹，例如&quot;rmdir -p a/b/c&#x27;&quot;                      与&quot;rmdir a/b/c a/b a&#x27;&quot; 基本相同-v, --verbose         输出处理的目录详情    --help            显示此帮助信息并退出    --version         显示版本信息并退出\n6.treetree命令以树状图列出目录的内容。\n1tree [选项] [参数]\n12345678910111213141516171819202122-a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-L 层级显示-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。\n7.mvmv命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或重命名文件。经常用来备份文件或者目录。\n123mv [选项]... 源文件 目标文件mv [选项]... 源文件... 目录mv [选项]... --target-directory=DIRECTORY SOURCE...\n123456789101112131415161718192021222324252627282930将源文件重命名为目标文件，或将源文件移动至指定目录。长选项必须使用的参数对于短选项时也是必需使用的。      --backup[=CONTROL]       为每个已存在的目标文件创建备份  -b                           类似--backup 但不接受参数  -f, --force                  覆盖前不询问  -i, --interactive            覆盖前询问  -n, --no-clobber             不覆盖已存在文件如果您指定了-i、-f、-n 中的多个，仅最后一个生效。      --strip-trailing-slashes  去掉每个源文件参数尾部的斜线  -S, --suffix=SUFFIX           替换常用的备份文件后缀  -t, --target-directory=DIRECTORY      将所有参数指定的源文件或目录                                        移动至 指定目录  -T, --no-target-directory     将目标文件视作普通文件处理  -u, --update                  只在源文件文件比目标文件新，或目标文件                                不存在时才进行移动  -v, --verbose         详细显示进行的步骤      --help            显示此帮助信息并退出      --version         显示版本信息并退出      备份文件的后缀为&quot;~&quot;，除非以--suffix 选项或是SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup 选项或VERSION_CONTROL 环境变量来选择。以下是可用的变量值：  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份\n8.cpcp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。\ncp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。\n1234用法：cp [选项]... [-T] 源文件 目标文件　或：cp [选项]... 源文件... 目录　或：cp [选项]... -t 目录 源文件...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667长选项必须使用的参数对于短选项时也是必需使用的。  -a, --archive\t\t\t等于-dR --preserve=all      --attributes-only\t\t\t只拷贝文件属性，不拷贝文件内容      --backup[=CONTROL\t\t为每个已存在的目标文件创建备份  -b\t\t\t\t类似--backup 但不接受参数      --copy-contents\t\t在递归处理是复制特殊文件内容  -d\t\t\t\t等于--no-dereference --preserve=links  -f, --force\t\t\t如果目标文件无法打开则将其移除并重试(当 -n 选项\t\t\t\t\t存在时则不需再选此项)  -i, --interactive\t\t覆盖前询问(使前面的 -n 选项失效)  -H\t\t\t\t跟随源文件中的命令行符号链接  -l, --link\t\t\t链接文件而不复制  -L, --dereference\t\t总是跟随符号链接  -n, --no-clobber\t\t不要覆盖已存在的文件(使前面的 -i 选项失效)  -P, --no-dereference\t\t不跟随源文件中的符号链接  -p\t\t\t\t等于--preserve=模式,所有权,时间戳      --preserve[=属性列表\t保持指定的属性(默认：模式,所有权,时间戳)，如果\t\t\t\t\t可能保持附加属性：环境、链接、xattr 等  -c                           same as --preserve=context      --sno-preserve=属性列表\t不保留指定的文件属性      --parents\t\t\t复制前在目标目录创建来源文件路径中的所有目录  -R, -r, --recursive\t\t递归复制目录及其子目录内的所有内容      --reflink[=WHEN]\t\t控制克隆/CoW 副本。请查看下面的内如。      --remove-destination\t尝试打开目标文件前先删除已存在的目的地\t\t\t\t\t文件 (相对于 --force 选项)      --sparse=WHEN\t\t控制创建稀疏文件的方式      --strip-trailing-slashes\t删除参数中所有源文件/目录末端的斜杠  -s, --symbolic-link\t\t只创建符号链接而不复制文件  -S, --suffix=后缀\t\t自行指定备份文件的后缀  -t,  --target-directory=目录\t将所有参数指定的源文件/目录                                           复制至目标目录  -T, --no-target-directory\t将目标目录视作普通文件  -u, --update                 copy only when the SOURCE file is newer                                 than the destination file or when the                                 destination file is missing  -v, --verbose                explain what is being done  -x, --one-file-system        stay on this file system  -Z, --context=CONTEXT        set security context of copy to CONTEXT      --help\t\t显示此帮助信息并退出      --version\t\t显示版本信息并退出默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文建为稀疏件。使用--sparse=never 参数禁止创建稀疏文件。当指定了--reflink[=always] 参数时执行轻量化的复制，即只在数据块被修改的情况下才复制。如果复制失败或者同时指定了--reflink=auto，则返回标准复制模式。备份文件的后缀为&quot;~&quot;，除非以--suffix 选项或是SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup 选项或VERSION_CONTROL 环境变量来选择。以下是可用的变量值：  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份有一个特别情况：如果同时指定--force 和--backup 选项，而源文件和目标文件是同一个已存在的一般文件的话，cp 会将源文件备份。\n9.rm删除 (unlink) 文件。\nrm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。\n注意：使用rm命令要格外小心。因为一旦删除了一个文件，就无法再恢复它。所以，在删除文件之前，最好再看一下文件的内容，确定是否真要删除。rm命令可以用-i选项，这个选项在使用文件扩展名字符删除多个文件时特别有用。使用这个选项，系统会要求你逐一确定是否要删除。这时，必须输入y并按Enter键，才能删除文件。如果仅按Enter键或其他字符，文件不会被删除。\n1rm [选项]… 文件…\n12345678910111213141516171819202122232425262728删除 (unlink) 文件。  -f, --force           强制删除。忽略不存在的文件，不提示确认  -i                    在删除前需要确认  -I                    在删除超过三个文件或者递归删除前要求确认。此选项比-i 提                        示内容更少，但同样可以阻止大多数错误发生      --interactive[=WHEN]      根据指定的WHEN 进行确认提示：never，once (-I)，                                或者always (-i)。如果此参数不加WHEN 则总是提示      --one-file-system         递归删除一个层级时，跳过所有不符合命令行参                                数的文件系统上的文件      --no-preserve-roo 不特殊对待&quot;/&quot;      --preserve-root   不允许删除&quot;/&quot;(默认)  -d, --dir\t删除空目录  -r, -R, --recursive   递归删除目录及其内容  -v, --verbose         详细显示进行的步骤      --help            显示此帮助信息并退出      --version         显示版本信息并退出默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定的目录，以及其下所有的内容。要删除第一个字符为&quot;-&quot;的文件 (例如&quot;-foo&quot;)，请使用以下方法之一：  rm -- -foo  rm ./-foo请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证该文件的内容无法还原，请考虑使用shred。\n10.touchtouch命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。\ntouch命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件，除非指定了”-c”或”-h”选项。\n注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有写文件的访问权限。\n1用法：touch [选项]... 文件...\n123456789101112131415161718192021不存在的文件将会被创建为空文件，除非使用-c 或-h 选项。如果文件名为&quot;-&quot;则特殊处理，更改与标准输出相关的文件的访问时间。长选项必须使用的参数对于短选项时也是必需使用的。  -a                    只更改访问时间  -c, --no-create       不创建任何文件  -d, --date=字符串     使用指定字符串表示时间替代当前时间  -f                    (忽略)  -h, --no-dereference          会影响符号链接本身，替代符号链接所指示的目的地                                (当系统支持更改符号链接的所有者时，此选项才有用)  -m                    只更改修改时间  -r, --reference=文件  使用指定文件的时间属性替代当前时间  -t STAMP              使用[[CC]YY]MMDDhhmm[.ss] 格式的时间替代当前时间  --time=WORD           使用WORD 指定的时间：access、atime、use 都等于-a                        选项的效果，而modify、mtime 等于-m 选项的效果      --help            显示此帮助信息并退出      --version         显示版本信息并退出请注意，-d 和-t 选项可接受不同的时间/日期格式。\n11.basenamebasename - 从文件名中剥离目录和后缀\nbasename命令用于打印目录或者文件的基本名称。basename和dirname命令通常用于shell脚本中的命令替换来指定和指定的输入文件名称有所差异的输出文件名称。\n12basename 名称 [后缀]basename 选项\n1234567显示 去掉 目录成分 后的 NAME. 如果 指定了 SUFFIX, 就 同时 去掉 拖尾的SUFFIX.--help \t显示 帮助信息, 然后 结束--version\t显示 版本信息, 然后 结束\n12.dirnamedirname - 从文件名剥离非目录的后缀\ndirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个/及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个/后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。dirname 和 basename通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。\n12dirname 名字dirname 选项\n1234567打印去除了/后面部分的NAME;如果NAME没有包含/,则输出`.&#x27;(表示当前目录).--help \t显示帮助并退出--version\t输出版本信息并退出\n13.renamerename命令用字符串替换的方式批量改变文件名。\nrename 用于 对文件进行命名管理，可进行批量命名并支持正则表达式， rename命令存在两个版本用法上有所区别 一个是 C语言版本支持通配符，另一个是 Perl版本.支持正则表达式\n123456789rename [选项] 表达式 替换文件…rename [options] expression replacement file…expression 将文件名需要替换的字符串replacement 将文件名中含有的原字符替换成目标字符串file 指定要改变文件名的文件列表\n1234567891011121314151617 -v, --verbose    解释正在进行的操作 -s, --symlink    在符号链接上执行 -h, --help     显示此帮助并退出 -V, --version  输出版本信息并退出 【常用通配符说明】 ?    表示一个任意字符 *    表示一个或一串任意字符-------------------------------------------------【常用正则表达式符号说明】^    匹配输入的开始位置$    匹配输入的结尾.    匹配除换行符外的任意字符+    匹配前一个字符一次或多次 例如，&quot;zo+&quot;可以匹配&quot;zoo&quot;,但不匹配&quot;z&quot;[a-z]    表示某个范围内的字符，例如，&quot;[a-z]&quot;匹配&quot;a&quot;与&quot;z&quot;之间的任何一个小写字母字符。[^m-z]    否定的字符区间。与不在指定区间内的字符匹配。\n14.filefile - 确定文件类型\nfile命令用来识别文件类型，也可用来辨别一些文件的编码格式。它是通过查看文件的头部信息来获取文件类型，而不是像Windows通过扩展名来确定文件类型的。\n1file [ -bcnsvzL ] [ -f 命名文件 ] [ -m 幻数文件 ] file …\n123456789101112131415161718-b    不输出文件名 (简要模式).-c    检查时打印输出幻数文件的解析结果.常与 -m 一起使用，用来在安装幻数文件之前调试它.-f 命名文件    从在参数表前的 命名文件 中读出将要检查的文件名(每行一个文件).要有 命名文件 ，或者至少有一个文件名参数; 如果要检查标准输入, 使用``-作为文件参数.-m list    指定包含幻数的文件列表.可以是单个文件，也可以是 用冒号分开的多个文件.-n    每检查完一个文件就强制刷新标准输出. 仅在检查一组文件时才有效. 一般在将文件类型输出到管道时才采用此选项.-v    打印程序版本并退出.-z    试图查看压缩文件内部信息.-L    (在支持符号链接的系统上)选项显示符号链接文件的原文件, 就像 ls(1) 命令的like-named 选项.-s    通常, file 只是试图去检查在文件列表中那些 stat(2) 报告为正常文件的文件的类型.由于读特殊文件将可能导致 不可知后果，所以这样可以防止发生问题.使用 -s 选项时 file 命令也将去读文件列表中的块特殊文件和字符特殊文件. 一般用于从原始磁盘分区中获得文件系统类型，此文件为块 特殊文件. 这个选项也导致 file 命令忽略 stat(2) 报告的文件大小，因为在有些系统中原始磁盘分区的大小报告为0.\n15.cat将[文件]或标准输入组合输出到标准输出。\ncat 命令连接文件并打印到标准输出设备上，经常用来显示整个文件的内容。cat 只能查看文本内容的文件，如查看二进制文件，则屏幕会显示乱码。另外，cat 还可以用来创建文件、合并文件等。\n1用法：cat [选项] [文件]...\n12345678910111213141516171819202122将文件列表中的文件或标准输入连接到标准输出。-A, --show-all\t等价于 -vET 。-b, --number-nonblank\t给非空输出行编号。-e     等价于 -vE 。-E, --show-ends\t在每行结束显示 $ 。-n, --number\t给所有输出行编号。-s, --squeeze-blank\t将所有的连续的多个空行替换为一个空行。-t     等价于 -vT 。-T, --show-tabs\t把 TAB 字符显示为 ^I 。-u     (被忽略的选项)-v, --show-nonprinting\t除了 LFD 和 TAB 之外所有控制符用 ^ 和 M- 记方式显示。--help 显示帮助并退出。--version\t显示版本信息并退出。\t没有指定文件或指定的文件是 -，则从标准输入读取。\n16.moremore命令用于将内容较长的文本文件内容（不能在一屏显示完）进行分屏显示，并且支持在显示时定位关键字。而对于内容较少的文本文件内容则推荐使用cat命令查看\nmore命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。\n1more [-dlfpcsu] [-num] [+/ pattern] [+ linenum] [file …]\n1234567891011-d\t显示帮助，而不是响铃-f\t统计逻辑行数而不是屏幕行数-l\t抑制换页(form feed)后的暂停-p\t不滚屏，清屏并显示文本-c\t不滚屏，显示文本并清理行尾-u\t抑制下划线-s\t将多个空行压缩为一行-NUM\t指定每屏显示的行数为 NUM+NUM\t从文件第 NUM 行开始显示+/STRING\t从匹配搜索字符串 STRING 的文件位置开始显示-V\t显示版本信息并退出\n17.lessless 与more命令类似，但可以通过翻页键查看上下页的内容\nless命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向下浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。\n1less [参数] [文件]\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182-b&lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o&lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x&lt;数字&gt; 将“tab”键显示为规定的数字空格命令内部操作按键功能如下：b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行 1) 向前搜索    / ： 使用一个模式进行搜索，并定位到下一个匹配的文本    n ： 向前查找下一个匹配的文本    N ： 向后查找前一个匹配的文本2) 向后搜索    ? ： 使用模式进行搜索，并定位到前一个匹配的文本    n ： 向后查找下一个匹配的文本    N ： 向前查找前一个匹配的文本2 全屏导航    ctrl + F ：向前移动一屏    ctrl + B ：向后移动一屏    ctrl + D ：向前移动半屏    ctrl + U ：向后移动半屏3 单行导航    j ： 向前移动一行    k ： 向后移动一行4 其它导航    G ： 移动到最后一行    g ： 移动到第一行    q / ZZ ： 退出 less 命令5 编辑文件    v ： 进入编辑模式，使用配置的编辑器编辑当前文件6 标记导航    当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置。    ma ： 使用 a 标记文本的当前位置    &#x27;a ： 导航到标记 a 处7 浏览多个文件    方式一，传递多个参数给 less，就能浏览多个文件。    less file1 file2    方式二，正在浏览一个文件时，使用 :e 打开另一个文件。    less file1    :e file2         当打开多个文件时，使用如下命令在多个文件之间切换    :n - 浏览下一个文件    :p - 浏览前一个文件\n18.grepLinux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\ngrep命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式。需要注意的是：一当模式中包含了空格，务必要用双引号将其引起来。\nlinux系统支持三种形式的grep命令，大儿子就是grep，标准，模仿的代表。二儿子兴趣爱好多-egrep，简称扩展grep命令，其实和grep -E等价，支持基本和扩展的正则表达式。小儿子跑的最快-fgrep，简称快速grep命令，其实和grep -F等价，不支持正则表达式，按照字符串表面意思进行匹配。\n12grep [options] PATTERN [FILE...]grep [options] [-e PATTERN | -f FILE] [FILE...]\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889匹配模式选择: -E, --extended-regexp     扩展正则表达式egrep -F, --fixed-strings       一个换行符分隔的字符串的集合fgrep -G, --basic-regexp        基本正则 -P, --perl-regexp         调用的perl正则 -e, --regexp=PATTERN      后面根正则模式，默认无 -f, --file=FILE           从文件中获得匹配模式 -i, --ignore-case         不区分大小写 -w, --word-regexp         匹配整个单词 -x, --line-regexp         匹配整行 -z, --null-data           一个 0 字节的数据行，但不是空行杂项: -s, --no-messages         不显示错误信息 -v, --invert-match        显示不匹配的行 -V, --version             显示版本号 --help                    显示帮助信息 --mmap                use memory-mapped input if possible输入控制: -m, --max-count=NUM       匹配的最大数 -b, --byte-offset         打印匹配行前面打印该行所在的块号码。 -n, --line-number         显示的加上匹配所在的行号 --line-buffered           刷新输出每一行 -H, --with-filename       当搜索多个文件时，显示匹配文件名前缀 -h, --no-filename         当搜索多个文件时，不显示匹配文件名前缀 --label=LABEL            print LABEL as filename for standard input -o, --only-matching       只显示一行中匹配PATTERN 的部分 -q, --quiet, --silent      不显示任何东西 --binary-files=TYPE   假定二进制文件的TYPE 类型；                                      TYPE 可以是`binary&#x27;, `text&#x27;, 或`without-match&#x27; -a, --text                匹配二进制的东西 -I                        不匹配二进制的东西 -d, --directories=ACTION  目录操作，读取，递归，跳过 -D, --devices=ACTION      设置对设备，FIFO,管道的操作，读取，跳过 -R, -r, --recursive       递归调用 --include=PATTERN     只查找匹配FILE_PATTERN 的文件 --exclude=PATTERN     跳过匹配FILE_PATTERN 的文件和目录 --exclude-from=FILE   跳过所有除FILE 以外的文件 -L, --files-without-match 匹配多个文件时，显示不匹配的文件名 -l, --files-with-matches  匹配多个文件时，显示匹配的文件名 -c, --count               显示匹配的行数 -Z, --null                在FILE 文件最后打印空字符文件控制: -B, --before-context=NUM  打印匹配本身以及前面的几个行由NUM控制 -A, --after-context=NUM   打印匹配本身以及随后的几个行由NUM控制 -C, --context=NUM         打印匹配本身以及随后，前面的几个行由NUM控制 -NUM                      根-C的用法一样的 --color[=WHEN], --colour[=WHEN]       使用标志高亮匹配字串；  -U, --binary               使用标志高亮匹配字串； -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式) 规则表达式：grep的规则表达式:^  #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。    $  #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。    .  #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。    *  #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。    .*   #一起用代表任意字符。   []   #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。    [^]  #匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    \\(..\\)  #标记匹配字符，如&#x27;\\(love\\)&#x27;，love被标记为1。    \\&lt;      #锚定单词的开始，如:&#x27;\\&lt;grep&#x27;匹配包含以grep开头的单词的行。    \\&gt;      #锚定单词的结束，如&#x27;grep\\&gt;&#x27;匹配包含以grep结尾的单词的行。    x\\&#123;m\\&#125;  #重复字符x，m次，如：&#x27;0\\&#123;5\\&#125;&#x27;匹配包含5个o的行。    x\\&#123;m,\\&#125;  #重复字符x,至少m次，如：&#x27;o\\&#123;5,\\&#125;&#x27;匹配至少有5个o的行。    x\\&#123;m,n\\&#125;  #重复字符x，至少m次，不多于n次，如：&#x27;o\\&#123;5,10\\&#125;&#x27;匹配5--10个o的行。   \\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。   \\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   \\b    #单词锁定符，如: &#x27;\\bgrep\\b&#x27;只匹配grep。  POSIX字符:为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。[:alnum:]    #文字数字字符   [:alpha:]    #文字字符   [:digit:]    #数字字符   [:graph:]    #非空字符（非空格、控制字符）   [:lower:]    #小写字符   [:cntrl:]    #控制字符   [:print:]    #非空字符（包括空格）   [:punct:]    #标点符号   [:space:]    #所有空白字符（新行，空格，制表符）   [:upper:]    #大写字符   [:xdigit:]   #十六进制数字（0-9，a-f，A-F）  \n19.egrepegrep命令用于在文件内查找指定的字符串。egrep执行效果与grep -E相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。\negrep支持扩展的正则表达式\n12345egrep [选项]... PATTERN [FILE]...在每个 FILE 或是标准输入中查找 PATTERN。PATTERN 是一个可扩展的正则表达式(缩写为 ERE)。例如: egrep -i &#x27;hello world&#x27; menu.h main.c\n注意: pattern如果是表达式或者超过两个单词的, 需要用引号引用. 可以是单引号也可双引号, 区别是单引号无法引用变量而双引号可以.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162在每个 FILE 或是标准输入中查找 PATTERN。PATTERN 是一个可扩展的正则表达式(缩写为 ERE)。例如: egrep -i &#x27;hello world&#x27; menu.h main.c正则表达式选择与解释:  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作  -f, --file=FILE           从 FILE 中取得 PATTERN  -i, --ignore-case         忽略大小写  -w, --word-regexp         强制 PATTERN 仅完全匹配字词  -x, --line-regexp         强制 PATTERN 仅完全匹配一行  -z, --null-data           一个 0 字节的数据行，但不是空行杂项:  -s, --no-messages         不显示错误信息  -v, --invert-match        选中不匹配的行  -V, --version             显示版本信息并退出      --help                显示此帮助并退出      --mmap                忽略向后兼容性输入控制:  -m, --max-count=NUM       匹配的最大数  -b, --byte-offset         打印匹配行前面打印该行所在的块号码。  -n, --line-number         显示的加上匹配所在的行号  --line-buffered           刷新输出每一行  -H, --with-filename       当搜索多个文件时，显示匹配文件名前缀  -h, --no-filename         当搜索多个文件时，不显示匹配文件名前缀  -o, --only-matching       只显示一行中匹配PATTERN 的部分  -q, --quiet, --silent     不显示所有输出      --binary-files=TYPE   假定二进制文件的TYPE 类型；                            TYPE 可以是`binary&#x27;, `text&#x27;, 或`without-match&#x27;  -a, --text                等同于 --binary-files=text  -I                        等同于 --binary-files=without-match  -d, --directories=ACTION  操作目录的方式；                            ACTION 可以是`read&#x27;, `recurse&#x27;,或`skip&#x27;  -D, --devices=ACTION      操作设备、先入先出队列、套接字的方式；                            ACTION 可以是`read&#x27;或`skip&#x27;  -R, -r, --recursive       等同于 --directories=recurse      --include=FILE_PATTERN  只查找匹配FILE_PATTERN 的文件      --exclude=FILE_PATTERN  跳过匹配FILE_PATTERN 的文件和目录      --exclude-from=FILE   跳过所有除FILE 以外的文件      --exclude-dir=PATTERN  跳过所有匹配PATTERN 的目录。  -L, --files-without-match  只打印不匹配FILEs 的文件名  -l, --files-with-matches  只打印匹配FILES 的文件名  -c, --count               只打印每个FILE 中的匹配行数目  -T, --initial-tab         行首tabs 分隔（如有必要）  -Z, --null                在FILE 文件最后打印空字符文件控制:  -B, --before-context=NUM  打印以文本起始的NUM 行  -A, --after-context=NUM   打印以文本结尾的NUM 行  -C, --context=NUM         打印输出文本NUM 行  -NUM                      等同于 --context=NUM      --color[=WHEN],      --colour[=WHEN]       使用标志高亮匹配字串；                            WHEN 可以是`always&#x27;, `never&#x27;或`auto&#x27;  -U, --binary              不要清除行尾的CR 字符(MSDOS 模式)  -u, --unix-byte-offsets   当CR 字符不存在，报告字节偏移(MSDOS 模式)不带 FILE 参数，或是 FILE 为 -，将读取标准输入。如果少于两个 FILE 参数就要默认使用 -h 参数。如果选中任意一行，那退出状态为 0，否则为 1；如果有错误产生，且未指定 -q 参数，那退出状态为 2。\n20.wcwc - 输出文件中的行数、单词数、字节数\n1wc [选项列表]... [文件名列表]...\n1234567891011121314对每个文件输出行、单词、和字节统计数，如果指定了多于一个文件则还有个行数的总计。没有指定文件或指定的文件是 -，则读取标准输入。-c, --bytes, --chars\t输出字节统计数。-l, --lines\t输出换行符统计数。-L, --max-line-length\t输出最长的行的长度。-w, --words\t输出单词统计数。--help \t显示帮助并退出--version\t输出版本信息并退出\n21.sortsort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。\n1用法：sort [选项]... [文件]...\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556长选项必须使用的参数对于短选项时也是必需使用的。排序选项：  -b, --ignore-leading-blanks   忽略前导的空白区域  -d, --dictionary-order        只考虑空白区域和字母字符  -f, --ignore-case             忽略字母大小写  -g, --general-numeric-sort    按照常规数值排序  -i, --ignore-nonprinting      只排序可打印字符  -M, --month-sort              比较 (未知) &lt; &quot;一月&quot; &lt; ... &lt; &quot;十二月&quot;                                在LC_ALL=C 时为(unknown) &lt; `JAN&#x27; &lt; ... &lt; `DEC&#x27;  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)  -n, --numeric-sort            根据字符串数值比较  -R, --random-sort             根据随机hash 排序      --random-source=文件      从指定文件中获得随机字节  -r, --reverse                 逆序输出排序结果      --sort=WORD               按照WORD 指定的格式排序：                                        一般数字-g，高可读性-h，月份-M，数字-n，                                        随机-R，版本-V  -V, --version-sort            在文本内进行自然版本排序其他选项：      --batch-size=NMERGE       一次最多合并NMERGE 个输入；如果输入更多                                        则使用临时文件  -c, --check, --check=diagnose-first   检查输入是否已排序，若已有序则不进行操作  -C, --check=quiet, --check=silent     类似-c，但不报告第一个无序行      --compress-program=程序   使用指定程序压缩临时文件；使用该程序                                        的-d 参数解压缩文件      --debug                   为用于排序的行添加注释，并将有可能有问题的                                        用法输出到标准错误输出      --files0-from=文件        从指定文件读取以NUL 终止的名称，如果该文件被                                        指定为&quot;-&quot;则从标准输入读文件名  -k, --key=位置1[,位置2]       在位置1 开始一个key，在位置2 终止(默认为行尾)                                参看POS 语法。  -m, --merge                   合并已排序的文件，不再进行排序  -o, --output=文件             将结果写入到文件而非标准输出  -s, --stable                  禁用last-resort 比较以稳定比较算法  -S, --buffer-size=大小        指定主内存缓存大小  -t, --field-separator=分隔符  使用指定的分隔符代替非空格到空格的转换  -T, --temporary-directory=目录        使用指定目录而非$TMPDIR 或/tmp 作为                                        临时目录，可用多个选项指定多个目录      --parallel=N              将同时运行的排序数改变为N  -u, --unique          配合-c，严格校验排序；不配合-c，则只输出一次排序结果  -z, --zero-terminated 以0 字节而非新行作为行尾标志      --help            显示此帮助信息并退出      --version         显示版本信息并退出POS 是F[.C][OPTS]，F 代表域编号，C 是域中字母的位置，F 和C 均从1开始计数如果没有有效的-t 或-b 选项存在，则从前导空格后开始计数字符。OPTS 是一个或多个由单个字母表示的顺序选项，以此覆盖此key 的全局顺序设置。如果没有指定key 则将其整个行。指定的大小可以使用以下单位之一：内存使用率% 1%，b 1、K 1024 (默认)，M、G、T、P、E、Z、Y 等依此类推。如果不指定文件，或者文件为&quot;-&quot;，则从标准输入读取数据。\n22.uniquniq - 删除排序文件中的重复行\nuniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。\nuniq命令全称是“unique”，中文释义是“独特的，唯一的”。该命令的作用是用来去除文本文件中连续的重复行，中间不能夹杂其他文本行。去除了重复的，保留的都是唯一的，也就是独特的，唯一的了。\n我们应当注意的是，它和sort的区别，sort只要有重复行，它就去除，而uniq重复行必须要连续，也可以用它忽略文件中的重复行。\n1用法：uniq [选项]... [文件]\n123456789101112131415161718192021222324从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。不附加任何选项时匹配行将在首次出现处被合并。长选项必须使用的参数对于短选项时也是必需使用的。  -c, --count           在每行前加上表示相应行目出现次数的前缀编号  -d, --repeated        只输出重复的行  -D, --all-repeated[=delimit-method    显示所有重复的行                        delimit-method=&#123;none(default),prepend,separate&#125;                        以空行为界限  -f, --skip-fields=N   比较时跳过前N 列  -i, --ignore-case     在比较的时候不区分大小写  -s, --skip-chars=N    比较时跳过前N 个字符  -u, --unique          只显示唯一的行  -z, --zero-terminated 使用&#x27;\\0&#x27;作为行结束符，而不是新换行  -w, --check-chars=N   对每行第N 个字符以后的内容不作对照      --help            显示此帮助信息并退出      --version         显示版本信息并退出若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将被跳过。提示：uniq 不会检查重复的行，除非它们是相邻的行。如果您想先对输入排序，使用没有uniq 的&quot;sort -u&quot;。同时，比较服从&quot;LC_COLLATE&quot; 变量所指定的规则。\n23.which查找环境变量中的文件\nwhich 命令用于查找并显示给定命令的绝对路径，环境变量 PATH 中保存了查找命令时需要遍历的目录。which 指令会在环境变量 $PATH 设置的目录里查找符合条件的文件。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n1which [选项] 执行文件名 […]\n1234567891011121314151617181920查找环境变量中的文件-a   查找全部内容，而非第一个文件-n   &lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p   &lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 -w 　指定输出时栏位的宽度。 -V 　显示版本信息。--version, -[vV]\t显示版本信息并退出--help\t显示帮助信息并退出--skip-dot\t跳过 PATH 中以点开头的目录--skip-tilde\t跳过 PATH 中以波形符号开头的目录--show-dot\t不要在输出中将点扩展到当前目录--show-tilde\t为 HOME 目录（非根目录）输出波形--tty-only\t如果不在 tty 上，停止右边的处理选项--all, -a\t打印 PATH 中的所有匹配项，而不仅仅是第一个--read-alias, -i\t从 stdin 中读取别名列表--skip-alias\t忽略选项 --read-alias；不读 stdin--read-functions\t从 stdin 读取 shell 函数--skip-functions\t忽略选项 --read-functions；不读 stdin\n\n八、 文件压缩解压命令1.tartar命令：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的\ntar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。\n首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。\n为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（bzip2和gzip命令）。\n1用法：tar 选项... 参数...\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203 主操作模式: -A, --catenate, --concatenate   追加 tar 文件至归档 -c, --create               创建一个新归档 -d, --diff, --compare      找出归档和文件系统的差异 --delete               从归档(非磁带！)中删除 -r, --append               追加文件至归档结尾 -t, --list                 列出归档内容 --test-label           测试归档卷标并退出 -u, --update               仅追加比归档中副本更新的文件 -x, --extract, --get       从归档中解出文件 操作修饰符: --check-device         当创建增量归档时检查设备号(默认) -g, --listed-incremental=文件处理新式的 GNU 格式的增量备份 -G, --incremental          处理老式的 GNU 格式的增量备份 --ignore-failed-read当遇上不可读文件时不要以非零值退出 -n, --seek                 归档可检索 --no-check-device      当创建增量归档时不要检查设备号 --occurrence[=NUMBER]  仅处理归档中每个文件的第 NUMBER个事件；仅当与以下子命令 --delete, --diff, --extract 或是 --list中的一个联合使用时，此选项才有效。而且不管文件列表是以命令行形式给出或是通过 -T 选项指定的；NUMBER 值默认为 1 --sparse-version=MAJOR[.MINOR]设置所用的离散格式版本(隐含--sparse) -S, --sparse               高效处理离散文件 重写控制: -k, --keep-old-files       解压时不要替换存在的文件 --keep-newer-files不要替换比归档中副本更新的已存在的文件 --no-overwrite-dir     保留已存在目录的元数据 --overwrite            解压时重写存在的文件 --overwrite-dir解压时重写已存在目录的元数据(默认) --recursive-unlink     解压目录之前先清除目录层次 --remove-files         在添加文件至归档后删除它们 -U, --unlink-first         在解压要重写的文件之前先删除它们 -W, --verify               在写入以后尝试校验归档 选择输出流: --ignore-command-error 忽略子进程的退出代码 --no-ignore-command-error将子进程的非零退出代码认为发生错误 -O, --to-stdout            解压文件至标准输出 --to-command=COMMAND将解压的文件通过管道传送至另一个程序 操作文件属性: --atime-preserve[=METHOD]在输出的文件上保留访问时间，要么通过在读取(默认 METHOD=‘replace’)后还原时间，要不就不要在第一次(METHOD=‘system’)设置时间 --delay-directory-restore 直到解压结束才设置修改时间和所解目录的权限 --group=名称         强制将 NAME作为所添加的文件的组所有者 --mode=CHANGES         强制将所添加的文件(符号)更改为权限CHANGES --mtime=DATE-OR-FILE   从 DATE-OR-FILE 中为添加的文件设置mtime -m, --touch                不要解压文件的修改时间 --no-delay-directory-restore取消 --delay-directory-restore 选项的效果 --no-same-owner        将文件解压为您所有 --no-same-permissions从归档中解压权限时使用用户的掩码位(默认为普通用户服务) --numeric-owner        总是以数字代表用户/组的名称 --owner=名称         强制将 NAME作为所添加的文件的所有者 -p, --preserve-permissions, --same-permissions解压文件权限信息(默认只为超级用户服务) --preserve             与 -p 和 -s 一样 --same-owner           尝试解压时保持所有者关系一致 -s, --preserve-order, --same-order为解压至匹配归档排序名称 设备选择和切换: -f, --file=ARCHIVE         使用归档文件或 ARCHIVE 设备 --force-local即使归档文件存在副本还是把它认为是本地归档 -F, --info-script=名称, --new-volume-script=名称在每卷磁带最后运行脚本(隐含 -M) -L, --tape-length=NUMBER   写入 NUMBER × 1024 字节后更换磁带 -M, --multi-volume         创建/列出/解压多卷归档文件 --rmt-command=COMMAND  使用指定的 rmt COMMAND 代替 rmt --rsh-command=COMMAND  使用远程 COMMAND 代替 rsh --volno-file=文件    使用/更新 FILE 中的卷数 设备分块: -b, --blocking-factor=BLOCKS   每个记录 BLOCKS x 512 字节 -B, --read-full-records    读取时重新分块(只对 4.2BSD 管道有效) -i, --ignore-zeros         忽略归档中的零字节块(即文件结尾) --record-size=NUMBER   每个记录的字节数 NUMBER，乘以 512 选择归档格式: -H, --format=FORMAT        创建指定格式的归档 FORMAT 是以下格式中的一种: gnu                      GNU tar 1.13.x 格式 oldgnu                   GNU 格式 as per tar &lt;= 1.12 pax                      POSIX 1003.1-2001 (pax) 格式 posix                    等同于 pax ustar                    POSIX 1003.1-1988 (ustar) 格式 v7                       old V7 tar 格式 --old-archive, --portability等同于 --format=v7 --pax-option=关键字[[:]=值][,关键字[[:]=值]]...控制 pax 关键字 --posix                等同于 --format=posix -V, --label=TEXT           创建带有卷名 TEXT的归档；在列出/解压时，使用 TEXT作为卷名的模式串 压缩选项: -a, --auto-compress        使用归档后缀来决定压缩程序 -I, --use-compress-program=PROG通过 PROG 过滤(必须是能接受 -d选项的程序) -j, --bzip2                通过 bzip2 过滤归档 --lzma                 通过 lzma 过滤归档 --no-auto-compress     do not use archive suffix to determine thecompression program -z, --gzip, --gunzip, --ungzip   通过 gzip 过滤归档 -Z, --compress, --uncompress   通过 compress 过滤归档 -J, --xz                   filter the archive through xz --lzop                 通过 lzop 过滤归档 本地文件选择: --add-file=文件      添加指定的 FILE 至归档(如果名字以 -开始会很有用的) --backup[=CONTROL]     在删除前备份，选择 CONTROL 版本 -C, --directory=DIR        改变至目录 DIR --exclude=PATTERN      排除以 PATTERN 指定的文件 --exclude-caches       除标识文件本身外，排除包含CACHEDIR.TAG 的目录中的内容 --exclude-caches-all   排除包含 CACHEDIR.TAG 的目录 --exclude-caches-under 排除包含 CACHEDIR.TAG的目录中所有内容 --exclude-tag=文件   除 FILE 自身外，排除包含 FILE的目录中的内容 --exclude-tag-all=文件   排除包含 FILE 的目录 --exclude-tag-under=文件   排除包含 FILE的目录中的所有内容 --exclude-vcs          排除版本控制系统目录 -h, --dereference跟踪符号链接；将它们所指向的文件归档并输出 --hard-dereference 跟踪硬链接；将它们所指向的文件归档并输出 -K, --starting-file=MEMBER-NAME从归档中的 MEMBER-NAME 成员处开始 --newer-mtime=DATE     当只有数据改变时比较数据和时间 --no-null              禁用上一次的效果 --null 选项 --no-recursion         避免目录中的自动降级 --no-unquote           不以 -T 读取的文件名作为引用结束 --null                 -T 读取以空终止的名字，-C 禁用 -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE只保存比 DATE-OR-FILE 更新的文件 --one-file-system      创建归档时保存在本地文件系统中 -P, --absolute-names       不要从文件名中清除引导符‘/’ --recursion            目录递归(默认) --suffix=STRING        在删除前备份，除非被环境变量SIMPLE_BACKUP_SUFFIX覆盖，否则覆盖常用后缀(‘’) -T, --files-from=文件    从 FILE中获取文件名来解压或创建文件 --unquote              以 -T读取的文件名作为引用结束(默认) -X, --exclude-from=文件  排除 FILE 中列出的模式串 文件名变换: --strip-components=NUMBER   解压时从文件名中清除 NUMBER个引导部分 --transform=EXPRESSION, --xform=EXPRESSION使用 sed 代替 EXPRESSION 来进行文件名变换 文件名匹配选项(同时影响排除和包括模式串): --anchored             模式串匹配文件名头部 --ignore-case          忽略大小写 --no-anchored          模式串匹配任意‘/’后字符(默认对 exclusion 有效) --no-ignore-case       匹配大小写(默认) --no-wildcards         逐字匹配字符串 --no-wildcards-match-slash   通配符不匹配‘/’ --wildcards            使用通配符(默认对 exclusion ) --wildcards-match-slash通配符匹配‘/’(默认对排除操作有效) 提示性输出: --checkpoint[=NUMBER]  每隔 NUMBER个记录显示进度信息(默认为 10 个) --checkpoint-action=ACTION   在每个检查点上执行 ACTION --index-file=文件    将详细输出发送至 FILE -l, --check-links只要不是所有链接都被输出就打印信息 --no-quote-chars=STRING   禁用来自 STRING 的字符引用 --quote-chars=STRING   来自 STRING 的额外的引用字符 --quoting-style=STYLE  设置名称引用风格；有效的 STYLE值请参阅以下说明 -R, --block-number         每个信息都显示归档内的块数 --show-defaults        显示 tar 默认选项 --show-omitted-dir 列表或解压时，列出每个不匹配查找标准的目录 --show-transformed-names, --show-stored-names显示变换后的文件名或归档名 --totals[=SIGNAL]      处理归档后打印出总字节数；当此SIGNAL 被触发时带参数 -打印总字节数；允许的信号为: SIGHUP，SIGQUIT，SIGINT，SIGUSR1 和 SIGUSR2；同时也接受不带 SIG 前缀的信号名称 --utc                  以 UTC 格式打印文件修改信息 -v, --verbose              详细地列出处理的文件 -w, --interactive, --confirmation每次操作都要求确认 兼容性选项: -o                         创建归档时，相当于 --old-archive；展开归档时，相当于 --no-same-owner 其它选项: -?, --help                 显示此帮助列表 --restrict             禁用某些潜在的有危险的选项 --usage                显示简短的用法说明 --version              打印程序版本长选项和相应短选项具有相同的强制参数或可选参数。除非以 --suffix 或 SIMPLE_BACKUP_SUFFIX设置备份后缀，否则备份后缀就是“~”。可以用 --backup 或 VERSION_CONTROL 设置版本控制，可能的值为： none, off       从不做备份 t, numbered     进行编号备份 nil, existing如果编号备份存在则进行编号备份，否则进行简单备份 never, simple   总是使用简单备份\n2.gzipgzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。\ngzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。\n1gzip [ -acdfhlLnNrtvV19 ] [-S 后缀] [ 文件名 ...  ]\n1234567891011121314151617-a或——ascii：使用ASCII文字模式；-d或--decompress或----uncompress：解开压缩文件；-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；-N或——name：压缩文件时，保存原来的文件名称及时间戳记；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；--best：此参数的效果和指定“-9”参数相同；--fast：此参数的效果和指定“-1”参数相同。\n3.gunzipgunzip命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gunzip压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。\n1gunzip [ -acfhlLnNrtvV ] [-S 后缀] [ 文件名 ...  ]\n1234567891011121314-a或——ascii：使用ASCII文字模式；-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息；\n4.bzip2Linux系统中bzip2命令的英文是“bunzip2”，即.bz2文件格式的压缩程序； bzip2命令系统默认是没有安装的，需要安装bzip2库才可以使用此命令。\nbzip2命令采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。\n1bzip2 [ -cdfkqstvzVL123456789 ] [ filenames ...  ]\n123456789101112-c或——stdout：将压缩与解压缩的结果送到标准输出；-d或——decompress：执行解压缩；-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；-h或——help：在线帮助；-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；-s或——small：降低程序执行时内存的使用量；-t或——test：测试.bz2压缩文件的完整性；-v或——verbose：压缩或解压缩文件时，显示详细的信息；-z或——compress：强制执行压缩；-V或——version：显示版本信息；--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。\n5.bunzip2bunzip2命令解压缩由bzip2指令创建的”.bz2”压缩包。对文件进行压缩与解压缩。此命令类似于gzip/gunzip)”命令，只能对文件进行压缩。对于目录只能压缩目录下的所有文件，压缩完成后，在目录下生成以“.bz2”为后缀的压缩包。bunzip2其实是bzip2的符号链接，即软链接，因此压缩解压都可以通过bzip2实现。\n1bunzip2 [ -fkvsVL ] [ filenames ...  ]\n12345-f或--force：解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件；-k或——keep：在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数；-s或——small：降低程序执行时，内存的使用量；-v或——verbose：解压缩文件时，显示详细的信息；-l，--license，-V或——version：显示版本信息。\n6.bzip2recoverbzip2recover命令用来修复损坏的.bz2文件 ， bzip2是以区块的方式来压缩文件，每个区块视为独立的单位。因此，当某一区块损坏时，便可利用bzip2recover，试着将文件中的区块隔开来，以便解压缩正常的区块。通常只适用在压缩文件很大的情况。\n1bzip2recover filename\n\n7.zipzip 命令是一个应用广泛的跨平台的压缩工具，压缩文件的后缀为 .zip文件\nzip程序将一个或多个压缩文件与有关文件的信息(名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性)一起放入一个压缩存档中。可以使用一个命令将整个目录结构打包到zip存档中。\n对于文本文件来说，压缩比为2：1和3：1是常见的。zip只有一种压缩方法(通缩)，并且可以在不压缩的情况下存储文件。(如果添加了bzip 2支持，zip也可以使用bzip 2压缩，但这些条目需要一个合理的现代解压缩来解压缩。当选择bzip 2压缩时，它将通货紧缩替换为默认方法。)zip会自动为每个要压缩的文件选择更好的两个文件(通缩或存储，如果选择bzip2，则选择bzip2或Store)。\n1zip [参数] [文件]\n12345678910111213141516171819202122232425262728293031323334-A：调整可执行的自动解压缩文件；-b&lt;工作目录&gt;：指定暂时存放文件的目录；-c：替每个被压缩的文件加上注释；-d：从压缩文件内删除指定的文件；-D：压缩文件内不建立目录名称；-f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；-F：尝试修复已损坏的压缩文件；-g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；-h：在线帮助；-i&lt;范本样式&gt;：只压缩符合条件的文件；-j：只保存文件名称及其内容，而不存放任何目录名称；-J：删除压缩文件前面不必要的数据；-k：使用MS-DOS兼容格式的文件名称；-l：压缩文件时，把LF字符置换成LF+CR字符；-ll：压缩文件时，把LF+cp字符置换成LF字符；-L：显示版权信息；-m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；-n&lt;字尾字符串&gt;：不压缩具有特定字尾字符串的文件；-o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；-q：不显示指令执行过程；-r：递归处理，将指定目录下的所有文件和子目录一并处理；-S：包含系统和隐藏文件；-t&lt;日期时间&gt;：把压缩文件的日期设成指定的日期；-T：检查备份文件内的每个文件是否正确无误；-u：更换较新的文件到压缩文件内；-v：显示指令执行过程或显示版本信息；-V：保存VMS操作系统的文件属性；-w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；-x&lt;范本样式&gt;：压缩时排除符合条件的文件；-X：不保存额外的文件属性；-y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；-z：替压缩文件加上注释；-$：保存第一个被压缩文件所在磁盘的卷册名称；-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值。\n8.unzipunzip命令用于解压缩由zip命令压缩的“.zip”压缩包。\n默认行为（就是没有选项）是从指定的ZIP存档中提取所有的文件到当前目录（及其下面的子目录）。一个配套程序zip（1L）创建ZIP存档；这两个程序都与PKWARE的PKZIP和PKUNZIP为MS-DOS创建的存档文件兼容，但许多情况下，程序选项或默认行为是不同的。\n1unzip [-Z] [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]] file[.zip] [file(s) ...] [-x xfile(s) ...] [-d exdir]\n123456789101112131415161718192021222324-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；-f：更新现有的文件；-l：显示压缩文件内所包含的文件；-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；-t：检查压缩文件是否正确；-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；-v：执行时显示详细的信息；-z：仅显示压缩文件的备注文字；-a：对文本文件进行必要的字符转换；-b：不要对文本文件进行字符转换；-C：压缩文件中的文件名称区分大小写；-j：不处理压缩文件中原有的目录路径；-L：将压缩文件中的全部文件名改为小写；-M：将输出结果送到more程序处理；-n：解压缩时不要覆盖原有的文件；-o：不必先询问用户，unzip执行后覆盖原有的文件；-P&lt;密码&gt;：使用zip的密码选项；-q：执行时不显示任何信息；-s：将文件名中的空白字符转换为底线字符；-V：保留VMS的文件版本信息；-X：解压缩时同时回存文件原来的UID/GID；-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；-x&lt;文件&gt;：指定不要处理.zip压缩文件中的哪些文件；-Z：unzip-Z等于执行zipinfo指令。\n9.zipinfozipinfo命令的全称为“zip information”，该命令用于列出压缩文件信息。执行zipinfo指令可得知zip压缩文件的详细信息。\n1zipinfo [-12hlmMstTvz][压缩文件][文件...][-x &lt;范本样式&gt;]\n123456789101112-1：只列出文件名称；-2：此参数的效果和指定“-1”参数类似，但可搭配“-h”，“-t”和“-z”参数使用；-h：只列出压缩文件的文件名称；-l：此参数的效果和指定“-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率；-m：此参数的效果和指定“-s”参数类似，但多会列出每个文件的压缩率；-M：若信息内容超过一个画面，则采用类似more指令的方式列出信息；-s：用类似执行“ls-l”指令的效果列出压缩文件内容；-t：只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率；-T：将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出；-v：详细显示压缩文件内每一个文件的信息；-x&lt;范本样式&gt;：不列出符合条件的文件的信息；-z：如果压缩文件内含有注释，就将注释显示出来。\n\n九、信息显示命令1.unameuname命令的英文全称即“Unix name”。\n用于显示系统相关信息，比如主机名、内核版本号、硬件架构、操作系统类型等。\n如果未指定任何选项，其效果相当于执行uname -s命令，即显示系统内核的名字。\n1用法：uname [选项]...\n1234567891011121314输出一组系统信息。如果不跟随选项，则视为只附加-s 选项。  -a, --all                     以如下次序输出所有信息。其中若-p 和                                -i 的探测结果不可知则被省略：  -s, --kernel-name             输出内核名称  -n, --nodename                输出网络节点上的主机名  -r, --kernel-release          输出内核发行号  -v, --kernel-version          输出内核版本  -m, --machine         输出主机的硬件架构名称  -p, --processor               输出处理器类型或&quot;unknown&quot;  -i, --hardware-platform       输出硬件平台或&quot;unknown&quot;  -o, --operating-system        输出操作系统名称      --help            显示此帮助信息并退出      --version         显示版本信息并退出\n2.hostnamehostname命令用于显示和设置系统的主机名称。环境变量HOSTNAME也保存了当前的主机名。在使用hostname命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改/etc/hosts和/etc/sysconfig/network的相关内容。\n1hostname [选项] [参数]\n1234567891011121314151617181920212223242526hostname - 用来显示或者设置当前系统的主机名，主机名被许多网络程序使用，来标识主机。-a,--alias    显示主机的别名(如果使用了的话).-d,--domain    显示DNS域名.不要使用命令 domainname 来获得DNS域名,因为这会显示NIS域名而非DNS域名.可使用 dnsdomainname 替换之.-F,--file filename    从指定文件中读取主机名.注释(以一个`#&#x27;开头的行)可忽略.-f,--fqdn,--long    显示FQDN(完全资格域名).一个FQDN包括一个短格式主机名和DNS域名.除非你正在使用bind或 者NIS来作主机查询,否则你可以在/etc/hosts文件中修改FQDN和DNS域名(这是FQDN的一 部分).-h,--help    打印用法信息并退出.-I, --all-ip-addresses all addresses for the host     显示主机的所有地址-i,--ip-address    显示主机的IP地址(组).-n,--node    显示DECnet节点名.如果指定了参数(或者指定了 --file name ),那么root也可以设置一个新的节点名.-s,--short    显示短格式主机名.这是一个去掉第一个圆点后面部分的主机名.-V,--version    在标准输出上打印版本信息并以成功的状态退出.-v,--verbose    详尽说明并告知所正在执行的.-y,--yp,--nis    显示NIS域名.如果指定了参数(或者指定了 --file name ),那么root也可以设置一个新的NIS域.\n3.uptimeuptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。\n1uptime [参数]\n\n\n\n\n-p\n以漂亮的格式显示机器正常运行的时间\n\n\n\n\n-s\n系统自开始运行时间，格式为yyyy-mm-dd hh:mm:ss\n\n\n-h\n显示帮助信息\n\n\n\n\n4.statstat命令用来显示文件或文件系统的详细信息\n1stat [选项]... 文件...\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162显示文件或文件系统的状态。  -L, --dereference     跟随链接  -f, --file-system     显示文件系统状态而非文件状态  -c --format=格式      使用指定输出格式代替默认值，每用一次指定格式换一新行      --printf=格式     类似 --format，但是会解释反斜杠转义符，不使用换行作                                输出结尾。如果您仍希望使用换行，可以在格式中                                加入&quot;\\n&quot;  -t, --terse           使用简洁格式输出      --help            显示此帮助信息并退出      --version         显示版本信息并退出有效的文件格式序列(不使用 --file-system)：  %a    八进制权限  %A   用可读性较好的方式输出权限  %b   计算已分配块数(参见%B)  %B   以字节为单位输出%b 所报告的每个块的大小  %C   SELinux 安全环境字符串  %d    十进制设备编号  %D    十六进制设备编号  %f    十六进制原始模式  %F    文件类型  %g    文件的属组ID  %G    文件的属组组名  %h    硬链接数量  %i    Inode 编号  %m    挂载点  %n    文件名  %N    如果对象是一个符号链接，显示引用到的其它文件名  %o    I/O 块大小  %s    总计大小，以字节为单位  %t    十六进制主设备类型  %T    十六进制子设备类型  %u    文件的属主ID  %U    文件的属主用户名  %w    文件创建时间，若未知则显示&quot;-&quot;  %W    从UNIX 元年起以秒计的文件创建时间，若未知则显示&quot;-&quot;  %x    上次访问时间  %X    从UNIX 元年起以秒计的上次访问时间  %y    上次修改时间  %Y    从UNIX 元年起以秒计的上次修改时间  %z    上次更改时间  %Z    从UNIX 元年起以秒计的上次更改时间有效的文件系统格式序列：  %a    非超级用户可用的剩余块数  %b    文件系统的总数据块数  %c    文件系统中文件节点总数  %d    文件系统中空闲文件节点数  %f    文件系统中空闲块数  %i    十六进制文件系统ID  %I    允许的文件名最大长度  %n    文件名  %s    块大小(用于快速传输)  %S    基本块大小(用于块计数)  %t    十六进制类型描述  %T    可读性较好的类型描述注意：您的shell 内含自己的stat 程序版本，它会覆盖这里所提及的相应版本。请查阅您的shell 文档获知它所支持的选项。\n5.dudu - 报告磁盘空间使用情况\ndu命令**的英文全称是“Disk Usage”，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区。\n12用法：du [选项]... [文件]...　或：du [选项]... --files0-from=F\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657POSIX 选项       -a     显示对涉及到的所有文件的统计，而不只是包含子目录。       -k     用1024字节作为计数单位，替代缺省时512字节的计数单位。       -x     只输出指定参数的实际使用空间，而不包括其下的子目录。       -s     只统计指定参数的在同一设备上所使用的空间。GNU 选项       -a, --all              显示对所有文件的统计，而不只是包含子目录。       -b, --bytes              输出以字节为单位的大小，替代缺省时1024字节的计数单位。       --block-size=size              输出以块为单位的大小，块的大小为 size  字节。(  file-  utils-4.0              的新选项)       -c, --total              在处理完所有参数后给出所有这些参数的总计。这个选项被              用给出指定的一组文件或目录使用的空间的总和。       -D, --dereference-args              引用命令行参数的符号连接。但不影响其他的符号连接。    这对找出象              /usr/tmp          这样的目录的磁盘使用量有用，          /usr/tmp              等通常是符号连接。  译住：例如在  /var/tmp   下建立一个目录test,              而/usr/tmp  是指向  /var/tmp  的符号连接。du  /usr/tmp  返回一项              /usr/tmp , 而 du - D /usr/tmp 返回两项 /usr/tmp，/usr/tmp/test。       --exclude=pattern              在递归时，忽略与指定模式相匹配的文件或子目录。模式    可以是任何              Bourne shell 的文件 glob 模式。( file- utils-4.0 的新选项)       -h, --human-readable              为每个数附加一个表示大小单位的字母，象用M表示二进制 的兆字节。       -H, --si              与    -h    参数起同样的作用，只是使用法定的    SI    单位(   用              1000的幂而不是  1024  的幂，这样  M   代表的就是1000000   而不是              1048576)。(fileutils-4.0 的新选项)       -k, --kilobytes              输出以1024字节为计数单位的大小。       -l, --count-links              统计所有文件的大小，包括已经被统计过的(作为一个硬连接)。       -L, --dereference              引用符号连接(不是显示连接点本身而是连接指向的文件或              目录所使用的磁盘空间)。       -m, --megabytes              输出以兆字节的块为计数单位的大小(就是 1,048,576 字节)。       --max-depth=n              只输出命令行参数的小于等于第n层的目录的总计。--max-depth=0的作用同于-s选项。(fileutils-4.0的新选项)       -s, --summarize              对每个参数只显示总和。       -S, --separate-dirs              单独报告每一个目录的大小，不包括子目录的大小。       -x, --one-file-system              忽略与被处理的参数不在同一个文件系统的目录。       -X file, --exclude-from=file              除了从指定的文件中得到模式之外与         --exclude        一样。              模式以行的形式列出。如果指定的文件是&#x27;-&#x27;,那么从标准输              入中读出模式。(fileutils-4.0 的新选项) GNU 标准选项       --help 在标准输出上输出帮助信息后正常退出。       --version              在标准输出上输出版本信息后正常退出。       --     终结选项列表\n6.dfdf命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。\n日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。\n1用法：df [选项]... [文件]...\n1234567891011121314151617181920212223242526272829303132GNU 参数说明\t   -a, --all              列出包括BLOCK为0的文件系统       --block-size=SIZE use SIZE-byte blocks              指定块的大小       -h,--huma-readable&quot;              用常见的格式显示出大小(例如:1K 234M 2G)       -H,--si&quot;              同上,但是这里的1k等于1000字节而不是1024字节       -i, --inodes              用信息索引点代替块表示使用状况       -k, --kilobytes              指定块大小等于1024字节来显示使用状况       -l, --local              只显示本地文件系统使用状况       -m, --megabytes              以指定块大小等于1048576字节(1M)来显示使用状况       --no-sync              在取得使用信息前禁止调用同步 (default)       -P, --portability              使用POSIX格式输出       --sync 在取得使用信息前调用同步       -t, --type=TYPE              只显示指定类型(TYPE)的文件系统       -T, --print-type              输出每个文件系统的类型       -x, --exclude-type=TYPE              只显示指定类型(TYPE)之外的文件系统.       -v (忽略)       --help 输出该命令的帮助信息并退出       --version              输出版本信息并退出             \n7.freefree - 显示系统中已用和未用的内存空间总和.\nfree 命令能够显示系统中物理上的空闲和已用内存，还有交换内存，同时，也能显示被内核使用的缓冲和缓存。这些信息是通过解析文件 /proc/meminfo 而收集到的。\n不带任何选项运行 free 命令会显示系统内存，包括空闲、已用、交换、缓冲、缓存和交换的内存总数。\n1free [参数]\n123456789-b 选项 以字节为单位显示内存总和; -k 选项(缺省的)以KB为单位显示; -m 选项以MB 为单位.-t 选项 显示 一个 总计行.-o  选项  禁止  &quot;buffer adjusted&quot; 行的显示. 除非 指定 free 从 (相应的)已用/未用的 内存 减去/加上 缓冲区内存.-s 使 free 以 delay 秒为间隔,  连续抽样显示.  delay  可以设置成浮点数,它用 usleep(3) 做 微秒级 延迟.-V 显示版本信息.\n\n十、用户和组管理命令1.susu命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。\n普通用户切换到root用户，可以使用su – 或su root,但是必须输入root密码才能完成切换。root用户切换到普通用户，可以使用su username,不需要输入任何密码即可完成切换。\n1su [选项] [-] [USER [参数]...]\n12345678910111213141516171819202122232425修改有效用户标识和组标识为USER的.-, -l, --login       使得shell为可登录的shell-c, --commmand=COMMAND       传递单个COMMAND给-c的shell.-f, --fast       传递-f给shell(针对csh或tcsh)-m, --preserve-environment       不重置环境变量-p     与-m同-s, --shell=SHELL       如果/etc/shells允许,运行SHELL.--help 显示帮助并退出--version       输出版本信息并退出单一的-意味着-l.如果没有给定USER,则假定为root.\n2.sudosudo - 以其他用户身份执行一条命令\nsudo命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。\nsudo 是一种权限管理机制，管理员可以给一些普通用户授权去执行一些 root 执行的操作，而不需要知道 root 的密码。\nsudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。\n12345678usage: sudo -h | -K | -k | -Vusage: sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user]            [command]usage: sudo [-AbEHknPS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p            prompt] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p            prompt] [-u user] file ...\n12345678910111213141516171819202122232425262728293031选项：  -A, --askpass               使用助手程序进行密码提示  -b, --background            在后台运行命令  -C, --close-from=num        关闭所有 &gt;= num 的文件描述符  -E, --preserve-env          在执行命令时保留用户环境  -e, --edit                  编辑文件而非执行命令  -g, --group=group           以指定的用户组或 ID 执行命令  -H, --set-home              将 HOME 变量设为目标用户的主目录。  -h, --help                  显示帮助消息并退出  -h, --host=host             在主机上运行命令(如果插件支持)  -i, --login                 以目标用户身份运行一个登录                              shell；可同时指定一条命令  -K, --remove-timestamp      完全移除时间戳文件  -k, --reset-timestamp       无效的时间戳文件  -l, --list                                               列出用户权限或检查某个特定命令；对于长格式，使用两次  -n, --non-interactive       非交互模式，不提示  -P, --preserve-groups                                    保留组向量，而非设置为目标的组向量  -p, --prompt=prompt         使用指定的密码提示  -r, --role=role             以指定的角色创建 SELinux 安全环境  -S, --stdin                 从标准输入读取密码  -s, --shell                 以目标用户运行                              shell；可同时指定一条命令  -t, --type=type             以指定的类型创建 SELinux 安全环境  -U, --other-user=user       在列表模式中显示用户的权限  -u, --user=user             以指定用户或 ID                              运行命令(或编辑文件)  -V, --version               显示版本信息并退出  -v, --validate              更新用户的时间戳而不执行命令  --                          停止处理命令行参数\nsudo配置文件sudo默认配置文件是/etc/sudoers ，一般使用Linux指定编辑工具visudo ，此工具的好处是可以进行错误检查。在添加规则不符合语法规则时，保存退出时会提示给我们错误信息；配置好后，可以用切换到您授权的普通用户下，通过sudo -l来查看哪些命令是可以执行的或禁止的；\n/etc/sudoers 文件中每行是一个规则，前面带有#号可以当作是注释的内容，并不执行；如果规则很长，可以写在多列上，可以用\\号来续行。\n/etc/sudoers 的规则可分为两类；一类是授权规则，另一类是别名定义；别名定义并不是必须的，但授权规则是必须的；\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[root@itcast ~]# cat /etc/sudoers## Sudoers allows particular users to run various commands as## the root user, without needing the root password.##该文件允许特定用户像root用户一样使用各种各样的命令，而不需要root用户的密码 #### Examples are provided at the bottom of the file for collections## of related commands, which can then be delegated out to particular## users or groups.## 在文件的底部提供了很多相关命令的示例以供选择，这些示例都可以被特定用户或  ## ## 用户组所使用  ## This file must be edited with the &#x27;visudo&#x27; command.## 该文件必须使用&quot;visudo&quot;命令编辑## Host Aliases#主机别名## Groups of machines. You may prefer to use hostnames (perhap using ## wildcards for entire domains) or IP addresses instead.## 对于一组服务器，你可能会更喜欢使用主机名（可能是全域名的通配符）## 或IP地址代替，这时可以配置主机别名  # Host_Alias     FILESERVERS = fs1, fs2# Host_Alias     MAILSERVERS = smtp, smtp2## User Aliases#用户别名## These aren&#x27;t often necessary, as you can use regular groups## (ie, from files, LDAP, NIS, etc) in this file - just use %groupname ## rather than USERALIAS## 这并不很常用，因为你可以通过使用组来代替一组用户的别名  # User_Alias ADMINS = jsmith, mikem## Command Aliases## These are groups of related commands...## 指定一系列相互关联的命令（当然可以是一个）的别名，通过赋予该别名sudo权限，  ## 可以通过sudo调用所有别名包含的命令，下面是一些示例## Networking#网络操作相关命令别名  Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig,  /sbin/mii-tool## Installation and management of software#软件安装管理相关命令别名  Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum## Services#服务相关命令别名 Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig## Updating the locate database#本地数据库升级命令别名  Cmnd_Alias LOCATE = /usr/sbin/updatedb## Storage#磁盘操作相关命令别名Cmnd_Alias STORAGE = /sbin/fdisk, /sbin/sfdisk, /sbin/parted, /sbin/partprobe, /bin/mount, /bin/umount## Delegating permissions#代理权限相关命令别名 Cmnd_Alias DELEGATING = /usr/sbin/visudo, /bin/chown, /bin/chmod, /bin/chgrp## Processes#进程相关命令别名Cmnd_Alias PROCESSES = /bin/nice, /bin/kill, /usr/bin/kill, /usr/bin/killall## Drivers#驱动命令别名Cmnd_Alias DRIVERS = /sbin/modprobe#环境变量的相关配置# Defaults specification## Disable &quot;ssh hostname sudo &lt;cmd&gt;&quot;, because it will show the password in clear. #         You have to run &quot;ssh -t hostname sudo &lt;cmd&gt;&quot;.#Defaults    requirettyDefaults    env_resetDefaults    env_keep = &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR \\                        LS_COLORS MAIL PS1 PS2 QTDIR USERNAME \\                        LANG LC_ADDRESS LC_CTYPE LC_COLLATE LC_IDENTIFICATION \\                        LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC \\                        LC_PAPER LC_TELEPHONE LC_TIME LC_ALL LANGUAGE LINGUAS \\                        _XKB_CHARSET XAUTHORITY&quot;## Next comes the main part: which users can run what software on## which machines (the sudoers file can be shared between multiple## systems).## 下面是规则配置：什么用户在哪台服务器上可以执行哪些命令（sudoers文件可以在多个系统上共享）## Syntax:##语法##      user    MACHINE=COMMANDS##  用户 登录的主机=（可以变换的身份） 可以执行的命令  #### The COMMANDS section may have other options added to it.## 命令部分可以附带一些其它的选项  #### Allow root to run any commands anywhere ## 允许root用户执行任意路径下的任意命令 root    ALL=(ALL)       ALL## Allows members of the &#x27;sys&#x27; group to run networking, software,## service management apps and more.# %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## 允许sys中户组中的用户使用NETWORKING等所有别名中配置的命令  ## Allows people in group wheel to run all commands# %wheel        ALL=(ALL)       ALL## 允许wheel用户组中的用户执行所有命令  ## Same thing without a password## 允许wheel用户组中的用户在不输入该用户的密码的情况下使用所有命令# %wheel        ALL=(ALL)       NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root## 允许users用户组中的用户像root用户一样使用mount、unmount、chrom命令 # %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom## Allows members of the users group to shutdown this system# %users  localhost=/sbin/shutdown -h now## 允许users用户组中的用户像root用户一样使用shutdown命令\nsudo命令别名规则别名规则定义格式如下\n123Alias_Type NAME = item1, item2, ...或者Alias_Type NAME = item1, item2, item3 : NAME = item4, item5\n别名类型（Alias_Type）：别名类型包括如下\n\nHost_Alias 定义主机别名；\nUser_Alias 用户别名，别名成员可以是用户，用户组（前面要加%号）\nRunas_Alias 用来定义runas别名，这个别名指定的是“目的用户”，即sudo 允许切换至的用户；\nCommand_Alias 定义命令别名；\n\n别名规则格式解析\nNAME 就是别名了，NMAE的命名是包含大写字母、下划线以及数字，但必须以一个大写字母开头，比如SYNADM、SYN_ADM或SYNAD0是合法的，sYNAMDA或1SYNAD是不合法的；\nitem 按中文翻译是项目，在这里我们可以译成成员，如果一个别名下有多个成员，成员与成员之间，通过半角逗号分隔；成员在必须是有效并事实存在的。什么是有效的呢？比如主机名，可以通过w查看用户的主机名（或ip地址），如果您只是本地机操作，只通过hostname 命令就能查看；用户名当然是在系统中存在 的，在/etc/paswd中必须存在；对于定义命令别名，成员也必须在系统中事实存在的文件名（需要绝对路径）；\nitem成员受别名类型 Host_Alias、User_Alias、Runas_Alias、Command_Alias 制约，定义什么类型的别名，就要有什么类型的成员相配。我们用Host_Alias定义主机别名时，成员必须是与主机相关相关联，比如是主机名（包括远程登录的主机名）、ip地址（单个或整段）、掩码等； 当用户登录时，可以通过w命令来查看登录用户主机信息；用User_Alias和 Runas_Alias定义时，必须要用系统用户做为成员；用 Cmnd_Alias 定义执行命令的别名时，必须是系统存在的文件，文件名可以用通配符表示，配置Cmnd_Alias时命令需要绝对路径；\n其中 Runas_Alias 和User_Alias 有点相似，但与User_Alias 绝对不是同一个概念，Runas_Alias 定义的是某个系统用户可以sudo 切换身份到Runas_Alias 下的成员；我们在授权规则中以实例进行解说；\n别名规则是每行算一个规则，如果一个别名规则一行容不下时，可以通过\\来续行；同一类型别名的定义，一次也可以定义几个别名，他们中间用:号分隔，\n3.","slug":"Linux操作系统（搬运）","date":"2024-07-01T00:00:00.000Z","categories_index":"","tags_index":"技术","author_index":"Gueason"},{"id":"85d3fedd41ce5b619a50d7691e9b44cb","title":"计算机组成原理408（搬运）","content":"第一章 计算机系统概述1.1 本章大纲要求与核心考点1.1.1 大纲内容(一) 计算机系统层次结构\n\n计算机系统的基本组成\n\n计算机硬件的基本结构\n\n计算机软件和硬件的关系\n\n计算机系统的工作原理\n“存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。\n\n\n(二) 计算机性能指标\n​        吞吐量、响应时间；\n​        CPU时钟周期、主频、CPI、CPU执行时间；\n​        MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。\n真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          计算机系统层次结构\n          6\n          0\n      \n      \n          计算机性能指标\n          9\n          2\n      \n  \n\n\n\n1.2 计算机系统简介1.2.1 计算机系统的概念和分类​        计算机系统由“硬件”和“软件”两大部分组成。\n\n“硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。\n\n“软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。\n\n\n​        计算机的软件通常又可以分为两大类：系统软件和应用软件。\n\n系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。\n应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。\n\n1.2.2 计算机的发展硬件的发展\n​        1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是”用电子管组成的电子数字积分机和计算机”。\n​        从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。\n硬件技术对计算机更新换代的影响\n\n\n\n\n\n代\n时间\n硬件技术\n速度（次/秒）\n\n\n\n\n一\n1946~1957\n电子管\n40, 000\n\n\n二\n1958~1964\n晶体管\n200, 000\n\n\n三\n1965~1971\n中、小规模集成电路\n1, 000, 000\n\n\n四\n1972~1977\n大规模集成电路\n10, 000, 000\n\n\n五\n1978~现在\n超大规模集成电路\n100, 000, 000\n\n\n\n\n摩尔定律\n​        集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。\n​        微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。\n​        摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。\n1.3 计算机系统的层次结构1.3.1 计算机系统的基本组成（一） 计算机硬件\n\n冯·诺依曼计算机\n\n​        冯·诺依曼在研究EDVAC计算机时提出了 “存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯•诺依曼计算机，其特点如下：\n\n采用“存储程序”的工作方式。\n\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。\n\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n\n指令和数据均用二进制代码表示。\n\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n\n\n\n\n计算机的功能部件\n\n\n存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。\n运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。\n控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n输入设备：用来输入原始数据和程序，如键盘、鼠标。\n输岀设备：用来输出计算机的处理结果，如显示器和打印机。\n\n​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。\n（二） 计算机软件\n\n软件的分类\n\n​        软件按其功能分类，可分为系统软件和应用软件。\n\n三个级别的计算机语言\n\n（1） 机器语言\n​        机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。\n（2） 汇编语言           \n​        汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。\n（3） 高级语言\n​        高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。\n​        由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。\n\n1.3.2 计算机硬件的基本结构​        典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。\n\n现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。\n\n图中各部件的功能是：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；\n存储器用来存放数据和程序；\n控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；\n输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。\n\n​        由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I/O设备(Input/Output equipment) 。\n​        这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I/O设备叫作外部设备。\n\n\n主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。\nALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。\nCU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。\n\n​        ALU和CU是CPU的核心部件。I/O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。\n1.3.3 计算机系统的多级层次结构​        从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：\n\n​    从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.4 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.5 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。\n​    （2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。\n​    （3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。\n​    （4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。\n2. 存储程序的基本思想​        “存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。\n\n\n程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；\n将PC的内容作为地址访问主存，取出指令；\n在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；\n当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。\n\n​        这样，计算机就可以周而复始地自动执行程序中的每一条指令了。\n3. 计算机硬件组成的细化说明\n​    （1）主存储器\n​        主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”存储字长“。\n​        主存中的每个存储单元有一个唯一的编号，叫做存储单元的”地址“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。\n​        为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。\n\nMAR（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。\nMDR（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。\n\n​    （2）运算器\n​        运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。\n\nACC： Accumulator，累加器；\nMQ： Multiplier-Quotient Register，乘商寄存器；\nX： 操作数寄存器\n\n​        这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：\n\n\n\n\n\n加法\n减法\n乘法\n除法\n\n\n\n\nACC\n被加数及和\n被减数及差\n乘积高位\n被除数及余数\n\n\nMQ\n——\n——\n乘数及乘积低位\n商\n\n\nX\n加数\n减数\n被乘数\n除数\n\n\n\n\n​        不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。\n​    （3）控制器\n​        控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。\nPC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。\nIR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。\n​        CU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。\n​    （4）I/O\n​        I/O 系统包括各种 I/O 设备及其相应的接口。每一种 I/O 设备都由 I/O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。\n4. 计算机硬件的工作过程​        总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：\n\n把程序和数据装入主存储器；\n从程序的起始地址运行程序；\n按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；\n用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。\n\n​        我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：\n​    （1）取指令： PC → MAR → M → MDR → IR\n​        根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。\n​    （2）分析指令： OP（IR） → CU\n​        指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。\n​    （3）执行指令：Ad（IR） → MAR → M → MDR → ACC\n​        取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。\n​    （4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC\n1.4 计算机性能指标1.4.1 主要性能指标\n机器字长\n\n​        机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。\n​        字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。\n\n指令字长：一条指令中包含的二进制代码的位数。\n存储字长：一个存储单元中存储的二进制代码的长度。\n\n​        指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。\n\n数据通路带宽\n\n​        数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。\n\n存储容量\n\n​        存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。\n​        主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。\n​                                                存储容量 = 存储单元个数 × 存储字长\n​        在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 216 = 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K=1024）；而如果 MDR 为32位， 那么主存的存储容量为 216 × 32 = 221 = 2Ｍ 位（1Ｍ=220）。\n​        现代计算机中常以字节的个数来描述容量的大小，一个字节（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 218 字节（Byte，简写为 B）表示，记作 218 B 或 256KB。\n​        同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G = 1KM = 230 ）。\n\n运算速度\n\n​        计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。\n1.5.2 专业术语解释​    吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n​    响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I/O操作等的时间）。\n​    主频（CPU 时钟频率）：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。\n​    CPU 时钟周期：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。\n​                                                            CPU 时钟周期 = 1 / 主频\n​    CPI：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。\n​    CPU 执行时间：运行一个程序所花费的时间。\n​                                                CPU 执行时间 = （指令数 × CPI）/ 主频\n​        对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。\n​        现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。\n​        MIPS：Million Instructions Per Second，每秒执行百万条指令的数目。\n​                                                            MIPS = 主频 /（CPI × 106）\n​        FLOPS：FLoating-point Operations Per Second，每秒执行浮点运算的次数。\n​        MFLOPS：百万次浮点运算每秒。 MFLOPS = 浮点操作次数 /（执行时间 * 106）\n​        GFLOPS：十亿次浮点运算每秒。 GFLOPS = 浮点操作次数 /（执行时间 * 109）\n​        TFLOPS：万亿次浮点运算每秒。 TFLOPS = 浮点操作次数 /（执行时间 * 1012）\n​        PFLOPS：千万亿次浮点运算每秒。 PFLOPS = 浮点操作次数 /（执行时间 * 1015）\n​        EFLOPS：百京次浮点运算每秒。 EFLOPS = 浮点操作次数 /（执行时间 * 1018）\n​        ZFLOPS：十万京次浮点运算每秒。 ZFLOPS = 浮点操作次数 /（执行时间 * 1021）\n​        需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB =  210 B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb/s = 103 b/s。\n1.5 章节练习一、单项选择题\n【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。\n\n​        A. 指令操作码的译码结果                B. 指令和数据的寻址方式\n​        C. 指令周期的不同阶段                    D. 指令和数据所在的数据单元\n​    答案： C\n\n【2015真题】计算机硬件能够直接执行的是 （  ）。\n\n​        I. 机器语言程序    II. 汇编语言程序    III. 硬件描述语言程序\n​        A. 仅 I             B. 仅 I、II            C. 仅 I、III            D. I、II、III\n​    答案： A\n\n【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。\n\n​        A. 汇编程序            B. 链接程序            C. 编译程序            D. 解释程序\n​    答案： C\n\n【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。\n\n​        A. 程序的功能都通过中央处理器执行指令实现            B. 指令和数据都用二进制表示，形式上无差别\n​        C. 指令按地址访问，数据都在指令中直接给出            D. 程序执行前，指令和数据需预先存放在存储器中\n​    答案： C\n\n【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。\n\n​        I. ALU        II. 指令寄存器        III. 通用寄存器        IV. 浮点寄存器\n​        A. 仅 I、II            B. 仅 I、III            C. 仅 II、III            D. 仅 II、III、IV\n​    答案： B\n\n【2010真题】下列选项中，能缩短程序执行时间的是（  ）。\n\n​        I. 提高 CPU 时钟频率    II. 优化数据通路结构    III. 对程序进行编译优化\n​        A. 仅 I 和 II            B. 仅 I 和 III            C. 仅 II 和 III            D. I、II、III\n​    答案： D\n\n【2011真题】下列选项中，描述浮点数操作速度的是（  ）。\n\n​        A. MIPS                    B. CPI                    C. IPC                    D. MFLOPS\n​    答案： D\n\n【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I/O 时间。若 CPU 速度提高 50%，I/O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。\n\n​        A. 55s                B. 60s                C. 65s                D. 70s\n​    答案： D\n\n【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。\n\n\n\n\n\n指令类型\n所占比例\nCPI\n\n\n\n\nA\n50%\n2\n\n\nB\n20%\n3\n\n\nC\n10%\n4\n\n\nD\n20%\n5\n\n\n\n\n​        该机的 MIPS 是 （  ）。\n​        A. 100                B. 200                C. 400                D. 600\n​    答案： C\n\n【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。\n\n​        A. 8.4s                B. 11.7s                C. 14s                D. 16.8s\n​    答案： D\n\n【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。\n\n​        A. 0.4                B. 0.625                C. 1.6                D. 2.5\n​    答案： C\n二、综合应用题\n说明机器字长、指令字长、存储字长的区别和联系。\n\n​    答案：\n​        机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。\n​        指令字长：一个指令字中包含二进制代码的位数。\n​        存储字长：一个存储单元存储二进制代码的长度。\n​        它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。\n\n用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 I）。\n|      指令类型      | CPI  | 指令混合比 || :————————: | :—: | :————: ||     算术和逻辑     |  1   |    60%     ||        转移        |  4   |    12%     || 高速缓存命中的访存 |  2   |    18%     || 高速缓存失效的访存 |  8   |    10%     |\n\n\n​    答案：\n​        CPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：\n​                        CPI = 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% = 0.6 + 0.48 + 0.36 +0.8 = 2.24\n​        MIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：\n​                                                    MIPS = 40 × 106 /（2.24 × 106 ）≈ 17.9\n​        程序的执行时间 T = 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：\n​                        T = CPI × 时钟周期 × 指令条数 = 2.24 ×（1 / 40MHz）× I = 5.6 × 10-8 × I  秒\n​        \n\n第二章 数据的表示和运算2.1 本章大纲要求与核心考点2.1.1 大纲内容（一）数制与编码\n\n进位计数制及其数据之间的相互转换\n定点数的表示和运算\n\n（二）运算方法和运算电路\n\n基本运算部件：加法器、算数逻辑部件（ALU）\n加/减运算：补码加/减运算器，标志位的生成\n乘/除运算：乘/除运算的基本原理，乘法电路和除法电路的基本结构\n\n（三）整数的表示和运算\n\n无符号整数的表示和运算\n有符号整数的表示和运算\n\n（四）浮点数的表示和运算\n\n浮点数的表示：IEEE 754标准\n浮点数的加/减运算\n\n2.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n真值、机器数，定点数的表示及原理\nC 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换\nALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法\nIEEE 754标准浮点数的表示和特点，浮点数的加/减运算方法\nC 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换\n数据按边界对齐方式的存储，数据按大端和小端方式存储\n\n2.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          定点数的表示与运算\n          10\n          8\n      \n      \n          IEEE 754标准浮点数，浮点数的运算\n          10\n          3\n      \n      \n          C语言中各种数据的转换\n          3\n          2\n      \n      \n          数据按边界对齐方式的存储，数据按大小端方式存储\n          4\n          0\n      \n  \n\n\n\n\n\n\n2.2 数制与编码2.2.1 进位计数制及其相互转换（一）进位计数制\n​        进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为基数；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。\n​        下表是十进制数、二进制数、十六进制数对照表。\n​        书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)16；八进制数后面加上“O”，如372O或(372)8；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)2。\n​                                        十进制数、二进制数、八进制数、十六进制数对照表\n\n\n\n\n十进制数\n二进制数\n八进制数\n十六进制数\n十进制数\n二进制数\n八进制数\n十六进制数\n\n\n\n\n0\n00000\n0\n0\n16\n10000\n20\n10\n\n\n1\n00001\n1\n1\n17\n10001\n21\n11\n\n\n2\n00010\n2\n2\n18\n10010\n22\n12\n\n\n3\n00011\n3\n3\n19\n10011\n23\n13\n\n\n4\n00100\n4\n4\n20\n10100\n24\n14\n\n\n5\n00101\n5\n5\n21\n10101\n25\n15\n\n\n6\n00110\n6\n6\n22\n10110\n26\n16\n\n\n7\n00111\n7\n7\n23\n10111\n27\n17\n\n\n8\n01000\n10\n8\n24\n11000\n30\n18\n\n\n9\n01001\n11\n9\n25\n11001\n31\n19\n\n\n10\n01010\n12\nA\n26\n11010\n32\n1A\n\n\n11\n01011\n13\nB\n27\n11011\n33\n1B\n\n\n12\n01100\n14\nC\n28\n11100\n34\n1C\n\n\n13\n01101\n15\nD\n29\n11101\n35\n1D\n\n\n14\n01110\n16\nE\n30\n11110\n36\n1E\n\n\n15\n01111\n17\nF\n31\n11111\n37\n1F\n\n\n\n\n​        计算机系统为什么要采用二进制？\n\n使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。\n二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。\n二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。\n\n\n（二）不同进制数的相互转换\n​        任意一个数 N，可以用 r 进制表示成下面的形式：\n​                                            N =（dn-1dn-2 … d1d0.d-1d-2 … d-m）\n​                                                = dn-1rn-1 + dn-2rn-2 + … + d1r1 + d0r0 + d-1r-1 + d-2r-2 + … + d-mr-m\n​                                                = ∑ diri\n​        其中，r 为基数；d 为系数，di 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；ri 叫做第 i 位上的权值。n、m 分别代表 N 的整数部分和小数部分的位数。\n（1）二进制和八进制、十六进制间的转换\n​        将二进制数1110011101.0010111转换为八进制数为：\n​                                                左侧补0                  分界点                右侧补0\n​                                                   ↓                         ↓                   ↓\n​                                                001 110 011 101 .  001 011 100\n​                                                 1       6     3      5  .    1      3      4\n​        所以 (1110011101.0010111)2 = (1635.134)8 ；\n​        同样道理，转换为十六进制数为：\n​                                                0011 1001 1101 .  0010 1110\n​                                                    3        9        D   .     2        E\n​        所以 (1110011101.0010111)2 = (39D.2E)16 ；\n\n二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。\n二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。\n八进制转换为二进制：每位都转换成对应的3位二进制数。\n十六进制转换为二进制：每位都转换成对应的4位二进制数。\n\n（2）任意进制数转换为十进制数\n​        任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 按权展开法。\n​        例如，将二进制数 11011.101 转换为十进制数为：\n​        (11011.101)2  = 1 × 24 + 1 × 23 + 0 × 22 + 1 × 21 + 1 × 20 + 1 × 2-1 + 0 × 2-2 + 1 × 2-3\n​                            = 27.625\n​        另一种方法是“按基数重复相乘/除法”，需要分整数部分和小数部分分别转换。\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n（3）十进制数转换为二进制数\n​        将十进制数转换为二进制数，一般采用 基数乘除法。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。\n\n整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）\n\n小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）\n\n\n​        例如，将十进制数 123.6875 转换为二进制数。\n​        整数部分：\n​          除2得商                            余数\n​        2 |123                …                1                最低位\n​          2  |61               …                1\n​           2 |30               …                0\n​           2 |15               …                1\n​            2  |7               …                1\n​            2  |3               …                1\n​            2  |1               …                1                最高位\n​            2  |0\n​        所以 (123)10 = (1111011)2\n​        小数部分：\n​          乘积取小数                                乘2得积                取整数部分\n​            0.6875                × 2                = 1.375                        1                        最高位\n​            0.375                  × 2                = 0.75                           0        \n​            0.75                    × 2                = 1.5                             1    \n​            0.5                      × 2                 = 1                                1                        最低位    \n​        所以 (0.6875)10 = (0.1011)2\n​        综合整数和小数部分，得到 (123.6875)10 = (1111011.1011)2\n​        另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：\n​        十进制数                位权                转换后的结果\n​            123                                            26    25    24    23    22    21    20\n​        ➖ 64                        26                1\n​              59\n​        ➖ 32                        25                        1\n​              27\n​        ➖ 16                        24                                1\n​              11\n​        ➖   8                        23                                        1\n​                3\n​        ➖   2                        21                                                        1\n​                1\n​        ➖   1                        20                                                                1\n​                0\n​        所以 (123)10 = (1111011)2 \n​        这种方法一般在转换很大的十进制数时比较方便。\n2.2.2 真值和机器数​        在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。\n​        对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。\n例如，一个有符号的小数：\n​                + 0.1011                在机器中表示为        0    1 0 1 1\n​                -  0.1011                在机器中表示为        1    1 0 1 1\n再比如，一个有符号的整数：\n​                + 1100                    在机器中表示为        0    1 1 0 0\n​                -  1100                    在机器中表示为        1    1 1 0 0\n​        把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。\n\n真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。\n机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。\n\n​        在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即定点表示和浮点表示。\n​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。\n​        在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。\n2.2.3 定点数及其编码表示​        小数点固定在某一位置的数为定点数，有以下两种格式。\n\n当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。\n​        在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。\n1. 无符号整数的表示​        当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 28-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。\n2. 带符号数的表示​        最高位用来表示符号位，而不再表示数值位。\n（1）定点整数\n​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。\n​        约定小数点在有效数值部分最低位之后。数据 x = x0x1x2…xn （其中 x0 为符号位，x1 ~ xn 是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：\n\n（2）定点小数\n​        约定小数点在有效数值部分最高位之前。数据 x = x0.x1x2…xn（其中 x0 为符号位，x1~xn 是尾数，x1 是最高有效位），在计算中的表示形式如下图所示：\n\n3. 原码、补码、反码和移码\n原码表示法\n\n​        用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:\n\n式子中 x 为真值，[ x ]原 表示原码机器数。\n​        类似，纯整数的原码定义如下：\n\n​    原码的性质：\n\n由符号位与数的绝对值组成，符号位是0为正、1为负\n\n0有 ±0 两个编码，即 [+0]原 = 00000 和 [-0]原 = 10000 \n\n\n\n补码表示法\n\n​        纯整数的补码定义为：\n\n​    这里 n 为整数的位数，真值 x 和补码机器数 [ x ]原 互为以 2n+1 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2n ≤ x ≤ 2n - 1，比原码多表示了一个数 -2n。\n​        补码的性质：\n\n补码和其真值的关系：[x]补 = 符号位 × 2n+1 + x\n0的编码唯一，因此整数补码比原码多1个数，表示 -2n\n符号位参与补码加减运算，统一采用加法操作实现\n将 [x]补 的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能\n\n​        例如，当 x = + 1010 时（n = 4），\n​        [x]补 = 0, 1010\n​        而当 x = - 1010 时，\n​        [x]补 = 2n+1 + x = 100000 - 1010 = 1, 0110\n​        补码和真值的转换：\n\n真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。\n补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。\n\n​        变形补码是采用双符号位的补码表示法，其定义为\n\n​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。\n\n反码表示法\n\n​        负数的补码可采用“数值位各位取反，末位加1”的方法得到，如果数值位各位取反而末位不加1，那么就是负数的反码表示。正数的反码定义和相应的补码（或原码）表示相同。\n​        反码表示存在以下几个方面的不足：0的表示不唯一（即存在±0）；表示范围比补码少一个最小负 数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。\n​        原码、补码、反码三种编码表示总结如下：\n\n三种编码的符号位相同，正数的机器码相同。\n\n原码和反码的表示在数轴上对称，二者都存在 ±0 两个零。\n\n补码的表示在数轴上不对称，0的表示唯一，补码比原码和反码多表示一个数。\n\n负数的反码、补码末位相差1。\n\n\n\n原码很容易判断大小。而负数的补码和反码很难直接判断大小，可采用这条规则快速判断：对于一个负数，数值部分越大，它的绝对值就越小，所以真值就越大（更靠近0）。\n\n\n移码表示法\n\n​        移码是在真值 x 上加上偏置值 2n 构成的，相当于 x 在数轴上向正方向偏移了若干单位。\n\n​    移码定义为:\n\n移码的性质：\n\n0的表示唯一， [+0]移 =  2n + 0 = [-0]移 = 2n - 0 = 100…0 \n符号位“1”表示正，“0”表示负，这与其他机器数正好相反。\n一个真值的移码和补码仅差一个符号位，[x]补 的符号位取反即得 [x]移，反之亦然。\n移码全0时，对应真值的最小值- 2n ；移码全1时，对应真值的最大值 2n -1。\n保持了数据原有的大小顺序，移码大真值就大，便于进行比较操作。\n移码常用来表示浮点数的阶码。它只能表示整数。\n\n2.2.4  C 语言中的整型数据类型\nC 语言中的整型数据简介\n\n​        C 语言中的整型数据就是定点整数，一般用补码表示。根据位数的不同，可以分为 字符型(char)、短整型(short)、整型(int)、长整型(long)。\n​        C 语言中的整型数据，可以分为 无符号整型 和 有符号整型 两种类型，在定义时只要加上 signed/unsigned 就可以明确指定了。\n​        char 是整型数据中比较特殊的一种，其他如 short/int/long 等都默认是带符号整数，但 char 默认是无符号整数。无符号整数（unsigned short/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\n​        signed/unsigned 整型数据都是按补码形式存储的，在不溢出条件下的加减运算也是相同的，只是 signed 型的最高位代表符号位，而在 unsigned 型中表示数值位，而这两者体现在输出上则分别是％d 和％u。\n\n有符号数和无符号数的转换\n\n​        C 语言允许在不同的数据类型之间做类型转换。C 语言的强制类型转换格式为“TYPE b = (TYPE) a”, 强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。\n​        先看由 short 型转换到 unsigned short 型的情况。考虑如下代码片段：\n123short x = -4321;unsigned short y = (unsigned short)x;\n​        执行上述代码后，x = -4321, y = 61215，得到的 y 似乎与原来的 x 没有一点关系。不过将这两个数转化为二进制表示时，我们就会发现其中的规律。\n​        通过本例可知：强制类型转换的结果是保持每位的值不变，仅改变了解释这些位的方式。有符号数转化为等长的无符号数时，符号位解释为数据的一部分，负数转化为无符号数时数值将发生变化。同理，无符号数转化为有符号数时，最高位解释为符号位，也可能发生数值的变化。\n\n不同字长整数之间的转换\n\n​        另一种常见的运算是在不同字长的整数之间进行数值转换。\n​        先看长字长变量向短字长变量转换的情况。考虑如下代码片段：\n123int x = 165537, u = -34991;                      //int型占用4字节short y = ( short )x, v = ( short )u;            //short型占用2字节\n​        执行上述代码后，x= 165537, y=-31071, u =-34991, v = 30545。x、y、u、v 的十六进制表示分别 是0x000286a1 0x86a1 . 0xffff7751、0x7751。由本例可知：长字长整数向短字长整数转换时，系统把多余的高位部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。\n​        最后来看短字长变量向长字长变量转换的情况。考虑如下代码片段:\n1234567short x = -4321;int y = (int)x;unsigned short u = (unsigned short)x;unsigned int v = (unsigned int)u;\n​        执行上述代码后，x = -4321, y = -4321, u = 61215, v = 61215。x、y、u、v 的十六进制表示分别是0xef1f. 0xffffef1f、0xef1f、0x0000ef1f。所以，短字长整数向长字长整数转换时，仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。\n​        从位值与数值的角度看，前3个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换可以理解为保证数值的相等。\n\n2.3 运算方法2.3.1 定点数的移位运算​        移位运算根据操作对象的不同，可以分为算术移位和逻辑移位。算术移位针对的是有符号数，逻辑移位针对的是机器码，可以看作无符号数。\n1. 算术移位​        算术移位的对象是有符号数，有符号数在计算机中采用补码表示。算术移位的特点是，移位后符号位保持不变；空出的位置根据正负和左右移位的情况，决定补 0 还是 1。\n\n对于正数，由于 [ x ]原 = [ x ]补 = 真值，因此移位后的空位均补 0。\n对于负数，算术左移时，高位移出，低位补 0；算术右移时，低位移出，高位补 1。\n\n​        可见，不论是正数还是负数，移位后其符号位均不变。\n​        例如，假设机器字长为 8，[4]补 = 0000 0100，[-4]补 = 1111 1100；\n\n将 4 算术左移一位，就得到了 0000 1000 = [8]补；算术右移一位，就得到了 0000 0010 = [2]补；\n\n将 -4 算术左移一位，就得到了 1111 1000 = [-8]补；算术右移一位，就得到了 1111 1110 = [-2]补；\n\n\n​        对于有符号数，左移一位若不产生溢出，相当于乘以2 （与十进制数左移一位相当于乘以10类似）; 右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。\n2. 逻辑移位​        逻辑移位不考虑符号位。\n​        移位规则：逻辑左移时，高位移出，低位补 0；逻辑右移时，低位移岀，高位补 0 。\n2.3.3 定点数的加减运算​        加减法运算是计算机中最基本的运算，由于减法可以看成是负值的加法，因此计算机中使用补码表示有符号数之后，可以将减法运算和加法运算合并在一起讨论。\n1. 补码的加减运算​        补码加减运算的规则简单，易于实现。补码加减运算的公式如下（设机器字长为 n）：​                                                                [A + B]补 = [A]补 + [B]补  (mod 2n)​                                                                [A - B]补 = [A]补 + [-B]补  (mod 2n)\n​        补码运算的特点如下：\n\n按二进制运算规则运算，逢二进一。\n如果做加法，两数的补码直接相加；如果做减法，则将被减数加上减数的机器负数。\n符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。\n最终将运算结果的高位丢弃，保留 n 位，运算结果也是补码。\n\n​        例如，假设机器字长为 8 （n = 8），那么\n​        [5]补 = 0000 0101，[4]补 = 0000 0100；\n​        [-5]补 = 1111 1011，[-4]补 = 1111 1100；\n​        [5 + 4]补 = 0000 0101 + 0000 0100 = 0000 1001 = [9]补；\n​        [5 - 4]补 = [5 + (-4)]补 = 0000 0101 + 1111 1100 = 1 0000 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0000 0100 + 1111 1011 = 1111 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1111 1011 + 1111 1100 = 1 1111 0111 = [-9]补；\n2. 溢出判别方法​        溢出 是指运算结果超出了数的表示范围。通常，大于能表示的最大正数称为正上溢，小于能表示的最小负数称为负上溢。仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。\n​        在之前的例子中，如果假设机器字长为 4（n = 4），能表示的有符号数范围为 -8 ~ 7，那么就有：\n​        [5]补 = 0101，[4]补 = 0100；\n​        [-5]补 = 1011，[-4]补 = 1100；\n​        [5 + 4]补 = 0101 + 0100 = 1001 = [-7]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 0101 + 1100 = 1 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0100 + 1011 = 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1011 + 1100 = 1 0111 = [7]补；        （负溢出）\n​        补码加减运算的溢出判断方法有以下 3 种：\n（1）采用一位符号位。\n​        参加操作的两个数符号相同，结果又与原操作数符号不同，就表示结果溢出。\n​        一正一负相加必然不会溢出；两正数相加得到一个负数（符号位为1），则正溢出；两负数相加得到一个正数，则负溢出。\n（2）采用双符号位。\n​        运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位就代表真正的符号。也就是说，符号位 S1S2 = 00 表示结果为正数，无溢出； S1S2 = 11 表示结果为负数，无溢出。 S1S2= 01 表示结果正溢出； S1S2 = 10 表示结果负溢出。溢出标志 OF = S1 ㊉ S2。\n​        比如上例中，如果采用双符号位，机器字长就应该扩展为 5，那么：\n​        [5]补 = 00 101，[4]补 = 00 100；\n​        [-5]补 = 11 011，[-4]补 = 11 100；\n​        [5 + 4]补 = 00 101 + 00 100 = 01 001 = [1]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 00 101 + 11 100 = 1 00 001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 00 100 + 11 011 = 11 111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 11 011 + 11 100 = 1 10 111 = [-1]补；        （负溢出）\n2.2.4 定点数的乘法运算1. 原码一位乘法​        原码乘法运算的符号位与数值位分开计算。\n\n确定乘积的符号位。由两个乘数的符号进行异或运算得到。\n计算乘积的数值位。两个乘数的数值部分之积，可看作两个无符号数的乘积。\n\n​        原码一位乘法的基本思路，就是类似竖式乘法的做法，让被乘数 x 分别乘以乘数 y 的每一位，然后再做叠加。不过竖式乘法需要做连加运算，这在电路实现上会有一些困难；改进的做法是，借鉴进制转换的“重复相乘/除法”，对每一位进行迭代计算。\n​        回忆一下二进制数转换成十进制数的重复相乘/除法：\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n​        所以，两数相乘时，就可以把乘数 y 用这种方式按每一位拆开，并乘以 x 、再逐位叠加就可以了。由于每次乘以 2 就相当于左移一位、除以 2 就相当于右移一位，因此只需要反复迭代这样的 移位 和 加法 运算就可以很容易地实现乘法了。\n\n原码一位乘法的运算规则如下：\n\n被乘数和乘数均取绝对值|x| 和 |y|参加运算，看作无符号数，符号位为 x0 ㊉ y0。\n乘数的每一位 yi 乘以被乘数 |x| 得到 |x| · yi，将该结果与前面所得的结果相加，作为部分积；初始值为 0。\n从乘数的最低位 yn 开始判断：若 yn = 1，则部分积加上被乘数 |x|，然后右移一位；若 yn = 0，则部分积加上 0，然后右移一位。\n重复上一步骤，判断 n 次。\n\n​        由于参与运算的是两个数的绝对值，因此运算过程中的右移操作均为逻辑右移。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 0.1011 = (0.6875)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 0.1101 × 0.1011 =  0.10001111 = (0.55859375)10\n\n2. 补码一位乘法​        带符号数的乘法，采用相加/相减的校正操作，直接计算补码数据的乘积。\n​        补码乘法是直接对补码进行的。对于纯整数，补码表达为：\n\n而类似的，纯小数补码定义为：\n\n所以，当取不同的正负符号时，补码表达会有所不同，继而影响到逐位相乘叠加的效果。\n​        已知 [ x ]补 = x0 . x1x2…xn，[ y ]补 = y0 . y1y2…yn，那么需要分不同的情况讨论：\n​        ① 被乘数 x 和乘数 y 符号均为正，即 x0 = y0 = 0 时，\n​        [ x ]补 = x，[ y ]补 = y，所以就有：\n\n类似原码一位乘法，利用移位和加法的叠加，就可以计算出补码的乘积；这也就是最终计算结果的补码。\n​        ② 被乘数 x 为正，乘数 y 为负，即 x0 = 0，y0 = 1 时，\n​        [ y ]补 = 1. y1y2…yn = 2 + y，所以：\n\n那么两数的乘积就可以写成：\n\n这样一个计算结果，它的补码表示为：\n\n​    可以看到，当乘数为负时，可以把乘数补码 [ y ]补 直接去掉符号位，当成一个正数与 [ x ]补 相乘；得到的结果再加上 [ -x ]补 进行校正。所以这种方法也叫做“校正法”。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 1.1011 = (-0.3125)10 时，计算 x · y。\n​        我们可以直接计算 0.1101 × 0.1011 = 0.10001111，再加上 [ -x ]补 = 1. 0011，得到 ：\n​         0.10001111 + 1. 0011 = 1.10111111 =  ( -0.25390625 )10\n\n​        ③ 被乘数 x 为负，乘数 y 为正，即 x0 = 1，y0 = 0 时，\n​        我们可以交换被乘数和乘数，直接按情况②来处理；也可以仔细分析，发现乘数 y 为正数，可以写成\n[ y ]补 = 0. y1y2…yn 的形式，同样可以借鉴情况②中的分析和原码一位乘的方法。当两数的补码相乘时：\n\n观察可以发现，与原码一位乘完全类似，补码相乘也可以将乘数展开，逐位进行相乘、右移和叠加。不过需要注意的是，这时由于被乘数 x 是负数，右移时就需要在左侧高位补 1，也就是做算术右移、而不是逻辑右移。\n​        这样一来，算术右移就实现了对真值 x 的“除以 2”操作，最终叠加之后的结果，就是 x · y 的补码了。\n​        例如，当 x = 1.1 = (-0.5)10，y = 0.011 = (0.375)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1 × 0.011 =  1.1101 = ( - 0.1875 )10        \n​        ④ 被乘数 x 和乘数 y 符号均为负，即 x0 = y0 = 1 时，\n​        通过情况②和③的分析可以看出，当乘数 y 为正时，可以直接按照原码一位乘的方式进行补码乘法，注意需要进行算术右移；而当乘数 y 为负时，则可以先不考虑 y 的符号位，同样按照原码一位乘进行补码乘法，最后的结果要再加上 [ -x ]补 进行校正。\n​        例如，当 x = 1.1 = (-0.5)10，y = 1.011 = (-0.625)10 时，计算 x · y。\n​        我们可以直接计算 1.1 × 0.011 =  1.1101，再加上 [ -x ]补 = 0.1，得到 ：\n​        1.1101 + 0.1 = 1 0.0101 =  ( 0.3125 )10\n​        可以看出，如果使用双符号位来表示正负，会更加方便。\n​        ⑤  Booth算法\n​        以上的 4 种情况需要分别讨论，根据乘数的符号来决定是否需要进行校正。\n​        如果不考虑操作数的符号，直接用统一的规则来处理所有情况，可以采用 Booth 算法。\n​        当被乘数 x 和乘数 y 符号任意时，按照之前讨论的校正法规则，可以写出一个统一的计算公式：\n\n​    容易推出，对于纯小数，在 mod 2 的前提下，[ -x ]补 = - [ x ]补，所以可以进一步推导得到：\n\n​    令 yn+1 = 0，那么就可以得到一个通项系数： di = yi+1 - yi ，上式可以进一步化简为：\n\n这样一来，补码乘法的计算方式就跟原码一位乘完全一样了，只是被乘数每次乘的不再是乘数 y 的每一位 yi，而是变成了 di = yi+1 - yi 。这样就有 1、-1 和 0 三种情况，每一次计算都由 di 来决定部分积叠加的是 [ x ]补、[ -x ]补 还是 0；然后再做一位算术右移得到新的部分积。最后一步，需要由 d0 = y1 - y0 决定是否有叠加项，但不再做位移。\n​        Booth 算法的移位规则如下表所示：\n\nBooth 算法的具体运算规则如下：\n①    符号位参与运算，运算的数均以补码表示。\n②    被乘数一般取 双符号位 参与运算，部分积取 双符号位，初值为 0，乘数取单符号位。\n③    乘数末尾增加一个“附加位” yn+1，初始值为 0。\n④    根据（yi，yi+1）的取值来确定操作，如上表所示。\n⑤    移位按补码右移规则（算术右移）进行。\n⑥    按照上述算法进行 n + 1 步操作，但第 n + 1 步不再移位，仅根据 y0 （符号位）与 y1 （第一位数值位）的比较结果做相应的叠加运算。所以总共需要进行 n + 1 次累加和 n 次右移。\n\n​        例如，当 x = 1.1101 = (-0.1875)10，y = 1.1011 = (-0.3125)10  时，计算 x · y。\n​        首先得到 [x]补 = 11.1101，[-x]补 = 00.0011。具体计算步骤如下：\n\n同样，最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1101 × 1.1011 =  0.00001111 = (0.05859375)10\n2.2.5 定点数的除法运算1. 原码一位除法（1）恢复余数法\n​        恢复余数法的特点是：当余数为负时，需要加上除数的绝对值，将其恢复成原本的余数。\n​        由于每次得到的是商的高位，所以每轮计算可以将余数和商同时左移一位；余数加上 [- y]补 ，判断正负来决定下一位商是 1 还是 0；如果为负，还需要先加上 [y]补 恢复余数，然后再做左移。\n\n​        例如，当 x = (-0.1011)2  = (-0.6875)10，y = (-0.1101)2 = (-0.8125)10 时，计算 x / y。\n​        首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x = 0.1011，y= 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x/ y = 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n溢出判断：当该位为 1 时，表示当前除法溢出，不能进行；当该位为 0 时，当前除法合法，可以进行。\n（2）不恢复余数法（加减交替法）\n​        在恢复余数法中，每当余数为负时都需要恢复余数，这就增加了运算量，操作也不规则，电路实现会比较复杂。加减交替法就克服了这一缺点。\n​        加减交替法 又称 不恢复余数法，是对恢复余数法的一种改进。\n​        通过分析恢复余数法可以发现，如果把第 i 轮计算的余数记作 Ri，那么：\n\n如果 Ri &gt; 0，就上商 1，接下来需要将余数 Ri 左移一位，再减去除数绝对值 y，即 2Ri - y；\n如果 Ri &lt; 0，就上商 0，接下来先加上 y 恢复余数，再做左移和减法，即 2 (Ri + y) - y = 2Ri + y。\n\n​        这样一来，就不需要额外恢复余数了，每轮计算的规则完全统一起来，只是左移之后再加/减 y^*^ 就可以了；所以把这种方法叫做“加减交替法”，或者“不恢复余数法”。\n\n​        还是上面的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        同样的步骤，首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x= 0.1011，y = 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x / y= 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n2. 补码一位除法（加减交替法）\n补码一位除法的运算规则如下：\n\n符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。\n如被除数与除数同号，则被除数减去除数；如被除数与除数异号，则被除数加上除数。\n余数与除数同号，商上1，余数左移一位再减去除数；余数与除数异号， 商上 0，余数左移一位再加上除数。\n重复执行上一步操作，操作 n 次。\n如果对商的精度没有特殊要求，一般采用“末位恒置 1”法。\n\n​    同样的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        首先得到： [x]补 = 1.0101，[y]补 = 1.0011，[-y]补 = 0.1101\n​        具体计算过程如下：\n\n所以商值为\n​        x / y = 0.1101\n2.4 浮点数的表示和运算2.4.1 浮点数的表示浮点数 就是小数点的位置可以浮动的数。例如：\n​        365.242 = 3.65242 × 10^2^\n​                       = 365242.0 × 10^-3^\n​                       = 0.365242 × 10^3^\n1. 浮点数的表示格式​        在计算机中，浮点数的格式如下图所示。采用这种数据格式的机器称为 浮点机。\n\n​    浮点数由 阶码 j 和 尾数 S 两部分组成。\n\n阶码是纯整数，阶符和阶码值合起来决定了小数点的实际位置；阶码值的位数 m 再结合阶符，可以反映浮点数的表示范围。\n尾数是纯小数，数符 Sf代表了浮点数的正负，而尾数值则是有效数位，位数 n 反映了浮点数的精度。\n\n2. 浮点数的表示范围​        假设浮点数 N 的阶码 j 数值部分有 m 位，尾数 S 数值部分有 n 位。\n​        阶码是纯整数，尾数是纯小数，它们可以各自选择编码方式。对于非规格化的浮点数，如果阶码和尾数都用原码表达，各自的取值范围如下：\n\n​        那么阶码 j 和尾数 S 组合之后，能表示的浮点数最大范围就是：\n\n在数轴上表示出来，如下图所示：\n\n原码是关于原点对称的，所以浮点数的表示范围也是关于原点对称的。\n​        当运算结果大于能表示的最大正数时，称为正上溢；小于最小负数时。称为负上溢：两者统称 上溢。由于尾数的溢出可以通过移位、增加阶码来调整，因此上溢的本质就是 阶码大于最大阶码，这时机器会停止计算，进行中断溢出处理。\n​        当运算结果在 0 至最小正数之间时，称为正下溢；在 0 至最大负数之间时，称为负下溢，统称 下溢。同样道理，下溢的本质是 阶码小于最小阶码，这时溢出的数值绝对值非常小，通常可以将尾数各位直接强置为 0，按 ”机器零“ 来处理，机器可以继续正常运行。\n​        类似地，如果阶码和尾数都用补码表达，各自的取值范围如下：\n\n​    用移码来表示阶码方便进行阶数的比较和对齐，简称 “对阶”。这在进行浮点数加减运算时非常重要，尾数只有在阶数相同的时候才能做加减，采用移码直接比较两个阶码的二进制大小关系就可以了：\n\n3. 浮点数的规格化​        由于规格化数的精度最高，所以当一个非零的浮点数不是规格化数时，应该通过左右移动尾数、并同时修改阶码的方法，将它转换为规格化数。把一个非规格化数转换成规格化数的过程，叫做 规格化。\n​        规格化的本质类似于 “科学计数法” 的表达，通过保证尾数最高数位上是一个有效值，尽可能多地保留有效数字的尾数，从而提高精度。\n​        规格化可以分为 “左规” 和 “右规” 两种。以基数 r = 2 为例：\n\n左规：向左规格化。当运算结果尾数的最高数位不是有效位，即出现 0.0…01… 的形式时，需要向左规格化。左规时，尾数左移一位，阶码减 1；\n右规：向右规格化。当运算结果尾数的小数点左侧出现有效位，即整数部分不为 0 时，需要向右规格化。右规时，尾数右移一位，阶码加 1；需要右规时，只需进行一次。\n\n​        当基数不同时，规格化的原则会有相应的改变。比如，当基数 r = 4 时，阶码每次加/减 1，就相当于多乘/除以 4，也就是左/右移 2 位。所以左规就是尾数左移 2 位，阶码减 1；右规是尾数右移 2 位，阶码加 1。尾数的最高 2 位不全为 0 的数，就是规格化数。\n\n4. IEEE 754 标准浮点数​        在现代计算机中，浮点数的格式一般采用 IEEE 制定的国际标准。IEEE 754 标准规定的浮点数形式为：\n\n\nS 为数符，直接表示浮点数的正负，它与尾数所表示的有效数位是分开的。\n阶码 E 包含了阶符，用移码来表示，不过这里移码的偏移量不是 2 的整次幂，而是要再减去 1。 假设阶码 E 的位数为 m + 1，那么偏移量就是 2^m - 1。\n尾数 M 是原码表示的纯小数。\n\n​        浮点数的位数不同，可以表示不同的数值范围和精度。IEEE 标准中常用的浮点数有三种：短浮点数（单精度）、长浮点数（双精度）和临时浮点数（延伸双精度）。\n\n​    以 32 位的单精度浮点数为例，所有的机器码和对应的取值范围如下：\n\n\n​    例如，对于十进制数 178.125，把它写成 IEEE 标准的短浮点数。\n​        我们需要分整数部分和小数部分，首先转换成二进制数的表示；然后写成类似 “科学计数法” 的二进制浮点数表达。\n\n​    这是一个正数，符号位为 0；然后从二进制浮点表达中得到阶码和尾数。将 8 位二进制阶码加上偏移量 127，尾数隐藏整数位的 1 后补成 23 位，就是最终符合 IEEE 标准的 32 位短浮点数。\n\n​    \n2.4.2 浮点数的加/减运算​    （1）对阶\n​        对阶的目的是使两个操作数的小数点位置对齐，使两个数的阶码相等。先求阶差，然后以 “小阶向大阶看齐” 的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。\n​    （2）尾数求和\n​        将对阶后的尾数，按定点数加/减运算规则运算。\n​    （3）规格化\n​        IEEE 754 规格化尾数的形式为 ±1.×…×，所以当计算结果为非规格化数时，需要进行规格化处理。\n\n左规：当结果为 ±0.0…01x…x 时，需进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1移到小数点左边。\n右规：当结果为 ±1x.x…x 时，出现了尾数的溢出，需进行右规。尾数右移一位，阶码加 1。当尾数右移时，最高位 1 被移到小数点前一位作为隐藏位；当最后一位移出时，要考虑舍入。\n\n​        左规一次相当于乘以2，右规一次相当于除以2；需要右规时，只需进行一次。\n​    （4）舍入\n​        在对阶和尾数右规时，尾数右移可能会将低位丢失，影响精度，IEEE 754有以下4种舍入方式：\n\n就近舍入：舍入为最近的那个数，类似于 “四舍五入”，一般被叫做 “ 0 舍 1 入” 法；如果被舍入的值恰好是 100…0 形式，选择舍入为最近的偶数；\n正向舍入：向 +∞ 方向舍入，即取右边那个数，也叫 “向上舍入”；\n负向舍入：向 -∞ 方向舍入，即取左边那个数，也叫 “向下舍入”；\n截断：朝 0 方向舍入，即取绝对值较小的那个数。\n\n​    （5）溢出判断\n​        浮点数的溢出，并不是以尾数溢岀来判断的；尾数溢出可以通过右规操作得到纠正。运算结果是否溢出，主要看结果的指数是否发生了溢出，因此是由阶码来判断的。\n\n若一个正阶码超出了最大允许值（127 或 1023），则发生上溢，产生异常；\n若一个负阶码超出了最小允许值（-149 或 -1074），则发生下溢，通常把结果按机器零处理。\n\n\n​        例如，两个数 x = 29/32 × 210，y = 5/8 × 25，用浮点加法计算 x + y。假设浮点数的阶码和尾数均用补码表示，且阶码为 5 位（含 2 位阶符），尾数为 7 位（含 2 位数符）。\n​        首先，将浮点数写成下面的规格化二进制形式：\n​        x = 0.11101 × 2111，y = 0.101 × 2101\n​        具体计算过程如下：\n​        （1）对阶\n​        阶码相减 00, 111 - 00, 101 = 00, 010，说明 x 的阶码比 y 的大 2，需要将 y 的尾数右移两位，阶码加 2：\n​        y = 0.00101 × 2111\n​        （2）尾数求和\n​        尾数相加 00.11101 + 00.00101 = 01.00010\n​        （3）规格化\n​        运算结果的尾数出现溢出，需要进行右规：尾数右移一位，阶码加 1：\n​        1.00010 × 22111 = 0.100010 × 221000，即计算结果为 01, 000; 00, 10001\n​        （4）舍入\n​        结果的尾数用补码表示为：00 10001，不需要舍入。\n​        （5）溢出判断\n​        结果的阶码用补码表示为：01 000，由于阶符为 01，说明结果溢出。\n\n2.5 数据的存储和排列2.5.1 数据按“边界对齐”方式存储​        可以假设字长为 32 位，可按字节、半字、字寻址。在对准边界的 32 位计算机中，半字地址是 2 的整数 倍，字地址是 4 的整数倍，当所存数据不满足此要求时，可填充一个或多个空白字节。这种存储方式称为 “边界对齐” 。这样无论所存的数据是字节、半字还是字，均可一次访存取出。虽然浪费了一些存储空间，但可提高存取速度。\n​        数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能取得所需数据，从而影响系统的效率。\n\n\n在 C 语言的 struct 类型中，边界对齐方式存储有两个重要要求：\n​        （1）每个成员按其类型的方式对齐，比如 char 类型的对齐值为 1，short 为 2，int 为 4（单位为字节）。\n​        （2）struct 的长度必须是成员中最大对齐值的整数倍（不够就补空字节），以便在处理 struct 数组时保证每项都满足边界对齐的条件。\n​        例如，下面是两个成员完全一样的结构体：\n12345678910struct A &#123;\tint i;\tchar c;\tshort s;&#125;struct B &#123;\tchar c;\tint i;\tshort s;&#125;\n​        但两者在内存中占据的空间却不同。这是因为结构体成员是按定义的先后顺序排列的，编译器要使它们在空间上对齐，所以应该有：\n​        每个成员存储的起始地址 ％ 该成员的长度 = 0\n​        同时，还需要让结构体的长度是最大成员长度的整数倍。\n\n2.5.2 数据的“大端方式”和“小端方式”存储​        在存储数据时，通常用 最低有效字节（LSB）和 最高有效字节（MSB）来分别表示数据的低位和高位。例如，在 32 位机器中定义了一个 int 类型的变量 i，机器数为 18 0B C5 F3H，那么它的 MSB = 18H，LSB = F3H。\n​        现代计算机基本都采用字节编址，也就是每个地址编号对应存放 1 个字节。不同类型的数据占用的字节数不 同，而程序中对每个数据只给定一个地址。变量 i 占据连续的四个字节，它们各有一个内存地址，而变量 i 的地址就是开始的那个字节的地址。假设 i 的地址为 6C 00H，那么 i 具体存放的四个字节的地址就是：6C 00H、6C 01H、6C 02H、6C 03H。而具体每个字节存放什么内容，可以有不同的定义方式。\n​        多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，分为两种排列方式：大端方式（big endian）和 小端方式（little endian）。\n\n\n大端方式：先存储高位字节，后存储低位字节。高位字节存储在低位地址中，字中的字节顺序和原序列相同。\n\n\n小端方式：先存储低位字节，后存储高位字节。低位字节存储在低位地址中，字中的字节顺序和原序列相反。\n\n2.6 章节练习一、单项选择题​    1. 【2018真题】冯·诺伊曼结构计算机中的数据采用二进制编码表示，其主要原因是（  ）。\n​        I. 二进制的运算规则简单                II. 制造两个稳态的物理器件较容易\n​        III. 便于用逻辑门电路实现算术运算\n​        A. 仅 I、II                B. 仅 I、III                C. 仅 II、III                D. I、II 和 III\n​        答案： D\n\n【 2015真题】由 3个“1”和 5个“0”组成的8位二进制补码，能表示的最小整数是  （   ）。\n\n​        A． -126                B． -125                C． -32                D． -3\n​        答案：B\n\n【2022真题】32 位补码所能表示的整数范围是    （   ）。\n\n​        A. -232~231-1         B. -231~231-1         C. -232~232-1         D. -231~232-1 \n​        答案：B\n\n【2021真题】已知带符号整数用补码表示，变量 x、y、z 的机器数分别为 FFFDH、FFDFH、7FFCH，下列结论中，正确的是    （   ）。\n\n​        A. 若x、y和z为无符号整数,则z&lt;x&lt;y        B. 若x、y和z为无符号整数,则x&lt;y&lt;z\n​        C. 若x、y和z为带符号整数,则x&lt;y&lt;z        D. 若x、y和z为带符号整数,则y&lt;x&lt;z\n​        答案：D\n​    5. 【2016真题】有如下 C 语言程序段 \n12short si = -32767;unsigned short usi = si;\n​        执行上述两条语句后， usi 的值为     （   ）。\n​        A． -32767         B． 32767         C． 32768         D． 32769 \n​        答案：D\n​    6. 【2019真题】考虑以下 C 语言代码： \n12unsigned short usi = 65535;short si = usi;\n​        执行上述程序段后， si 的值是     （   ）。 \n​        A．-1         B．-32767         C．-32768         D．-65535 \n​        答案：A\n​    7. 【2012真题】假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，执行下列 C 语言语句： \n12unsigned short x=65530;unsigned int y=x;\n​        得到 y 的机器数为     （   ）。\n​        A． 0000 7FFAH       B． 0000 FFFAH         C． FFFF 7FFAH         D． FFFF FFFAH\n​        答案：B\n\n【2009真题】一个 C 语言程序在一台 32 位机器上运行。程序中定义了三个变量 x、 y 和 z，其中 x 和 z 为 int 型， y 为 short 型。当 x=127， y=-9 时，执行赋值语句 z=x+y 后， x、 y 和 z 的值分别是 （   ）。\n\n​    A． x=0000007FH， y=FFF9H， z=00000076H            B． x=0000007FH， y=FFF9H， z=FFFF0076H​    C． x=0000007FH， y=FFF7H， z=FFFF0076H            D． x=0000007FH， y=FFF7H， z=00000076H \n​    答案：D\n​    9. 【2018真题】整数x的机器数为1101 1000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各    是    （   ）。\n​    A.1110 1100、1110 1100                B. 0110 1100、1110 1100\n​    C.1110 1100、0110 1100                D. 0110 1100、 01101100\n​    答案：B\n\n【2013真题】某字长为 8 位的计算机中，已知整型变量 x、y的机器数分别为$[x]_补=1 {\\quad} 1110100，[y]补=1 {\\quad}0110000$。若整型变量 $z=2*x+y/2$，则 z 的机器数为    （   ）。\n\n​    A.  1 1000000            B.  0 0100100            C.  1 0101010            D.  溢出\n​    答案：A\n\n【2018真题】假定带符号整数采用补码表示，若 int 型变量 x 和 y 的机器数分别是 FFFF FFDFH 和 0000 0041H，则 x、y 的值以及 x-y 的机器数分别是    （   ）。\n\n​    A.x=-65，y=41，x-y 的机器数溢出                                B.x=-33，y=65，x-y 的机器数为FFFF FF9DH\n​    C.x=-33，y=65，x-y 的机器数为FFFF FF9EH                D. x = -65，y = 41，x-y 的机器数为FFFF FF96H \n​    答案：C\n\n【2016真题】某计算机字长为 32 位，按字节编址，采用小端（Little Endian）方式存放数据。假定有一个 double 型变量，其机器数表示为 1122 3344 5566 7788H，存放在 0000 8040H 开始的连续存储单元中，则存储单元 0000 8046H 中存放的是     （   ）。\n\n​    A． 22H                     B． 33H                     C． 66H                     D． 77H \n​    答案：A\n\n【2018真题】某32位计算机按字节编址，采用小端(Little Endian)方式。若语句 “inti=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00 00”，则语句 “int i = -64;” 对应指令的机器代码是    （   ）。\n\n​    A.C7 45 FC C0 FF FF FF        B.C7 45 FC 0C FF FF FF        C.C7 45 FC FF FF FF C0        D.C7 45 FC FF FF FF 0C\n​    答案：A\n\n【2012真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 型和 short型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下： \n\n123456struct&#123;\tint a;\tchar b;\tshort c;&#125; record;record.a=273;\n​        若 record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址分别为     （   ）。\n​    A. 0x00、 0xC00D         B. 0x00、 0xC00E        C. 0x11、 0xC00D         D. 0x11、 0xC00E \n​    答案：D\n\n【2020真题】在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C语言结构型变量a分配存储空间。\n\n1234Struct record&#123;\tshort   x1;\tint   x2;&#125; a;\n​        若a的首地址为 2020 FE00H，a的成员变量x2的机器数为1234  0000H，则其中34H所在存储单元的地址是    （   ）。\n​    A. 2020 FE03H                B. 2020 FE04H                C.2020 FE05H                D. 2020 FE06H\n​    答案：D\n\n【2012真题】 float 类型（即 IEEE754 单精度浮点数格式）能表示的最大正整数是     （   ）。\n\n​    A． 2126-2103               B． 2127-2104               C． 2127-2103               D． 2128-2104\n​    答案：D\n\n【2013真题】某数采用 IEEE 754 单精度浮点数格式表示为C640 0000H，则该数的值是    （   ）。\n\n​    A. $-1.5×2^{13}$                B. $-1.5 × 2^{12}$                C. $-0.5×2^{13}$                D. $-0.5×2^{12}$\n​    答案：A\n\n【2014真题】ﬂoat 型数据常用 IEEE 754 单精度浮点格式表示。 假设两个 ﬂoat 型变量 x 和 y 分别存放在32位寄存器 f1 和 f2 中，若(f1)=CC90 0000H, (f2)= B0C0 0000H, 则 x 和 y 之间的关系为    （   ）。\n\n​    A. xy且符号相同           D. x&gt;y且符号不同\n​    答案：A\n\n【2015真题】下列有关浮点数加减运算的叙述中，正确的是    （   ）。Ⅰ ．对阶操作不会引起阶码上溢或下溢Ⅱ ．右规和尾数舍入都可能引起阶码上溢Ⅲ．左规时可能引起阶码下溢Ⅳ．尾数溢出时结果不一定溢出\n\n​    A．仅Ⅱ 、 Ⅲ                 B． 仅Ⅰ 、 Ⅱ 、 Ⅳ                C．仅Ⅰ 、 Ⅲ、 Ⅳ                D． Ⅰ 、 Ⅱ 、 Ⅲ、 Ⅳ \n​    答案： D\n\n【2018真题】IEEE 754 单精度浮点格式表示的数中，最小的规格化正数是    （   ）。\n\n​    A.1.0x2-126                    B. 1.0x2-127                    C.1.0x2-128                    D.1.0x2-149\n​    答案：A\n\n【2020真题】已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H时，x 的值可能是    （   ）。\n\n​    A.-7x227                        B.-216                        C. 217                        D. 25x227\n​    答案：A\n\n【2021真题】下列数值中,不能用 IEEE 754 浮点格式精确表示的是    （   ）。\n\n​    A.1.2                                B.1.25                                C.2.0                                    D.2.5\n​    答案：A\n\n【2022真题】-0.4375 的 IEEE 754 单精度浮点数表示为（ ）。\n\n​    A. BEE0 0000H             B. BF60 0000H             C. BF70 0000H             D. C0E0 0000H \n​    答案：A\n二、综合应用题\n【2020真题】有实现 x*y 的两个 C 语言函数如下:\n\n12unsigned umul (unsigned x, unsigned y)&#123;return x*y; &#125;int imul (int x,int y) &#123;return x* y;&#125;\n​    假定某计算机 M 中 ALU 只能进行加运算和逻辑运算。请回答下列问题。\n​    （1）若 M 的指令系统中没有乘法指令，但有加法、减法和位移等指令，则在 M 上也能实现上述两个函数中的乘法运算，为什么?\n​    （2）若 M 的指令系统中有乘法指令，则基于 ALU、位移器、寄存器以及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么?\n​    （3）针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令；c）有使用阵列乘法器实现的乘法指令，函数 umul() 在哪种情况下执行时间最长？哪种情况下执行的时间最短？说明理由。\n​    （4）n 位整数乘法指令可保存 2n 位乘积，当仅取低 n 位作为乘积时，其结果可能会发生溢出。当 n=32、x=231-1、y=2 时，带符号整数乘法指令和无符号整数乘法指令得到的 x*y 的 2n 位乘积分别是什么（用十六进制表示）？此时函数 umul() 和 imul() 的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低 n 位作为乘法结果时，如何用 2n 位乘积进行溢出判断？\n​    答案：\n​    （1）编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法、移位等指令实现乘法运算。\n​    （2）控制逻辑的作用为： 控制循环次数，控制加法和移位操作。\n​    （3）a）最长， c）最短。\n​        对于 a）， 需要用循环代码段（软件）实现乘法操作，因而需反复执行很多条指令， 而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长； 对于 b）和 c）， 都只要用一条乘法指令实现乘法操作，不过， b）中的乘法指令需要多个时钟周期才能完成，而 c）中的乘法指令可以在一个时钟周期内完成， 所以 c）执行时间最短。\n​    （4）当 n=32、 x=231-1、 y=2 时，带符号整数和无符号整数乘法指令得到的 64 位乘积都为 0000 0000 FFFF FFFEH。\n​        函数 imul 的结果溢出，而函数 umul 结果不溢出。对于无符号整数乘法，若乘积高 n 位全为 0， 则不溢出，否则溢出。\n【2017真题】 已知\n\n计算 f(n) 的 C 语言函数 f1 如下： \n12345678int f1(unsigned n)&#123;\tint sum=1, power=1;\tfor(unsigned i=0;i&lt;=n-1;i++)&#123;\t\tpower *= 2;\t\tsum += power;\t&#125;\treturn sum;&#125;\n​        将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位， float 采用 IEEE 754 单精度标准。请回答下列问题。\n​    （1）当 n=0 时， f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为什么？\n​    （2）f1(23) 和 f2(23) 的返回值是否相等？机器数各是什么（用十六进制表示）？\n​    （3）f1(24)和 f2(24)的返回值分别为 33 554 431 和 33 554 432.0， 为什么不相等？\n​    （4）f(31)=232-1， 而 f1(31) 的返回值却为 -1，为什么？若使  f1(n) 的返回值与 f(n) 相等，则最大的 n 是多少？\n​    （5）f2(127) 的机器数为 7F80 0000H， 对应的值是什么？若使 f2(n) 的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？ \n​        答案：\n​    （1）由于 i 和 n 是 unsigned 型，故“i&lt;=n-1”是无符号数比较； n=0 时， n-1 的机器数为全1，值是 232-1，为 unsigned 型可表示的最大数，条件“i&lt;=n-1”永真，因此出现死循环。\n​        若 i 和 n 改为 int 类型，则不会出现死循环。因为“i&lt;=n-1”是带符号整数比较， n=0 时， n-1 的值是-1，当 i=0 时条件“i&lt;=n-1”不成立，此时退出 for 循环。\n​    （2）f1(23)与 f2(23)的返回值相等。\n​        f(23) = 223+1-1 = 224-1，它的二进制形式是 24 个1。 int 占 32 位，没有溢出。 float 有 1 个符号位， 8 个指数（阶码）位， 23 个底数（尾数）位， 23 个底数位可以表示 24 位的底数。所以两者返回值相等。\n​        f1(23)的机器数是 00FF FFFFH；f2(23)的机器数是 4B7F FFFFH。显而易见前者是 24 个 1，即 0000 0000 1111 1111 1111 1111 1111 1111（2），后者符号位是 0，指数位为 23+127(10) = 1001 0110（2），底数位是 111 1111 1111 1111 1111 1111（2）。\n​    （3）当 n=24 时， f(24) = 1 1111 1111 1111 1111 1111 1111 B，而 float 型数只有 24 位有效位，舍入后数值增大，所以 f2(24) 比 f1(24) 大 1。\n​    （4）f(31) 已超出了 int 型数据的表示范围，用 f1(31) 实现时得到的机器数为 32 个 1，作为 int 型数解释时其值为-1，所以 f1(31) 的返回值为-1。 \n​        因为 int 型最大可表示数是 0 后面加 31 个 1，故使 f1(n)的返回值与 f(n)相等的最大 n 值是 30。\n​    （5） f2 返回值为 float 型，7F80 0000H 中数符为0，阶码全为1，尾数为0。IEEE 754 标准用“阶码全 1、尾数全 0”表示无穷大。所以机器数 7F80 0000H 对应的值是+∞。\n​        当 n=126 时， f(126) = 2127-1 = 1.1…1×2126，对应阶码为 127+126=253，尾数部分舍入后阶码加 1，最终阶码为 254，是 IEEE 754 单精度格式表示的最大阶码。故使 f2 结果不溢出的最大 n 值为 126。\n​        当 n=23 时， f(23) 为 24 位 1， float 型数有 24 位有效位，所以不需舍入，结果精确。所以使 f2 获得精确结果的最大 n 值为 23。\n第三章 存储器3.1 本章大纲要求与核心考点3.1.1 大纲内容（一）存储器的分类\n（二）层次化存储器的基本结构\n（三）半导体随机存储器\n\nSRAM 存储器\nDRAM 存储器\nFlash 存储器\n\n（四）主存储器\n\nDRAM 芯片和内存条\n多模块存储器\n主存和CPU之间的连接\n\n（五）外部存储器\n\n磁盘存储器\n固态硬盘（SSD）\n\n（六）高速缓冲存储器（Cache）\n\nCache 的基本工作原理\nCache 和主存之间的映射方式\nCache 中主存块的替换算法\nCache 写策略\n\n（七）虚拟存储器\n\n虚拟存储器的基本概念\n\n页式虚拟存储器\n基本原理，页表，地址转换，TLB（快表）\n\n段式虚拟存储器\n\n段页式虚拟存储器\n\n\n3.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n半导体存储芯片的特性、工作原理、扩展技术及与 CPU 的连接，多模块存储器的原理。\n磁盘存储器的原理、特点、性能指标，RAID 的原理，固态硬盘的特点和原理。\n程序访问的局部性原理，Cache 的工作原理及性能计算，Cache 和主存的三种映射方式的原理、 特点、地址结构、访存过程，Cache 替换算法（常考 LRU） , Cache 写策略，Cache 块中的标记项。\n虚拟存储器的基本原理，页表机制（二级页表结合操作系统考查），快表的原理，具有快表和 Cache 的多级页式存储系统的工作原理（综合性较强），段式和段页式虚拟存储器的基本原理。\n\n3.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          高速缓冲存储器（Cache）\n          12\n          9\n      \n      \n          虚拟存储器\n          5\n          9\n      \n      \n          半导体存储器\n          6\n          1\n      \n      \n          主存的扩展及与 CPU 的连接\n          6\n          1\n      \n      \n          磁盘存储器\n          4\n          0\n           \n      \n          低位交叉存储器\n          2\n          1\n      \n  \n\n\n\n\n\n\n\n3.2 存储器概述3.2.1 存储器的分类​        \n\n1. 按存储介质分类​        存储介质是指能寄存“0”、“1”两种代码并能区别两种状态的物质或元器件。存储介质主要有半导体器件、磁性材料和光盘等。\n\n半导体存储器\n\n​        存储元件由半导体器件组成的存储器称为半导体存储器。现代半导体存储器都用超大规模集成电路工艺制成芯片，其优点是体积小、功耗低、存取时间短。\n​        半导体存储器又可按其材料的不同， 分为双极型（TTL）半导体存储器和 MOS 半导体存储器两种。前者具有高速的特点；后者具有高集成度的特点，并且制造简单，成本低廉，功耗小，所以 MOS 半导体存储器被广泛用。\n\n磁性材料存储器\n\n​        磁性材料存储器主要依靠磁性材料作为记录的介质，是不易失的永久记忆存储器。又可以分为磁表面存储器和磁芯存储器。\n​        磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。按载磁体形状的不同，可分为磁盘、磁带和磁鼓。\n​        磁芯是由硬磁材料做成的环状元件，在磁芯中穿有驱动线(通电流)和读出线，这样便可进行读/写操作，这种存储器称为磁芯存储器。磁芯属磁性材料，故它也。不过，磁芯存储器的体积过大、工艺复杂、功耗太大，目前几乎已不被采用。\n\n光盘存储器\n\n​        光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器，具有非易失性的特点。光盘具有记录密度高、耐用性好、可靠性高和可互换性强等特点。\n2. 按存取方式分类​        按存取方式可把存储器分为随机存储器、只读存储器、顺序存取存储器和直接存取存储器。\n\n随机存储器（Random Access Memory， RAM）\n\n​        RAM是一种可读/写存储器， 其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        由于存储信息原理的不同， RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充放电原理寄存信息）。\n\n只读存储器（Read Only Memory， ROM）\n\n​        只读存储器是能对其存储的内容读出，而不能对其重新写人的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写人新的信息去改变原始信息。\n​        所以 ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n\n串行访问存储器\n\n​        如果对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器，也称为顺序存取存储器。显然这种存储器由于信息所在位置不同，使得读/写时间均不相同，比如磁带存储器就是一种顺序存取存储器。\n\n直接存取存储器\n\n​        还有一种属于部分串行访问的存储器，比如磁盘。在对磁盘读/写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，称为直接存取存储器。\n3. 按在计算机中的作用分类​        按在计算机系统中的作用不同，存储器可以分为主存储器、辅助存储器、缓冲存储器。\n\n主存储器（简称主存）：用来存放程序和数据，可以和CPU直接交换信息。\n\n辅助存储器（简称辅存）：主存储器的后援存储器， 用来存放当前暂时不用的程序和数据， 它不能与CPU直接交换信息。两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。\n\n缓冲存储器（简称缓存，Cache） 用在两个速度不同的部件之中。\n\n\n\n3.2.2 存储器的性能指标1.存储速度​    （1）存取时间\n​        要想衡量存储速度，最直观的指标就是完成一次存储器读/写操作所需要的时间，这叫做 存取时间，又称为 访问时间（Memory Access Time）。\n​        存取时间又分为读出时间和写入时间。读出时间是从存储器接受到有效地址开始，到产生有效输出所需的全部时间；写入时间是从存储器接受到有效地址开始，到数据写入被选中存储单元为止的全部时间。\n​    （2）存储器周期\n​        存储器周期 （Memory Cycle Time）指连续进行两次独立的存储器操作（读或者写）需要的最小时间间隔，也叫 存取周期。需要注意的是，存储器周期并不等同于完成一次读写操作的时间，而是要更大；因为存储器经过一次读写操作后，并不能立即进行下一次读写，中间还需要一段时间来恢复内部状态。所以，\n​                                                            存储器周期 = 存取时间 + 恢复时间\n​    （3）存储器带宽\n​        一般来说，存储器周期越短，存储器的速度就越快；这前提是存储器的每次读写操作处理的数据位数相同。通常情况下，存储器每次读写的位数是跟存储字长相关的，字长越长，一个存取周期处理的数据就越多。\n​        所以可以用 数据传输率 来表示存储速度，而 存储器带宽 就是衡量数据传输率重要指标。存储器带宽指单位时间内存储器存取的数据量。单位为位/秒（b/s），或者字节/秒（B/s）、字/秒。\n​                                                            存储器带宽 = 数据宽度 / 存储周期\n​        例如，存储器周期为 500 ns，每个存取周期可以访问 16 位，那么带宽就是：\n​                                                                16 bit ÷ 500 ns = 32 Mb/s\n2. 存储容量​        存储容量指存储器能存放的数据总量，一般用二进制代码的总位数（bit）来表示。\n​                                                    存储容量 = 存储字数 × 存储字长\n​        存储字数代表了存储器地址空间的大小，由地址线的位数决定。容量一般也可以用字节总数（Byte）来表示，也就是：\n​                                            存储容量（字节数） = 存储字数 × 存储字长 / 8\n​        例如，某机器存储字长为 8 位，地址线有 28 位，那么它的主存最大存储容量为：\n​                                                        2^28^ × 8 / 8 = 2^28^ B = 256 MB\n3. 位价​        每位价格也就是存储器的单位成本。\n​                                                    位价 = 总成本 / 总容量\n​        一般来说，速度越高，位价就越高；容量越大，位价就越低；而且容量越大，速度也会越低。\n3.2.3 层次化存储器的基本结构​        \n\n\n寄存器通常都制作在 CPU 芯片内。寄存器中的数直接在 CPU 内部参与运算， CPU 内可以有十几个、几十个寄存器，它们的速度最快，位价最高，容量最小。\n主存用来存放将要参与运行的程序和数据，它与 CPU 速度差距较大。\n为了使主存和 CPU 之间速度更好地匹配， 需要在主存与 CPU 之间插入一种比主存速度更快、容量更小的高速缓冲存储器 Cache，其位价要高于主存。\n\n\n\n缓存-主存层次\n\n​        这一层次主要解决 CPU 和主存速度不匹配的问题。由于缓存的速度比主存的速度高， 只要将CPU近期要用的信息调人缓存， CPU 便可以直接从缓存中获取信息， 从而提高访存速度。但由于缓存的容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换掉。主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。\n\n主存-辅存层次\n\n​        这一层次主要解决存储系统的容量问题。辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息， 但它的容量比主存大得多， 可以存放大量暂时未用到的信息。当CPU需要用到这些信息时， 再将辅存的内容调人主存， 供CPU直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的。\n3.3 半导体存储器​        半导体存储器分为 随机存取存储器（RAM）和 只读存储器（ROM）。\n​        RAM 是一种可读/写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        RAM 按照存储信息的原理不同，又可以分为静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM），主存储器主要由 DRAM 实现，靠近处理器的那一层缓存 （Cache）则由 SRAM 实现，它们都是易失性存储器。ROM 是非易失性存储器。\n\n主存中各个存储单元的空间位置，是由一个地址号来表示的；通过地址总线可以给定一个存储单元的地址号，从而根据地址读出或者写入一个存储字。\n\n译码驱动：将地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作。\n读/写电路：包括读出放大器和写入电路，用来完成读/写操作。\n\n​        存储芯片通过地址总线、数据总线和控制总线与外部连接。地址线和数据共同反映了芯片的存储容量。比如，10 根地址线，4 根数据线，表示芯片的存储容量为：2^10^ × 4 = 4 Kb。\n\n地址线是单向输入的，其位数与芯片存储容量有关。\n数据线是双向输入的，其位数与芯片每次可读出或写入的数据位数有关，从而也影响到存储容量。\n控制线包括了读/写控制线和片选线。读/写控制线决定芯片进行的具体操作，片选线用来选择芯片。\n\n\n半导体存储芯片的译码驱动，主要有两种方式：线选法 和 重合法。\n\n线选法：是用一根字选择线（字线），直接选中一个存储单元的各位。这种方式结构比较简单，不过只适合用于容量不大的存储芯片。\n\n采用线选法译码驱动的存储芯片结构示意图。这个芯片有 8 位地址线和 8 位数据线，所以有 28 = 256 个存储字，需要 256 根字线来实现选中每个存储字。\n\n\n重合法：用两个方向的地址，共同决定选中存储矩阵中的一个存储单元。相比 “一维” 的线选法，重合法就升级到了 “二维”，可以用更少的选择线实现对所有存储单元的选择。\n\n使用 X、Y 两个方向的地址译码器分别对 4 位地址进行译码，只需要两个方向各 16 根选择线，就可以直接选中 16 × 16 存储矩阵中的每一位。\n\n3.3.1 SRAM​        通常把存放一个二进制位的物理器件称为存储元，它是存储器最基本的构件。地址码相同的多个存储元构成一个存储单元。存储单元的集合构成存储体。\n​        静态 RAM（Static RAM，SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此信息被读出后，它仍保持其原状态而不需要刷新；这种读特性被称为“非破坏性读出”。\n\n下面是 Intel 2114 RAM 芯片的存储矩阵结构示意图。2114 芯片有 10 根地址线，其中 6 根行地址线、4 根列地址线，存储矩阵由 64 × 64 个基本单元电路组成，总容量为 1K × 4 位。\n\nSRAM 使用触发器工作原理存储信息，因此在读出信息后，它仍会保持原来的状态，不需要刷新。不过如果电源掉电，存储的信息就会丢失，所以它属于易失性半导体存储器。\n​        SRAM 的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于 Cache。\n3.3.2 DRAM​        动态 RAM（Dynamic RAM，DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的。若电容上存有足够多的电荷表示存 “1”，电容上无电荷则表示存 “0”。\n​        常见的动态 RAM 基本单元电路有三管式和单管式两种。单管式只需要一个 MOS 管和一个电容，因此可以极大地提高集成度。\n\n可以看到，DRAM 的基本存储元可以只使用一个晶体管, 所以它比 SRAM 的密度要高很多。为了进一步提高集成度，DRAM 采用 地址复用技术，地址信号分行、列两次传送，这样地址线是原来的一半，地址引脚数也可以减少一半，就能够进一步减小芯片的体积。\nDRAM 通过DRAM 接口把地址一分为二，然后利用两个连续的时钟周期传输地址数据。这样就达到了芯片上使用一半的针脚实现同SRAM 同样的功能的目的，但内部地址线数实际不变，逻辑上减半。\n\n​      \n​       下面是 Intel 4116 RAM 芯片的整体结构和存储矩阵示意图。4116 芯片的存储矩阵为 128 × 128，共有 16 K 个单管 MOS 基本单元电路，容量为 16K × 1 位。本来芯片应该有 14 根地址线，不过为了减少芯片封装的引脚数，地址线只有 7 根。这就需要将完整的地址信息分成行地址、列地址两部分（各自 7 位），分两次传送。\n\n\n​        相对 SRAM 来说，DRAM 具有容易集成、价位低、容量大和功耗低等优点，但 DRAM 的存取速度比 SRAM慢，一般用于大容量的主存系统。\nDRAM 的刷新​        由于电容上的电荷一般只能维持1 ~2ms，因此即使电源不掉电，信息也会自动消失。为此，必须在 2ms 内对所有存储单元恢复一次原状态，这个过程称为 再生 或者 刷新。\n​        刷新的过程，实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。由于存储单元是被随机访问的，有些存储单元可能一直不会被访问，因此其存储的原信息将会慢慢消失。因此，必须进行定时刷新。一般要求在一定的时间内，对动态 RAM 的全部基本单元必须作一次刷新，这个时间称为 刷新周期，也叫 再生周期，一般取 2ms。\n​        通常有三种刷新方式：集中刷新、分散刷新和异步刷新。\n​    （1）集中刷新\n​        在规定的一个刷新周期内，对全部存储单元集中一段时间进行逐行刷新；刷新时必须停止读/写操作。\n​        例如，我们有一个芯片的存储矩阵为 128 × 128，它的存取周期为 0.5 μs，刷新周期为 2 ms（4000 个存取周期），那么对它的 128 行存储单元进行集中刷新需要：\n​                                                                        0.5 μs × 128 = 64 μs\n​        那剩余的 1936 μs（3872个存取周期）就可以用来读/写或者维持信息。由于在这 64 μs 内无法进行读/写操作，所以这段刷新时间被称为 “死时间”，也叫访存 “死区”。死时间占据存取周期的比例 64 μs / 2 ms × 100% = 3.2%，称为死时间率。\n\n2）分散刷新\n​        对每行存储单元的刷新，分散到每个存取周期内完成。这样，每个存储周期 tC 就分成了两段：前半段 tM用来读/写或者维持信息，后半段 tR 用来刷新。所以：\n​                                                                                    tM = tM + tR\n​        同样以 128 × 128 存储矩阵的芯片为例，读/写周期 tM = tR = 0.5 μs，那么存取周期 tC = 1 μs。逐行进行刷新，每隔 128 μs 就可以将存储芯片全部刷新一遍。\n\n这样的好处是不存在停止读/写操作的死时间，而且刷新间隔比要求的刷新周期 2ms 短得多；缺点在于存取周期 tC 变长了，使得整个系统速度变慢。 \n​    （3）异步刷新\n​        异步刷新是前两种方式的结合，它既可以缩短 “死时间”，又能充分利用最大的刷新间隔 2ms。\n​        还是之前的例子，对于 128 × 128 存储矩阵的芯片，存取周期 tC = 0.5 μs，可以让它把对 128 行的刷新平均分配到 2ms 的刷新周期内。也就是说，每隔 2ms ÷ 128 ≈ 15.6 μs 刷新一行，每次刷新的时间还是一个存取周期 tR = 0.5 μs。\n\n这样一来，2ms 内用于刷新的时间仍然是 128 tR = 64 μs，而由于分散到了整个刷新周期内，每次刷新一行只停了一个存取周期；所以对于每行来说，刷新的间隔还是 2ms，而 “死时间” 缩短为 0.5 μs。\n​        如果将 DRAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不会访问存储器，所以这样就完全避免了 “死时间” 的问题，从根本上提高了机器效率。\nDRAM 和 SRAM 的比较​        目前，随着 DRAM 的容量不断扩大，速度不断提高，它的应用要比 SRAM 更加广泛。DRAM 主要用在计算机的主存中，而 SRAM 通常用于容量不大的高速缓存（Cache）中。\n​        两者的特点可以比较如下：\n\n3.3.3 ROM​        ROM （Read Only Memory）最原始的定义是 “只读存储器”，一旦写入原始信息后就不能更改。所以ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n​        不过随着用户的需要和技术的发展，又出现了更多类型的 ROM，让用户拥有了修改数据的能力。\n​        根据制造工艺不同，ROM 可分为固定掩模型 ROM（MROM）、一次可改写 ROM （PROM）、紫外线擦除电可编程 ROM（EPROM）、电擦除电可编程 ROM （EEPROM）、快擦写（Flash）存储器。\n​    \n​        SRAM、DRAM 和 ROM 这 3 种存储器的特点可以总结如下。\n\n3.4 主存储器3.4.1 主存储器的基本组成​        主存储器简称主存或内存，是计算机中存储程序和数据的重要部件。主存内包含了存储体、各种逻辑部件以及控制电路等。\n​        主存是通过按地址访问的方式，对存储体内的存储单元进行读写操作的。因此主存首先需要从 MAR 中获取地址，由译码器进行地址译码、再经过驱动电路，进而通过选择线选中所需访问的单元。读出时，需要经过读出放大器才能将被选中存储单元的内容送到 MDR；写入时，MDR 中的数据也需要经过写入电路才能真正存入被选中的单元。所以主存实际结构的基本组成如下：\n\n译码器、驱动器和读写电路都集成在 DRAM 存储芯片中，而 MAR 和 MDR 则集成在 CPU 芯片内。存储芯片可以通过总线与 CPU 相连。\n\n当要从主存中读某个数据字时，首先由 CPU 将字的地址送到 MAR，通过地址总线送至主存，然后发出读命令；主存的译码器将地址总线送来的地址译码，导通对应存储单元的选择线，收到读信号后，便将该单元的内容送到数据总线上，进而交给 MDR。\n​        如果要向主存写入一个数据字，仍然需要 CPU 先把地址送到 MAR，并把要写的数据送到 MDR，然后发出写命令；主存译码器依然从地址总线读取地址进行译码，接到写命令后，就把数据线上的信息写入对应的存储单元。\n主存中地址的分配​        主存中各存储单元的空间位置，都是由存储单元的地址号表示的；地址总线的作用就是给出要访问的存储单元的地址。每次访问存储单元，可以读出或者写入一个存储字。\n​        存储字长必须是字节（8位）的整数倍，不同机器的存储字长不同。计算机一般既可以按字来寻址，也可以按字节寻址。例如，一台机器的存储字长为 32 位，并且可以按字节寻址，那么它的每个存储字都包含了 4 个具有独立地址的字节，地址的分配方式如下：\n\n如果这台机器的地址线为 24 位，那么按字节寻址的范围是 2^24^ = 16M，按字寻址的范围为 16M / 4 = 4 M。\n3.4.2 主存和 CPU 之间的连接1. 主存容量扩展​        单片存储芯片的容量有限，所以主存需要将多个存储芯片连在一起扩展成更大的存储器。这称为 存储容量的扩展，主要的方法有 位扩展 和 字扩展。\n（1）位扩展\n​        位扩展是指对字长进行扩展，也就是增加存储字长。这种情况下，系统地址线位数等于芯片地址线位数，而系统数据线位数多于芯片数据线位数。\n​        位扩展的连接方式：各芯片的地址线、片选线和读写控制线与系统总线相应 并联；各芯片的 数据线单独引出，分别连接系统数据线。各芯片同时工作。\n​        以之前介绍过的 SRAM 芯片 2114 为例，它的存储容量为 1K × 4，那么用 2 片 2114 采用位扩展的方式可以组成 1K × 8 的存储器。如下所示：        \n\n（2）字扩展  \n​        字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。这种情况下，系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。\n​        字扩展的连接方式：各芯片的地址线与系统地址线的 低位对应相连，芯片的数据线和读写控制线与系统总线相应 并联；由系统地址线的 高位译码 得到各芯片的片选信号。各芯片分时工作，同一时间只能有一个芯片被选中。\n​        例如，用 2 片容量为 1K × 4 的 2114 芯片，采用字扩展的方式可以组成 2K × 4 的存储器。如下所示：\n\n​    扩展之后的地址线为 11 位，共有 2^11^ = 2 K 个地址。其中：\n\n第一片 2114 的地址范围为 000 0000 0000 ~ 011 1111 1111；\n第二片 2114 的地址范围为 100 0000 0000 ~ 111 1111 1111。\n（3）字和位同时扩展\n\n\n​        字和位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。\n​        字和位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展相同；由系统地址线高位译码产生若干个片选信号，分别接到各组芯片的片选信号。\n​        例如，用 8 片容量为 1K × 4 的 2114 芯片，字和位同时扩展之后可以组成 4K × 8 的存储器。如下所示：\n\n扩展之后的地址线为 12 位，共有 2212 = 4 K 个地址。其中：\n\n第一、二片 2114 通过位扩展构成第一组，地址范围为 0000 0000 0000 ~ 0011 1111 1111；\n第三、四片 2114 通过位扩展构成第二组，地址范围为 0100 0000 0000 ~ 0111 1111 1111；\n第五、六片 2114 通过位扩展构成第三组，地址范围为 1000 0000 0000 ~ 1011 1111 1111；\n第七、八片 2114 通过位扩展构成第四组，地址范围为 1100 0000 0000 ~ 1111 1111 1111。\n\n2. 主存与CPU的连接（1）合理选择存储芯片。通常选用 ROM 存放系统程序，选用 RAM 组成用户区。\n（2）地址线的连接。CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）；CPU 地址线的高位在扩充存储芯片时用，以选择存储芯片（片选）。\n（3）数据线的连接。比较CPU的数据线数与存储芯片的数据位数。如果相等可以直接相连；如果不等，必须对存储芯片进行扩位，使其数据位数与 CPU 的数据线数量相等。\n（4）读/写命令线的连接。CPU 的读/写命令线一般可以直接与存储芯片的读/写控制端相连。\n（5）片选线的连接。片选信号一般由系统地址线高位译码，它是主存与 CPU 连接的关键。\n3.4.3 多模块存储器1. 单体多字存储器​        在主存中，程序和数据是连续存放的，所以 CPU 访存取出的信息也是连续的。如果将存储器的存储单元进行扩展，让它能够存储更多的字，那么就可以在一个存取周期内，从同一地址取出更多的指令。将多条指令逐条送至 CPU 执行，由于 CPU 的速度远高于主存，这样就相当于增大了主存的带宽，提高了速度。\n​        这种方式是对单独的存储器进行了扩展，类似于位扩展的思路，不过是将一个地址对应的数据扩展到了多个存储字。所以这种结构的存储器称为 单体多字存储器。\n​        例如，对于一个单体四字存储器，可以在一个存取周期取出四个字的信息。假设指令字长就是一个存储字，那么原先一个存取周期拿到一条指令，现在就可以拿到 4 条；逐条传给 CPU 进行处理，就相当于每隔 1/4 周期，主存就向 CPU 传送了一条指令，带宽变成了 4 倍。\n\n\n结构特点：存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。\n访问方式：一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。\n\n优点：宽度为单体单字存储器的近 m 倍（访问的内容在同一行时）。\n\n缺点：如果出现访问冲突（需要的内容不在同一行）或遇到转移指令，效率会显著降低。\n\n2. 多体并行系统​        另一种思路是采用多模块组成存储器，各个模块可以并行读写，这就是多体并行系统。每个模块有相同的容量和存取速度，各模块都有自己独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路和读/写电路，它们能并行工作，也能交叉工作。\n​        所谓的 “并行工作”，就是 CPU 可以同时访问 N 个模块，同时启动，同时读出；当然，由于总线是公共的，同时读出的 N 个字需要在总线上分时传送。\n​        根据对这 N 个模块中存储单元的不同编址方式，多体并行系统又可以分为 多体高位交叉存储器 和 多体低位交叉存储器。\n（1）多体高位交叉存储器\n​        多体高位交叉存储器中，各模块采用 高位交叉方式编址。\n​        高位交叉方式编址时，地址分为两部分，高位地址表示体号，低位地址为体内地址。这种编址方式下，一个模块（也就是 “体”）内的地址是连续的，程序存储时会按照体内地址的顺序存放，也就是先存一个模块，存满之后再存下一个；所以这种方式也叫 “顺序存储”。\n\n只要调动合理，使不同的请求源同时去访问不同的模块，就可以实现并行工作。比如，CPU 在访问一个模块的同时，外部设备可以以直接存储器访问（DMA）的方式访问另一个模块，这样两个体就是并行工作的。\n（2）多体低位交叉存储器\n​        多体低位交叉存储器中，各模块采用 低位交叉方式编址。\n​        低位交叉编址是指用主存地址的低位来指明存储器模块，高位指明模块内的字地址。这种编址方式下，连续的地址分布在相邻的模块中，同一模块内的地址是不连续的，因此也叫做 “交叉存储”。有 M 个模块的低位交叉编址，又叫 模 M 编址。\n\n​       上面是一个模 4 交叉编址的存储器，存储体模块个数为 4，所以第一个模块中所有存储单元的地址号，对 4 取模都为 0；同样道理，第二、三、四个模块的地址号，对 4 取模结果分别为 1、2、3。具体的编址地址号如下所示：\n\n​        程序按照地址连续存放在相邻模块中，采用低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用 流水线 方式并行存取，提高存储器的带宽。\n​        在一个存取周期 T 内，m 个模块按一定的顺序分时启动；如果分时启动的时间间隔为 t = T/m，那么在一个存取周期内，CPU 交叉访问各个模块，从而使各模块的读/写操作交错重叠进行，最终向 CPU 可以传送 m 个字。这样，存储器的带宽提升为 m 倍。\n​        由于各个模块传送取出的字共享总线，因此假设总线传输周期为 τ，当 t 小于等于 τ 时，就可以获得最大的存储器带宽。所以：\n​                                                                                t = T/m ≤ τ\n​        所以，对于一个存取周期为 T、总线传输周期为 τ 的机器，设计多体低位交叉存储器时应该有 m ≥ T / τ。一般取最小值即可，在采用流水线方式时应该满足 \n​                                                                                    T = m τ\n​        对于四体低位交叉编址存储器 T = 4 τ，按流水线方式工作时不同模块访问字的时间顺序如下：\n\n​    可以看出，对于流水线工作的低位交叉存储器，连续读取 n 个字所需的时间为：\n​                                                                            t1 = T + ( n - 1 ) τ \n​        而如果是高位交叉存储器，对应的时间为：\n​                                                                                    t2 = n T\n​        对于上面的四字低位交叉存储器，τ = T / 4，所以 t1 = ( n + 3 ) T / 4，明显要低于 t2；当 n 非常大时，t1 趋近于 T / 4，即速度提升了 4 倍。\n3.5 外部存储器​        外部存储器是主存的后援设备，也叫做辅助存储器，简称 外存 或 辅存，与主存一起构成了存储器系统的主存-辅存层次。与主存相比，外存容量大、速度慢、价格低，可以脱机保存信息，属于 非易失性存储器。\n​        用于计算机系统的外存主要有磁盘、磁带、光盘；磁盘和磁带都属于 磁表面存储器。而目前广泛应用的 固态硬盘（SSD）主体由闪存芯片构成，属于半导体存储器。\n3.5.1 磁盘存储器​        磁盘是应用最为广泛的外存设备。磁盘根据结构和盘片材质的不同，可以分为 硬磁盘 和 软磁盘，如今随着存储技术的发展，软磁盘存储器已渐渐不再使用，而硬磁盘存储器依然在外存中占据着重要的比例。\n​        磁盘存储器具有外存设备普遍的优缺点：\n\n优点：存储容量大，位价低；记录介质可重复使用；记录信息可长期保存而不丢失, 甚至可脱机存档；非破坏性读出，读出时不需要再生。\n缺点：存取速度慢，机械结构复杂。\n\n1. 磁表面存储器和磁记录原理​        磁表面存储器在不同形状（盘状、带状）的载体上涂有磁性材料层，这磁层就是记录信息的存储介质。存储器工作时，依靠载体的机械运动，由磁头在磁层上进行读/写操作；信息就记录在磁层上，这些信息的轨迹叫做 磁道。磁盘的磁道是一个个同心圆，磁带的磁道则是一条条直线。\n\n磁记录原理：磁表面存储器在磁头和磁性记录介质做相对运动时，通过电磁转换完成读/写操作。\n磁记录方式：又称为编码方法，就是按某种规律把一连串的二进制信息转换成磁表面相应的磁化状态。通常采用调频制（FM）和改进型调频制（MFM）的记录方式。    \n\n\n2. 硬磁盘的分类和基本结构（1）硬磁盘存储器的类型\n​        硬磁盘中的存储载体是盘片，它是由硬质铝合金材料制成的，其表面涂有一层硬磁特性材料，可以被磁化从而完成信息的存储。通过磁头和盘片的相对运动，就可以实现信息的读取和写入。\n\n根据能否更换盘片，硬磁盘可以分为 可换盘磁盘 和 固定盘磁盘。\n\n​        可换盘磁盘的盘片可以脱机保存，所以更换的时候可以只换单片，方便维护和扩容；固定盘磁盘的盘片则不能从驱动器中取下，更换的时候需要整体更换，可靠性更高。\n\n按照磁头的工作方式，硬磁盘可以分为 固定磁头磁盘 和 移动磁头磁盘。\n\n\n\n固定磁头的磁盘存储器，磁头位置是固定不动的，磁盘上的每一个磁道都对应着一个磁头，盘片也不可以更换；这样省去了磁头在盘片上移动寻找磁道的时间，存取速度更快。\n移动磁头的磁盘存储器，存取数据时磁头需要在盘面上做径向运动；这类存储器可以只有一个盘片，也可以有多个盘片。多个盘片会装在一个同心主轴上，每个记录面各有一个磁头。所有这些磁头连成一体，固定在支架上移动；任何时刻所有磁头和主轴的距离都相等，它们位于和圆心相等距离的一组磁道上，这组磁道称为一个 柱面。\n\n（2）硬磁盘存储器的组成\n​        硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。\n\n\n磁盘驱动器\n\n​        磁盘驱动器是主机之外的一个独立装置，又称作 磁盘机。驱动器主要包括主轴、定位驱动和数据控制 3 个部分。\n\n\n磁盘控制器\n\n​        磁盘控制器是磁盘存储器和主机的接口，通常就是一块电路板，插在主机总线插槽中。它的作用是接收由主机发来的命令，将其转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送，并且控制驱动器的读/写操作。一个磁盘控制器可以控制多台驱动器。\n​        将磁盘控制器的功能全部内置在磁盘设备中，主机和设备之间就可以采用标准的通用接口了。最初这种接口就称为 IDE（Integrated Drive Electronics）接口，同时期还有更高性能的 SCSI（Small Computer System Interface）接口；之后又发展出了采用串行传输技术的接口，这就是 SATA（Serial Advanced Technology Attachment）和 SAS（Serial Attached SCSI）。目前我们的个人电脑中，大多都是采用 SATA 接口的硬盘。\n\n盘片\n\n​        盘片是磁盘中存储信息的载体，由驱动器控制它的转动并读/写数据；有时也会直接把盘片当作驱动器的一部分。目前硬盘的盘片正朝着小体积大容量的方向发展，记录密度越来越高。\n3. 磁盘的工作原理（1）磁盘存储区域\n​        一块磁盘划分为若干个记录面，每个记录面划分为若干条 磁道，而每条磁道又划分为若干个 扇区，扇区（也称块、扇段）是磁盘读写的最小单位，即磁盘按块存取。一个具有多盘片的磁盘组，可将其 n 个面上所有同一半径的磁道看成一个圆柱面，称为 柱面；在移动磁头的组合盘中，多个磁头一次定位的磁道集合就是一个柱面。    \n\n\n\n磁头数：表示磁盘总共有几个磁头，一般来说一个记录面对应一个磁头，所以等于记录面数。\n\n柱面数：表示磁盘中柱面的个数，等于每个记录面上的磁道数。\n\n扇区数：表示每条磁道上有几个扇区。\n\n\n（2）磁盘地址\n​         一个磁盘存储器可以有多台驱动器，不同的驱动器可以用一个编号（驱动器号，或者台号）来区分。当驱动器号确定后，磁盘进行寻址定位时，首先需要整体移动磁头找到对应柱面（磁道）、再选定磁头，最后转动盘片找到扇区。所以寻址所需要的磁盘地址，一般由 驱动器号、柱面（磁道）号、盘面号、扇区号 组成。\n​        磁盘的地址格式如下所示:\n\n\n\n\n驱动器号\n柱面（磁道）号\n盘面号\n扇区号\n\n\n\n\n\n\n\n\n\n​        例如，系统中有 4 个驱动器，每个驱动器带一个磁盘组，其中有 11 个盘片（最外层上下侧为保护面），每个盘面有 203 个磁道、划分为 16 个扇区。则可以算出，驱动器号需要 2 位；柱面号需要 8 位（ 27 &lt; 203 &lt; 28 ）；而 11 个盘片有 20 个盘面，所以盘面号需要 5 位；扇区号需要 4 位。最终每个磁盘地址要 19 位二进制代码。\n\n\n\n\n驱动器号（2位）\n柱面（磁道）号（8位）\n盘面号（5位）\n扇区号（4位）\n\n\n\n\n\n\n\n\n\n（3）磁盘的工作过程\n​        磁盘的主要操作是寻址、读盘、写盘。磁盘属于机械式部件，其读/写操作是串行的，不可能在同一 时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。\n\n磁盘的性能指标\n\n（1）记录密度\n​        记录密度通常是指单位长度内所存储的二进制信息量。磁盘存储器用 道密度、位密度 和 面密度 来表示。\n（2）存储容量\n​        存储容量指磁盘能存储的二进制信息的总数量，一般以位或者字节为单位。磁盘存储容量 C 可以计算为：\n\n​        其中 n 为 盘面数，k 为每个盘面的磁道数，s 为每条磁道上记录的二进制代码数。\n（3）平均寻址时间\n​        磁盘的存取方式是直接存取，它的寻址时间分为两个部分：磁头寻找目标磁道的时间 t~s~；和找到磁道后，磁头等待要读写的磁道区段（扇区）旋转到磁头下方的时间 tw。由于寻找相邻磁道和不相邻磁道的时间不同，磁头等待不同扇区的时间也不同，所以应该取平均值，称为 平均寻址时间；它是 平均寻道时间 tsa 和 平均等待时间     twa之和。\n\n​        平均寻址时间再加上数据传输时间，就是磁盘的 平均访问时间。\n（4）数据传输率\n​        数据传输率是指单位时间内，磁盘向主机传送数据的位数或字节数。数据传输率 DR 与记录位密度 D~b~ 和磁道运动速度 V 有关；\n\n​        对于磁盘来说，“磁道运动速度” 一般用磁盘的转速 r （单位 转/s）表示，那么\n\n（5）误码率\n​        误码率是衡量磁盘出错概率的参数，等于从磁盘读出信息时，出错信息位数和读出信息总位数之比。为了减少出错率，磁盘一般采用循环冗余校验（CRC）码来发现和纠正错误。\n5. 冗余磁盘阵列 RAID​        冗余磁盘阵列（Redundant Array of Independent Disks，RAID）是将多个独立的物理磁盘组成一个磁盘阵列，引入并行处理技术，让数据在多个物理盘上分割交叉存储、并行访问。 \n​        根据不同的目的，可以采用不同的 RAID 方案；在 RAID1 ~ RAID5 的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。RAID 的分级如下所示：\n\nRAID0：无冗余和无校验的磁盘阵列。\n\nRAID1：镜像磁盘阵列，无校验。\n\nRAID2：采用纠错的海明码的磁盘阵列。\n\nRAID3：位交叉奇偶校验的磁盘阵列。\n\nRAID4：块交叉奇偶校验的磁盘阵列。\n\nRAID5：无独立校验的奇偶校验磁盘阵列。\n\n​        其中，RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。\n​        RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另 一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。\n​        总之，RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高吞吐量；通过镜像功能，提高了安全性、可靠性；通过数据校验，提供容错能力。\n3.5.2 固态硬盘（SSD）​        固态硬盘（Solid State Disk，SSD）是基于闪存（Flash）技术的半导体存储器，它与 U 盘并没有本质差别。SSD 由闪存芯片和闪存翻译层组成，闪存芯片代替了传统磁盘中的磁盘驱动器，闪存翻译层则将来自 CPU 的读写请求翻译成对芯片的读写控制信号，相当于磁盘中的磁盘控制器。    \n\n固态硬盘有很多优点。它由半导体存储器构成，没有机械部件，所以随机访问速度比磁盘快很多，也没有任何机械噪声和震动。另外，SSD 还具有能耗低、抗震性好、安全性高等优点。\n​        当然，固态硬盘也有缺点。它最大的问题是依然基于 EEPROM 的擦除原理，随机写入比较慢。\n​        固态硬盘的数据都存放在闪存芯片中。一个闪存芯片内包含了多个 “块”，每个块又由若干 “页” 组成。数据以页为单位进行读写，但是需要以块为单位进行擦除；所以只有一页所属的块整个被擦除之后，才能重新写这一页。一旦一个块被擦除了，块中的每一页都可以再写一次。一般某个块进行了数千次重复写之后，就会损坏。\n\n​    因此随机写很慢，有两个原因：首先，擦除块本身就比较慢；其次，如果试图写的页所在块已经有数据了，那么这个块中其它所有有数据的页都必须被复制到一个新块（擦除过的块），然后才能进行写操作。\n​        因此，闪存的擦写寿命是有限的，读/写数据通常会集中在 SSD 的一部分闪存，这部分闪存就会损坏得特别快；在磨损不均衡的情况下，数个闪存块的损坏，会导致整个 SSD 损坏。为弥补 SSD 的寿命缺陷，引入了 磨损均衡技术，SSD 磨损均衡技术大致分为两种：\n\n动态磨损均衡：写入数据时，自动选择较新的闪存块。\n静态磨损均衡：监测并自动进行数据分配，让旧的闪存块承担无须写数据的储存任务，同时让较新的闪存块空出来；平常的读/写操作都在较新的闪存块中进行，这样就使各闪存块的损耗更为均衡。\n\n​        有了磨损均衡技术，SSD 的寿命就比较可观了。例如，对于一个 256 GB 的 SSD，闪存的擦写寿命是 500 次的话，那么就需要写入125 TB 数据才可能损坏；而目前的 Flash 芯片已经做到至少可以擦写上万次了。\n3.6 高速缓冲存储器（Cache）​        为了解决 CPU 和主存之间速度不匹配的问题，计算机系统中引入了高速缓存（Cache）的概念。基本想法就是使用速度更快但容量更小、价格更高的 SRAM 制作一个缓冲存储器，用来存放经常用到的信息；这样一来，CPU 就可以直接与 Cache 交换数据，而不用访问主存了。\n​        这种方案之所以有效，是因为通过对大量典型程序分析发现，在一定时间内，CPU 要从主存取指令或者数据，只会访问主存局部的地址区域。这是由于指令和数据在内存中都是连续存放的，而且有些指令和数据会被多次调用（比如常用函数、循环代码段、数组和一些常数）；也就是说，指令和数据在主存中地址分布不是随机的，而是相对的簇聚。这使得 CPU 执行程序时，访存具有相对的局部性；这称为程序访问的 局部性原理。\n\n时间局部性：如果一个数据现在被访问了，那么以后很有可能也会被访问\n空间局部性：如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问\n\n​        局部性原理是 Cache 高效工作的理论基础。\n3.6.1 Cache 的基本工作原理​        为了便于 Cache 与主存交换信息，Cache 和主存都被划分为相等的块。Cache 块又称 Cache 行，每块由若干字节组成，块的长度称为块长。由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，Cache 中仅保存主存中最活跃的若干块的副本。\n1. Cache 工作原理​        假设主存按字节编址，地址用 n 位二进制码表示，那么主存容量为 2n B；块的大小为 16 个字节，那么主存中块的个数为：2n / 16 = 2n-4。那么如果对每个块也做一个编号，其实就对应着地址中的前 n - 4 位。\n\n这样，主存地址就分成了两部分：高 n - 4 位表示主存中的 “块地址”，低 4 位表示 “块内地址”，块内地址其实就是具体存储字在块内的 “偏移量”。类似，Cache 中地址也可以分成这样的两部分，由于 Cache 中块长与主存一致，所以低 4 位同样是块内地址；剩余的高位则为 Cache 的块号。Cache 的块号位数小于 n - 4。\n\n所以，可按照某种策略预测 CPU 在 未来一段时间内要访存的数据，将其装入 Cache。当 CPU 要读取主存中的某个字时，分为两种情况：\n\nCache 命中：需要的字已经在缓存中，就将其地址转换为缓存地址，直接访问 Cache，与主存无关；\nCache 未命中：需要的字不在缓存中，仍需访问主存，并将该字所在的块一次性地从主存调入 Cache。\n\n​        如果某个主存块已经调入 Cache，就称该主存块和 Cache 中的缓存块建立了对应关系。由于 Cache 容量有限，当 Cache 已满时，就需要根据某种替换算法，让需要调入 Cache 的块替换之前某个缓存块的内容。所以，一个缓存块不可能永远只对应一个主存块；需要给每个缓存块设置一个标记，写入当前对应的主存块号，表示它当前存放了哪个主存块。\n​        CPU 与 Cache 之间的数据交换，通常是以字为单位；而 Cache 与主存之间的数据交换则以块为单位。\n2. 命中率​        Cache 的效率，通常用 命中率 来衡量。命中率是指 CPU 要访问的信息已经在 Cache 中的比率。Cache 的容量和块长都是影响命中率的重要因素。\n​        假设一个程序执行期间，访问 Cache 的总命中次数为 NC，访问主存的总次数为 NM~，那么命中率为：\n\n​        设 tC 为命中时的 Cache 访问时间，tM~ 为未命中时的主存访问时间，那么 Cache - 主存系统的平均访问时间   ta 为：\n\n​        由于 tC 远小于 tM~，因此平均访问时间 ta 越接近 tC 就说明 Cache 效率越高。用 e 表示访问效率，则有：\n\n​        命中率 h 越接近 1，访问效率就高。一般来说，Cache 容量越大，命中率就越高；而块长与命中率的关系较为复杂，它取决于程序的局部特性，一般取每块 4 ~ 8 个可编址单位（字或字节）效果较好。\n3. Cache 的基本结构​        Cache 主要由 Cache 存储体、主存 - Cache 地址映射变换机构、Cache 替换机构几大模块组成。\n\n（1）Cache 存储体\n​        Cache 存储体以块为单位与主存交换信息，Cache 访存的优先级最高。\n​    （2）主存 - Cache 地址映射变换机构\n​        地址映射变换机构会将 CPU 送来的主存地址转换为 Cache 地址。由于主存和 Cache 块长相同，所以块内地址是不变的，地址变换主要就是主存的块号（高位地址）到 Cache 块号之间的转换。这涉及到一个函数的映射关系，被称为 地址映射。\n​    （3）Cache 替换机构\n​        地址转化之后，如果 Cache 命中，CPU 就直接访问 Cache 存储体；如果不命中，CPU 需要访问主存将需要的字取出，并把它所在的主存块调入 Cache。如果 Cache 已满，无法将主存块直接调入 Cache，就需要 Cache 内的替换机构执行替换策略。\n​        所谓替换策略，就是按一定的替换算法，确定从 Cache 中移出哪个块返回主存，并把新的主存块调入 Cache 进行替换。\n​        在执行写操作时，还需要考虑如何使 Cache 如何与主存的内容保持一致。这就需要用某种 Cache 写策略。\n4. Cache 的改进​        Cache 的改进，主要就是由一个缓存改为使用多个缓存。主要有两个方向：增加 Cache 级数；将统一的 Cache 变为分立的 Cache。\n​    （1）两级缓存\n​        最初在 CPU 和主存之间只设一个缓存，称为 单一缓存。随着集成电路密度的提高，这个缓存就直接与 CPU 集成在了一个芯片中，所以又称为 片内缓存（片载缓存）。\n​        由于片内缓存容量无法做到很大，所以可以考虑在片内缓存和主存之间再加一级缓存，称为 片外缓存，也由 SRAM 组成。这种由片外缓存和片内缓存构成的 Cache 系统被称为 “两级缓存”，片内缓存作为第一级（L1 Cache），片外缓存作为第二级（L2 Cache）。\n​    （2）分立缓存\n​        指令和数据都存放在同一缓存内的 Cache，称为 统一缓存；而 分立缓存 则将指令和数据分别存放在两个缓存中，一个叫指令 Cache，另一个叫数据 Cache。这两种缓存的选择主要考虑两个因素：\n\n主存结构。如果计算机主存中指令、数据是统一存储的，则相应的 Cache 采用统一缓存；如果主存指令、数据分开存储，则相应的 Cache 采用分立缓存。\n机器对指令执行的控制方式。如果采用了超前控制或者流水线控制方式，一般都采用分立缓存。所谓超前控制，是指在当前指令执行尚未结束时就提前把下一条准备执行的指令取出；而所谓流水线控制，就是多条指令同时分阶段执行。\n\n3.6.2 Cache 和主存之间的映射方式​        Cache 块中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，这相当于定义了一个函数：\n​                                                                    Cache 地址 = f ( 主存地址 )\n​        当然，由于 Cache 和主存块长一样，而块内地址只是字在当前块内的 “偏移量”，所以映射转换之后块内地址是不变的。我们需要的其实只是 Cache 块号和主存块号之间的函数关系：\n​                                                                    Cache 块号 = f ( 主存块号 )\n​        Cache 块远少于主存块，所以 Cache 块不可能永远对应唯一的主存块，需要在 Cache 中为每一个块加一个 标记，指明它是主存中哪一块的副本。这个标记的内容，应该能够唯一确定对应主存块的编号。另外，为了说明 Cache 行中的信息是否有效，每个 Cache 行还需要有一个 有效位，该位为 1 时，表示 Cache 中该映射的主存块数据有效；为 0 则无效。\n​        地址映射的方法有以下 3 种。\n1. 直接映射​        直接映射 的思路非常简单，就是 “挨个对应”，主存中的每一块只能装入 Cache 中的唯一位置。由于 Cache 容量很小，当主存中的块已经 “遍历” 完所有 Cache 地址后，下一个主存块的对应位置就又成了 Cache 中的第一行（第一个块）。\n​        很明显，这跟 “顺序存储” 的思路是一样的，用主存块号对 Cache 的总行数取模，就可以得到对应 Cache 的行号了：\n​                                                                Cache行号 = 主存块号  mod  Cache总行数\n​        例如，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 只有 4 行（4 个块），那么采用直接映射方式的对应关系如下：\n\n \n​      而在缓存（Cache）设计中，一行（line）通常等同于一块（block）。每一行缓存存储一个块的数据，这个块对应于主存中的一个相同大小的数据块。具体解释如下：\n\n缓存行（Cache Line）：\n一行缓存包含的数据单位，包含一个数据块、一个标记（tag）、有效位（valid bit）和可能的脏位（dirty bit）。\n在直接映射缓存中，每个缓存行唯一对应一个特定的主存块。\n\n\n块（Block）：\n块是从主存中提取的一组连续字节。主存中的块被映射到缓存中的行。\n缓存行的数据部分存储主存块的内容。\n\n\n\n假设我们有以下参数：\n\n主存地址位数：32位\n主存块大小：4个字，每字32位（即每块16字节）\n缓存数据容量：4K字（16KB）\n\n\n对于采用回写策略的缓存，每行缓存不仅存储数据块，还需要附加的元数据：\n\n数据位数：16字节（128位）\n标记位数：\n偏移位数（块内地址）：log2(16) =4 位\n索引位数（块数/行数）：log2(1024) =10 位\n标记位数（剩下的位数用于标记，以确定缓存行对应的具体主存块。将主存中所有228块全部映射到缓存的1024行中，则还需要18位来确定218中的哪个。）：32 - (10 + 4) = 18 位\n\n\n有效位（Valid Bit）：1位\n脏位（Dirty Bit）：1位\n\n主存至缓存的具体映射关系如下：\n\n\n主存中的每个块根据索引部分映射到缓存中的一个行。\n多个主存块可以具有相同的索引，从而映射到同一个缓存行，但它们的标记不同。\n\n采用回写策略的缓存行的总位数分解如下：\n\n每行的总位数：\n\n\n​           更加一般化，假设 Cache 共有 2c 行，主存有 2m 个块，那么 Cache 行号有 c 位，主存块号有 m 位。在直接映射方式中，主存块号为 0、2c、2c+1… 的块，都映射到 Cache 的第 0 行；而主存中块号为 1、2c + 1、2c+1 + 1… 的块，映射到 Cache 的第 1 行；以此类推。\n​        这样一来，主存块号的低 c 位就对应了 Cache 中的行号；当一个块存放在 Cache 中，只需要高 m - c 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - c 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        所以直接映射方式下，主存地址结构为：\n\n​        访存过程：\n​        ① 根据访存地址中间的 c 位，找到对应的 Cache 行。\n​        ② 将该 Cache 行中的标记和主存地址的高 t 位标记进行比较。\n​        ③ 若相等且有效位为1，则 Cache 命中，此时根据主存地址中低位的块内地址，在对应的 Cache 行中存取信息；若不相等或有效位为 0，则 Cache 未命中，此时 CPU 从主存中读出该地址所在的一块信息，并送至对应的 Cache 行中，将有效位置 1，并置标记为地址中的高 t 位。\n\n​    直接映射实现简单，但不够灵活，即使 Cache 的其他许多地址空着也不能占用，这使得直接映射的块冲突概率高，空间利用率低。\n2. 全相联映射​        直接映射的问题在于，我们找到的是从主存块到缓存行的一种 “多对一” 的关系，每一个主存块只能对应唯一的缓存行，从而导致冲突概率高。如果让一个主存块，可以映射到多个缓存块上，变成 “多对多” 的关系，明显就可以减少冲突了。\n​        最简单的情况，就是不加任何条件限制，让主存的每一个块都可以映射到 Cache 的任意位置；简单来说就是 “有空就填”，放在哪里都可以。这就是 全相联映射 方式。        \n\n由于没有任何规律，所以当一个块存放在 Cache 中，无法根据 Cache 行号推出它对应主存块的任何信息；因此必须在每行的标记中明确指出该行取自主存的哪一块，这样标记就需要完整的 m 位主存块号。CPU 访存时，需要与所有 Cache 行的标记进行比较。\n​        全相联映射方式下，主存的地址结构为：\n\n  全相联映射方式的优点是灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。\n3. 组相联映射​        把直接映射和全相联映射两种方式结合起来，就是 组相联映射 方式。\n​        组相联的思路是将 Cache 分成 Q 个大小相等的组，每个主存块可装入对应组的任意一行；它所在的组则按顺序依次排列得到。也就是 组间采用直接映射、而 组内采用全相联映射 的方式。当 Q=1 时，变为全相联映射；当 Q = Cache 行数时变为直接映射。\n​        假设每组有 R 个 Cache 行，则称之为 R 路组相联；例如每组有 2 个 Cache 行时称为 2 路组相联。\n​        类似的例子，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 有 8 行（8 个块），采用 2 路组相联映射方式，那么共有 Q = 8 / 2 = 4 组。对应关系如下：\n\n​    可以看出，现在的 “组号” 就相当于直接映射方式下的行号，可以由主存块号对组数 Q 取模得到：\n​                                                        Cache组号 = 主存块号  mod  Cache组数\n​        更加一般化，假设 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q ，行号的低 c - q 位就代表了 Cache 行在组内的序号。\n​        在 R 路组相联映射方式中，主存块号为 0、2q、2q+1… 的块，都映射到 Cache 的第 0 组，可以选择组内 2c-q 行的任一行；而主存中块号为 1、2q + 1、2q+1 + 1… 的块，映射到 Cache 的第 1 组，同样可以任选组内的 Cache 行；以此类推。\n​        这样一来，主存块号的低 q 位就对应了 Cache 中的组号；当一个块存放在 Cache 中，只需要高 m - q 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - q 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        可以将以上 3 中映射方式对比如下：\n\n3.6.3 Cache 中主存块的替换算法​        如果有新的主存块需要调入 Cache，而可用空间又已经占满，这时就需要替换掉某个旧块，这就产生了替换策略（替换算法）的问题。当采用直接映射时，替换的位置是固定的，无须考虑替换算法；而在采用全相联映射或组相联映射时，就需要使用替换算法来确定到底置换哪个 Cache 行。\n​        常用的替换算法有 随机（RAND）算法、先进先出（FIFO）算法、最近最少使用（LRU）算法 和 最不经常使用（LFU）算法。其中最常考查的是 LRU 算法。\n\n随机算法：随机地确定替换的 Cache 块。实现简单，但未依据局部性原理，命中率较低。\n先进先出算法（Fisrt In First Out，FIFO）：选择最早调入的行进行替换。实现简单，但也未依据局部性原理。\n最近最少使用算法（Least Recently Used，LRU）：依据局部性原理，选择近期最久未访问过的 Cache 行作为被替换的行。LRU 算法为每个 Cache 行设置一个计数器，用来记录每个块的使用情况，并根据计数值选择淘汰某个块。\n最不经常使用算法（Least Frequently Used，LFU）：将一段时间内访问次数最少的 Cache 行换出。与 LRU 类似，也设置一个计数器，Cache 行建立后从 0 开始计数，每访问一次计数器加 1，需要替换时将计数值最小的行换出。\n\n​        例如，假设一台机器 Cache 有 8 个行，初始值为空，采用 4 路组相联映射方式和 LRU 替换策略，当顺序访问主存块号为 0，4，8，3，0，6，12，0，4，8 时，缓存的命中和替换情况如下：\n\nLRU 算法中利用计数器来表示 Cache 行未被访问的时间。整体原则是：当 Cache 行有新的主存块调入时，计数器开始计数，初始值为 0，此后每遇到一次对 Cache（或 Cache 组）的访问就加 1；如果一次访问 Cache 命中了这一行，就将计数器清 0；每次有 Cache 行计数器清 0，其它行的计数器依然要加 1，不过只需要计数值比当前行更小的那些继续加 1 就可以了。\n​        需要替换时，直接选择计数值最大的行，调入新的块并将计数器置 0。这是由于不同的 Cache 行不会同时开始计数，且每次都同步加 1，所以所有 Cache 行的计数值都不会相同，每次发生替换时必然能够找到一个最大值；而一旦有计数器清 0，比它计数值更大的那些也是都不加 1，依然保持着原有的大小顺序。\n​        这样一来，如果当前 Cache 共有 2c 行，分为 Q = 2q 组，每组行数为 R = 2c / Q = 2c-q ，那么计数器的值就不会超过 R；只要用 c - q 位就可以表示计数器了，这被叫做 LRU 位。因此，计数值的位数与 Cache 组的大小有关。当为 2 路时有 1 位 LRU 位，4 路时有 2 位 LRU 位。LRU 位会同标记、有效位一同作为 Cache 的一部分。\n3.6.4 Cache 写策略​        因为 Cache 中的内容是主存块内容的副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache内容和主存内容保持一致。此时分两种情况：\n（1）Cache 写命中（要修改的单元在 Cache 中）\n​        这种情况有两种处理方法：\n\n写直达法\n\n​        也叫全写法、写穿透法。将数据同时写入 Cache 和主存。这种方法实现简单，一致性好。缺点是降低了速度，时间开销为访存时间。为了减少写入主存的开销，可以在 Cache 和主存之间加一个写缓冲。\n\n写回法\n\n​        也叫回写法、写返回法。数据只写入 Cache，而不立即写入主存，只有当此块被换出时才写回主存。这种方法效率很高，但一致性较差。在每个 Cache 行中设置一个修改位（脏位），若修改位为 1（“脏”），则说明对应 Cache 行中的块被修改过，替换时须写回主存；若修改位为 0（“净”），则替换时无须写回主存。\n（2） Cache 写未命中（要修改的单元不在 Cache中 ）\n​        这种情况也有两种处理方法：\n\n写分配法\n\n​        把数据写入主存，同时将该块调入Cache。这种方法依据了空间局部性原理。\n\n非写分配法\n\n​        只把数据写入主存，不进行调块。\n​        非写分配法通常与全写法合用，写分配法通常与回写法合用。\n​        这样，还是之前的机器，采用组相联映射的 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q  ，即采用 R 路组相联映射，假如还采用了 LRU 替换策略和回写法，那 Cache 行应该包含以下部分：\n\n​        现代计算机通常设立多级 Cache，一般两级 Cache 按离 CPU 的远近分别命名为 L1 Cache、L2 Cache，离 CPU 越近则速度越快、容量越小。指令 Cache 与数据 Cache 分离一般在 L1 级，LI Cache 对 L2 Cache 使用全写法，L2 Cache 对主存使用回写法。由于L2 Cache的存在，避免了因频繁写而造成写缓冲溢出的情况。\n3.7 虚拟存储器​        早期的计算机，CPU 是直接操作主存的，也就是运行程序时，直接给出要访问的实际主存地址。这种方式简单直接，但是会有一些问题：\n\n不同的程序之间需要共享内存，它们的内存地址空间很难隔离，从而导致程序运行的稳定性和安全性降低；\n主存容量有限，如果同时执行的程序太多、使用内存太大容易超出容量限制而崩溃。\n\n\n为了解决这些问题，在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统。\n​        主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。\n3.7.1 虚拟存储器的基本概念​        虚拟存储器将主存和辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存的实际存放位置。用户编程允许涉及的地址称为 虚地址 或 逻辑地址，虚地址对应的存储空间称为虚拟空间。实际的主存地址称为 实地址 或 物理地址，实地址对应的是主存地址空间。虚地址比实地址要大很多。\n​        使用虚拟存储器之后，程序中看到的地址都是逻辑地址。在访存时，逻辑地址首先会被转换成物理地址，然后再访问实际物理内存。\n\n这样一来，每一个程序都有独立的虚拟地址空间，不同进程的虚拟地址空间互相不干扰，提高了安全性。在每个进程看来，就像它自己独享了整个内存。当物理内存不够时，可以将一部分不常使用的内存块换出（Swap-out）到磁盘中，下次使用时再换入到内存中（Swap-in），这样程序就可以使用超过实际物理内存大小的地址空间了。\n\nCPU 使用逻辑地址时，先判断这个逻辑地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问。若主存已满，则采用 替换算法 置换主存中的页。\n​        虚拟存储器采用了和 Cache 类似的技术，将辅存中经常被访问的数据副本存放到主存中。但缺页 （或段）而访问辅存的代价很大，因此虚存机制采用 全相联映射，每个页可以存放到主存区域的任意一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而采用 回写法。    \n3.7.2 页式虚拟存储器​        页式虚拟存储器 以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为 实页 或 页框，虚存的页称为 虚页。这样，一个逻辑地址可以分为两段：虚页号 和 页内地址。\n\n虚页和实页之间采用全相联映射，所以从主存中依次查找要访问的虚页号比较困难。所以我们专门引入一个数据结构，用来保存虚页号和实页号的映射关系，这就是 页表。页表可以实现从逻辑地址到物理地址的转换。\n1. 页表​        页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。每个程序都有自己的页表，页表一般长久地保存在内存中。\n​        页表中的每一项，都包含以下几部分：\n\n有效位：也称 装入位，用来表示对应页面是否在主存，若为 1，则表示该虚页已从外存调入主存，此时页表项存放该页的物理页号；若为 0，则表示页面没有调入主存，此时页表项可以存放该页的磁盘地址。\n脏位：也称 修改位，用来表示页面是否被修改过，虚拟存储机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。\n引用位：也称 使用位，用来配合替换策略进行设置，例如是否使用先进先出（FIFO）或近期最少使用（LRU）策略等。\n\n\n​        CPU 执行指令时，需要先将逻辑地址转换为主存物理地址。每个进程都有一个 页表基址寄存器，存放该进程的页表首地址，然后根据逻辑地址高位部分的虚页号找到对应的页表项。若装入位为 1，则取出物理页号，和逻辑地址低位部分的页内地址拼接，形成物理地址；若装入位为 0，则说明缺页，需要操作系统进行 缺页处理。缺页时会由 CPU 的内存管理单元（MMU）发出中断，操作系统需要将相应的页从磁盘取回调入主存，并将物理页的地址填入页表中。\n​        页式虚拟存储器的优点是：页的长度固定，页表简单，调入方便。缺点是：最后一页的零头无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。\n2. 快表（TLB）​        有了虚拟存储器之后，CPU 在寻址时所生成的都是虚拟地址。于是 CPU 在取指或者执行访存指令的时候，都需要进行地址翻译，而每次地址翻译都要访问主存中的页表，会产生严重的开销。\n​        依据程序执行的局部性原理，当 CPU 在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在 Cache 中，就可以不访问主存直接进行地址翻译了；这样明显能提高效率。\n​        在 CPU 芯片中，加入一个专门存放最常访问的页表项的 Cache，就叫做 转址旁路缓存（Translation Lookaside Buffer，TLB），一般简称为 “快表”。TLB 实质上就是 “页表的 Cache”，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本；所以 TLB 又被称为 页表缓存。\n\n​        相应地，把放在主存中的页表称为 慢表（Page）。 在地址转换时，先查找快表，若命中，则无须再访问主存中的页表（慢表）。\n​        TLB 通常采用 全相联映射。每个 TLB 项由页表表项内容加上一个 TLB 标记字段以及有效位等标志位组成，TLB 标记用来表示该表项取自页表中哪个虚页号对应的页表项，其内容就是该页表项对应的虚页号。\n\n3. 具有 TLB 和 Cache 的多级存储系统​        TLB 和 Cache 都属于缓存，不过它们的用途不同：\n\nTLB 用来保存最近经常访问的页表项，是对 地址映射 的缓存。\nCache 用来保存最近经常访问的主存块，是对 数据内容 的缓存。\n\n​        所以对于一个有虚拟存储器的计算机系统，可以先通过 TLB 对逻辑地址的翻译进行加速，快速得到一个物理地址；然后再通过 Cache 的地址转换判断是否 Cache 命中，从而对数据的访问进行加速。\n​        这样就将 Cache 和 TLB 结合起来，构成了多级存储系统。下面就是一个具有 2 路组相联映射 Cache 和 TLB 的多级存储系统；CPU 给出的是一个 32 位的逻辑地址，TLB 采用全相联映射，每一项都有一个比较器。\n\n\n查找时将虚页号与每个 TLB 标记同时进行比较，若有某一项相等且对应有效位为 1，则 TLB 命中，此时可直接通过TLB进行地址转换；若未命中，则 TLB 缺失，需要访问主存去査页表。\n图中所示是 两级页表方式，虚页号被分成 页目录索引 和 页表索引 两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB。若 TLB 已满，则还需要采用替换策略。\n完成由逻辑地址到物理地址的转换后，Cache 机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的 Cache 行或组，将对应 Cache 行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则 Cache 命中，此时根据块内地址取岀对应的字送 CPU。\n\n​        查找时，快表和慢表也可以同步进行。若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器，但访问主存速度几乎没有下降。\n​        在一个具有 Cache 和 TLB 的虚拟存储系统中，CPU —次访存操作可能涉及对 TLB、页表（Page）、Cache、主存和磁盘的访问。CPU 在访存过程中存在 3 种缺失情况：\n​        ① TLB 缺失：要访问页面的页表项不在 TLB 中；\n​        ② Page 缺失：要访问的页面不在主存中。\n​        ③ Cache 缺失：要访问的主存块不在 Cache 中；\n​        需要注意，如果 TLB 命中，那么 Page 一定命中；如果 Page 缺失，那么 Cache 一定缺失。所以有如下一些组合情况：\n\n\n第 1 种情况下，无须访问主存，地址转换和访问数据都可以通过高速缓存完成；\n第 2 种和第 3 种情况都 需要访问一次主存，第 2 种是访问主存取数据，第 3 种是访问页表转换物理地址；\n第 4 种情况需要访问两次主存，访问页表转换物理地址一次、访存取数据一次；\n第 5 种情况就是 “缺页异常”，需要访问磁盘，并且至少访问两次主存。\n\n​        Cache 缺失处理由硬件完成；缺页处理由软件完成，操作系统通过 “缺页异常处理程序” 实现；而 TLB 缺失既可以用硬件也可以用软件来处理。\n3.7.3 段式虚拟存储器​        在段式虚拟存储器中，将虚拟空间用 “段” 进行分割；而段是按程序的逻辑结构划分的，各段的长度因程序而异。虚地址分为两部分：段号 和 段内地址。虚地址到实地址之间的变换是由 段表 来实现的。段表的每行记录与某个段对应的段号、 装入位和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。\n\n​        CPU 用逻辑地址访存时，先根据段号与段表基地址拼接成对应的段表项，再根据该段表项的装入位判断该段是否已调入主存（装入位为 “1”，表示该段已调入主存）。当已调入主存时，从段表读岀该段在主存的起始地址，与段内地址相加，得到对应的主存物理地址。\n​        段式虚拟存储器的优点是，段的分界与程序的逻辑分界相对应，这使得程序易于编译、修改和保护，也便于多道程序共享；缺点是因为段长度可变，分配空间不便，容易留下碎片，造成浪费。\n3.7.4 段页式虚拟存储器​        把程序按逻辑块分段，段内再分页，主存空间也划分为大小相等的页，程序对主存的调入调出仍以 页 为基本单位，这样的虚拟存储器称为 段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个 段表，每段对应一个 页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。\n\n​        虚地址分为 段号、段内页号、页内地址 3 部分。CPU 根据虚地址访存时，首先根据段号得到段表地址，然后从段表中取出该段的页表起始地址，与虚地址段内页号拼接，得到页表地址；最后从页表中取出实页号，与页内地址拼接成主存实地址。\n​        段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护；缺点是在地址变换过程中需要两次查表，系统开销较大。\n3.7.5 虚拟存储器与 Cache 的比较​        相同点：\n\n目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。\n都把数据划分为信息块，作为基本的传送单位，虚拟存储器系统的信息块更大。\n都有地址的映射算法、替换算法、更新策略等问题。\n依据局部性原理，应用“快速缓存”思想，将活跃的数据放在相对高速的部件中。\n\n​        不同点：\n\nCache主要是为了提高系统速度，而虚拟存储器是为了解决主存容量不足的问题。\nCache由硬件实现，对所有程序员透明；虚拟存储器由操作系统和硬件共同实现，对应用程序员透明。\n在不命中时对性能的影响不同。因为 CPU 的速度约为 Cache 的 10 倍，而主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统在不命中时对系统性能的影响更大。\nCPU 与 Cache 和主存有直接通路，而辅存与 CPU 没有直接通路。在 Cache 不命中时，CPU 能和主存直接通信；而虚拟存储器系统在不命中时，须先将数据从硬盘调入主存，CPU 才能访问。\n\n3.8 章节练习一、单项选择题\n【2010真题】下列有关 RAM 和 ROM 的叙述中，正确的是    （    ）。\n\n​        Ⅰ ． RAM 是易失性存储器， ROM 是非易失性存储器​        Ⅱ ． RAM 和 ROM 都采用随机存取方式进行信息访问​        Ⅲ． RAM 和 ROM 都可用作 Cache​        Ⅳ． RAM 和 ROM 都需要进行刷新\n​        A．仅Ⅰ 和Ⅱ                     B．仅Ⅱ 和Ⅲ                    C．仅Ⅰ 、 Ⅱ 和Ⅳ                     D．仅Ⅱ 、 Ⅲ和Ⅳ\n​        答案：A\n\n【2011真题】下列各类存储器中，不采用随机存取方式的是    （    ）。\n\n​        A． EPROM                       B． CDROM                       C． DRAM                           D． SRAM\n​        答案：B\n\n【2015真题】下列存储器中，在工作期间需要周期性刷新的是    （    ）。        \n\n​        A． SRAM                        B． SDRAM                            C． ROM                         D． FLASH \n​        答案：B\n\n【2012真题】下列关于闪存（Flash Memory）的叙述中，错误的是     （    ）。\n\n​        A． 信息可读可写，并且读、写速度一样快\n​        B． 存储元由 MOS 管组成，是一种半导体存储器\n​        C． 掉电后信息不丢失，是一种非易失性存储器\n​        D． 采用随机访问方式，可替代计算机外部存储器 \n​        答案：A\n\n【2011真题】某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4MB×8 位的 RAM芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是     （    ）。\n\n​        A． 22 位                       B． 23 位                       C． 25 位                       D． 26 位\n​        答案：D\n​        要点：MAR 的位数跟主存地址空间有关，与主存实际容量无关。\n\n【2010真题】假定用若干个 2K×4 位的芯片组成一个 8K×8 位的存储器，则地址 0B1FH 所在芯片的最小地址是    （   ）。\n\n​        A． 0000H                     B． 0600H                     C． 0700H                     D． 0800H\n​        答案：D\n\n【2014真题】某容量为 256MB 的存储器由若干 4Mx8 位的 DRAM 芯片构成， 该 DRAM 芯片的地址引脚和数据引脚总数是    （    ） 。\n\n​        A. 19                             B. 22                         C. 30                         D. 36 \n​        答案：A        \n​        要点：DRAM 采用地址复用技术，地址线为正常的一半。 \n\n【2016真题】某存储器容量为 64KB，按字节编址，地址 4000H~5FFFH 为 ROM 区，其余为 RAM 区。若采用 8K× 4 位的 SRAM 芯片进行设计，则需要该芯片的数量是     （    ）。\n\n​        A． 7                             B． 8                          C． 14                         D． 16 \n​        答案：C\n\n【2018真题】假定 DRAM 芯片中存储阵列的行数为 r、列数为 c，对于一个2Kx1 位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 r、c的取值分别是    （    ）。\n\n​        A. 2048、1                    B. 64、32                    C. 32、64                    D. 1、2048\n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，按行刷新。\n\n【2017真题】某计算机主存按字节编址，由 4 个 64M × 8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是    （    ）。\n\n​        A． 1                             B． 2                             C． 3                             D． 4 \n​        答案：C\n​        要点：多体低位交叉存储器可增大带宽，每个存储周期对所有芯片各读取一次；double 型变量占 8 个字节。\n\n【2021真题】某计算机的存储器总线中有 24 位地址线和 32 位数据线，按字编址，字长为 32 位。若 00 0000H~3F FFFFH 为 RAM 区，则需要 512K x 8 位的 RAM 芯片数为    （    ）。\n\n​        A.8                                B.16                                C.32                                D.64\n​        答案：C\n\n【2022真题】某内存条包含 8 个 8192 x 8192 x 8 位的 DRAM 芯片，按字节编址，支持突发 (burst) 传送方式，对应存储器总线宽度为 64 位，每个 DRAM 芯片内有一个行缓冲区 (row buﬀer)。 下列关于该内存条的叙述中，不正确的是    （   ）。\n\n​        A. 内存条的容量为 512 M                             B. 采用多模块交叉编址方式\n​        C. 芯片的地址引脚为 26 位                           D. 芯片内行缓冲有 8192 x 8 位 \n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，地址引脚为正常的一半；行缓冲区的大小就是一行的大小。\n\n【2013真题】下列选项中，用于提高 RAID 可靠性的措施有    （    ）。\n\n​        I.磁盘镜像        II. 条带化        III.奇偶校验        IV.增加 Cache机制\n​        A.仅I、II            B.仅I、III            C.仅I、III和IV            D.仅II、III和IV\n​        答案：B\n​        要点：RAID 通过条带化来实现并行读写；通过磁盘镜像和校验增加可靠性。\n\n【2013真题】某磁盘的转速为 10000 转/分，平均寻道时间是 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为    （    ）。\n\n​        A.9ms                    B.9.4 ms                    C.12 ms                    D. 12.4 ms\n​        答案：B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间 + 控制器延迟  。\n\n【2015真题】若磁盘转速为 7200 转/分，平均寻道时间为 8 ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是     （    ）。\n\n​        A． 8.1 ms                     B． 12.2 ms                 C． 16.3 ms                     D． 20.5 ms\n​        答案： B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间  。\n\n【2019真题】下列关于磁盘存储器的叙述中，错误的是     （    ）。\n\n​        A．磁盘的格式化容量比非格式化容量小                B．扇区中包含数据、地址和校验等信息\n​        C．磁盘存储器的最小读写单位为一字节                D．磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成 \n​        答案：C\n​        要点：磁盘最小读写单位为一个扇区。\n\n【2014真题】采用指令 Cache 与数据 Cache 分离的主要目的是    （    ） 。\n\n​        A. 降低 Cache 的缺失损失                 B. 提高 Cache 的命中率                \n​        C. 降低 CPU 平均访存时间                 D. 减少指令流水线资源冲突\n​        答案：D\n\n【2017真题】某C语言程序段如下：\n\n123456for(i=0; i&lt;=9; i++)&#123;     temp=1;    for(j=0； j&lt;=i； j++)temp * =a[j];    sum + =temp；&#125;\n​        下列关于数组 a 的访问局部性的描述中，正确的是     （    ）。\n​        A．时间局部性和空间局部性皆有\n​        B．无时间局部性，有空间局部性\n​        C．有时间局部性，无空间局部性\n​        D．时间局部性和空间局部性皆无 \n​        答案：A\n\n【2015真题】假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写（Write Back）方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是         （    ）。\n\n​        A． 146K                             B． 147K                        C． 148K                         D． 158K\n​        答案：C\n​        要点：直接映射方式下，主存块号位数 m = 标记位数 t + Cache 行号位数 c ；\n​                    回写策略下，每个 Cache 行需要另加 1 位修改位（脏位）；\n​                    Cache 行总位数 = 1位有效位 + 1位修改位 +（LRU位）+ 标记 + 数据。\n\n【2022真题】若计算机主存地址为 32 位，按字节编址，某 Cache 的数据区容量为 32KB, 主存块大小为 64B, 采用 8 路组相联映射方式，该 Cache 中比较器的个数和位数分别为     （    ）。\n\n​        A. 8, 20                     B. 8, 23                     C. 64, 20                     D. 64, 23 \n​        答案：A\n​        要点：Cache 中比较器的个数就是组相联的路数 R，比较器的位数就是标记 t 的位数。\n​                    组相联映射方式下，主存块号位数 m = 标记位数 t + Cache 组号位数 q\n\n【2016真题】有如下 C 语言程序段：\n\n12for(k=0; k&lt;1000; k++)    a[k] = a[k]+32;\n​        若数组 a 及变量 k 均为 int 型， int 型数据占 4B，数据 Cache 采用直接映射方式，数据区大小为 1KB、块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为     （    ）。\n​        A． 1.25%                     B． 2.5%                     C． 12.5%                     D． 25% \n​        答案：C\n​        要点：循环内语句需要对 a[k] 访问两次，第一次未命中，并将其所在块调入主存；第二次命中；在该块中的后面三个元素的 6 次访问也都命中。\n\n【2010真题】下列命中组合情况中，一次访存过程中不可能发生的是     （    ）。\n\n​        A． TLB 未命中， Cache 未命中， Page 未命中\n​        B． TLB 未命中， Cache 命中， Page 命中\n​        C． TLB 命中， Cache 未命中， Page 命中\n​        D． TLB 命中， Cache 命中， Page 未命中 \n​        答案：D\n​        要点：TLB 命中，Page 必命中；Page 缺失，Cache 必缺失。\n\n【2019真题】下列关于缺页处理的叙述中，错误的是     （    ）。A．缺页是在地址转换时 CPU 检测到的一种异常B．缺页处理由操作系统提供的缺页处理程序来完成C．缺页处理程序根据页故障地址从外存读入所缺失的页D．缺页处理完成后回到发生缺页的指令的下一条指令执行 \n\n​        答案：D\n​        要点：缺页处理完成后回到发生缺页的指令继续执行。\n\n【2020真题】下列关于 TLB 和 Cache 的叙述中，错误的是    （    ）。\n\n​        A.命中率都与程序局部性有关                            B.缺失后都需要去访问主存\n​        C.缺失处理都可以由硬件实现                            D.都由 DRAM 存储器组成\n​        答案：D\n\n【2015真题】假定编译器将赋值语句 “ x=x+3; ” 转换为指令 “add xaddr, 3”，其中， xaddr 是 x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是    （    ）。\n\n​        A． 0                                 B． 1                            C． 2                             D． 3 \n​        答案：B\n​        要点：直写方式下，每次写入都必须将数据同时写入 Cache 和主存。\n\n【2013真题】某计算机主存地址空间大小为256 MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB (快表)采用全相联映射，有 4 个页表项，内容如下表所示\n\n\n​        则对虚拟地址 03FF F180H 进行虚实地址变换的结果是    （   ）。\n​        A.015 3180H                    B.003 5180H                    C.TLB缺失                    D.缺页\n​        答案：A\n​        要点：虚页号的位数，可以由虚页的个数推出；TLB 中保存的标记就是虚页号。\n\n【2022真题】某计算机主存地址为 24 位，采用分页虚拟存储管理方式，虚拟地址空间大小为 4GB, 页大小为4KB, 按字节编址。 某进程的页表部分内容如下表所示。 \n\n\n​        当 CPU 访问虚拟地址 0008 2840H 时，虚－实地址转换的结果是     （    ）。\n​        A. 得到主存地址 02 4840H                         B. 得到主存地址 18 0840H \n​        C. 得到主存地址 01 8840H                         D. 检测到缺页异常 \n​        答案：C\n二、综合应用题\n【2016真题】某计算机采用页式虚拟存储管理方式，按字节编址，虚拟地址为 32 位，物理地址为 24 位，页大小为 8KB；TLB 采用全相联映射； Cache 数据区大小为 64KB，按 2 路组相联方式组织，主存块大小为 64B。存储访问过程的示意图如下。 \n\n\n​        请回答下列问题。\n​    （1）图中字段 A~G 的位数各是多少？ TLB 标记字段 B 中存放的是什么信息？\n​    （2）将块号为 4099 的主存块装入到 Cache 中时，所映射的 Cache 组号是多少？对应的 H 字段内容是什么？\n​    （3) Cache 缺失处理的时间开销大还是缺页处理的时间开销大？为什么？ \n​        答案：\n​    （1）页大小为 8KB，页内偏移地址为 13 位，故 A=B=32-13=19； D=13； C=24-13=11；\n​        主存块大小为 64B，故 G=6。 \n​        2 路组相联，每组数据区容量有 64 B×2=128B，共有 64KB/128B=512 组，故 F=9；\n​        E = 24-G-F = 24-6-9 = 9。\n​        因而  A=19， B=19， C=11， D=13， E=9， F=9， G=6。\n​        TLB 中标记字段 B 的内容是虚页号，表示该 TLB 项对应哪个虚页的页表项。\n​    （2）块号 4099=00 0001 0000 0000 0011B，因此，所映射的 Cache 组号为 0 0000 0011B=3，对应的 H 字段内容为 0 0000 1000B。 \n​    （3） Cache 缺失带来的开销小，而处理缺页的开销大。 因为缺页处理需要访问磁盘，而 Cache 缺失只要访问主存。\n\n【2018真题】某计算机采用页式虚拟存储管理方式，按字节编址。CPU 进行存储访问的过程如图所示。\n\n\n​        根据上图回答下列问题。\n​        (1) 主存物理地址占多少位？\n​        (2) TLB 采用什么映射方式？TLB 用 SRAM 还是 DRAM 实现?\n​        (3) Cache 采用什么映射方式？若 Cache 采用 LRU 替换算法和回写（Write Back）策略，则 Cache 每行中除数据（Data）、Tag 和有效位外，还应有哪些附加位？Cache 总容量是多少？Cache 中有效位的作用是什么？\n​        (4) 若 CPU 给出的虚拟地址为 0008 C040H，则对应的物理地址是多少？是否在 Cache 中命中？说明理由，若 CPU 给出的虚拟地址为 0007 C260H，则该地址所在主存块映射到的 Cache 组号是多少?\n​        答案：\n​    （1）物理地址由实页号和页内地址拼接，因此其位数为 16+12 = 28；或直接可得 20+3+5 = 28。\n​    （2） TLB 采用全相联映射，可以把页表内容调入任一块空 TLB 项中， TLB 中每项都有一个比较器，没有映射规则，只要空闲就行。 TLB 采用静态存储器 SRAM，读写速度快，但成本高，多用于容量较小的高速缓冲存器。\n​    （3）图中可以看到， Cache 中每组有两行，故采用 2 路组相联映射方式。\n​        因为是 2 路组相联并采用 LRU 替换算法，所以每行（或每组）需要 1 位 LRU 位；因为采用回写策略，所以每行有 1 位修改位（脏位），根据脏位判断数据是否被更新，如果脏位为 1 则需要写回内存。\n​        28 位物理地址中 Tag 字段占 20 位，组索引字段占 3 位，块内偏移地址占 5 位，故 Cache 共有 23 = 8组，每组 2 行，每行有 25 = 32B；故 Cache 总容量为 8×2×(20+1+1+1+32×8) = 4464 位 = 558 字节。\n​        Cache 中有效位用来指出所在 Cache 行中的信息是否有效。\n​    （4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。\n​        利用虚拟地址的虚页号部分去查找 TLB 表（缺失时从页表调入），将实页号取出后和虚拟地址的页内地址拼接，就形成了物理地址。\n​        虚页号 008CH 恰好在 TLB 表中对应实页号 0040H（有效位为 1，说明存在），虚拟地址的后 3 位为页内地址 040H，则对应的物理地址是 0040040H。物理地址为 0040040H，其中高 20 位 00400H 为标志字段，低 5 位 00000B 为块内偏移量，中间 3 位 010B 为组号 2，因此将 00400H 与 Cache 中的第 2 组两行中的标志字段同时比较，可以看出，虽然有一个 Cache 行中的标志字段与 00400H 相等，但对应的有效位为 0，而另一 Cache 行的标志字段与 00400H 不相等，故访问 Cache 不命中。\n​        因为物理地址的低 12 位与虚拟地址低 12 位相同，即为 0010 0110 0000B。根据物理地址的结构，物理地址的后八位 01100000B 的前三位 011B 是组号，因此该地址所在的主存映射到 Cache 组号为 3。 \n\n【2020真题】假定主存地址为 32 位，按字节编址，指令 Cache 和数据 Cache 与主存之间均采用 8 路组相联映射方式，直写（WriteThrough）写策略和 LRU 替换算法，主存块大小为 64B，数据区容量各为 32KB。开始时 Cache 均为空。请回答下列问题。(1) Cache 每一行中标记（Tag）、LRU 位各占几位？是否有修改位？(2) 有如下 C 语言程序段:\n\n12for (k=0; k&lt;1024 ;k++)    s[k]=2*s[k];\n​        若数组 s 及其变量 k 均为 int 型，int 型数据占 4B，变量 k 分配在寄存器中，数组 s 在主存中的起始地址为0080 00C0H，则该程序段执行过程中，访问数组 s 的数据 Cache 缺失次数为多少？\n​        (3) 若 CPU 最先开始的访问操作是选取主存单元 0001 0003H 中的指令，简要说明从 Cache 中访问该指令的过程，包括 Cache 缺失处理过程。\n​        答案：\n​    （1）主存块大小为 64B=26 字节，故主存地址低 6 位为块内地址， Cache 组数为 32KB/(64B×8) = 64=26， 故主存地址中间 6 位为 Cache 组号， 主存地址中高 32-6-6=20 位为标记；\n​        采用 8 路组相联映射， 故每行中 LRU 位占 3 位；\n​        采用直写方式，故没有修改位。\n​    （2）因为数组s的起始地址最后 6 位全为 0， 故 s 位于一个主存块开始处，共占 1024×4B/64B=64 个主存块；\n​        执行程序段过程中，每个主存块中的 64B/4B=16 个数组元素依次读、写 1 次， 因而对于每个主存块，总是第一次访问缺失，以后每次命中。\n​        综上， 数组 s 的数据 Cache 访问缺失次数为 64 次。（3） 0001 0003H = 0000 0000 0000 0001 0000  000000  000011B， 根据主存地址划分可知，组索引为 0， 故该地址所在主存块被映射到指令 Cache 第 0 组； \n​        因为 Cache 初始为空，所有 Cache 行的有效位均为 0， 所以 Cache 访问缺失。此时，将该主存块取出后存入指令 Cache 第 0 组的任意一行，并将主存地址高 20 位（00010H）填人该行标记字段，设置有效位，修改 LRU 位， 最后根据块内地址 000011B 从该行中取出相应内容。\n\n【2021真题】假设计算机 M 的主存地址为 24 位，按字节编址；采用分页存储管理方式，虚拟地址为 30 位,页大小为 4 KB；TLB 采用 2 路组相联方式和 LRU 替换策略，共 8 组。请回答下列问题。\n\n​        (1) 虚拟地址中哪几位表示虚页号？哪几位表示页内地址？\n​        (2) 已知访问 TLB 时虚页号高位部分用作 TLB 标记，低位部分用作 TLB 组号，M 的虚拟地址中哪几位是 TLB 标记？哪几位是 TLB 组号？\n​        (3) 假设 TLB 初始时为空，访问的虚页号依次为 10、12、16、7、26、4、12 和 20，在此过程中，哪一个虚页号对应的 TLB 表项被替换？说明理由。\n​        (4) 若将 M 中的虚拟地址位数增加到 32 位，则 TLB 表项的位数增加几位？\n​        答案：\n​        注意：对于本题的 TLB，需要采用处理 Cache 的方式求解。\n​    （1）按字节编址， 页面大小为 4 KB=212B，所以页内地址为 12 位。 虚拟地址中高 30-12=18 位表示虚页号， 虚拟地址中低 12 位表示页内地址。\n​    （2）TLB 采用 2 路组相联方式，共 8=23 组，用 3 位来 标记组号。 虚拟地址（或虚页号）中高18-3=15 位为 TLB 标记， 虚拟地址中随后 3 位（或虚页号中低 3 位）为 TLB 组号。\n​    （3）虚页号 4 对应的 TLB 表项被替换。 因为虚页号与 TLB 组号的映射关系为\n​                        TLB 组号＝虚页号 mod TLB 组数＝虚页号 mod 8, \n​        因此，虚页号 10,12,16, 7,26,4,12,20 映射到的 TLB 组号依次为 2,4,0,7,2,4,4,4。\n​        TLB 采用 2 路组相联方式， 从上述映射到的TLB 组号序列可以看出，只有映射到 4 号组的虚页号数量大于 2, 相应虚页号依次是 12,4,12 和 20。根据 LRU 替换策略， 当访问第 20 页时， 虚页号 4 对应的TLB 表项被替换出来。\n​    （4）虚拟地址位数增加到 32 位时， 虚页号增加了 32-30=2 位， 使得每个TLB 表项中的标记字段增加 2 位， 因此，每个TLB 表项的位数增加 2 位。\n第四章 指令系统4.1 本章大纲要求与核心考点4.1.1 大纲内容（一）指令系统的基本概念\n（二）指令格式\n（三）寻址方式\n（四）数据的对齐和大/小端存放方式\n（五）CISC 和 RISC 的基本概念\n（六）高级语言程序与机器级代码之间的对应\n\n编译器、汇编器和链接器的基本概念\n选择结构语句的机器级表示\n循环结构语句的机器级表示\n过程（函数）调用对应的机器级表示\n\n4.1.2 核心考点​        本章内容是也是考研考察的一个重点，一般会与第二章、第三章和第五章进行结合，往往以综合应用题的形式出现。而常见的寻址方式很容易以单项选择题的形式进行考察。\n​        需要重点掌握的内容包括：\n\n指令的格式及相关概念，定长与扩展操作码格式。\n常见的寻址方式、特点及有效地址的计算。\n常用的汇编指令，过程调用、选择语句和循环语句的机器级表示，标志位及其使用。\nCISC 和 RISC 的基本概念，CISC 和 RISC 的比较。\n\n4.1.3 真题分布        \n          考点\n          考查次数\n            \n          单项选择题\n          综合应用题\n            \n          常见寻址方式\n          9\n          5\n            \n          指令格式\n          4\n          6\n            \n          程序的机器级代码表示\n          0\n          2\n            \n          CISC 和 RISC\n          1\n          1 \n      \n4.2 指令和指令格式​        计算机是通过连续执行一条条机器语言语句，而实现自动工作的。习惯上就把每一条机器语言的语句称为 指令，而把全部机器指令的集合称为机器的 指令系统。\n\n指令（机器指令）是指计算机执行某种操作的机器语言命令。\n一台计算机的所有指令的集合构成该计算机的 指令系统，也称 指令集。\n\n​        指令系统是计算机的主要属性，位于硬件和软件的交界面上。\n4.2.1 指令的基本格式​        指令由 操作码 和 地址码（操作数地址） 两部分组成。\n\n\n操作码：指出指令执行什么操作和具有何种功能。例如，指出是算术加运算，还是减运算；是程序转移，还是返回操作。\n地址码：指岀被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。\n\n4.2.2 指令字长​        指令字长 是指一条指令中所包含的二进制代码的位数，它取决于操作码的长度、操作数地址的长度和操作数的个数。不同机器的指令字长是不同的，指令字长通常取 8 的整数倍。\n​        按照字长是否可变，又可以将指令系统分为 定长指令字结构 和 变长指令字结构。\n1. 定长指令字结构​        在一个指令系统中，若所有指令的长度都是相等的，称为 定长指令字结构（定字长指令）。\n​        早期的计算机都是定长指令字结构，而且指令字长、机器字长、存储字长全部相等；这样每次访问某个存储单元，就可以取出一个完整的指令或者数据。\n\n​        定字长指令的执行速度快，控制简单。精简指令系统计算机（Reduced Instruction Set Compter，RISC）采用定字长指令。\n2. 变长指令字结构​        随着计算机的发展，存储容量不断增大，要求处理的数据类型也越来越多，指令字长发生了很大变化。一台计算机的指令系统可以采用不同长度的指令，比如单字长指令、多字长指令。\n​        若指令系统中各种指令的长度随指令功能而异，就称为 变长指令字结构（变字长指令）。由于主存是按字节编址的，所以指令字长多为字节的整数倍。\n\n​        控制变长指令的电路会比较复杂，而且多字长指令需要多次访问主存才能取出一条完整指令，导致了 CPU 速度降低。\n​        原则上讲，短指令比长指令好，因为短指令能节省存储空间，提高取指令的速度，但也有很大的局限性。长指令占用更多的存储空间，取指令的时间也会更长，但其能扩大寻址范围或可带多个操作数。 如果长、短指令在同一机器中混合使用，就会给指令系统带来很大的灵活性。为了提高指令运行速度、节省存储空间，一般会尽可能地把常用的指令设计成单字长或者短字长的格式。\n​        复杂指令系统计算机 （Complex Instruction Set Compter，CISC）采用变字长指令。\n4.2.3 地址码​        地址码 用来指出指令操作涉及到的数据或指令具体保存的位置，可以包括：\n\n源操作数的地址（一个或两个）\n操作结果的地址\n下一条指令的地址\n\n​        这里的 “地址” 一般指主存地址，也可以是寄存器的地址，甚至可以是 I/O 设备的地址。\n​        我们以主存地址为例，分析一        其中 OP 是操作码；地址码 A1 为第一操作数地址，A2 为第二操作数地址，Am 为结果地址，A4 为下一条指令的地址。\n​        这一指令完成的操作可以写作：下地址码的分配。根据地址码字段的数量不同，可以把指令再做分类：\n1. 四地址指令​        地址码字段最多的指令，可以包含所有的信息，共有四个地址字段：\n\n​        其中 OP 是操作码；地址码 A1 为第一操作数地址，A2 为第二操作数地址，A3 为结果地址，A4 为下一条指令的地址。\n​        这一指令完成的操作可以写作：\n\n​        对 A1 和 A2 中存放的数据执行 OP 操作，得到的结果填入 A3 ，然后再跳转到 A4 位置执行下一条指令。后续指令地址可以任意填写。\n\n​        假设采用定字长指令结构，指令字长为 32 位，操作码 OP 固定为 8 位。这样，每个地址码就应该占据 6 位，那么能够寻址的地址范围为 2^6^ = 64。\n​        这里如果都是主存地址，那么完成这样的一条四地址指令，需要访问主存 4 次（取指令 → 取操作数 A1 → 取操作数 A2 → 结果写入 A3）。\n2. 三地址指令​        程序中大多数指令都是顺序执行的，而程序计数器 PC 存放了当前要执行指令的地址，每次执行完会自动计算下一条指令的地址（“加 1”）；所以一般并不需要在指令中直接给出下一条指令的地址，A4 可以省去，这样就得到了三地址指令。\n\n​        跟四地址指令一样，它也可以完成操作：\n\n(A_1)OP(A_2)→A_3​        后续的指令地址隐含在 PC 中。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码也可以占据 8 位，能够寻址的地址范围为 2^8^ = 256。当然，完成这样一条指令同样需要 4 次访存。\n3. 二地址指令​        如果将操作的结果直接保存在某个操作数地址对应的存储单元，就又可以在指令中节省一个地址 A3，这样就得到了二地址指令。\n\n它表示执行的操作为：\n\n​        这里 A1 既代表第一个源操作数的地址，也代表本次运算结果的存放地址。这种情况下，完成这一条指令同样需要 4 次访存（取指令 → 取操作数 A1 → 取操作数 A2 → 结果写入 A1）。\n​        由于访存开销比较大，计算机运行过程中，可以将中间计算结果暂存在 CPU 的寄存器（如 ACC）中，这样就节省了最后写入主存的过程。这时的二地址指令表示执行的操作为：\n\n​        这种情况下，完成指令只需要 3 次访存。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码可以占据 12 位，能够寻址的地址范围为 2^12^ = 4K。\n4. 一地址指令​        自然可以想到，如果把二地址指令的两种情况结合起来，把某个操作数放在寄存器中，同时计算结果也放在寄存器中，那么就又可以节省一个地址了；这就是一地址指令。\n\n它表示执行的操作为：\n\n​        这里第一个操作数存放在 ACC 中，第二个操作数地址为 A1，运算结果仍存放在 ACC 中。这样，完成指令只需要 2 次访存（取指令 → 取操作数 A1）。\n​        当然，上面所讨论的都是需要两个操作数的情况；一些特殊的操作，可能只需要一个操作数，比如按位取反、自增自减操作。这时表示执行的操作为：\n\n​        因为得到的结果还要再写回到对应地址中，所以需要 3 次访存（取指令 → 取操作数 A1 → 结果写入 A1）。如果指令字长仍为 32 位、操作码为 8 位，那么地址码可以占据 24 位，能够寻址的地址范围为 2^24^ = 16M。\n5. 零地址指令​        在指令系统中，还有一种指令是没有地址码的，这就是零地址指令。零地址指令中只有操作码也可以分两种情况：\n\n没有操作数的指令，比如空操作（NOP）、停机（HLT）；\n有一个隐含操作数的指令，比如子程序返回（RET）、中断返回（IRET），这类操作利用了栈数据结构，操作数的地址就隐含在堆栈指针（SP）中。\n\n4.2.4 操作码​        操作码的位数就代表了机器的操作种类，也就是机器指令集中的指令条数。操作码的长度可以是固定的，也可以是变化的。根据操作码长度是否可变，可以分为 定长操作码 和 变长操作码 两种指令格式。\n1. 定长操作码指令格式​        定长操作码指令，是在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般 n 位操作码字段的指令系统最大能够表示 2^n^ 条指令。\n\n​        这种指令格式便于计算机硬件设计，指令译码和识别时间短，广泛应用于字长较长的、大中型计算机和超级小型计算机以及 RISC（Reduced Instruction Set Compter，精简指令集计算机）中。当计算机字长为 32 位或更长时，这是常规做法。\n2. 扩展操作码指令格式​        可变长度操作码指令，是指全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。\n​        常见的可变长度操作码是 扩展操作码。在指令字长一定的条件下，操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码。\n​        在设计扩展操作码指令时，需要注意两点：\n\n不允许短操作码是长操作码的前缀；\n各指令的操作码一定不能重复。\n\n​        下面就是一种扩展操作码的示例。指令字长为 16 位，前 4 位为基本操作码字段 OP，另有 3 个 4 位的地址字段分别为 A1、A2、A3。\n\n​        4 位基本操作码若全部用于三地址指令，则有 16 条。如果考虑到需要扩展到较少地址的指令，则将三地址指令减为 15 条，1111 留作扩展操作码使用；二地址指令为 15 条，1111 1111留作扩展操作码使用；一地址指令为 15 条，1111 1111 1111 留作扩展操作码使用；零地址指令为 16 条。\n​        除了这种安排以外，还有其他多种扩展方法，如形成 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令；或者 12 条三地址指令、61 条二地址地址、47 条一地址指令和 16 条零地址指令。\n\n​        在通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n4.2.5 指令的操作数类型和操作类型1. 操作数类型​        计算机中常见的操作数类型有数字、地址、字符、逻辑数据等。\n\n数字：计算机中常见的数字有定点数、浮点数和十进制数，它们分别用不同格式的二进制编码来表达。\n地址：本质上也是一种数据，很多时候需要对操作数地址进行计算，可以认为是一个无符号整数。\n字符：文本或者字符串也是一种常见的数据形式。计算机不能直接存储和传送数据，需要按一定规则对字符进行编码；广泛使用的是 ASCII 编码。\n逻辑数据：除算术运算外，计算机还经常需要进行逻辑运算，此时二进制码中的 0 和 1 就应该被看作逻辑上的 “假” 和 “真”，参与逻辑与或非运算。这样的数据就是 “逻辑数据”。\n\n2. 指令的操作类型​        设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。\n​    （1）数据传送\n​        数据传送指令通常有寄存器之间的数据传送（MOV）、从内存单元读取数据到 CPU 寄存器 （LOAD）、从CPU 寄存器写数据到内存单元（STORE）等。\n​    （2）算术和逻辑运算\n​        这类指令主要有加（ADD）、减（SUB）、比较（CMP）、乘（MUL）、除（DIV）、加1 （INC）、减1 （DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等。\n​    （3）移位操作\n​        移位操作指令主要有算术移位指令、逻辑移位指令、循环移位指令等。移位操作经常被用来替代简单的乘/除法运算。\n​    （4）转移操作\n​        转移操作指令主要有无条件转移（JMP）指令、条件转移（BRANCH）指令、调用（CALL）指令、 返回（RET）指令、陷阱（TRAP）指令等。\n​        ① 无条件转移指令\n​        在任何情况下都执行转移操作，可以直接把程序转移到下一条要执行指令的地址。\n​        例如：“ JMP  X ”，就是无条件跳转到地址 X 去执行下一条指令。\n​        ② 条件转移指令\n​        条件转移指令仅在满足特定条件时才执行转移操作，转移条件一般是一个或几个标志位的值。这些标志位是某些操作的结果，也叫做 “条件码”。例如：\n\n零标志位（ZF），当结果为 0 时，ZF = 1；\n负标志位（SF），结果为负时，SF = 1；\n溢出标志位（OF），结果溢出时，OF = 1；\n进位标志位（CF），最高位有进位时，CF = 1；\n奇偶标志位（PF），结果为偶数时，PF = 1\n\n​        这样，\n​        “ JZ  X ”，就表示判断结果是否为 0：如果为 0 就跳转到 X，如果不为 0 则继续顺序执行；\n​        “ JO  Y ”，就表示判断结果是否溢出：如果溢出就跳转到 Y，如果没有溢出则继续顺序执行；\n​        “ JC  Z ”，就表示判断结果最高位是否有进位：如果有进位就跳转到 Z，如果没有则继续顺序执行。\n​        ③ 调用和返回指令\n​        调用指令可以实现从一个程序到另一个程序的转移操作。\n​        程序中，有些特定的程序段会被反复调用。为了避免重复编写，可以将这些程序段设定为 子程序；需要调用时，只需要执行子程序调用指令就可以了。还有一些子程序是系统提供的，用户也可以直接调用。\n​        调用指令（CALL）一般与 返回指令（RETURN）配合使用。CALL 用来从当前程序位置转移至子程序的入口，RETURN 则用于子程序执行完后重新返回到原程序的调用点。\n\n​        调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。\n​        ④ 陷阱（Trap）指令\n​        陷阱其实是一种意外事故引发的中断。比如，电压不稳定、I/O 设备发生故障、用户使用未定义的指令、除数为 0 等等各种意外事件，都会导致计算机不能继续正常工作。此时计算机就发出陷阱信号，暂定当前程序的执行，转入故障处理程序进行相应的处理。\n​        计算机的陷阱指令一般不提供给用户使用，而是作为隐指令，在出现故障时由 CPU 自动产生并执行。\n​    （5）输入输出操作\n​        对于 I/O 单独编址的计算机，通常设有 I/O 指令。这类指令用于 CPU 与外部设备交换数据或传送控制命令及状态信息。\n​    （6）其它操作\n​        计算机中还有一些通用的控制操作，比如等待（WAIT）、停机（HLT）、空操作（NOP）、开关中断、置条件码等，都有相应的指令来完成。\n4.3 寻址方式​        寻址方式是寻找指令或操作数有效地址的方式，也就是指确定本条指令的数据地址，以及下一条将要执行的指令地址的方法。\n​        寻址方式分为指令寻址和数据寻址两大类。\n4.3.1 指令寻址​        指令寻址是指寻找下一条将要执行的指令地址。指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。\n\n顺序寻址：可通过 程序计数器（PC）加1，自动形成下一条指令的地址。\n跳跃寻址：通过 转移类指令 实现。跳跃寻址是指下一条指令的地址码不是由 PC 给出的，而是本条指令给出的。\n\n\n​        注意：这里所说的 “ PC 加1 ” 并不是 PC 一定会加 “1” 这个数值，而是要加当前指令占据的地址长度，从而总能得到下一条指令的地址；例如，如果机器按字节编址，当前指令字长是 4 个字节，那么执行这条指令后 PC = PC + 4。\n4.3.2 数据寻址​        数据寻址是指确定本条指令中所有操作数的地址，即寻找指令要操作的数据的地址。        \n​        指令中的地址字段并不一定代表操作数的真实地址，称为形式地址（A）。结合形式地址和寻址方式，可计算出操作数在存储器中的真实存储地址，这一地址称为有效地址（EA）。\n​        由于地址字段表达的含义不同，可以有多种不同的寻址方式：比如 直接寻址、间接寻址、寄存器寻址 等。此外，如果通过将某个寄存器内容与一个形式地址相加而生成有效地址，这种方式称为 偏移寻址。偏移寻址又包括基址寻址、变址寻址 和 相对寻址。\n​        数据寻址方式的种类较多，通常在指令中设一个字段，用来指明属于哪种寻址方式。由此可得指令的格式如下：\n\n\n​        操作码的位数决定了指令的条数，寻址特征和形式地址共同决定了可寻址的范围。\n\n若为立即寻址，则形式地址的位数决定了数的范围。\n若为直接寻址，则形式地址的位数决定了可寻址的范围。\n若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。\n若为寄存器间接寻址，则寄存器字长决定了可寻址的范围。\n\n​        下面是常见数据寻址方式的详细介绍。\n1. 立即寻址​        指令的地址字段指出的不是操作数的地址，而是操作数本身，称为 立即寻址，又称为 立即数寻址。 数据采用补码形式存放。\n\n​        上面图中 # 表示立即寻址特征，A 就是操作数本身。\n\n优点：指令在执行阶段不访问主存，指令执行速度快。\n缺点：A的位数限制了立即数的范围，只适合操作数较小的情况。\n\n2. 直接寻址​        指令格式的地址字段中直接指出操作数在内存中的地址，就称为 直接寻址。即\n\n\n\n优点：指令简单，不需要专门计算操作数的地址，指令在执行阶段仅访问一次主存。\n\n缺点：A 的位数决定了操作数的寻址范围，操作数的地址不易修改。\n\n\n3. 间接寻址​        间接寻址 是相对于直接寻址而言的，是指指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址所在的存储单元地址；也就是 “地址的地址”，即 \n\n​        这里用（A）来表示地址为 A 的存储单元所存放的数据。\n\n​        间接寻址也可以分为多次进行，简称 多次间址。对于两次间接寻址，地址 A 存储的内容 A1 还不是有效地址 EA，地址 A1 对应的存储单元所存储的内容才是 EA。这时可以用存储字的首位来标记间接寻址是否结束：存储字首位为 “1” 时，说明还需要继续寻址；为 “0” 时，寻址结束，当前存储字存放的就是 EA。\n\n优点：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）；便于编制程序。\n缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次间址需多次访存)。\n\n4. 隐含寻址​        隐含寻址 是指指令字中不直接给出操作数的地址，而是隐含在某个寄存器中（通过操作码表示）。比如，一地址指令中，对于加法操作就可以只给出一个操作数的地址，而把另一个操作数放在 ACC 中；这时 ACC 就是另一个操作数的地址。\n\n​        因为隐含寻址可以省去指令字中的一个地址，所以这种方式可以缩短指令字长，在计算机的指令集中被广泛使用。\n5. 寄存器寻址​        寄存器寻址 的指令在执行时所需的操作数来自寄存器，运算结果也写回寄存器；地址码字段直接指出了寄存器的编号，即\n\nEA = R_i​        这样，指令执行期间不需要访问主存，减少了执行时间；而且计算机中寄存器数量是有限的，所以地址字段只需要用很少的二进制位指明寄存器编号即可，节省了存储空间。因此寄存器寻址在计算机被广泛应用。\n\n\n优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快。\n\n缺点：寄存器的价格昂贵，且数量有限。\n\n\n6. 寄存器间接寻址​        如果寄存器中不是直接给出操作数，而是操作数的内存地址，那么就称为 寄存器间接寻址。即 \n\n​        这是寄存器寻址和间接寻址的结合。跟寄存器寻址相比，指令的执行阶段还需要访问主存；跟间接寻址相比，则可以少一次对主存的访问。\n\n\n优点：获得操作数地址的速度较快；寄存器编号较短，可有效减少操作数字段的位数。\n\n缺点：寄存器数量有限；指令的执行阶段需要访问主存（因为操作数在主存中）。\n\n\n7. 基址寻址​        基址寻址 是一种偏移寻址的方式，需要设有基址寄存器 BR ；将基址寄存器 BR 的内容（基地址）加上指令中的形式地址，就可以形成操作数的有效地址。即\n\n​        其中基址寄存器既可采用专用寄存器，也可采用通用寄存器。采用专用基址寄存器 BR ，使用时不用明确指出，只需要指令中的寻址特征反映出是基址寻址即可，这是 隐式 基址寄存器；对应地，如果采用通用寄存器，则需要用户明确指出用哪个寄存器作为基址寄存器，这是 显式 基址寄存器。\n\n\n优点：可扩大寻址范围；有利于多道程序设计和浮动程序编制。\n\n缺点：偏移量（形式地址 A）的位数较短。\n\n\n8. 变址寻址​        变址寻址 和基址寻址极为相似，需要设有变址寄存器 IX；将变址寄存器 IX 的内容加上指令中的形式地址，就可以形成操作数的有效地址。即\n\n​        只要变址寄存器的位数足够，也可以扩大操作数的寻址范围。变址寄存器同样可以采用隐式和显式两种方式。\n\n​        不过从本质上讲，变址寻址和基址寻址还是有较大区别的。\n\n基址寄存器是面向 操作系统 的，主要用于为程序或数据分配存储空间，其内容由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的；\n变址寄存器的内容是由 用户设定 的，在程序执行过程中其值可变，而指令字中的 A 是不可变的。变址寻址主要用于处理数组问题。\n\n​        例如，某个数组 a 内有 N 个数据元素，在主存中存放的首地址为 D。那么如果要对数组所有元素求和，可以通过直接寻址的方式依次叠加得到结果，写成汇编语言程序如下：\n\n​        随着 N 的增大，程序的指令条数会越来越多，占据的存储空间也越来越大。\n​        而如果使用变址寻址，只需要将数组元素的索引下标放入变址寄存器中，每次改变变址寄存器的内容（加 1），就能用同样的指令 “ ADD X, D ” 处理所有所有数的相加了。\n\n​        利用一个条件转移指令（BNE），当变址寄存器 X 中内容还没有增大到 N 时，就跳转回 M 处再次执行相同的指令；当增大到 N 时就结束，得到最后结果。这样，不论 N 取多大，这段程序都只需用 7 条指令，所占存储单元大大减少。这其实就是 “循环” 的实现思路。\n\n优点：可扩大寻址范围；在循环体中将 A 设为数组初始地址，可实现数组功能；适合编制循环程序。\n\n9. 相对寻址​        相对寻址 也是偏移寻址的一种，它所基于的是 程序计数器 PC 。将 PC 的内容加上指令中的形式地址，就形成操作数的有效地址，即\n\n​        相对寻址通常用于转移类指令，转移后的的目标地址与当前指令有一段距离，称为 相对位移量；这里就是形式地址 A ，所以 A 也称为 位移量。A 的位数决定了操作数的寻址范围，可正可负，用补码表示。\n\n​        相对寻址的最大特点是转移的目标地址不固定，可以随 PC 的值变化；这样，无论程序加载到主存的哪段区域，都以正确运行，对于编写浮动程序非常有利。例如，之前计算数据和的程序，跳转的目标地址固定为 M；如果程序的首地址发生了改变，M 也会变化。可以将条件转移指令改为相对寻址：\n\n​        这样，无论程序浮动到哪一地址空间，都可以正常运行了。另外，相对寻址也可以和间接寻址结合使用。\n\n优点：便于程序浮动，广泛应用于转移指令。\n\n10. 堆栈寻址​        堆栈寻址 要求计算机中设有堆栈。堆栈既可以用寄存器组来实现，称为 硬堆栈；也可以利用主存的一部分空间作为堆栈，称为 软堆栈。\n​        以软堆栈为例，可以用一个 堆栈指针 SP （Stack Pointer）指出栈顶地址，也可以用 CPU 中的寄存器作为 SP。根据栈数据结构的特点，操作数只能在栈顶指针指向的存储单元里存取。\n\n\n​        可以看出，堆栈寻址也是一种 隐含寻址，操作数的地址被隐含在了 SP 中。而从本质上看，把 SP 看作存放有效地址的寄存器，堆栈寻址就是一种 寄存器间接寻址。\n​        堆栈有 进栈（PUSH）和 出栈（POP）两种操作：\n\n进栈（PUSH A）：（SP）- 1 → SP；（ACC）→ M [ (SP) ]\n出栈（POP A）： （M [ (SP) ]）→ ACC；（SP）+ 1 → SP\n\n​        上面讨论的，都是主存按字编址的情况。如果主存按字节编址，则每次进出栈时 SP 的变化 Δ 会受到存储字长的影响；如果存储字长为 2 字节（16 位）则 Δ = 2，为 4 字节则 Δ = 4。\n\n​        下表列出了所有寻址方式、有效地址及访存次数的简单总结（不含取本条指令的访存）。\n\n\n\n\n寻址方式\n有效地址 EA\n访存次数\n\n\n\n\n立即寻址\n不需要\n0\n\n\n直接寻址\nEA = A\n1\n\n\n间接寻址\nEA = (A)\n2（一次间址）\n\n\n隐含寻址\n隐含在寄存器中\n0\n\n\n寄存器寻址\nEA = Ri\n0\n\n\n寄存器间接寻址\nEA = (Ri)\n1\n\n\n基址寻址\nEA = (BR) + A\n1\n\n\n变址寻址\nEA = (IX) + A\n1\n\n\n相对寻址\nEA = (PC) + A\n1\n\n\n堆栈寻址\nEA = (SP) - 1  （入栈） 或  EA = (SP)  （出栈）\n0（硬堆栈）或 1（软堆栈）\n\n\n\n\n4.4 CISC 和 RISC 的基本概念​        指令集的不同会导致一个处理器的基础结构不同。\n​        最早的 CPU 出现在 20 世纪 70 年代，当时的集成电路技术制约了一块芯片上能实现什么，所以它们的指令集都非常有限；以 8 位 CPU 为主，Intel 8080、MOS 6502、MC 6800 就是其中的代表。之后随着超大规模集成电路技术的发展，微处理器发展得非常迅速，指令集也越来越复杂；并且出现了将处理器、RAM、ROM 和 I/O接口等计算机基本部件集成到一个芯片上的微控制器（MCU），这就是 单片机，Intel 的 MCS-51 系列就是其中的代表。\n​        现代计算机按照处理器的 指令集架构（Instruction Set Architecture，ISA）主要可以分为两种：\n\nCISC（Complex Instruction Set Computer，复杂指令集计算机）\nRISC（Reduced Instruction Set Computer，精简指令集计算机）        \n\n​        面对越来越多的需求，计算机需要完成的任务越来越重，对计算机性能的要求也越来越高。关于如何提升计算机性能，两种指令集架构代表了不同的思路。\n4.4.1 CISC​        CISC 通过设置更多、更复杂的指令来实现更多的功能，这样就可以减少运行程序所需的指令数，依靠硬件提升运行速度。\n​        这种架构的代表公司就是 Intel，它在 1978 年推出了著名的 16 位微处理器 8086，此后又推出了 80286 和 32 位的 80386、80486 以及 奔腾（Pentium）处理器，因而这一系列的处理器都被称为 “ x86 架构 ”。如今已经进入 64 位时代，这一家族采用的指令集架构称为 “ x86-64 ” 或简称 “ x64 ”，代表就是酷睿（Core）处理器。AMD 公司生产的 CPU 主要也是 x86/64 架构。\n​        CISC 的主要特点如下：\n\n指令数目庞大且复杂。Intel 描述全套指令的文档有 1200 多页；\n指令字长是可变的。x86-64 的指令长度可以是 1 ~ 15 个字节；\n每个指令可以执行若干简单操作，例如存储器读取、存储、计算操作等，因此很多指令都能进行访存操作，可以对内存中的操作数直接进行算术和逻辑运算；\n寻址方式丰富。内存中操作数的指示符可以有各种组合，包括偏移量、基址和变址寄存器以及伸缩因子；\n逻辑控制电路复杂，寄存器较少，使用主存中的软堆栈来实现堆栈寻址；\n对机器级程序来说，实现细节是不可见的，全部由硬件完成。\n\n​        因此，CISC 有着非常明显的优缺点。\n\n优点：\n\n运行程序所需的指令数少，有效提升性能；\n\n更加依赖硬件实现功能，编写软件代码较为简单。\n\n\n\n缺点：\n\n指令执行时间差异很大，复杂的指令需要若干时钟周期才可以实现；\n\n指令的使用频率差异很大，很多复杂指令的使用率并不高；\n\n有些指令非常复杂，以至于无法通过组合逻辑电路直接完成，所以需要采用 微程序控制；\n\n编译器能做的优化有限。  \n\n\n\n4.4.2 RISC​        庞大的指令系统设计起来非常复杂，研制周期变得很长，成本耗费巨大。而且对传统 CISC 的测试发现，典型程序中 80% 的语句只用到了系统中 20% 的指令，这被称为 80 - 20 规律。\n​        于是人们开始了对指令系统合理性的研究，试图通过 “做减法” 来从另一个角度提升效率，这样就产生了 RISC。 \n​        RISC 的主要思路是减少指令种类、简化指令功能，通过降低单个指令的执行周期数（CPI）来提高 MIPS，从而提升运行速度。\n​        由于简化了指令集，CPU 芯片就不需要太大的空间来制作逻辑控制电路，而可以加入更多的寄存器，这样就可以让数据运算更快。基于这样的想法，IBM 公司开发出了第一代 RISC 架构计算机；与此同时，斯坦福大学的 RISC 研究课题 MIPS，考虑到了对处理器流水线的优化，研究结果转化成了后来 MIPS 公司的 R 系列产品。\n​        1985 年，Acom 公司设计出了基于 RISC 指令集的 32 位计算机，简称 ARM（Acorn RISC Machine）。1990 年，Acom 改组为 ARM 公司，专门研发芯片架构、出售芯片技术授权，它的指令集架构就被称为 “ ARM 架构 ”。由于 ARM 架构低功耗、低成本的特点，在嵌入式处理器中得到了非常广泛的应用：智能手机、智能汽车、智能家居等各种领域都可以看到 ARM 架构处理器的身影。\n​        如今 RISC 架构已经发展到第五代，称为 RISC-V，这是一个完全开源的指令集架构，采用宽松的 BSD 协议，企业可以完全自由免费使用，同时也容许企业添加自有指令集进行拓展。\n​        RISC 的主要特点有:  \n\n指令数量比 CISC 要少得多；只使用频度较高的简单指令，通过简单指令的组合实现复杂指令功能。早期的 RISC 指令通常少于 100 个；\n\n指令字长是固定的。早期的 RISC 通常将所有的指令都编码为 4 个字节；\n\n允许访存的指令只有 load 和 store，这被称为 load / store 体系结构。因此只能对寄存器中的操作数进行算术和逻辑运算，不能直接对内存中的操作数进行运算；\n\n寻址方式简单，一般所有的 load / store 都通过寄存器中的内容和指令字段中的偏移量来实现；\n\n逻辑控制电路比较简单，有大量的通用寄存器，可以使用硬堆栈来实现堆栈寻址。\n\n对机器级程序来说，实现细节是可见的。因此编译器需要在一些约束条件下进行性能优化；\n因此，RISC 的优缺点和 CISC 相比也是非常明显的。\n\n优点：\n\nCPI 大大降低，并且通过大量寄存器减少了访存次数，有效提升性能；\n采用流水线技术，大部分指令在一个时钟周期完成；采用超标量和超流水线技术，可以使每条指令的平均执行时间小于一个时钟周期；\n控制器便于设计和实现，采用组合逻辑控制（硬布线），不用微程序控制；\n\n可以利用编译器对程序性能进行优化。\n\n低功耗、低成本\n\n\n缺点：\n\n指令的种类和寻址方式都比较少，编写软件比较麻烦；有些早期的 RISC 机器甚至没有乘法指令，需要用一系列加法来实现；\n对编译器的要求比较高，编译器采用不同的优化策略可以显著改变运行性能；\n\n不同指令系统间兼容性差。\n\n\n\n\n4.4.3 CISC 和 RISC 的比较​        下表中详细列出了 CISC 和 RISC 的特点对比：\n\n\n\n\n对比项目\nCISC\nRISC\n\n\n\n\n指令数量\n多\n较少\n\n\n指令字长\n不固定\n固定\n\n\n可访存指令\n无限制\nLoad / Store\n\n\n各种指令使用频率\n相差很大\n相差不大\n\n\n各种指令执行时间\n相差较大\n绝大多数在一个时钟周期内完成\n\n\n寻址方式\n多\n少\n\n\n通用寄存器数量\n较少\n多\n\n\n堆栈寻址\n软堆栈\n硬堆栈\n\n\n控制方式\n微程序控制\n组合逻辑控制（硬布线）\n\n\n机器级程序实现细节\n不可见\n可见\n\n\n编译器\n难以优化\n需要优化\n\n\n指令流水线\n可以通过一定的方式实现\n必须实现\n\n\n功耗\n较高\n较低\n\n\n兼容性\n较好\n较差\n\n\n主要应用领域\nPC 和服务器\n嵌入式设备\n\n\n\n\n​        如今，RISC 机器在发展进化的过程中，逐渐引入了更多的指令；而 CISC 机器也会充分利用高性能的流水线结构。商品化的计算机一般都会将 RISC 和 CISC 结合起来，取长补短。\n4.5 高级语言程序与机器级代码4.5.1 x86 汇编指令基础1. 相关寄存器（1）通用寄存器\n​        x86 架构的 CPU 中会设置一组 通用寄存器，用来存储整数数据和指针（地址）。\n​        最初的 8086 有 8 个 16 位的寄存器，分别叫做 ax、bx、cx、dx、si、di、bp、sp，每个寄存器都有各自特殊的用途，这都体现在它们的名字中。当扩展到 32 位架构（标准名称为 IA32）时，这些寄存器也都扩展为 32 位，名称前加上了 ’‘e“ 表示扩展（extended）。\n​        每个 32 位的通用寄存器，都可以将低 16 位当作一个 16 位寄存器独立使用，最低 8 位当作一个 8 位寄存器使用；而 ax、bx、cx、dx 的高低字节都可以分别作为两个 8 位寄存器，称为 ah、bh、ch、dh 和 al、bl、cl、dl。\n\n​        这里用途最为特殊的，就是堆栈指针 ebp 和 esp，它们配合可以很容易地实现子过程的调用和返回；另外，一般也经常用 ebp + 偏移量 的形式来定位存放在栈中的局部变量。\n​        扩展为 64 位的 x86-64 架构后，原先的 8 个 32 位寄存器全部扩展到 64 位，标号以 r 开头；此外还新增了 8 个通用寄存器，标号为 r8 ~ r15。\n\n\n（2）指令指针寄存器\n​        除通用寄存器外，x86 架构的 CPU 还会设置一系列特殊功能的寄存器。其中最为重要的就是 指令指针寄存器 IP（Instruction Pointer），它存放了下一条要执行的指令的地址；很明显，这其实就是我们之前介绍的 程序计数器 PC。\n​        最初的 ip 也是 16 位的；到了 IA32 架构下，指令指针寄存器也扩展为 32 位，称为 eip；而到了 x86-64 时代，对应也扩展成了 64 位的指令寄存器，称为 rip。\n（3）标志寄存器\n​        标志寄存器 flags  里面有众多标志位，记录了 CPU 执行指令过程中的一系列状态，大都由 CPU 自动设置和修改。\n\nZF 零标志\nCF 进位标志\nSF 符号标志\nOF 溢出标志\nPF 奇偶标志\nTF 跟踪标志\nIF 中断标志\n…\n\n​        很显然，标志寄存器其实就是之前提到的 程序状态字 PSW。IA32 架构下标志寄存器为 32 位，称为 efl（eflags），除去一些不使用的保留位外，每一位都对应着一个状态标志；x86-64 架构下扩展为 64 位，不过扩展的高位都没有使用，相当于还是 32 位。\n2. 汇编指令格式​        对于 x86 指令集的汇编代码，也有两种不同的指令格式。\n\nATT 格式：由 AT&amp;T 公司而得名，这是 GCC 等常用工具的默认格式。\nIntel 格式：Intel 文档中和 Microsoft 编程工具采用的汇编格式。\n\n​        这两种格式整体风格相似，但也有很多不同：\n\n​        x86 是复杂指令集架构，支持多种寻址方式，两种格式的各种寻址方式如下：\n\n​        下面是 mov 指令的一些示例。mov 指令用于移动数据，可以将立即数、寄存器和内存中的操作数，移动到寄存器或者内存中。需要注意，ATT 格式的数据传输方向是从左向右，而 Intel 格式恰好相反。\n\n​        mov 指令不能将一个内存中的操作数，移动到另一个内存地址。\n​        下面我们主要以 Intel 格式为例，来详细介绍 C 语言和汇编指令的对应关系。\n3. 常用汇编指令（1）数据传输指令\n\nmov：在寄存器和内存之间移动数据；\nlea：load effective address，加载有效地址，将一个内存地址加载到目的寄存器；\npush：将数据压入栈，同时 esp 减去数据长度；\npop：将栈顶数据弹出栈，同时 esp 加上数据长度；\n\n（2）算术和逻辑运算指令\n​        主要可以按照操作数的个数分为两类：\n\n双操作数 —— add（加）、sub（减）、mul（无符号乘）、imul（有符号乘）、and（逻辑与）、or（或）、xor（异或）、sal/shl（左移）、sar（算术右移）、shl（逻辑右移）\n\n​        格式为：  op  D, S\n​        表示计算 D (op) S 的值，结果存入 D 中。\n\n单操作数 ——  inc（自增）、dec（自减）、neg（取负）、not（取反）\n\n​        计算的结果仍然存入操作数所在位置。\n\n​        比较特别的是除法指令，它们都只有一个操作数，表示除数，被除数则放在 edx : eax 中；得到的结果商放在 eax 中，余数放在 edx 中：\n\ndiv：无符号除\nidiv：有符号除\n\n（3）转移指令\n\n无条件转移：jmp\n\n​        jmp 指令后面一般跟一个 “标签”（label），用来指明可以直接跳转到的目的地。它的底层编码一般都是 PC 相对的，也就是相对寻址。\n\n有条件转移\n\n​        标志寄存器 efl 中有很多标志状态，也称为 “条件码”，它们记录了最近的算术逻辑操作的结果属性。通过检测这些寄存器中的条件码，就可以执行条件转移指令了。最常用的条件码有：ZF（零标志）、CF（进位标志）、SF（符号标志）、OF（溢出标志）；一般会对它们进行组合，用来表示更加容易理解的控制条件。\n\n​        上面的条件跳转指令，需要先做一个算术或逻辑运算、更改条件码；而很多时候我们只需要做一个简单比较即可，并不需要将运算结果保存。有两类特殊指令可以只改变条件码、而不改变其它任何的寄存器：\n\n​        这两种指令，特别是 cmp 经常和条件转移指令配合使用，用来实现条件分支（选择）和循环结构的程序。\n\n调用和返回\n进行子过程（函数）调用时，使用 call 指令；返回原函数时使用 ret 指令。\n\n\n4.5.2 从 C 语言程序到汇编程序1.  编译器、汇编器和链接器​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用 C 语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用 GCC 编译器可以将它翻译成一个可执行目标程序 hello。具体的过程如下图所示：\n\n​        第二步编译的结果，生成了汇编程序 hello.s，这就是汇编语言描述的机器指令；汇编程序再经过汇编就可以得到二进制的机器语言程序。\n​        在一些集成开发环境（比如 Visual Studio）中，可以在调试（Debug）模式下对机器码进行 ”反汇编“，得到相应的汇编语言代码。\n2. 进程的地址空间​        C 语言程序运行之后，对应的进程都会有自己独立的地址空间；这就是操作系统为每个进程提供的 虚拟地址空间。对于 32 位系统，进程虚拟地址空间的大小就是 2^32^ B = 4 GB。\n​        整个虚拟空间需要操作系统统一管理，因此进程的虚拟地址空间中必须保留一部分给操作系统内核使用。对于 Linux 系统（32 位），内核区大小为 1GB，地址从 0xc0000000 ~ 0xffffffff；而 Windows 系统默认情况下内核区大小为 2GB，地址从 0x80000000 ~ 0xffffffff。其余低地址部分则为用户区。\n​        下面是一个 x86 Linux 进程的虚拟地址空间。\n\n​    用户区主要包括这样几部分：\n\n程序代码和数据：主要包括 只读代码段 和 读写段（.data 和 .bss）。对所有进程来说，代码都是从固定地址开始，紧接着就是 C 语言中的全局和静态数据。其中 .data 中是已初始化的全局和静态 C 变量，而 .bss 中是未初始化的全局和静态变量。\n堆（Heap）：用于运行时的动态内存分配，向上（高地址）生长。代码和数据区，在进程开始运行时就被指定了大小；而通过调用 malloc 和 free 这样的 C 标准库函数，可以让堆区动态地扩展和收缩。\n共享库的内存映射区：用户区的中间部分是一块内存映射区域，用来存放像 C 标准库这样的共享库。\n用户栈（Stack）：位于虚拟地址空间用户区顶部，向下（低地址）生长。一般用来存储局部变量和函数参数，结合堆栈指针可以方便地实现函数的调用和返回。\n\n3. 利用栈实现函数调用​        C 语言中的函数是一种重要的抽象，它将代码按功能封装起来，让程序结构更加清晰、可重用性更高。\n​        每个函数内部可以定义局部变量，这些变量只具有局部作用域。所以，嵌套函数调用时（例如，在函数 P 中调用函数 Q），就可以利用栈数据结构 ” 后进先出 “（LIFO）的特点，在栈内依次保存函数 P 和 Q 的相关内容。\n​        这样，进程中的每一个函数，都会在栈上有一块自己的空间，就叫做 ” 栈帧 “（stack frame）；当前正在执行的函数的栈帧总是在栈顶。这样 esp 的内容就是栈顶地址，而 ebp 的内容就保存当前栈顶栈帧的 “底部” 地址。\n\n​        于是，在调用一个函数 Q（子过程）时，可以在栈上继续给 Q 中的局部变量分配内存空间（入栈）。当 Q 调用结束，就将 Q 的所有局部变量释放（出栈）。\n​        想要用机器级代码实现函数调用，还需要考虑下面几个问题：\n​        ① 参数传递：函数 Q 应该能获取到 P 传入的参数；这可以通过指定参数存放的位置（写入寄存器或者入栈）来实现。\n\n​        ② 转移控制：调用 Q 时，需要跳转到函数 Q 入口处执行指令，这可以用 call 指令实现；调用结束，还应返回到 P 中的调用点继续执行，这需要保存之前调用点的信息，将下一条指令地址入栈。\n\n​        等到调用结束时，执行 ret 指令返回，就执行出栈操作，将栈中保存的地址交给 eip，继续执行 P 中的下一条指令。\n\n​        ③ 保存上下文：原函数 P 使用的寄存器的内容，应该进行保存；调用结束后，还应该进行恢复。\n​        调用 Q 后，可以先将原函数 P 的上下文（寄存器值）做一个入栈保存；然后再分配内存给 Q 的局部变量。待 Q 调用结束后，先释放 Q 的局部变量，然后继续弹栈恢复 P 的上下文。\n\n​        比较特殊的是栈基指针 ebp，在调用 Q 之后，它应该指向 Q 的栈帧的底部；所以应该先将之前的 ebp（P 的栈帧底部）入栈，然后将 ebp 移向 esp 的位置。之后再保存 P 其它寄存器的值、分配空间给 Q 的局部变量。\n12push  ebpmov   ebp, esp\n​        当 Q 调用结束返回时，只要反向执行，让 esp 移向 ebp 的位置；再将原先保存的 ebp 的值弹出，并放入 ebp 中就可以了：\n12mov   esp, ebppop   ebp\n​        对于函数调用开始时（call 之后）两条对 ebp 的处理指令，可以用一条 enter 指令来代替；函数结束时（ret 之前）的两条指令，则可以用 leave 来代替。\n​        ④ 返回值传递：函数 Q 调用结束，执行 ret 指令，此时应该能将返回值传回原函数 P；可以通过指定某个寄存器（eax）接收返回值来实现。\n​        这样，我们可以将完整的栈帧结果表示如下：\n\n​        栈帧中主要由 4 部分构成：上一层函数的上下文（主要是寄存器的值）、当前函数的局部变量、调用下一层函数所需的参数，以及返回地址。对于当前执行的函数 Q，没有参数构造区和返回地址两部分。\n4.5.3 选择结构语句的机器级表示​        除顺序结构外，高级语言程序中一般还会有选择结构和循环结构。\n​        选择结构 又称为 分支（branch）结构。C 语言中的选择语句主要有 if … else 和 switch … case，此外三目运算符 ? : 也可以实现选择结构。\n​        很显然，通过设置条件码（标志位）、结合各类转移指令，就可以很容易地实现程序中的选择语句。\n​        下面一段 C 语言代码使用 if - else 语句实现了选择结构：\n12345678910int a = 23;int b = 31;if (a &gt; b)&#123;\ta++;&#125;else &#123;\ta--;&#125;printf(&quot; a = %d\\n&quot;, a);\n​        可以发现它等效于使用 2 个 goto，分别跳过 if 后面的分支和 else 后面的分支：\n12345678\tif (a &lt;= b)\t\tgoto L1;\ta++;\tgoto L2;L1:\ta--;L2:\tprintf(&quot; a = %d\\n&quot;, a);\n​        这样，很容易得到对应的汇编代码：\n\n4.5.4 循环结构语句的机器级表示​        C 语言中的循环语句有 do - while、while 和 for 三种。汇编语言中，同样可以用条件测试和跳转指令的组合来实现循环的效果。在循环结构中，通常使用条件转移指令来判断循环的结束。\n1. do - while 循环​        下面是一段使用了 do - while 循环的 C 语言代码：\n12345int a = 0;do &#123;\ta++;&#125; while (a &lt; 5);printf(&quot; a = %d \\n &quot;, a);\n​        很明显，循环部分可以利用 if 判断和 goto 语言来实现：\n123456\tint a = 0;L1:\ta++;\tif (a &lt; 5)\t\tgoto L1;\tprintf(&quot; a = %d \\n &quot;, a);\n​        这样，类比之前选择结构，可以得到对应的汇编表示如下：\n\n2. while 循环​        while 循环与 do - while 类似，区别在于第一次执行循环体之前就要先做条件判断。下面是一段 while 循环的 C 语言代码：\n12345int a = 0;while (a &lt; 5) &#123;\ta++;&#125;printf(&quot; a = %d \\n &quot;, a);\n​        如果用 goto 进行改写，可以参考 if - else 的实现，使用两个 goto 分别进行满足、不满足循环条件时的跳转：\n12345678\tint a = 0;L1:\tif (a &gt;= 5)\t\tgoto L2;\ta++;\tgoto L1;L2:\tprintf(&quot; a = %d \\n &quot;, a);\n​        于是对应的汇编程序如下：\n\n3. for 循环​        for 循环可以将循环变量和循环条件统一列出，因此对程序员来说是最友好的；但它直接转换成汇编语言会有一定的难度。for 循环的基本形式如下：\n12for( 初始化循环变量; 判断循环条件; 更新循环变量)    循环体\n​        可以把它先改写成 while 循环的形式：\n123456初始化循环变量;while( 判断循环条件 )&#123;    循环体;    更新循环变量;&#125;\n​        这样，就可以用 goto 改写如下：\n123456789\t初始化循环变量;L1:\tif（循环条件不成立）    \tgoto L2;    循环体;    更新循环变量;\tgoto L1;L2:\t循环外语句;\n​        当然，如果不改写成 while、完全按照 for 循环的执行顺序来处理，就会麻烦很多。比如下面是一段 for 循环的 C 语言代码：\n123456int a = 10;for (int i = 0; i &lt; 5; i++)&#123;\ta--;&#125;printf(&quot; a = %d \\n &quot;, a);\n​        对应的汇编代码如下：\n\n​        很明显，本质上三种循环都是等效的，而比较之下 do-while 循环的汇编指令最简洁。因此，大多数编译器会进行优化，将另两种循环语句转换为 do-while 语句形式来生成机器代码。\n​        另外，x86 架构指令集还提供了一个 loop 指令专门用于循环的实现。它默认使用 ecx 寄存器作为循环计数器，每次执行到 loop 指令都会先对 ecx 做减 1 操作；然后判断 ecx 是否为 0，如果不为 0 则跳转到 loop 后面标号对应的位置，如果为 0 则循环结束继续向下执行。\n123456mov ecx, 10.L1:mov eax, dword ptr [a]sub eax, 1mov dword ptr [a], eaxloop .L1\n​        上面的 loop 指令相当于：\n123dec ecxcmp ecx, 0jne .L1\n​        这样减少了指令数，汇编代码的可读性更高了。除 loop 外，还有类似的 loopz 和 loopnz 指令，它们判断循环继续的条件除了 ecx != 0 外，还有对 ZF 的要求。\n4.5.5 过程（函数）调用对应的机器级表示​        下面是一段 C 语言的函数调用过程。我们在 main 函数中调用了 add 函数，进行两个整数的求和。\n123456789101112131415int add(int x, int y);int main() &#123;\tint a = 23;\tint b = 31;\tint sum = add(a, b);\tprintf(&quot; sum = %d\\n&quot;, sum);&#125;int add(int x, int y) &#123;\tint sum = x + y;\treturn sum;&#125;\n​        函数调用时，首先应该跳转之前，将需要的参数进行保存；然后执行 call 指令，同时将下一条指令地址入栈。主程序 main 对应的汇编代码如下：\n\n4.6 章节练习一、单项选择题\n【2010真题】下列寄存器中，汇编语言程序员可见的是    （    ）A．存储器地址寄存器（MAR） B．程序计数器（PC）C．存储器数据寄存器（MDR） D．指令寄存器（IR）\n\n​        答案：B\n\n【2021真题】下列寄存器中，汇编语言程序员可见的是    （    ）\n\n​        Ⅰ.指令寄存器                Ⅱ.微指令寄存器                Ⅲ.基址寄存器                Ⅳ.标志/状态寄存器\n​        A.仅Ⅰ、Ⅱ                        B.仅Ⅰ、Ⅳ                        C.仅Ⅱ、Ⅳ                        D.仅Ⅲ、Ⅳ\n​        答案：D\n​        要点：汇编程序员可见的寄存器有基址寄存器、变址寄存器、状态/标志寄存器（PSW）、程序计数器 PC 和通用寄存器组；而 MAR、MDR、IR 是 CPU 内部工作寄存器， 对汇编程序员不可见。微指令寄存器属于微程序控制器的组成部分， 它是硬件设计者的任务，对汇编程序员是透明的。\n\n【2022真题】下列选项中，属于指令集体系结构（ISA）规定的内容是     （    ）\n\n​        I. 指令字格式和指令类型         II. CPU 的时钟周期         III. 通用寄存器个数和位数         IV. 加法器的进位方式 \n​        A. 仅 I、 II                         B. 仅I、 III                     C. 仅 II、 IV                     D. 仅 I、 III、 IV \n​        答案：B\n​        要点：指令集处于软硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由 ISA 规定。两个 CPU 可以有不同的时钟周期，但指令集可以相同，CPU 的时钟周期不由 ISA 规定。 加法器的进位方式涉及电路设计， 也不由指令集规定。\n\n【2009真题】下列关于 RISC 的叙述中， 错误的是     （    ）A． RISC 普遍采用微程序控制器B． RISC 大多数指令在一个时钟周期内完成C． RISC 的内部通用寄存器数量相对 CISC 多D． RISC 的指令数、寻址方式和指令格式种类相对 CISC 少 \n\n​        答案：A\n​        要点：相对于 CISC ， RISC 的特点是以硬布线逻辑为主，不用或者少用微程序控制。\n\n【2011真题】下列给出的指令系统特点中，有利于实现指令流水线的是     （    ）\n\n​        Ⅰ ．指令格式规整且长度一致 \n​        Ⅱ ．指令和数据按边界对齐存放 \n​        Ⅲ．只有 Load/Store 指令才能对操作数进行存储访问 \n​        A．仅Ⅰ 、 Ⅱ                     B．仅Ⅱ 、 Ⅲ                     C．仅Ⅰ 、 Ⅲ                     D． Ⅰ 、 Ⅱ 、 Ⅲ \n​        答案：D\n​        要点：以上三点都是 RISC 的特点，都可以有效简化指令流水线的复杂度。\n\n【2016真题】某计算机主存空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是     （    ）\n\n​        A． 30、 30     B． 30、 32     C． 32、 30     D． 32、 32 \n​        答案：B\n​        要点：程序计数器（PC）给出下一条指令字的访存地址，取决于存储器的字数；指令寄存器（IR）用于存放取得的指令，取决于指令字长。\n\n【2017真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条，二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是    （    ）\n\n​        A． 24位     B． 26位     C． 28位     D． 32位 \n​        答案：A\n​        要点：指令字长应是字节的整数倍。\n\n【2022真题】设计某指令系统时，假设采用 16 位定长指令字格式，操作码使用扩展编码方式，地址码为 6位，包含零地址、 一地址和二地址 3 种格式的指令。 若二地址指令有 12 条，一地址指令有254 条，则零地址指令的条数最多为     （    ）\n\n​        A. 0     B. 2     C. 64     D. 128 \n​        答案：D\n\n【2011真题】偏移寻址通过将某个寄存器内容与一个形式地址相加而生成有效地址。下列寻址方式中， 不属于偏移寻址方式的是    （    ）\n\n​        A．间接寻址   B．基址寻址   C．相对寻址   D．变址寻址\n​        答案：A\n\n【2017真题】下列寻址方式中，最适合按下标顺序访问一维数组元素的是    （    ）\n\n​        A．相对寻址     B．寄存器寻址     C．直接寻址     D．变址寻址\n​        答案：D\n\n【2020真题】某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对 4 种寻址方式。单地址指令中，直接寻址方式的可寻址范围是    （    ）\n\n​        A. 0 ~ 255                B. 0 ~ 1023                C. -128 ~ 127                D. -512 ~ 511\n​        答案：A\n​        要点：4 种寻址方式需要有 2 位寻址特征位。\n\n【2009真题】某机器字长为 16 位，主存按字节编址，转移指令采用相对寻址，由两个字节组成，第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节 PC 自动加 1。若某转移指令所在主存地址为 2000H，相对位移量字段的内容为 06H，则该转移指令成功转移后的目标地址是  （    ）\n\n​        A． 2006H     B． 2007H     C． 2008H     D． 2009H\n​        答案：C\n\n【2013真题】假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000H；地址 1000H 中的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000H中的内容为 4000H，则变址寻址方式下访问到的操作数是    （    ）。\n\n​        A.1000H                        B.2000H                        C.3000H                        D.4000H\n​        答案：D\n\n【2014真题】某计算机有 16 个通用寄存器，采用 32 位定长指令字， 操作码字段（含寻址方式位）为 8 位，Store 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器， 且偏移量用补码表示， 则 Store 指令中偏移量的取值范围是    （    ）\n\n​        A. -32768-+32767                 B. -32767-+32768                 C. -65536-+65535                 D. -65535-+65536 \n​        答案：A\n​        要点：16 个寄存器需要 4 位地址码表示。\n\n【2016真题】某指令格式如下所示 \n\n其中 M 为寻址方式， I 为变址寄存器编号， D 为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是     （    ）\nA． I + D     B． ( I ) + D      C． ( ( I ) + D )     D． ( ( I ) ) + D \n答案：C\n要点：变址寻址中 EA = ( I ) + D；间接寻址中 EA = （ D ）。\n\n【2018真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1 。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是     （    ）。\n\n\n​        A.25                                B.32                                C.64                                D.100\n​        答案：B\n​        要点：数组首地址就是形式地址 D，变址寄存器中存放的是数组下标。\n\n【2018真题】减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)→R3”，该指令执行后将生成进位/借位标志CF 和溢出标志 OF。若(R1)=FFFF FFFFH，(R2)=FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为    （    ）。\n\n​        A. CF = 0, OF = 0                    B. CF = 1 , OF = 0                    C. CF = 0, OF = 1                    D. CF = 1, OF = 1\n​        答案：A\n​        要点：减法操作只需判断借位标志；当最高位进位和符号位进位的值不相同时才产生溢出。\n\n【2019真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H，则该操作数的 LSB（最低有效字节）所在的地址是     （    ）\n\n​        A． F000 FF12H     B． F000 FF15H     C． EFFF FF12H     D． EFFF FF15H \n​        答案：D\n​        要点：基址寻址方式， EA = (BR) + A；大端方式编址，低位字节存放在字的高地址处。\n二、综合应用题\n【2017真题】在按字节编址的计算机 M 上，上题中 f1 的部分源程序（阴影部分）与对应的机器级代码（包括指令的虚拟地址）如下：\n\n12345678int f1(unsigned n)&#123;\tint sum=1, power=1;\tfor(unsigned i=0;i&lt;=n-1;i++)&#123;\t\tpower *= 2;\t\tsum += power;\t&#125;\treturn sum;&#125; \n1234567891011121314\t\tint f1(unsigned n)1\t\t00401020\t55\t\t\t\tpush ebp\t\t...\t\t\t...\t\t\t\t...\t\t\tfor(unsigned i=0;i&lt;=n-1;i++)\t\t...\t\t\t...\t\t\t\t...20\t\t0040105E\t39 4D F4\t\tcmp dword ptr [ebp-0Ch], ecx\t\t...\t\t\t...\t\t\t\t...\t\t\t&#123;\tpower *= 2;\t\t...\t\t\t...\t\t\t\t...23\t\t00401066\tD1 E2\t\t\tshl edx, 1\t\t...\t\t\t...\t\t\t\t...\t\t\treturn sum;\t\t...\t\t\t...\t\t\t\t...35\t\t0040107F\tC3\t\t\t\tret\n​        其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。请回答下列问题。\n​    （1）计算机 M 是 RISC 还是 CISC？ 为什么？ \n​    （2）f1 的机器指令代码共占多少字节？要求给出计算过程。\n​    （3）第 20 条指令 cmp 通过 i 减 n-1 实现对 i 和 n-1 的比较。执行 f1(0) 过程中当 i=0 时， cmp 指令执行后，进/借位标志 CF 的内容是什么？要求给出计算过程。\n​    （4）第 23 条指令 shl 通过左移操作实现了 power 2 运算，在 f2 中能否也用 shl 指令实现 power 2？ 为什么？ （注：将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。）\n​        答案：\n​    （1）M 为 CISC。 因为 M 的指令长短不一，不符合 RISC 指令系统特点。\n​    （2）f1 的机器代码占 96 B。\n​        因为 f1 的第一条指令 “push ebp” 所在的虚拟地址为 0040 1020H，最后一条指令 “ret” 所在的虚拟地址为 0040 107FH，所以， f1 的机器指令代码长度为 0040 107FH - 0040 1020H + 1 = 60H = 96 个字节。  \n​    （3）CF = 1。\n​        cmp 指令实现 i 与 n-1 的比较功能，进行的是减法运算。在执行 f1(0) 过程中， n=0，当 i=0 时，i = 0000 0000H，n-1 = FFFF FFFFH。因此，当执行第 20 条指令时，在补码加/减运算器中执行 “0 减 FFFF FFFFH” 的操作，即 0000 0000H+0000 0000H+1=0000 0001H，此时，进位输出 C=0，减法运算时的借位标志 CF=C⊕1=1。 \n​    （4）f2 中不能用 shl 指令实现 power*2。\n​        因为 shl 指令用来将一个整数的所有有效数位作为一个整体左移；而 f2 中的变量 power 是 float 型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现 “乘 2” 的功能，因而 f2 中不能用 shl 指令实现 power*2。\n\n\n【2019真题】已知 $f(n) = n! = n(n-1)(n-2)…2*1$ ，计算 f(n) 的 C 语言函数 f1 的源程序（阴影部分）及其在 32 位计算机 M 上的部分机器级代码如下：  \n\n\n​        其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址， int 型数据占 32 位。请回答下列问题：\n​    （1）计算 f(10) 需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？\n​    （2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？\n​    （3）根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？已知第 16 行的 call 指令采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第 16 行的 call 指令的后 4 字节为偏移量， M 是采用大端方式还是采用小端方式？\n​    （4） f(13) = 6227020800，但 f1(13) 的返回值为 1932053504，为什么两者不相等？要使 f1(13) 能返回正确的结果，应如何修改 f1 的源程序？\n​    （5）第 19 行的 imul 指令（带符号整数乘）的功能是 R[eax]←R[eax]×R[ecx]，当乘法器输出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF = 1？要使 CPU 在发生溢出时转异常处理，编译器应在 imul 指令后应加一条什么指令？ \n​        答案：\n​    （1）计算 f(10) 需要调用函数 f1 共 10 次，执行第 16 行的 call 指令会递归调用 f1。​    （2）第 12 行的 jle 指令是条件转移指令，其含义为小于等于时转移，本行代码的意义为：当 n≤1 时，跳转至地址 0040 1035H。\n​        第 16 行的 call 指令为函数调用指令，第 20 行的 jmp 指令为无条件转移指令，第 30 行的 ret 指令为子程序的返回指令，这三条指令一定会使程序跳转执行。\n​    （3）其长度计算机 M 上按字节编址，第 16 行的 call 指令的虚拟地址为 0040 1025H，长度为 5 字节，故第 17 行的指令的虚拟地址为 0040 1025H + 5 = 0040 102AH 。第 16 行的 call 指令采用相对寻址方式，即目标地址= (PC) +偏移量， call 指令的目标地址为 0040 1000H，所以偏移量=目标地址- (PC) = 0040 1000H - 0040 102AH = FFFF FFD6H。\n​        根据第 16 行的 call 指令的偏移量字段为 D6 FF FF FF，可以确定 M 采用小端方式。\n​    （4）因为 f(13) = 6227020800，其结果超出了 32 位 int 型数据可表示的最大范围，因此 f(13) 的返回值是一个发生了溢出的错误结果。为使 f1(13) 能返回正确结果，可将函数 f1 的返回值类型改为 double（或 long long，或 long double，或 float）类型。\n​    （5）imul 指令最终结果放在 32 位的 eax 中，所以若乘积的高 33 位为非全 0 或非全 1，则 OF = 1。编译器应在 imul 指令后加一条 “溢出自陷指令”，使得  CPU 自动查询溢出标志 OF，当 OF=1 时调出“溢出异常处理程序”。\n\n\n【2021真题】假定计算机 M 字长为 16 位，按字节编址，连接 CPU 和主存的系统总线中地址线为 20 位、数据线为 8 位，采用 16 位定长指令字，指令格式及其说明如下：\n\n\n​        其中，op1 ~ op3 为操作码，rs、rt 和 rd 为通用寄存器编号，R[r] 表示寄存器 r 的内容，imm 为立即数，target 为转移目标的形式地址。请回答下列问题。\n​    （1）ALU 的宽度是多少位？可寻址主存空间大小为多少字节？指令寄存器、主存地址寄存器（MAR）和主存数据寄存器（MDR）分别应有多少位?\n​    （2）R 型格式最多可定义多少种操作？I 型和 J 型格式总共最多可定义多少种操作？通用寄存器最多有多少个？\n​    （3）假定 op1 为 0010 和 0011 时，分别表示带符号整数减法和带符号整数乘法指令，则指令 01B2H 的功能是什么（参考上述指令功能说明的格式进行描述）？\n​        若 1、2、3 号通用寄存器当前内容分别为 B052H、 0008H、0020H，则分别执行指令 01B2H 和 01B3H 后，3 号通用寄存器内容各是什么？各自结果是否溢出？\n​    （4）若采用 l 型格式的访存指令中 imm（偏移量）为带符号整数，则地址计算时应对 imm 进行零扩展还是符号扩展？\n​    （5）无条件转移指令可以采用上述哪种指令格式？\n​        答案：\n​    （1）ALU 的宽度为 16 位，ALU 的宽度即 ALU 运算对象的宽度，通常与字长相同。\n​        地址线为 20 位，按字节编址，可寻址主存空间大小为 220 字节（或 1MB)。\n​        指令寄存器有 16 位， 和单条指令长度相同。\n​        MAR 有 20 位，和地址线位数相同。MDR 有 8 位，和数据线宽度相同。\n​    （2）R 型格式的操作码有 4 位， 最多有 24 = 16 种操作。\n​        I 型和 J 型格式的操作码有 6 位，因为它们的操作码部分重叠，所以共享这 6 位的操作码空间，且前 6 位全 0  的编码已被 R 型格式占用， 因此 I 和 J 型格式最多有 26 -1 = 63 种操作。\n​        从 R 型和 I 型格式的寄存器编号部分可知， 只用 2 位对寄存器编码， 因此通用寄存器最多有 2^2^ = 4 个。\n​    （3）指令 01B2H = 000000 01 10 11 0010B 为一条 R 型指令，操作码 0010 表示带符号整数减法指令，其功能为 R[3] $\\leftarrow$ R[1] - R[2]。\n​        执行指令 01B2H 后，R[3] = B052H-0008H = B04AH，结果未溢出。\n​        指令 01B3H = 000000 01 10 11 0011B，操作码 0011 表示带符号整数乘法指令。执行指令 01B3H 后，R[3] = R[1] x R(2] = B052H x 0008H = 8290H，结果溢出。\n​    （4）在进行指令的跳转时，可能向前跳转，也可能向后跳转。偏移量是一个带符号整数， 因此在地址计算时，应对 imm 进行符号扩展。\n​    （5）无条件转移指令可以采用 J 型格式， 将 taget 部分写入 PC 的低 10 位，完成跳转。 \n第五章 中央处理器（CPU）5.1 本章大纲要求与核心考点5.1.1 大纲内容（一）CPU 的功能和基本结构\n（二）指令执行过程\n（三）数据通路的功能和基本结构\n（四）控制器的功能和工作原理\n（五）异常和中断机制\n\n异常和中断的基本概念\n异常和中断的分类\n异常和中断的检测与响应\n\n（六）指令流水线\n\n指令流水线的基本概念\n指令流水线的基本实现\n结构冒险、数据冒险和控制冒险的处理\n超标量和动态流水线的基本概念\n\n（七）多处理器基本概念\n\nSISD、SIMD、MIMD、向量处理器的基本概念\n硬件多线程的基本概念\n多核处理器（multi-core）的基本概念\n共享内存多处理器（SMP）的基本概念\n\n5.1.2 核心考点​          本章知识点较多，综合性比较强。其中，指令流水线是历年考查的一个重点，数据通路、控制器原理出现的频率也很高，单项选择和综合应用题都有可能出现。本章单独出题一般以概念和原理为主，计算较少；往往会与第四章结合进行综合考查，有时也会结合第二章、第三章的内容。\n​        需要掌握的内容包括：\n\nCPU 的基本结构，运算器和控制器的组成，各种寄存器的功能和特性。\n指令周期的概念，指令执行的过程和方案。\n数据通路的结构，数据通路中的数据传送流程和控制信号。\n硬布线控制器的概念和原理；微程序控制器的概念和原理，微指令的编码方式及特点；两种控制器的比较。\n异常和中断的概念和分类；异常和中断的响应过程。\n指令流水线的概念、分类和原理；流水线冒险与处理方法；流水线的性能指标；超标量流水线。\n多处理器的基本概念和分类。\n\n5.1.3 真题分布        \n          考点\n          考查次数\n            \n          单项选择题\n          综合应用题\n            \n          指令流水线\n          10\n          2\n            \n          控制器的功能和工作原理\n          6\n          5\n            \n          CPU的功能和基本结构\n          5\n          4\n            \n          数据通路的功能和基本结构\n          3\n          4\n            \n          指令执行过程\n          2\n          2\n            \n          多处理器的基本概念\n          1\n          0\n      \n5.2 CPU 的功能和基本结构5.2.1 CPU 的功能​        中央处理器（CPU）由 运算器 和 控制器 组成。\n​        运算器负责数据加工，也就是对数据进行算术和逻辑运算；而控制器则需要完成计算机各部件之间的协调和控制，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n​        计算机核心的功能就是自动执行一系列指令，这项工作主要由 CPU 中的控制器来完成。具体来说，指令的执行过程包括了 取指令、分析指令 和 执行指令 三个步骤。\n\n\n取指令：控制器能够自动地从存储器中取出指令，并且按预定的顺序依次取下一条指令。这要求控制器可以自动形成要执行的指令地址，并发出取指命令将对应的指令从主存取到控制器中。\n\n分析指令：首先，控制器需要分析指令需要完成什么操作，从而发出对应的操作命令；其次，控制器需要分析操作数的地址，计算出有效地址。\n\n执行指令：根据分析出的 “操作命令” 和 “操作数地址”，控制器就可以形成操作控制信号序列， 通过对运算器、主存以及 I/O 设备的操作，执行每条指令。\n\n​        除此之外，控制器还必须能控制程序的输入和运算结果的输出，以及对总线（Bus）的控制，甚至需要处理一些运行中的异常情况和特殊请求。\n​        所以总结起来，CPU 的功能包括：\n\n数据加工：对数据进行算术和逻辑运算。\n\n指令控制：控制程序的顺序执行，完成取指令、分析指令和执行指令的操作。\n\n操作控制：产生完成每条指令的一系列操作命令，把各种控制信号送往相应的部件，使这些部件按指令的要求进行工作。\n时间控制：对各种操作加以时间上的控制，为每条指令按时间顺序提供应有的控制信号。 \n中断处理：对计算机运行中出现的异常情况和特殊请求进行处理。\n\n5.2.2 CPU 的基本结构​        根据 CPU 的功能可以看出，数据的运算需要由运算器来完成，剩下的功能则由控制器完成。\n\n1. 运算器​        运算器需要对数据进行运算，所以核心部件是 算术逻辑单元（ALU），此外还有一系列的 寄存器 用来缓存数据、运算结果和状态。\n​        运算器中的寄存器主要有暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）、程序状态字寄存器（PSW）等。\n\n暂存寄存器：用于暂存从主存读来的数据。\n\n累加寄存器（ACC）：用于暂存 ALU 的运算结果，可以作为加法运算的一个操作数再次输入 ALU。\n\n通用寄存器组：通用功能的一组寄存器，主要用于存放操作数和地址信息。\n\n程序状态字寄存器（PSW）：对于算术/逻辑运算指令或测试指令的运行结果，专门用一个寄存器 PSW 来保存各种状态信息，也叫 条件码寄存器。典型的条件码有溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。\n\n\n​        这些寄存器对于程序员来说，除了暂存寄存器一般是透明的，其它都是可见的。\n2. 控制器​        控制器是计算机中负责协调控制的部件，主要功能就是取指令、分析指令、执行指令。\n​        控制器需要根据指令中操作码、指令的执行步骤以及当前状态字信息，来生成一系列对计算机各部件的控制信号（也叫做 “微操作”），这个专门的部分就叫做 “控制单元”（CU）。\n​        为了准确地取出指令，需要一个寄存器来保存下一条指令的地址，这就是 程序计数器（PC）；取出的指令同样也需要先保存下来再做分析，存放指令的寄存器就是 指令寄存器（IR），另外还需要一个 指令译码器（ID）来对指令操作码进行译码。最后，还需要有 中断系统 来处理异常情况和特殊请求。\n​        MAR 和 MDR 一般也会集成在控制器中。因此控制器内的寄存器主要有：\n\n程序计数器（PC）：存放下一条指令的主存地址。\n\n指令寄存器（IR）：存放取出的指令。\n\n主存地址寄存器（MAR）：存放要访问的主存单元的地址。\n\n主存数据寄存器（MDR）：存放要向主存写入或从主存读出的信息。\n\n\n​        这些寄存器的功能主要是控制指令的执行过程，因此大多数情况下对用户是透明（不可见）的。不过一般情况下计算机允许汇编程序员访问程序计数器（比如 x86 架构下的 IP），因此 PC 可以认为对汇编程序员来说是可见的。\n​        除此之外，CPU 中一般还会包含 高速缓存（Cache）和 内存管理单元（MMU），以及用于数据传输的内部数据总线和产生时序信号的时序电路。\n5.3 指令周期5.3.1 指令周期的概念​        计算机取出并执行完一条指令所需的全部时间，就叫做 指令周期。\n​        我们已经知道，一条指令的执行过程可以分为 取指令、分析指令 和 执行指令 三个步骤，因此一个指令周期也应该包含这三部操作需要的时间。由于分析指令时可以用硬件实现操作码的译码，因此这步操作用时很短，一般可以将取指令和分析指令合并为一个阶段，对应的时间称为 取指周期；而执行指令阶段所需的时间就称为 执行周期。\n\n​        很明显，各种指令的取指周期是一样的，但由于具体的执行操作不同，执行周期各不相同；因此指令周期是可以不同的。\n​        前面我们将 ”分析指令“ 这一步合并入了取指周期，是因为操作码的译码非常简单；但分析指令不仅仅要对操作码进行译码，还需要根据形式地址得到有效地址。在间接寻址的方式下，指令字中给出的是 ”地址的地址“，所以需要先访问主存一次、取出有效地址，然后再次访问主存取出操作数。这个阶段称为 间址周期。\n\n​        此外，计算机在执行过程中，可能会出现异常情况或者特殊请求，这时需要进行中断处理。所以 CPU 会在每条指令执行阶段结束前，发出 ”中断查询信号“，检测是否有某个 I/O 设备提出了中断请求；如果有，则 CPU 进入中断响应阶段，称为 中断周期。中断周期中 CPU 需要将程序断点保存到存储器中。\n\n​        所以，一个完整的指令周期应该包括 取指、间址、执行 和 中断 4 个部分。间址和中断周期不一定会包含在指令周期中。这 4 个周期内都会有访存操作，又可称为 CPU 的 ”工作周期“。\n\n取指：访问主存取出指令\n间址：访问主存获取有效地址\n执行：从主存中取操作数，或将结果写入主存\n中断：将程序断点保存到主存\n\n​        在 CPU 的硬件底层，为了区分不同的工作周期、更方便地设计控制单元 CU，往往会设置一组 CPU 工作周期的 ”标志触发器“。\n\n​        上面的 4 个 D 触发器 FE、IND、EX 和 INT 就对应了指令周期的取指（fetch）、间址（indirect addressing）、执行（execute）、中断（interrupt） 4 个阶段，以 ”1“ 状态来表示有效。在取指阶段，只要设置 FE 为 1，就可以由它控制取指阶段的各步操作；当取指结束、进入间址周期时，只要将 FE 置 0、IND 置 1 就可以了。\n5.3.2 时钟周期和机器周期1. 时钟周期​        计算机是由 时钟信号 来控制时间顺序的。\n​        时钟信号是由机器中的主振电路（比如晶体振荡器）发出脉冲信号后，经整型或分频后产生。时钟信号的宽度称为 时钟周期，时钟信号的频率就是 CPU 的 主频，时钟周期和机器主频互为倒数。时钟周期是 CPU 工作的最小时间单位。\n\n​    用时钟信号控制节拍发生器，可以产生 节拍；每个节拍的宽度就对应着一个时钟周期。在一个节拍内，机器可以完成一个最小的操作（微操作），或者是几个需要同时执行的操作。\n2. 机器周期​        每条指令都可以包含四个不同的阶段，每个阶段都至少会访问一次主存。\n​        由于访问主存占据了大部分时间，需要一次访存的操作耗时都差不多，因此我们可以设置一个统一的 ”基准时间“，在这个基准时间内，所有阶段的操作都可以完成；这个基准时间就被称为 机器周期。\n\n​        可以看到，一个指令周期包含了若干个机器周期，而一个机器周期又包含若干时钟周期。\n​        上面的例子中，每个机器周期都是相等的，包含 4 个节拍（时钟周期），这是定长的机器周期；如果每个机器周期中包含的节拍数不等，就是不定长的机器周期：\n\n​        不定长的机器周期更适合比较简单的指令，它可以跳过一些不需要的时钟周期，从而让整个指令周期变短。我们可以默认给一个较短的机器周期，对于比较复杂的操作，则通过增加节拍、通过延长机器周期来解决。\n5.3.3 处理器的设计方式​        针对指令周期采用不同的方式，可以设计出不同类型的 CPU。\n1. 单周期处理器​        单周期处理器中，指令周期固定为 一个时钟周期。\n​        在这种方式下，所有的指令都在相同的时间内执行完成，把这个时间就设置为时钟周期，因此 CPI 为 1。因为指令是串行执行的，这样，时钟周期就会以最慢的指令的执行时间为准，从而导致 CPU 主频较低、运行速度较慢。\n​        单周期处理器实现比较简单，但性能较差，不能充分利用硬件资源。\n2. 多周期处理器​        多周期处理器，则是指每条指令需要若干个时钟周期来完成。\n​        一般来说，多周期处理器会将整个 CPU 的指令执行过程分成几个阶段，每个阶段又用若干个时钟周期去完成，然后开始下一条指令的执行。这样，各种指令执行需要的时钟周期数就可能不同。\n​        多周期 CPU 可以更加充分地利用硬件资源，提升执行效率。不过由于每种指令的执行时间不同，需要对指令进行分类，实现起来较为复杂。\n3.  流水线处理器​        流水线处理器同样会将 CPU 执行指令的过程分为几个阶段，而每个阶段都占用相同的时间（机器周期）；在同一时间，在计算机的各个部件上可以依次执行每条指令的不同阶段，就像在流水作业线上处理指令一样。\n​        这样的方式使得指令可以并行执行，大大提升了系统运行效率。每个机器周期，CPU 都会取出一条新的指令；如果以机器周期作为时钟周期，那么理想情况下，流水线的执行效率可以做到接近于每个时钟周期处理 1 条指令，即 CPI 为 1。\n5.4 指令流水线​        对于计算机系统而言，提升器件性能和改进系统结构，是提高整体性能的两大途径。指令流水线 就是改进处理器架构的一项并行处理技术，可以极大地提高 CPU 的工作效率。\n​        计算机中的并行性体现在不同的级别上。通常可以分为以下 4 个级别：\n\n作业级/程序级\n任务级/进程级\n指令之间级\n指令内部级\n\n​        前两个级别是粗粒度的，又称为 过程级，一般用软件算法实现；而后两个级别是细粒度的，又称为 指令级，一般用硬件实现。指令流水线就是一项实现指令级并行的技术。\n5.4.1 指令流水线的基本概念和原理1. 流水线的概念和原理​        类似于工厂中流水装配线的思想，指令的执行过程也可以分成不同的阶段，每个阶段需要的 CPU 部件是不同的；所以 CPU 各个部件可以同时对不同的指令进行处理，这就是指令流水线。\n​        如果只把指令处理过程分成两个阶段：取指令和执行指令，那么没有采用流水线的计算机会串行处理每条指令：\n\n​        取指令的操作可以由取指部件完成，执行指令的操作则可以由执行部件完成。所以这种顺序执行的方式尽管实现简单，但是对硬件的利用率不高。\n​        如果采用流水线，则可以在时间上将不同指令的执行 ”重叠“ 起来，实现并行的效果：\n\n​        划分两个阶段，可以同时有两条指令重叠，这称为指令的 二级流水。\n​        理论上讲，二级流水线同时有两条指令执行，相当于可以将指令周期减半、速度提升一倍。\n2. 六级流水线​        为了进一步提升处理速度，可以将指令的处理过程划分成更为细致的几个阶段：\n\n取指（FI）：从主存取出一条指令，并暂存在缓冲区（IR）中。\n指令译码（DI）：确定操作方式和操作数的寻址方式。\n计算操作数地址（CO）：根据寻址方式，计算操作数的有效地址。\n取操作数（FO）：从主存中取出操作数（如果在寄存器中，则可以跳过这个阶段）。\n执行指令（EI）：执行指令的具体操作，将结果存放在目的位置（寄存器）。\n写操作数（WO）：将结果写入主存。\n\n​        共有 6 个阶段，所以可以构建出六级流水线。流水线中各阶段应该有相同的机器周期，这里我们可以假设以上各段时间相同。对应的指令六级流水时序图如下：\n\n​        这样的流水线处理器中，应该设计 6 个操作部件，可以同时处理 6 条指令，从而大大提高了程序的运行速度。假设机器周期就等于时钟周期，也就是每个阶段用时是 1 个时钟周期，那么流水线可以做到 CPI 接近于1。\n​        当然，实际的流水线远远达不到这样的性能。流水线也有很多问题：\n\n实际处理器中，每条指令不一定包含了完整的 6 个阶段；\n实际的处理器中，指令处理的各个阶段时间不会相同；\n这里需要假设不存在同时访存的冲突，所以所有指令都可以同时并行；实际情况下，指令可能存在冲突；\n当遇到条件转移指令时，下一条指令是无法提前确定的，只能根据前一条指令的执行结果来判断，时间上会有损失。\n\n3. 流水线处理器的设计原则​        流水线处理器设计的基本原则，就是：\n\n机器周期应该是定长的，并且以用时最长的处理阶段为准；它对应着每个流水线阶段（简称 ”流水段“ ）的时间长度。\n流水段的个数，应该以最复杂指令的处理阶段数量为准；\n\n​        很明显，如果 CPU 采用的指令集比较复杂，流水线的效率就会大打折扣。所以更有利于实现流水线的指令集架构，应该满足：\n\n尽量采用定长指令字；\n尽量简化指令的功能，每条指令只完成最基本的功能；\n简化寻址方式，每条指令都可以在较短的时间内得到需要的有效地址；\n使用 load / store 体系结构，只有 load / store 指令可以进行访存操作；\n使用大量寄存器，尽量减少访存操作。\n\n​        可以看出，这些都是 RISC 的特点。所以说，RISC 更加有利于实现流水线；而具体实现中，一般会将每个阶段的机器周期设为一个时钟周期，这样大部分指令都可以在一个时钟周期完成完成。\n5.4.2 流水线冒险​        在指令流水线中，往往会出现一些造成 ”断流“ 的情况，导致流水线无法正确处理指令，这就是 流水线冒险。\n​        流水线冒险主要有三种：结构冒险、数据冒险 和 控制冒险。\n​        我们可以先考虑一个具体的案例。假设现在有一个五级流水线，5个阶段设计分别为：取指令（FI）、指令译码/读寄存器（ID）、执行/计算有效地址（EX）、访存（MEM）、结果写回寄存器（WB）。那么不同类型的指令，在各流水段的操作也有所不同：\n\n​        接下来考虑三种不同的流水线冒险。\n1. 结构冒险​        当流水线中多条指令重叠执行时，不同指令可能会争用同一功能部件而产生资源冲突，这就是 结构冒险，也称为资源相关。\n​        例如，取指阶段 IF 和访存阶段 MEM 都需要访问主存，而冯诺依曼架构的计算机大多会把指令和数据保存在同一个存储器中、且只有唯一的访问口。那么如果在某个时钟周期内，流水线上某一条指令处在 IF 阶段、另一条指令处在 MEM 阶段，就会发生访存冲突。\n\n​        上表中，在第 4 个时钟周期，第 i 条指令 LOAD 处于 MEM 段，正在访问主存；而同时第 i + 3 条指令处于 IF 段，也需要访问主存取指：于是产生了冲突。\n​        解决方案是可以让后一条指令暂停一个时钟周期，等前一条指令完成访存操作后，再开始取指。\n\n​        另一种方案是，可以设置两个独立的存储器，分别存放指令和数据，这样就可以从根本上避免冲突。另外也可以采用 ”指令预取“ 技术，在 CPU 中设置指令队列，将指令预先取出来放到队列中排队。\n2. 数据冒险​        在流水线中，指令之间可能会有数据的关联。如果一条指令的执行，需要用到之前指令的计算结果；那么当之前的指令尚未执行结束时，下一条指令就直接开始读取数据，就会产生冲突。这种情况被称为 数据冒险。\n​        例如，流水线中有下面两条连续的指令：\n​        ADD    R1，R2，R3                                （R2）+（R3）→ R1\n​        SUB     R5，R1，R4                                （R1）-（R4）→ R5\n​        这里，第一条指令将 R2 和 R3 中的数据相加，结果放入 R1；然后第二条指令又将 R1 中的数据取出，跟 R4 的值做减法，结果写入 R5。\n​        在不采用流水线时，按照顺序执行是完全没有问题的；但当采用了流水线结构后，这种 ”先写后读“ 的顺序就发生了变化：\n\n​        在第 3 个时钟周期，SUB 指令就开进入指令译码、读取寄存器 R1 的数据了；而要到第 5 个时钟周期，ADD 指令才会将真正的计算结果写回。”先写后读“ 就变成了 ”先读后写“，产生了数据相关的冲突。\n​        根据指令间对数据读写操作的先后顺序，数据冒险可以分成三类：\n\n写后读（Read After Write，RAW）：也就是先写后读，如果试图写入前就读取，就会读出错误的 旧 内容；\n读后写（Write After Read，WAR）：也就是先读后写，如果试图读取前就写入，就会读出错误的 新 内容；\n写后写（Write After Write，WAW）：两次连续的写入，如果改变了写入顺序，最后保存的数据就是先写入的值；\n\n​        如果只考虑按顺序流动的流水线，那其实只会出现 RAW 相关的情况；而假如是非按序流动的流水线，允许后面的指令超过前面的指令、先流出流水线，那就还可能发生 WAR 和 WAW 的情况。\n​        解决数据冒险可以采用下面的方法：\n（1）后推法\n​        要想解决数据冒险，最简单的解决方案，还是先将后面的指令暂停，等前面指令完成、生成所需的结果之后再继续进行。这种方法称为 后推法。\n​        例如，我们再增加几个指令，构成一个指令序列：\n​        ADD    R1，R2，R3                                （R2）+（R3）→ R1\n​        SUB     R5，R1，R4                                （R1）-（R4）→ R5\n​        AND    R7，R1，R6                                （R1）AND（R6）→ R7\n​        OR       R9，R1，R8                                （R1）OR（R8）→ R9\n​        XOR     R11，R1，R10                            （R1）AND（R10）→ R11\n​        第一条 ADD 指令将 R2 和 R3 相加的结果写入 R1，之后的 4 条指令 SUB、AND、OR、XOR 都要使用 R1 中的值作为一个源操作数。这里就出现了 RAW 数据冒险。\n\n​        如果采用后推法，将后续指令延迟到 ADD 指令完成写回 WB 阶段之后，就可以解决数据冒险：\n\n（2）专用通路技术（数据旁路技术）\n​        另一种解决方案是采用定向技术，也叫 专用通路技术 或 旁路技术。\n​        基本思想是，上一条指令的运行结果，在 EX 阶段就已经产生；那就不必等到上一条指令后续阶段全部完成（写回寄存器），可以直接将结果送到后续指令需要的地方。这样流水线就可以不发生停顿。\n​        由于需要对后续指令进行数据的定向传送操作，所以应该加入另外的部件。\n\n​        上图就是一个带有旁路技术的 ALU 部件。ADD 指令执行的结果，会存入 暂存器 中；而暂存器的结果又会通过旁路通道，经多路开关直接送回 ALU 参与后续的计算。这里的定向传送，只发生在 ALU 内部。\n3. 控制冒险​        控制冒险 主要是由 转移指令 引起的。当遇到条件转移指令（分支指令）时，由于只有上一条指令执行结束才能知道是否跳转，因此一般我们只能采用猜测法，默认不发生跳转、继续取下一条指令；如果真的发生了跳转，这时之前的操作全部作废，需要重新按照 PC 跳转的位置取指执行。这就破坏了流水线的连续流动。\n​        还是用之前的六级流水线的例子，假设指令 3 是一条条件转移指令。\n\n​        指令 3 是条件转移指令，所以只有在第 7 个时钟周期（时间单元）、指令 2 执行完毕之后才能判断是否进行跳转：如果不跳转，则继续执行指令 4；如果跳转，则执行指令 15。\n​        采用猜测法，默认不跳转，所以流水线继续取指令 4，并正常向前流动；但当到第 7 个时钟周期时，发现结果满足条件，需要进行跳转，则之前第 4、5、6、7 个时钟周期所做的操作全部作废，第 8 个时钟周期重新取指令 15，继续流水线的流动。在第 9 ~12 个时钟周期内，没有指令完成，这是预测失败带来的转移损失。\n​        据统计，转移指令大约占到了程序总指令数的 1/4，所以控制冒险会严重影响流水线的性能。为了解决控制冒险，可以采用下面的方法：\n\n尽早判别转移是否发生，尽早生成转移目标地址。\n\n预取转移成功和不成功两个控制流方向上的目标指令。\n\n加快和提前形成条件码。\n\n提高转移方向的猜测率。\n\n\n5.4.3 流水线的性能指标​        流水线的性能，一般用三项指标来衡量：吞吐率、加速比、效率。\n\n​        流水线只有在达到稳定、连续流动的时候，才能获得最大吞吐率。实际上，流水线在开始时有一段建立时间，结束时又有一段排空时间；另外还有各种冒险因素使流水线无法连续流动，所以实际吞吐率总是小于最大吞吐率。\n（2）实际吞吐率\n​        假设流水线中总共有 n 条指令，完成 n 条指令的总时间为 t，那么实际吞吐率就是 n / t。同样，对于 m 段指令流水线，若各段时间为 Δt，那么连续处理 n 条指令时，除了第 1 条指令需要 m · Δt 时间，其它 n - 1 条指令都是每隔 Δt 就会完成一条。所以：\n\n\n2. 加速比​        流水线的加速比，指的是采用流水线处理指令的速度，和同样功能的非流水线的速度之比。\n​        如果流水线每段时间均为 Δt，那么同样是完成 n 条指令，使用 m 段流水线需要的时间为：\n\n\n​        可以看出，当 n → +∞ 时，Sp 趋近于 m，也就是流水线的最大加速比等于流水线的段数。\n3. 效率​        流水线的效率，是指流水线中各功能段的利用率。\n​        因为流水线有建立时间和排空时间，所以各功能段设备不会一直处于工作状态，会有一段空闲时间。假设 m 段流水线各段时间均为 Δt，我们可以将每个功能段（空间）在每个 Δt（时间）内的工作状态画出来，这就是流水线的 “时空图”：\n\n​        上图是一个 4 段流水线（m = 4）的时空图，那么处理 n 条指令一共需要时间为 m · Δt + (n-1) · Δt，在时空图上总的时空区域为：m · (m+n-1) · Δt ；而各段真正处于工作的时空区域为：m · n · Δt。\n​        一般就用流水线各段处于工作的时空区域，和总时空区域的比值，来衡量流水线的效率。计算公式为：\n\n5.4.4 流水线的多发技术​        流水线技术大大提升了 CPU 的处理效率，给计算机系统结构带来了重大改进。通过开发流水线的多发技术，又可以进一步地对流水线进行改进和提升。\n​        所谓的多发技术，就是设法提升流水线的并行效果，尽量在一个时钟周期内可以完成更多的指令。常见的多发技术有 超标量技术、超流水线技术 和 超长指令字技术。\n1. 超标量技术​        超标量（SuperScalar）流水线技术也叫做动态多发射技术，它是指在每个时钟周期内，可以同时并发多条独立的指令；也就是以并行操作的方式，将两条或两条以上的指令编译执行。\n\n​        上图是普通流水线和超标量流水线的对比。这里是一条四级流水线，处理一条指令分为 4 个阶段：取指（IF）、译码（ID）、执行（EX）和 写回（WR）。假设每段时间就是一个时钟周期。\n​        可以看到，普通流水线每个时钟可以产生一条指令的结果；而超标量流水线每个时钟周期都可以产生多条指令的结果。\n​        要实现超标量技术，CPU 中要配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能够实现同时执行多个相同阶段的操作。另外，还需要编译器采用编译优化技术，找到能并行执行的指令进行调配。\n2. 超流水线技术​        超流水线（SuperPipeline）技术是将一些流水线寄存器插入到流水线段中，相当于把每个阶段再进行细分。\n\n​        上图中原来的一个时钟周期又分成了三段。这样超流水线的处理器可以在一个时钟周期内，让功能部件处理 3 条指令；相当于流水线是以 3 倍于原时钟频率的速度运行。\n3. 超长指令字技术​        超长指令字技术（VLIW）也称静态多发射技术，它和超标量技术有共同特点，都是采用多条指令在多个部件中并行处理的架构，从而在一个时钟周期内能够流出多条指令。\n\n​        跟超标量技术的区别在于：超标量的指令来自同一标准的指令流；而超长指令字则是由编译器挖掘出指令间潜在的并行性，然后把多条能并行的指令直接组合成一条指令——这是一条具有多个操作码字段的超长指令。这条超长指令可以控制机器中的多个独立的功能部件同时操作，相当于同时执行了多条指令。\n​        超长指令字技术比超标量有更高的并行处理能力，但对编译器优化的要求更高，对 Cache 容量的要求更大。\n5.5 数据通路和控制信号5.5.1 数据通路的概念和功能​        计算机中，将各个功能部件连接起来、可以进行数据传送的路径称为 数据通路。\n\n​        数据通路的主要功能，就是实现计算机中不同部件间的信息传送和数据交换。在这里我们主要讨论 CPU  内部的数据通路，它描述了信息在 CPU 内各部件之间传递的路径，也包括了路径上流经的部件，比如 ALU、寄存器、中断系统等。\n5.5.2 指令周期中的数据流​        CPU 的指令周期可以分为取指、间址、执行和中断四个阶段，在不同的阶段，控制器应该产生不同的控制信号。我们可以先来分析一下每个阶段中数据的流动方向，这就是指令周期中的 数据流。\n1. 取指周期​        这里我们只讨论 CPU 中最重要的 4 个寄存器 PC、IR、MAR 和 MDR。MAR 与地址总线相连，存放要访问的存储单元地址；MDR 与数据总线相连，存放从主存中读出的或者要写入主存的数据；PC 存放要执行的指令地址，有 “自动加 1” 的计数功能；IR 存放正在执行的指令。\n\n​        ① 将 PC 中存放的当前指令的地址，送到 MAR；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出读命令，经控制总线到达主存；\n​        ④ 主存中对应存储单元的内容（指令）经数据总线，传送给 MDR；\n​        ⑤ MDR 中的内容送至 IR，并将操作码交给 CU 进行译码；\n​        ⑥ CU 控制 PC 内容加 1，形成下一条指令的地址。\n2. 间址周期​        取指周期结束后，CU 就会检查 IR 中的内容，判断寻址方式；如果有间接寻址，就执行间址周期中的操作。\n\n​        ① 取 MDR（或 IR）中的地址码，记作 Ad (MDR)，送至 MAR；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出读命令，经控制总线到达主存；\n​        ④ 主存中对应存储单元的内容（地址）经数据总线，传送给 MDR；\n​        ⑤ 将有效地址传送到 IR 的地址字段（在一些机器中，这一步可以省略）。\n3. 执行周期​        在执行周期，可能会涉及到对 ALU 的操作、寄存器之间的数据传递，以及对主存的读写操作。因为不同的指令在执行周期会有不同的操作，对应的数据流也会有所不同，所以不能用同一的数据流图来表示。\n4. 中断周期​        CPU 进入中断周期后，会进行一系列的操作；核心部分就是要将当前程序执行的状态保存下来，等到中断服务程序执行完毕后再返回继续执行。\n\n​        ① CU 将一个特殊地址（比如 0 地址）送至 MAR，这个地址对应的存储单元保存程序的断点信息，主要就是 PC 的值；\n​        ② 将 MAR 中的地址送至地址总线；\n​        ③ CU 发出写命令，经控制总线到达主存；\n​        ④ 将 PC 的内容（程序断点位置）传送给 MDR；\n​        ⑤ 将 MDR 中的断点信息经数据总线，存入主存中；\n​        ⑥ CU 将中断服务程序的入口地址送至 PC，准备执行中断服务程序。\n5.5.3 指令周期的微操作​        CPU 的控制器可以根据每条指令的具体操作，生成一系列的控制信号，控制数据通路上每个三态门在不同时钟周期的 “开” 和 “关”，从而起到控制指令执行的过程。这样的控制信号，就被称为 “微操作” 或者 “微指令”。\n​        下面我们依然根据指令周期的 4 个阶段，分别分析对应的微操作命令。\n1. 取指周期​        对应上一小节分析的取指令过程，可以归纳为以下几个微操作：\n\n2. 间址周期\n\n3. 执行周期​        在执行周期，不同指令的微操作是不同的。这里我们将指令按照功能分为非访存指令、访存指令和转移指令来进行分析。\n（1）非访存指令\n​        这类指令一般只是执行一步简单的操作，在执行周期不访问主存。\n\n（2）访存指令\n​        这类指令在执行阶段需要访问存储器，例如一个操作数在主存中的加法指令，以及从主存中存取数据的指令。简单起见，我们这里只讨论直接寻址的情况。\n\n（3）转移指令\n​        转移指令只是通过对 PC 的更改，实现指令执行的跳转，因此执行阶段也不需要访问主存。\n\n4. 中断周期\n\n5.5.3 数据通路的基本结构和控制信号​        CPU 外部和主存、I/O 设备的连接，一般采用总线方式。而 CPU 内部数据通路的结构，其实就是 CPU 内部的连线方式。根据 CPU 内是否采用总线方式进行连接，数据通路可以分为两种结构。\n1. 不采用 CPU 内部总线​        如果不采用 CPU 内部总线的方式，就需要将 CPU 内的所有需要进行数据传递的部件单独连接起来，相当于为两者之间搭建了一条 “专线”，所以这种方式也叫做 专用数据通路 方式。\n​        这种专用数据通路中所有的路径都是 “专线专用”，不存在冲突，因此性能更好；但所有部件之间都需要进行线路连接，布线比较复杂，硬件成本较高，可扩展性比较差。\n\n​        上图就是未采用总线方式时的数据通路和控制信号。为了简便这里没有画出每个部件输入输出通路的控制门，只用一个小圆圈代替，上面用箭头标出了每个门电路的控制信号 Ci 。\n\n​        接下来以一条采用了间接寻址的加法指令为例：\n1ADD @ X\n​        这条指令中 @ 是间接寻址标志，X 是存放操作数地址的存储单元地址。需要间接寻址取出操作数，与寄存器 ACC 的值相加，得到的结果再写回 ACC 中。我们依然按照指令周期的不同阶段来进行分析：\n（1）取指周期\n\n​        ① 控制信号 C0 有效，打开 PC 送往 MAR 的控制门：（PC）→ MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门：M (MAR) → DB → MDR；\n​        ⑤ C3 有效，打开 MDR 和 IR 之间的控制门，将指令传送至 IR：（MDR）→ IR；\n​        ⑥ C4 有效，打开指令的操作码送往 CU 的输出门：OP(IR) → CU；\n​            CU 在指令操作码和时钟信号的控制下，就可以进一步产生各种控制信号了。\n​        ⑦ PC 内容加 1： （PC）+ 1 → PC \n（2）间址周期\n\n​        ① C5 有效，打开 MDR 和 MAR 之间的控制门，将指令中的形式地址送至 MAR：Ad (MDR) → MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门，将有效地址写入 MDR：M (MAR) → DB → MDR\n​            至此，就获取到了指令操作数的有效地址。\n（3）执行周期\n\n​        ① C5 有效，打开 MDR 和 MAR 之间的控制门，将有效地址送至 MAR： (MDR) → MAR；\n​        ② C1 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；\n​        ③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；\n​        ④ C2 有效，打开数据总线（DB）送至 MDR 的输入门，将操作数存入 MDR：M (MAR) → DB → MDR\n​            至此，就获取到了指令需要的操作数。\n​        ⑤ C6、C7 同时有效，打开寄存器 ACC 和 MDR 连接 ALU 的控制门；\n​        ⑥ 通过 CPU 内部控制线对 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；\n​        ⑦ C8 有效，打开 ALU 通往 ACC 的控制门，将计算结果存入 ACC：（ACC）+（MDR）→ （ACC）\n​            至此，就完成了加法运算的执行过程。\n\n​        还有一些控制信号这条指令没有涉及到：C9 和 C10 分别是控制 PC 的输出和输入的控制信号；C11 和 C~12~ 分别是控制 ACC 的输出和输入的控制信号。\n2. 采用 CPU 内部总线​        类似于系统总线，CPU 内部也可以采用总线方式连接，这种总线也叫做 片内总线。片内总线就是 CPU 内部所有部件的公共数据通路，寄存器之间、寄存器与 ALU 之间都由片内总线连接。\n​        如果只有一条片内总线，这样的结构称为 CPU 内部单总线。这种结构比较简单，硬件容易实现和进行扩展，但存在数据冲突的情况，性能较差。\n\n​        上图中就是采用了 CPU 内部总线方式（单总线）的数据通路和控制信号。每个寄存器都与总线直接相连，这里同样省略了控制门的符号，用一个小圆圈代替，上面用箭头标出了对应的控制信号。控制信号的下标为 i 表示这是输入端的控制，下标为 o 表示输出端的控制。\n​        这里的 ALU 增加了两个寄存器 Y 和 Z，主要是因为 ALU 是组合逻辑电路，本身没有存储数据的功能，运算时必须要求两个输入端同时有效；而单总线上同一时刻（一个时钟周期）只能传送一个数据。因此我们可以设置一个输入寄存器 Y 保存其中一个操作数，让它保持不变，另一个操作数则从总线上获得。同样道理，ALU 的输出也不能直接连接总线输出，否则会影响总线上的输入数据，只能先在输出寄存器 Z 中暂存，等到下个时钟周期再输出。\n\n​        接下来我们依然以加法指令 “ADD @ X” 为例，按指令周期的不同阶段来分析 CU 发出的控制信号。\n（1）取指周期\n\n​        ① PC~o~ 和 MARi 有效，PC 中的内容经内部总线送往 MAR：（PC）→ MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（指令）送至 MDR：M (MAR)  → MDR；\n​        ④ MDR~o~ 和 IRi 有效，将 MDR 的内容送至 IR：（MDR）→ IR；\n​            至此，指令送至 IR，操作码字段交给 CU，就可以进一步产生各种控制信号了。\n​        ⑤ PC 内容加 1： （PC）+ 1 → PC \n（2）间址周期\n\n​        ① MDR~o~ 和 MARi 有效，将指令的形式地址经内部总线送至 MAR：Ad (MDR) → MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（有效地址）送至 MDR：M (MAR)  → MDR；\n​            至此，就获取到了指令操作数的有效地址。\n（3）执行周期\n\n​        ① MDR~o~ 和 MARi 有效，将有效地址经内部总线送至 MAR：（MDR）→ MAR；\n​        ② CU 通过控制总线向主存发出读命令（R）：1 → R；\n​        ③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（数据）送至 MDR：M (MAR)  → MDR；\n​            至此，就获取到了操作数。\n​        ④ MDR~o~ 和 Yi 有效，将操作数送至寄存器 Y，直接作为 ALU 的一个输入：（MDR）→ Y；\n​        ⑤ ACC~o~ 和 ALUi 有效，同时 CU 向 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；得到的结果直接送往寄存器 Z：（ACC）+（Y）→ Z；\n​        ⑥ Z~o~ 和 ACCi 有效，将运算结果写入 ACC：（Z）→ ACC\n​            至此，就完成了加法运算的执行过程。\n\n​        现代计算机的 CPU 都集成在一个芯片内，所以采用片内总线的方式可以极大地节省连线，使芯片密度更高、布局更为合理，也更加容易扩展。\n​        而为了提升性能，解决单总线结构的数据冲突问题，可以增加总线的数量，这就是 CPU 内部多总线方式。这种结构的 CPU 内部有多条公共通路；相比单总线一个时钟内只允许传送一个数据，多总线可以同时传送多个数据，效率更高。\n5.6 控制器的原理和设计​        控制单元 CU 控制一条指令执行的过程，实质上就是发出控制信号、依次执行一个微操作序列的过程。很明显，不同的指令中包含的微操作数量不等，每个微操作的复杂程度也不同，所以每条指令的执行时间都是不同的。\n​        在 CPU 内，可以通过时钟信号产生节拍，来控制每个微操作的执行。一个指令周期可以包含多个机器周期，每个机器周期又可以包含多个节拍，这样就构成了 多级时序系统。\n​        控制不同的微操作序列，需要产生不同的时序控制信号。至于如何形成这些控制信号，可以采用不同的时序控制方式，这就被称为 CU 的 控制方式。\n5.6.1 CU 的控制方式​        CU 的控制方式，主要有 同步控制、异步控制、联合控制 和 人工控制 四种。\n1. 同步控制​        最常见的控制方式就是 同步控制。这种方式下 CPU 有一个统一的时钟，所有指令的每一个微操作，执行顺序都是事先确定好的，根据时钟信号在不同的时钟周期依次执行。\n​        根据机器周期的不同设置方式，同步控制又有三种不同的方案：\n​    （1）采用定长的机器周期\n​        这是最简单的方式，不论指令对应的微操作有多少、也不管微操作有多复杂，一律采用统一的机器周期来执行各种不同的指令，每个机器周期包含相同的节拍数，每个节拍的宽度完全一致。\n\n​        这样的话，机器周期的选择必须要以执行最慢的指令和微操作为准，对于比较简单的指令就会有时间上的浪费。\n​    （2）采用不定长的机器周期\n​        采用不定长的机器周期时，每个机器周期内的节拍数可以不等，这样就可以解决微操作执行时间不统一的问题了。\n\n​        一般会把大多数微操作安排在一个较短的机器周期内完成，而对于比较复杂的微操作，则通过延长机器周期来解决。\n​    （3）中央控制和局部控制相结合\n​        这种方式相当于是定长和不定长机器周期的结合。将机器的大部分指令安排在统一的机器周期内完成，称为 中央控制，这个机器周期一般比较短；而将少数复杂指令中的一些操作，通过插入一些额外的节拍来进行处理，这称为 局部控制。\n\n​        局部控制的每个节拍跟中央控制的节拍宽度相同，个数则是不确定的。\n2. 异步控制​        异步控制方式不存在统一的时钟信号，没有固定的周期节拍和时钟同步；每条指令和每个微操作耗费的时间都以它们在电路中完成为准。\n​        这种控制方式 CPU 没有空闲时间，利用率更高；但微操作的时序就需要有专门的 “应答线路” 来进行控制，结构会更加复杂。\n3. 联合控制​        联合控制方式就是同步控制和异步控制的结合。这种方式下，对于指令中大部分一致的微操作，采用同步控制；而对于小部分特殊的、时间难以确定的操作，则采用异步控制。\n4. 人工控制​        为了调试机器和软件开发的需要，可以在机器面板或者内部设置一些开关或者按键，由人工进行操作控制。例如，一些机器设有 Reset（复位）键，可以人工恢复初始状态。\n\n​        确定了 CU 的控制方式，就可以设计具体的控制单元了。根据产生微操作控制信号的方式不同，控制器又可以分为 组合逻辑控制器 和 微程序控制器。\n5.6.1 组合逻辑控制器​        组合逻辑控制器直接通过组合逻辑电路的设计，根据当前的指令操作码、工作周期标志以及时钟信号生成对应的控制信号（微操作）序列，实现控制器的各种功能。也叫做 硬布线控制器。\n1. 基本原理和结构框图​        组合逻辑控制器的控制信号，都是由控制单元（CU）产生的。它的输入是时钟信号、操作码译码之后的信号以及条件码标志位。\n\n​        存放在 IR 中的 n 位操作码可以经过一个译码器，产生 2n 个输出；于是每种操作码都会对应一个输出信号送至 CU。\n​        CU 的时钟信号就是一个脉冲序列，让它通过一个节拍发生器（计数器）就可以产生一个宽度等于时钟周期的节拍序列。在每个节拍内，可以保证完成一次微操作，数据信息能够完成数据通路中的流动。这样，CU 就可以按照节拍来发出控制信号的序列了。\n2. 微操作的节拍安排​        接下来就可以将每个工作周期中的微操作，安排到对应的节拍中了。\n​        安排微操作的节拍应该遵循以下基本原则：\n​        ① 微操作的先后顺序不能发生改变；\n​        ② 如果是控制不同部件的微操作，可以同时执行的话，应该尽可能安排在同一个节拍内；\n​        ③ 如果有些微操作耗时不长，那可以将多个这样的微操作安排在一个节拍内完成，并且允许它们有先后次序。\n​        现在我们假设采用定长机器周期的同步控制方式，每个机器周期包含 3 个节拍。以上一节讨论的 10 条不同指令为例，可以安排微操作的节拍如下：\n（1）取指周期\n\n（2）间址周期\n\n（3）执行周期\n​        同样，还是针对不同类型的指令，分别分析微操作的节拍安排。\n​        1）非访存指令\n​        非访存指令一般都只有很简单的操作，因此可以直接把微操作安排在一个节拍内。可以选择 T0 ~ T2 的任一节拍，其余节拍空闲。\n​        这里以 CLA 指令为例，把它的微操作安排在 T2 节拍内：\n\n​        2）访存指令\n​        访存指令中需要进行访问主存操作，微操作的节拍安排可以跟取指、间址周期类似。\n\n​        3）转移指令\n​        同样，转移指令微操作比较简单，可以在 T0 ~ T2 任选一个节拍进行安排。\n\n（4）中断周期\n​        在指令周期的最后阶段，CPU 会向所有中断源发出中断查询信号，若检测到有中断请求，在允许中断的条件下就会进入中断周期。中断周期的微操作节拍安排如下：\n\n5.6.2 微程序控制器​        组合逻辑控制器线路庞杂，为了克服这个缺点，可以采用类似 “存储程序” 的方法，来形成具体的微操作序列；这被叫做 “微程序”，采用这种技术的控制器就被称为 微程序控制器。\n1. 基本原理和结构框图​        微程序控制器的基本思想是，将每条机器指令编写成一个 微程序，每一个微程序包含若干条 微指令，每一条微指令对应一个或几个微操作命令。然后把这些微程序存入一个 控制存储器（简称控存，CM）中，用读取指令的方式将它们读出依次执行就可以了。\n\n​        这样，每一条机器指令都可以对应着一个微程序。对于取指、间址、中断周期，所有指令的操作都是相同的，因此可以统一编制成一个微程序；而每条指令执行阶段的操作则单独对应一个微程序。这样，控制存储器中微程序的个数，就是机器指令的数量，再加上对应取指、间址、中断周期的 3 个微程序。\n​        微指令的基本格式，应该包含两个字段，前面是操作控制字段，对应着微操作命令，可以发出各种控制信号；后面是顺序控制字段，可以指出下条微指令的地址（简称 下地址），从而控制微指令序列的顺序执行。\n\n​    微程序控制单元的结构如下所示：\n\n\n控制存储器：微程序控制单元的核心部件，存放着全部的微程序；显然控存可以采用 ROM 实现。\nCMAR：控存地址寄存器，用来存放准备读取的微指令地址；\nCMDR：控存数据寄存器，用来存放从控存读出的指令；\n顺序逻辑：用来形成下一条微指令的地址，用来控制微指令序列的执行顺序。\n\n2. 微程序控制器的工作过程​        我们可以结合一个具体的例子，来说明微程序控制器的工作过程。假设一段用户程序，有下面的两条汇编指令：\n123LDA  XADD  Y...\n​        当执行到第一条指令 LDA X 时，PC 的值为这条指令在主存中存放的地址。控制单元 CU 将执行以下的操作。\n​    （1）取指阶段\n​        首先进入取指周期，微程序控制单元将执行取指阶段的每一个微操作。\n\n​        ① 将取指周期的微程序首地址 M 送至 CMAR：M → CMAR；\n​        ② 取微指令，将控存 M 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 (PC) → MAR，1 → R；\n​        ④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 1，所以将 M + 1 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑤ 取下一条微指令，将控存 M + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR，（PC）+ 1 → PC；\n​        ⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 2，所以将 M + 2 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑧ 取下一条微指令，将控存 M + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ IR，\nOP (IR) → CU。\n​        至此，第一条指令 “LDA X” 已经取出并保存到了 IR 中。\n​    （2）执行阶段\n​        简单起见，我们假设这条指令采用了直接寻址，因此跳过间址周期，直接进入执行周期。\n\n​        ① 根据指令的操作码，形成取数指令的微程序首地址 Q，并送至 CMAR：OP (IR) → 微地址形成部件 → CMAR；\n​        ② 取微指令，将控存 Q 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 Ad (IR) → MAR，1 → R；\n​        ④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 1，所以将 Q + 1 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑤ 取下一条微指令，将控存 Q + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR；\n​        ⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 2，所以将 Q + 2 送至 CMAR：Ad (CMDR) → CMAR；\n​        ⑧ 取下一条微指令，将控存 Q + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；\n​        ⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ ACC。\n​        至此，就完成了取数指令 LDA X 的全部操作。\n​        最后一条微指令的顺序控制字段为 M，所以接下来 CPU 又将进入下一条指令 ADD Y 的取指周期，从控存中依次读出微程序的每条微指令、发出一系列的控制信号。\n​        微程序控制单元设计的过程中，关键问题是微指令的操作控制字段怎样去发出控制信号，以及如何具体产生下一条微指令的地址。这跟 微指令的编码方式 和 微地址的形成方式 有关。\n3. 微指令的编码方式​        微指令的编码方式，主要是指怎样对微指令的操作控制字段进行编码，进而发出对应的控制信号。所以也称为 微指令的控制方式。\n​        微指令的编码方式主要有以下几种。\n​    （1）直接编码（直接控制）\n​        最简单的方案，就是让微指令的操作控制字段中，每一位都对应着一个微操作命令；这种编码方式就称为 直接编码方式。\n\n​        当控制字段的某位为 “1” 时，就表示控制信号有效，进而打开对应数据通路的控制门；为 “0” 时则表示控制信号无效，控制门关闭。\n​        这种方式实现简单、含义清晰，而且只要微指令从控存中读取出来就立刻可以发出对应的控制信号，速度非常快。不过由于微操作数量众多，因此控制字段的位数也会非常多，可能达到几百位，造成控存容量过大。\n​    （2）字段直接编码\n​        想要减少控制字段的位数，可以通过加一个译码器来解决。不过由于可能会有多个微操作命令同时有效（并行）的情况，因此可以根据并行发出的微命令个数将控制字段再做 “分段”，每段内分别进行译码、对应一个微操作命令。\n​        这种方式由字段直接译码发出微命令，所以叫做 字段直接编码方式，也称为 显式编码。\n\n​        这里所谓的 “微命令” 就是 CU 发出的控制信号，而 “微操作” 就是微命令生效后执行的过程，它们是一一对应的关系，所以一般我们不再过多区分。\n​        指令执行过程中，有一些微命令可以同时产生，我们称它们是 “相容” 的；而如果一组微命令不能同时发生，则称它们是 “互斥” 的。字段直接编码时，应该将互斥的一组微命令放在一个字段内；而不同字段的微命令，则是相容的。每个字段的长度可以不同。此外，每个字段还应该留出一种状态，表示不发出这一组中的任何微命令。\n\n​        例如，某机器的微指令格式中，有 8 个控制字段，每个字段可以分别发出 5、8、3、16、1、7、25、4 种控制信号。那么采用直接编码和字段直接编码方式设计微指令，需要的操作控制字段至少是多少位？\n​    （1）直接编码\n​        微指令操作控制字段的位数，就是总的控制信号数：\n5+8+3+16+1+7+25+4=69\n​    （2）字段直接编码\n​        每个字段需要保留一个编码，表示不做任何操作；因此 8 个字段分别需要表示 6、9、4、17、2、8、26、5 种情况。对应的编码位数应该是：3、4、2、5、1、3、5、3，因此总位数为：\n3+4+2+5+1+3+5+3=26\n​        很明显，使用字段直接编码可以有效地减少控制字段的位数。\n\n​    （3）字段间接编码\n​        这种方式在字段直接编码的基础上，又增加了一步转换，即一个字段的某些微命令，还需要受到另一字段译码输出的控制，因此被称为 字段间接编码，也叫 隐式编码。\n\n​        这种方式可以进一步减少控制字段位数，但电路更加复杂、而且削弱了微指令的并行控制能力，因此一般只是作为字段直接编码的辅助手段。\n​    （4）混合编码\n​        将直接编码和字段编码（直接或者间接）混合使用，就成了 混合编码方式。这种方式主要是综合考虑微指令字长、灵活性和执行速度各方面的要求。\n4. 微指令格式​        微指令的格式跟微指令的编码方式有关，通常可以分为水平型微指令和垂直型微指令。\n​    （1）水平型微指令\n​        水平型微指令的主要特点，就是一次能定义并执行多个并行操作的微命令。从编码方式看，前面介绍的直接编码、字段直接编码、字段间接编码以及混合编码都属于水平型微指令。\n​    （2）垂直型微指令\n​        垂直型微指令不强调并行控制的功能，而是采用了类似机器指令中操作码的方式，在操作控制字段中用 “微操作码” 来规定微指令的功能。通常一条微指令中，只有 1 ~ 2 个微命令，控制 1 ~ 2 种操作。\n\n​        相比而言，水平型微指令并行操作能力更强、速度更快、效率更高、灵活性强；而垂直型微指令与机器指令更加类似，语义更加清晰。水平型微指令用较长的微指令结构，换取较短的微程序；而垂直型微指令是以较长的微程序结构，换取较短的微指令结构。\n5. 微指令序列地址的形成​        微指令执行过程中，在不同阶段，需要采用不同的方式形成后续微指令的地址。\n​    （1）直接由当前微指令的下地址字段给出\n​        大部分微指令都会在下地址字段直接指出下一条微指令的地址，在每一段微程序内部一般都是这种方式。也被称为 断定方式。\n​    （2）根据指令的操作码形成\n​         取指周期结束、机器指令被存放入 IR 后，接下来执行阶段微指令的地址，会由微地址形成部件根据操作码产生。\n​        所谓的微地址形成部件，其实也就是一个编码器，它的输入是指令操作码，输出是对应微程序执行阶段的首地址。它可以用 PROM 来实现，以指令的操作码作为 PROM 的地址，相应的存储单元存放微程序首地址。\n​        对于不同的方式，可以用一个 多路选择器，通过对当前一些状态标志的判断来进行选择。\n\n​        除了上面最基本的两种方式，还可以采用以下方法形成微指令序列地址。\n​    （3）增量计数器法\n​        可以发现，大多数情况下后续微指令的地址都是连续的，所以可以借鉴 PC 的功能，采用 “增量计数法” 形成后续微指令的地址：(CMAR) + 1 → CMAR。\n​    （4）分支转移\n​        当遇到转移指令时，微指令也会出现分支，这时必须根据转移方式指明的判别条件，根据各种标志决定下一条微指令的地址。\n​    （5）通过测试网络形成\n​        这种方式微指令的地址码分两部分，高段为非测试地址，需要直接保留；低段则为测试地址，需要结合测试源的信号、通过测试网络来生成。\n​    （6）由硬件生成微程序入口地址\n​        电源接电后，程序第一条微指令的地址（入口地址），可以由专门的硬件电路产生。\n​        另外，当有中断请求且条件满足时，CPU 进入中断周期，这时也可以由硬件产生中断周期微程序的入口地址。同理，当有间接寻址时，也可以由硬件产生间址周期微程序的入口地址。\n6. 微程序设计​        设计微程序控制器，主要任务其实就是编写各条指令的微程序。\n​        具体步骤也可以分为三步：首先写出所有指令的全部微操作以及节拍安排；其次确定微指令格式；最后编写出每条微指令的二进制代码（称为 微指令码点）。\n​    （1）写出机器指令的微操作以及节拍安排\n​        这里我们用跟组合逻辑设计相同的案例，只考虑 10 条机器指令。简单起见，我们这里不考虑间接寻址和中断的情况，只讨论取指和执行周期。\n​        1）取指阶段\n​        跟组合逻辑设计类似，取指阶段的微操作可以安排在三个节拍内：\n\n​        如果一个节拍内的微操作，都对应一条微指令，那么上面的取指微程序对应着 3 条微指令。\n​        不过我们发现，微程序控制器的所有控制信号都来自于微指令，而微指令都存放在控制存储器中。所以每条微指令执行之前，必须有一个将微指令地址送至 CMAR 的过程。或者说，每条微指令执行结束，应该形成后续地址，交给 CMAR；这必须额外耗费一个时钟周期（节拍）。\n\n​        这样，取指操作就需要 6 条微指令来完成。所有微指令都会由时钟信号的上升沿打入 CMDR 中。\n​        2）执行阶段\n​        同样，执行阶段的微操作是由指令操作码决定的；每条微指令完成之后同样要考虑后续指令地址的形成。\n​        a）非访存指令\n\n​        b）访存指令\n\n​        c）转移指令\n\n​        以上总共有微指令 38 条，不同的微操作有 20 个。\n​    （2）确定微指令格式\n​        确定微指令格式，主要是确定微指令的编码方式、后续微指令地址的形成方式，以及微指令字长 3 个方面。\n\n微指令编码方式：微操作不多，可以采用直接编码方式；\n后续地址形成方式：根据指令操作码和微指令的下地址，确定后续微指令地址的形成；\n微指令字长：20 个微操作，对应 20 位操作控制字段；38 条微指令，需要 6 位下地址字段。微指令字长至少取 26 位。\n\n​        进一步分析可以发现，38 条微指令中，19 条都是将后续地址送入 CMAR 的操作。这不仅在微指令上有所浪费，而且相当于每两个时钟周期，才能取出并执行一条微指令。\n​        我们可以将 CMDR 的下地址字段 Ad (CMDR) 直接接到控制存储器的地址线上，在下一个时钟信号的上升沿，就将对应地址的内容（下一条微指令）读取到 CMDR 中。这样就省去了 CMAR，直接用 Ad (CMDR) 取代，而且做到了每一个时钟周期完成一条微指令，大大提升了运行速度。\n​        同样，指令操作码 OP (IR) 通过微地址形成部件产生的后续地址，也可以直接送到控制存储器的地址线上。\n\n​        通过这样的化简，我们就省去了 19 条微指令，并同时省去了 Ad (CMDR) → CMAR 和 OP (IR) → 微地址形成部件 → CMAR 两个微操作。于是总共只需要 38 - 19 = 19 条微指令和 20 - 2 = 18 个微操作。\n​        这样，最少只需要 18 位控制字段和  5 位地址字段。不过为了便于以后扩展，我们可以取 24 位操作控制字段和 6 位下地址字段。微指令格式如下：\n\n​    操作控制字段的第 0 ~ 17 位分别控制的微操作为：\n\n​    （3）编写微程序码点\n​        根据每条微指令的操作控制字段和下地址，就可以得到每一条微指令对应的二进制代码（码点）了。这里我们省略了码点中所有的 0。\n\n7. 其它微程序设计技术​        微程序控制器中，控制信号是以二进制代码的形式出现，因此不需要像组合逻辑那样考虑逻辑表达式的化简，因此设计更加简便，更容易调试和修改。当然，由于执行每个微操作都要访问控制存储器，所以对控制存储器的速度要求较高。微程序控制器通常应用在 CISC 架构中，目前大多数计算机都会采用微程序设计技术。\n​        微程序设计技术也可以有其它一些方式的扩展。\n​    （1）静态微程序设计\n​        通常指令系统是固定的，对应每一条机器指令的微程序，都是计算机的设计者预先编写好的，这种微程序设计技术称为 静态微程序设计，其控制存储器一般采用 ROM。\n​    （2）动态微程序设计\n​        如果可以通过改变微指令和微程序，来改变机器的指令系统，这种微程序设计技术称为 动态微程序设计。这种方式可以在一台机器上实现不同类型的指令系统，有利于仿真和研究测试，其控制存储器需要采用 EPROM。\n​    （3）毫微程序设计\n​        如果采用两级微程序的设计方法，用第一级微程序来解释机器指令，再用第二级微程序（称为 “毫微程序”）来解释第一级微程序，这样的设计方式就称为 毫微程序设计。组成毫微程序的 毫微指令 是用来解释微指令的。\n​        采用毫微程序设计计算机的优点是，可以用更少的控制存储器空间来达到高度的并行；不过同时运行速度会受到一定程度的影响。\n5.7 中断和异常5.7.1 基本概念和分类​        计算机在执行程序的过程中，有时会遇到一些异常情况或者特殊请求；这时就需要计算机暂停正在运行的程序，转而先去处理这些异常或特殊请求，处理结束之后再返回程序的断点处继续执行。这种处理方式就被称为 “中断”，计算机的这种功能就称为 中断处理；实现这种功能所需的软硬件技术统称为 中断技术。\n​        很显然，对于一些突发情况和实时传来的外部信号，相比时刻查询的方式，使用中断技术可以大大地提高计算机的整体效率。\n​        能够引发中断的因素有很多，比如电源掉电、打印机请求、运算溢出、缺页等等。通常将能够引起中断的各种因素称为 中断源。根据各种中断源的类型，可以对中断进行不同的分类。\n1. 中断和异常​        从中断的来源看，直观上可以分成两类：一类是由外部设备向 CPU 发出的请求（比如打印），或者突发的外部事件或环境对计算机造成了影响（比如电源掉电），在 CPU 外部产生；另一类是 CPU 在执行指令时遇到的异常情况，在 CPU 内部产生。\n​        通常将 CPU 内部产生的中断称为 异常（Exception），也称作 内中断。异常一般是 CPU 的控制单元（CU）在执行指令时遇到了意外情况、因而必须暂停处理；由于一定会在一条指令执行结束后才发出中断，因此也被叫做 同步中断。\n​        与之对应，来自于 CPU 外部其它硬件设备的中断，就被称为 外中断，或者直接叫做（狭义的） 中断（Interrupt）。它们通常是外部设备依照 CPU 时钟随机产生的，因此也被叫做 异步中断。\n\n​        事实上，对于中断（狭义）和异常，CPU 的处理流程都是先中止当前正在执行的程序、转而去执行相应的中断处理程序（称为 “中断服务程序”），完成中断响应之后，再回到断点处继续执行。因此，一般可以把它们统称为（广义的）中断。\n2. 中断和异常的分类​        中断请求并不一定都非常急迫、必须立刻响应。CPU 可以对中断进行判别、选择，屏蔽某些中断源的请求；根据是否可以被屏蔽，中断（狭义）又可以分成两类：\n\n可屏蔽中断：可屏蔽中断有 “屏蔽” 和 “非屏蔽” 两种状态；处在屏蔽状态的中断，CPU 将不予以响应。I/O 设备的中断请求都属于可屏蔽中断。\n\n不可屏蔽中断：一些急迫事件 CPU 必须予以响应，发出的中断不能屏蔽。例如电源掉电就属于不可屏蔽中断。\n\n\n\n​        而对于异常，由于它跟指令的执行有关，因此根据中断处理完成后、接下来指令执行的情况，可以进一步进行分类：\n\n故障（Fault）：通常可以纠正，一旦纠正则程序可以重新执行原先产生中断的那条指令；也称为 “程序性事故”。例如运算溢出、缺页异常。\n陷阱（Trap）：这种异常是人为设置的，表示自愿停止现行程序、转入中断处理，因此也叫 “自愿中断”、“自陷”。一般计算机中都会设置陷阱指令，执行到它就会转至别处做特殊处理，完成之后就返回到陷阱指令的下一条指令继续执行。例如调试程序时的断点设置、执行系统调用等。\n异常中止（Abort）：如果发生了严重的错误，程序无法继续执行，那么就只能把控制权交给异常中止处理程序；而现行程序只能强制停止运行。例如硬件故障、系统表中无效的值等。\n\n3. 中断系统​        中断改变了计算机执行程序的顺序，因此需要 CPU 进行特别的处理。为了实现中断处理的功能，CPU 中一般会设置专门的处理机构，这就是 中断系统。\n​        中断系统主要需要解决以下一些问题：\n\n中断源怎样向 CPU 发出中断请求；\n\n当有多个中断源同时发出请求时，怎样确定响应顺序；\n\nCPU 怎样响应中断请求；\n\nCPU 响应中断之后，怎样保护现场；\n\nCPU 响应中断后，怎样暂停原程序的执行、找到中断服务程序的入口地址；\n\n中断处理结束后，CPU 如何恢复现场、返回原程序的断点处；\n\n如果中断处理时又有新的中断请求，应该怎样处理。\n接下来我们就通过学习中断系统，来解决这些问题。\n\n\n5.7.2 中断的检测​        在 CPU 的指令周期中，最后一个阶段就是 中断周期。在一条指令执行阶段的最后时刻，CPU 会发出 中断查询信号，检测是否有中断请求。如果有，则进入中断周期进行中断处理。\n1. 中断请求标记​        不同的中断源都可以向 CPU 发出中断请求，为了区分中断源，中断系统中会专门设置一个 中断请求标记触发器，简称 中断请求触发器，用 INTR 表示。当某个中断源的触发器 INTRi 为 “1” 时，就表示该中断源发来了请求。\n​        这些触发器可以分散在各个中断源的接口电路中，也可以集成在 CPU 中，组成一个 中断请求标记寄存器。\n\n​        寄存器里的每一位就对应着一个中断源的请求触发器。任意一个触发器为 1，就表示对应的中断源发出了中断请求。\n2. 中断判优​        在中断系统中，同一时刻只能响应一个中断源的请求。如果有多个中断源同时发出了请求，那就需要中断系统按照设定好的优先顺序来依次响应；这被称为 中断判优。中断源的优先级是依据重要性和急迫性而定的。\n​        中断判优就是要对一组中断请求按优先级进行 “排队”，可以用硬件和软件两种方式实现。\n​    （1）硬件排队\n​        硬件排队是直接用硬件电路实现中断请求的排队，具体方法很多，主要有两种：一种是在 CPU 内统一设置一个 “排队器”；另一种是在中断源设备的接口电路中分别设置排队器。\n\n在 CPU 内设置排队器：各中断源的请求触发器按优先级依次排列，高优先级的请求信号通过接入一个多输入的与非门，来 “封住” 低优先级的中断请求。\n\n\n在接口电路中设置排队器：每个接口电路中都设置一个反相器和一个与非门，与非门的输出接入下一级，就可以实现对更低优先级中断请求的封锁。它们彼此之间直接连成链状，因此也称为 “链式排队器”。\n\n​    （2）软件排队\n​        软件排队，就是直接通过编写查询程序实现中断请求的排队。\n\n​        程序按照中断源的优先级，从高到低依次判断是否有中断请求，这样就保证了中断响应的顺序。\n5.7.3 中断的响应1. 中断响应的条件​        由于在处理中断时，CPU 不应受到新中断请求的打扰，因此需要有 “开关中断” 的功能。在中断系统中，这是由 允许中断触发器 EINT 和专门的指令来实现的。\n​        EINT 可以被 开中断指令 置 “1”，这时表示 CPU 打开了中断功能，允许响应中断源的请求；EINT 也可以被 关中断指令 置 “0”，这意味着 CPU 关闭中断功能，禁止响应中断。\n​        在 x86 架构的 CPU 中，EINT 就对应着 标志寄存器（程序状态字）efl 中的一位，用 IF 表示。\n\n​        因此可以总结，当 EINT = 1 且有中断请求（INTRi = 1）时，CPU 就可以响应中断。\n2. 中断响应的时间​        很多情况下中断请求的产生是随机的，为了不影响 CPU 的正常工作，需要周期性地在统一的时刻由 CPU 发出中断查询信号，判断当前是否有中断请求。\n\n​        因此 CPU 响应中断的时间，一定是在每条指令执行阶段的结束时刻；相当于在指令周期最后又加入了一个阶段，这就是 中断周期。执行周期结束后，如果有中断请求，则 CPU 进入中断周期；如果没有则直接进入下一条指令的取指周期。\n3. 中断响应的过程​        CPU 响应中断之后，就会进入中断周期。在中断周期 CPU 会执行一系列的操作，这些操作都是由一条 中断隐指令 完成的。所谓的隐指令，指的是指令系统中本身没有这条指令，它是由硬件自动完成的。具体操作如下：\n​    （1）保护程序断点\n​        将当前 PC 的内容（程序断点位置）保存到主存中。可以存入特定的某个地址（比如 0 地址），也可以存入堆栈中。\n​    （2）寻找中断服务程序的入口地址\n​        在中断周期内，可以用两种方法寻找中断服务程序的入口地址：硬件向量法和软件查询法，分别对应着硬件和软件实现。\n​    （3）关中断\n​        为了在响应中断后，不受到新的中断请求的干扰，在中断周期需要自动做 “关中断” 的操作，禁止 CPU 再次响应中断请求。关中断的具体操作就是将允许中断触发器 EINT 置 “0”，一般直接由硬件电路实现。\n​        对应的微操作如下：\n\n5.7.4 中断服务程序1. 中断服务程序的入口地址​        不同的中断请求，需要执行不同的中断服务程序。寻找中断服务程序的入口地址，通常可以采用两种方法：硬件向量法 和 软件查询法。\n​    （1）硬件向量法\n​        所谓硬件向量法，就是使用硬件直接产生一个 向量地址，再用这个向量地址找到中断服务程序的入口地址。向量地址由中断向量地址形成部件产生。\n​        中断向量地址形成部件的输入，是来自排队器的输出 INTPi ，它的输出则是一个二进制的 中断向量。一般可以让一个中断源对应一个向量地址，因此这个部件本质上就是一个编码器。\n\n​        通过向量地址寻找中断服务程序入口地址可以采用两种方法。\n\n\n在向量地址对应内存单元放一条 无条件转移指令。这样 CPU 响应中断时，只要将向量地址交给 PC，然后执行这条指令，就可以跳转到中断服务程序入口地址了。\n设置 向量地址表。向量地址表存放在主存中，向量地址就是对应存储单元的地址，而存放的内容就是中断服务程序的入口地址。\n\n​        硬件向量法寻找入口地址速度快，现代计算机中普遍使用这种方法。\n​    （2）软件查询法\n​        用软件寻找中断服务程序入口地址的方法，就叫做软件查询法。各个中断源对应的入口地址，是由程序员（或系统）预先定好、写入程序的；可以结合软件排队的中断判优，确定要响应某个中断请求时，直接跟上一条转移指令、跳转至定义好的入口地址就可以了。\n​        软件查询法不涉及硬件，更加容易维护和扩展，但查询的时间更长。\n2. 中断服务程序的流程​        不同的中断请求对应的中断服务程序不同，不过它们的处理流程是类似的，一般包括 保护现场、中断服务、恢复现场 和 中断返回 4 个部分。\n​    （1）保护现场\n​        保护现场通常包含两层含义：一是保存程序的断点，这由中断隐指令完成；二是保存通用寄存器和状态寄存器的内容，这需要中断服务程序完成。\n​        具体操作就是在中断服务程序的起始部分，安排几条存数（Store）指令，将寄存器的内容全部保存到主存中；或者直接用入栈（Push）指令将寄存器内容推入栈中。\n​    （2）中断服务\n​        中断服务是中断服务程序的主体部分，针对不同的中断源，需要做出对应的操作内容。\n​    （3）恢复现场\n​        中断服务程序的结尾部分，还需要恢复现场。对应着之前的保护现场，这一步可以用取数（Load）指令或者出栈（Pop）指令，将保存在主存中的信息恢复到寄存器中。\n​    （4）中断返回\n​        中断服务程序的最后一条指令，通常是一条 中断返回指令，从而返回到原程序的断点处继续执行。\n\n​        如果在 CPU 执行中断服务程序时，又来了一个新的中断请求，这时有两种处理方式：一种是直接不予响应，即 CPU 在响应中断的过程中保持 “关中断” 状态，直到中断服务程序执行结束、返回之前才开中断；另一种则是 CPU 立即响应新的中断请求，这需要在中断服务程序的开始阶段 “开中断”。 \n5.7.5 中断屏蔽技术1. 多重中断​        如果 CPU 在响应某个中断请求的时候，另一个中断源又提出了一个新的中断请求；而 CPU 立即响应这个请求，暂停正在运行的中断服务程序、转而去运行新的中断服务程序，这就是 中断嵌套，也称为 多重中断。 与之对应，如果 CPU 在响应中断时不去响应新的中断请求，则称为 单重中断。\n\n​        实现多重中断，需要满足两个基本条件：\n\n提前设置 “开中断” 指令\n\n​        由于进入中断周期后，中断隐指令会自动将 EINT 置为 0，因此默认会关中断、不再响应新的中断请求；这时如果希望处理多重中断，就必须在中断服务程序的开始阶段设置 “开中断” 指令来打开中断。\n\n优先级高的中断源有权中断优先级低的中断源\n\n​        只有优先级别更高的中断源，才能打断正在执行的中断服务程序、优先被响应。\n\n​        例如，有 A、B、C、D 四个不同的中断源，优先级为 A &gt; B &gt; C &gt; D。在 CPU 执行程序时，在某个指令周期，同时查询到了 B、C 发来的中断请求；之后在执行中断服务程序的过程中，又先后查询到了 D、A 的请求。那么如果允许多重中断，中断处理的时间顺序如下：\n\n\n​        中断请求如果同时到来（比如上例中的 B、C），我们可以进行中断判优、利用排队器决定它们的先后顺序。但对于多重循环，还需要在中断响应过程中继续判断优先级、决定是否可以打断当前的中断服务程序。这是通过 中断屏蔽技术 来实现的。\n2. 中断屏蔽触发器​        为了实现对每个中断源的屏蔽，可以在中断请求触发器 INTR 之前增设一个 中断屏蔽触发器 MASK。当 MASK 为 “1” 时，表示该中断源被屏蔽，中断请求不被响应。\n​        屏蔽触发器同样既可以设置在接口电路中、也可以直接集成在 CPU 内。以 I/O 设备作为中断源为例，I/O 设备的接口电路中会有一个 完成触发器 D，它为 “1” 则表示设备已经处于就绪状态、要向 CPU 发出中断请求了。一般情况下，D 的输出可以直接接到中断请求触发器 INTR 的输入；现在则可以与 MASK 的输出经与非门之后、再交给 INTR。\n\n​        这样，当设备已经准备就绪（D = 1），且设备未被屏蔽（MASK = 0）时，来自 CPU 的中断查询信号就会将 INTR 置 “1”，表示该设备发出了中断请求信号。\n​        同样，排队器内也可以加上屏蔽条件，就组成了具有屏蔽功能的排队器。例如集成在 CPU 内的排队器如果加上屏蔽功能，只需要另外将屏蔽信号也接入与非门就可以了：\n\n3. 屏蔽字和屏蔽技术​        显然，对于每个中断源，中断请求触发器 INTR 和 中断屏蔽触发器 MASK 都是成对出现的。如果将所有屏蔽触发器组合在一起，也可以构成一个 屏蔽寄存器。屏蔽寄存器的内容就称为 屏蔽字。\n​        屏蔽字可以在中断服务程序中进行设置，屏蔽字和中断源的优先级是一一对应的。以 16 个中断源 I1 ~ I16 的屏蔽字为例，每个屏蔽字都是 16 位：\n\n​        在不同中断源的中断服务程序中，可以设置适当的屏蔽字，就能对优先级不同的中断源进行屏蔽。\n​        例如，在   I1 的服务程序中，将屏蔽字设为全 1，就表示它的优先级最高：在响应 I1 中断请求的过程中，不会再去响应任何新的请求（包括 I1 自己发来的）；这相当于就是单重中断。而对于 I3 ，在服务程序中将屏蔽字前两位设为 0、后面为 1，表示 I1、I2 优先级更高、不被屏蔽，而后面的中断源（包括自己）被屏蔽；于是开中断之后，I1、I2 发来的新中断请求就可以打断当前 I3 的中断服务程序，实现了多重中断。\n4. 改变处理优先级​        使用屏蔽技术还可以改变中断源的优先等级。中断源的优先级，包括两层含义：响应优先级 和 处理优先级。\n\n响应优先级：CPU 响应各中断源请求的先后次序，跟排队器有关，一般是硬件线路设定好的，不易改动；\n处理优先级：CPU 实际执行中断服务程序的先后次序，可以通过屏蔽技术进行改动。\n\n​        如果不采用屏蔽技术，那么处理的优先顺序就是按照响应优先级来的。例如，A、B、C、D 四个中断源，优先级别为 A &gt; B &gt; C &gt; D，根据这一次序设计出排队器之后，当它们同时发来中断请求时，处理顺序就是响应顺序：\n\n​        如果采用了屏蔽技术，就可以在不改变响应顺序的前提下，改变 CPU 处理中断的顺序。假如我们希望将它们的处理次序改为 A → D → C → B，那么每个中断源的中断服务程序中应该重新设置屏蔽字：\n\n​        这样，同样还是 A、B、C、D 同时发出中断请求，这时的处理顺序就会变为：\n\n​        显然，采用屏蔽技术改变处理优先级，需要在中断服务程序中重置屏蔽字。这样，中断服务程序的处理流程就会变为：\n\n​        跟之前相比，增加了 置屏蔽字 和 恢复屏蔽字 两步操作。而为了防止在恢复阶段又出现新的中断，需要先关中断、等到恢复现场和屏蔽字之后再次开中断。\n5.8 多处理器基本概念5.8.1 SISD、SIMD、MIMD 和向量处理器​        通过改进系统结构，可以有效地提升计算机的性能，一个方向就是 并行处理。指令流水线就是一种典型的并行处理技术，它提供的是 指令 的并行；而另一种思路则是考虑让 数据 的处理并行起来。\n1. 费林分类法​        美国计算机科学家迈克尔 · 费林（Michael Flynn）根据指令和数据是否并行，将计算机体系结构分为四类：\n\n\nSISD（Single Instruction stream, Single Data stream）：单指令流单数据流。普通的串行执行结构，CPU 同时只能执行一条指令，处理一条数据；\nSIMD（Single Instruction stream,  Multiple Data streams）：单指令流多数据流。单条指令可以同时对应处理多个数据，从而实现了数据的并行处理；\nMISD（Multiple Instruction streams, Single Data stream）：多指令流单数据流。多条指令同时执行，但只处理一条数据，这种架构非常罕见，只是作为一种理论模型；\nMIMD（Multiple Instruction streams, Multiple Data streams）：多指令流多数据流。同时执行多条不同的指令，它们分别处理不同的数据；这种方式实现了线程、指令和数据的全方位并行处理。\n\n2. SIMD 和向量处理器​        SIMD 的特点是，设置了多个并行的执行单元，而所有的执行单元都是同步的，执行的指令从同一个 PC 中取出，由同一个控制单元来进行调度管理。SIMD 对应的程序设计风格可以跟 SISD 非常相近，但要求程序中必须存在大量同构的数据，以便实现 数据级并行。\n​        向量处理器是 SIMD 架构的一种具体实现，可以并行执行一组数据（向量）的计算任务。\n​        向量处理器的基本原理是，从主存中收集数据，将它们按照顺序放到一组 向量寄存器 中，使用流水线式的执行单元在寄存器中依次进行操作，然后将结果写回主存。\n5.8.2 硬件多线程​        相比 SIMD，MIMD 提高了更高的并行程度。MIMD 需要同时执行不同的指令流，这就要依赖多个 进程（process） 或者 线程（thread） 同时执行，让处理器时刻保持忙碌状态。\n​        对于一个处理器，可以允许多个线程以重叠的方式，共享处理器的功能部件；当一个线程停顿时，就切换到另一个线程，从而更加充分地利用了硬件资源。这种技术就称为 硬件多线程（hardware multithreading）。\n​        在支持硬件多线程的 CPU 中，需要为每个线程提供单独的寄存器堆和 PC 等资源，这样就可以在共享资源的同时保持线程的独立状态。\n​        硬件多线程主要有两种实现方法。\n\n细粒度多线程\n\n​        每条指令执行后就进行线程切换，从而实现多线程在时间上的交叉执行。这种交叉执行是轮转进行的，并且会跳过停顿的任何线程。\n\n粗粒度多线程\n\n​        仅在发生高开销的停顿时（例如末级 cache 失效），才进行线程切换。对于流水线中的停顿，需要清空或者冻结流水线，因此流水线的重启开销比较大。\n​        除此之外，硬件多线程还可以结合流水线多发技术，进一步降低成本、提高并行效率，这就是 同时多线程（Simultaneous Multithreading，SMT）。同时多线程是硬件多线程的一种变体，它结合使用多发射、动态调度流水线的处理器资源，来实现 线程级 和 指令级 并行。\n​        英特尔（Intel）公司的 “ 超线程 “（Hyper-Threading）技术，就是一种在单个 CPU 上实现硬件多线程的方式。\n5.8.3 多核处理器和 SMP1. 多核处理器​        另一种实现线程级并行的方式，就是在一个处理器芯片上，集成多个处理单元。为了区分不同的概念，每个处理单元就称为一个 ” 核 “（core），有多个核的处理器就被称为 多核处理器。\n​        要想充分利用多核处理器的性能，应该采用多线程的方式执行程序。这样，多个线程可以在不同的核上并行执行，大大提升运行效率。\n​        多核处理器一般也采用硬件多线程技术，为了进行区分，有时会将单个核心上同时运行多个线程称为有多个 ”逻辑内核“，而对应的真正的核心则称为 ”物理内核“。\n\n​        在多核处理器中，一般所有内核会有自己独立的寄存器和 L1、L2 缓存，而共享更低级的 cache（L3）和主存。\n\n​        如果不对处理单元进行集成，也可以用同样的架构将多个处理器联合在一起，这就是所谓的 多处理器。广义上讲，多核处理器也是一种多处理器。\n2. 共享内存多处理器（SMP）​        编写运行在多处理器上的并行程序会更加复杂。在架构上，一个很重要的影响因素是，是否为所有处理器提供一个共享的统一物理地址空间；换句话说，所有处理器（核心）是否可以访问同一个主存储器。于是多处理器又可以划分为两种架构。\n​        共享内存多处理器（Shared Memory Processor，SMP）为所有处理器提供统一的物理地址空间。处理器通过存储器中的 共享变量 进行通信，所有处理器都能通过加载（Load）和存储（Store）指令访问任意的主存位置。\n\n​        尽管物理地址空间是统一的、共享的，但如果存储器本身也采取了并行架构（例如多模块存储器），不同的处理器对存储器不同部分的访问可能就会有区分。因此 SMP 又可以有两种类型。\n\n统一内存访问（Unified Memory Access，UMA）多处理器\n\n​        不管是来自哪个处理器的访存指令，延迟都是一致的。这样，每个处理器对所有存储单元的访问时间都大致相同，是对称的系统架构。\n\n非统一内存访问（Non-Unified Memory Access，NUMA）多处理器\n\n​        访存指令的延迟不一致，取决于哪个处理器去访问哪个存储单元。一般架构中，每个处理器（CPU）会单独直接连接一部分主存，称为 本地内存；其它主存部分则通过总线进行访问，称为 远程内存。\n3. MPP 和集群​        如果不采用共享内存的方式，而是让每个处理器都拥有私有的地址空间，这样就可以让各个处理器更加独立、获得更好的并行性和可扩展性。这种架构被称为 大规模并行处理（Massive Parallel Processing，MPP）。\n\n​        采用 MPP 架构的多处理器，必须通过显式的 消息传递 进行通信，因此传统上也把这种类型的计算机称为 显式消息传递计算机。\n​        更进一步，我们可以通过标准网络交换机上的 I/O 接口进行连接，用一组计算机的集合来构建出消息传递多处理器，这种形式就被称为 集群（Cluster）。集群是一种分布式系统，已经成为如今并行处理计算机最典型的架构，也是大数据领域的技术基础。\n5.9 章节练习一、单项选择题\n【2011真题】假定不采用 Cache 和指令预取技术，且机器处于“开中断” 状态，则在下列有关指令执行的叙述中， 错误的是     （    ）\n\n​        A．每个指令周期中 CPU 都至少访问内存一次\n​        B．每个指令周期一定大于或等于一个 CPU 时钟周期\n​        C．空操作指令的指令周期中任何寄存器的内容都不会被改变\n​        D．当前程序在每条指令执行结束时都可能被外部中断打断 \n​        答案：C\n​        要点：每个指令执行完成后，PC的值都会改变，从而可以继续执行下一条指令；即使是空操作也会执行 PC + 1 的动作。\n\n【2016真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是    （    ）\n\n​        A．可以采用单总线结构数据通路\n​        B．处理器时钟频率较低\n​        C．在指令执行过程中控制信号不变\n​        D．每条指令的 CPI 为 1 \n​        答案：A\n​        要点：单总线结构下，所有部件需要争用唯一的总线，不支持并发传送操作；因此单周期处理器不可以采用单总线结构数据通路。\n\n【2019真题】下列有关处理器时钟脉冲信号的叙述中，错误的是    （    ）\n\n​        A．时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成\n​        B．时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频\n​        C．时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定\n​        D．处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令 \n​        答案：D\n​        要点：CPU 从内存中取出并执行一条指令所需的全部时间称为指令周期，指令周期又由若干机器周期组成，一个机器周期又包含若干时钟周期。\n\n【2020真题】下列给出的处理器类型中，理想情况下，CPI 为 1 的是    （    ）\nⅠ.单周期 CPU        Ⅱ.多周期 CPU        Ⅲ.基本流水线 CPU        Ⅳ.超标量流水线 CPU\nA. 仅Ⅰ、Ⅱ                B. 仅Ⅰ、Ⅲ                C. 仅Ⅱ、Ⅳ                D. 仅Ⅲ、Ⅳ\n答案：B\n\n\n​        要点：多周期 CPU 指的是将整个 CPU 的执行过程分成几个阶段，每个阶段用一个时钟周期去完成，然后开始下一条指令的执行，而每种指令执行时所用的时钟数可以不同。基本流水线理想情况下 CPI 为 1；而超标量流水线可以通过增加功能部件实现并行，CPI 可以小于1。\n\n【2009真题】某计算机的指令流水线由四个功能段组成，指令流经各功能段的时间（忽略各功能段之间的缓存时间）分别为 90ns、 80ns、 70ns 和 60ns，则该计算机的 CPU 时钟周期至少是     （    ）\n\n​        A． 90ns     B． 80ns     C． 70ns     D． 60ns\n​        答案：A\n\n【2010真题】下列选项中， 不会引起指令流水线阻塞的是    （    ）\n\n​        A．数据旁路（转发）            B．数据相关            C．条件转移             D．资源冲突\n​        答案：A\n​        要点：数据旁路技术是解决数据冒险的一种方法。\n\n【2016真题】在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令序列存在数据冒险的指令对是    （    ） \n\n1234I1： add R1， R2， R3; （R2） +（R3） → R1I2： add R5， R2， R4; （R2） +（R4） → R5I3： add R4， R5， R3; （R5） +（R3） → R4I4： add R5， R2， R6; （R2） +（R6） → R5  \n​        A． I1 和 I2                     B． I2 和 I3                     C． I2 和 I4                     D． I3 和 I4 \n​        答案：B\n​        要点：数据冒险也叫数据相关，指在程序中存在必须等前条指令执行完才能执行后一条指令的情况。\n\n【2017真题】下列关于超标量流水线特性的叙述中，正确的是    （    ）\n\n​        Ⅰ . 能缩短流水线功能段的处理时间\n​        Ⅱ．能在一个时钟周期内同时发射多条指令\n​        Ⅲ．能结合动态调度技术提高指令执行并行性\n​        A．仅Ⅱ                 B．仅Ⅰ、Ⅲ                 C．仅Ⅱ、Ⅲ                 D．Ⅰ、Ⅱ和Ⅲ \n​        答案：C\n​        要点：超标量流水线每个时钟周期可以并行完成一条以上的指令，但不能缩短功能段的处理时间。\n\n【2018真题】若某计算机最复杂指令的执行需要完成 5 个子功能，分别由功能部件 A~E 实现，各功能部件所需时间分别为 80ps、50ps、50ps、70ps 和 50ps，采用流水线方式执行指令，流水段寄存器延时为 20ps，则CPU 时钟周期至少为    （    ）\n\n​        A.60 ps                        B.70 ps                            C.80 ps                        D.100 ps\n​        答案：D\n​        要点：流水线上每个流水段的时间相同，应该取最大的功能部件运行时间，并且加上寄存器的延时。\n\n【2019真题】在采用 “取指、译码/取数、执行、访存、写回”  5 段流水线的处理器中，执行如下指令序列，其中 s0、 s1、 s2、 s3 和 t2 表示寄存器编号。 \n\n1234I1： add s2,s1,s0 \t// R[s2] ← R[s1] + R[s0]I2： load s3,0(t2) \t// R[s3] ← M[R[t2]+0]I3： add s2,s2,s3 \t// R[s2] ← R[s2] + R[s3]I4： store s2,0(t2) \t// M[R[t2]+0] ← R[s2]\n​        下列指令对中，不存在数据冒险的是     （    ）\n​        A．I1和 I3                 B． I2 和 I3                 C． I2 和 I4                 D． I3 和 I4 \n​        答案：C\n​        要点：A、B、D 选项的指令对都发生了 “写后读” 的情况，存在数据冒险。\n\n【2021真题】下列关于数据通路的叙述中，错误的是    （    ）\n\n​        A.数据通路包含 ALU 等组合逻辑（操作）元件\n​        B.数据通路包含寄存器等时序逻辑（状态）元件\n​        C.数据通路不包含用于异常事件检测及响应的电路\n​        D.数据通路中的数据流动路径由控制信号进行控制\n​        答案：C\n​        要点：指令执行过程中数据所经过的路径， 包括路径上的部件， 称为数据通路。 ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等， 都是指令执行过程中数据流经的部件， 都属于数据通路的一部分。 \n\n【2009真题】相对于微程序控制器，硬布线控制器的特点是    （    ） \n\n​        A．指令执行速度慢，指令功能的修改和扩展容易 \n​        B．指令执行速度慢，指令功能的修改和扩展难\n​        C．指令执行速度快，指令功能的修改和扩展容易\n​        D．指令执行速度快，指令功能的修改和扩展难 \n​        答案：D\n\n【2017真题】下列关于主存储器（MM）和控制存储器（CS）的叙述中，错误的是    （    ）\n\n​        A． MM 在 CPU 外， CS 在 CPU 内\n​        B． MM 按地址访问， CS 按内容访问\n​        C． MM 存储指令和数据， CS 存储微指令\n​        D． MM 用 RAM 和 ROM 实现， CS 用 ROM 实现\n​        答案：B\n​        要点：控制存储器按照微指令的地址访问。\n\n【2012真题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有 33 个微命令，构成 5 个互斥类，分别包含 7、 3、 12、 5 和 6 个微命令，则操作控制字段至少有     （    ）\n\n​        A. 5 位                 B. 6 位                 C. 15 位                 D. 33 位 \n​        答案：C\n\n【2014真题】某计算机采用微程序控制器，共有 32 条指令， 公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（下地址字段法）确定下条微指令地址， 则微指令中下地址字段的位数至少是    （    ）\n\n​        A. 5                         B. 6                         C. 8                         D. 9 \n​        答案：C\n​        要点：微指令下地址字段的位数，与微指令的条数有关。总共有 4 × 32 + 2 = 130 条微指令。\n\n【2020真题】下列关于“自陷”(Trap，也称陷阱)的叙述中，错误的是    （    ）\n\n​        A.自陷是通过陷阱指令预先设定的一类外部中断事件\n​        B.自陷可用于实现程序调试时的断点设置和单步跟踪\n​        C.自陷发生后CPU将转去执行操作系统内核相应程序\n​        D.自陷处理完成后返回到陷阱指令的下一条指令执行\n​        答案：A\n​        要点：自陷产生于 CPU 内部，属于内中断。\n\n【2009真题】下列选项中，能引起外部中断的事件是    （    ）  \n\n​        A．键盘输入                      B．除数为 0                 C．浮点运算下溢                   D．访存缺页\n​        答案：A\n\n【2015真题】内部异常（内中断）可分为故障（fault）、陷阱（trap）和终止（abort）三类。下列有关内部异常的叙述中，错误的是    （    ）\n\n​        A．内部异常的产生与当前执行指令相关                        B．内部异常的检测由CPU内部逻辑实现\n​        C．内部异常的响应发生在指令执行过程中                    D．内部异常处理后返回到发生异常的指令继续执行 \n​        答案：D\n\n【2017真题】下列关于多重中断系统的叙述中， 错误的是    （    ）\n\n​        A．在一条指令执行结束时响应中断                        B．中断处理期间 CPU 处于关中断状态\n​        C．中断请求的产生与当前指令的执行无关            D． CPU通过采样中断请求信号检测中断请求 \n​        答案：B\n​        要点：实现多重中断，中断处理期间必须开中断。\n\n【2022真题】下列关于并行处理技术的叙述中，不正确的是    （    ） \n\n​        A. 多核处理器属于 MIMD 结构                            B. 向量处理器属于 SIMD 结构\n​        C. 硬件多线程技术只可用于多核处理器                D. SMP 中所有处理器共享单一物理地址空间 \n​        答案：C\n二、综合应用题\n【2014真题】某程序中有如下循环代码段P: \n\n1for(int i = 0; i &lt; N; i++) sum+=A[i];\n​        假设编译时变量 sum 和 i 分别分配在寄存器 R1 和 R2 中。常量 N 在寄存器 R6 中，数组 A 的首地址在寄存器 R3 中 。 程序段 P 起始地址为 0804 8100H，对应的汇编代码和机器代码如下表所示。 \n\n​        执行上述代码的计算机 M 采用 32 位定长指令字， 其中分支指令 bne 采用如下格式： \n\n​        OP 为操作码；Rs 和 Rd 为寄存器编号；OFFSET 为偏移量，用补码表示。 请回答下列问题，并说明理由。\n​        1）M 的存储器编址单位是什么？\n​        2）已知 sll 指令实现左移功能， 数组 A 中每个元素占多少位？\n​        3）表中 bne 指令的 OFFSET 字段的值是多少？已知 bne 指令采用相对寻址方式， 当前 PC 内容为 bne 指令地址， 通过分析表中指令地址和 bne 指令内容 ， 推断出 bne 指令的转移目标地址计算公式。\n​        4）若 M 采用如下 “按序发射、按序完成” 的 5级指令流水线： IF (取值 ）、ID (译码及取数）、 EXE (执行）、 MEM (访存）、 WB (写回寄存器 ），且硬件不采取任何转发措施， 分支指令的执行均引起 3个时钟周期的阻塞， 则 P 中哪些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令 1 的执行不会因为与指令 5 的数据相关而发生阻塞？ \n​        答案：\n​        1）M 的存储器编址单位为字节。因为 M 采用 32 位定长指令字，每个指令占 4 个字节；而指令间的地址差为 4，所以每个地址对应 1 个字节。\n​        2）A 中每个元素占 32 位。左移 2 位相当于乘以 4，所以每个元素占 4 个字节。\n​        3）bne 指令 OFFSET 字段的机器补码为 FFFAH，真值为 -6。正常情况下，OFFSET 乘以指令字长就应该是偏移的地址差：\n\n​        不过在这里，bne 指令地址和要跳转到的 loop 地址差为\n\n​        所以很明显，发生跳转的时候，应该基于 bne 下一条指令的地址 0804 8118H ，再加上 OFFSET × 4，就是转移的目标地址。相当于 PC 先做了 +1 操作（对应地址 +4）：\n\n​        4）由于数据相关而发生阻塞的指令为第 2、 3、 4、 6 条，因为第 2、 3、 4、 6 条指令都与各自前一条指令发生数据相关。\n​        第 6 条指令会发生控制冒险。\n\n​        当前循环的第 5 条指令与下次循环的第 1 条指令虽然有数据相关，但由于第 6 条指令后有 3 个时钟周期的阻塞，因而消除了该数据相关。\n\n\n【2022真题】某 CPU 中部分数据通路如图所示， 其中， GPRs 为通用寄存器组；FR 为标志寄存器，用于存放 ALU 产生的标志信息；带箭头虚线表示控制信号，如控制信号 Read、Write 分别表示主存读、 主存写， MDRin表示内部总线上数据写入MDR，MDRout 表示 MDR 的内容送内部总线。\n\n\n​        请回答下列问题。\n​        1）设 ALU 的输入端 A、 B 及输出端 F 的最高位分别为 A15 、 B15 及 F15 ,  FR 中的符号标志和溢出标志分别为 SF 和 OF，则 SF 的逻辑表达式是什么？A 加 B、 A 减 B 时 OF 的逻辑表达式分别是什么？要求逻辑表达式的输入变量为 A15 、 B15 及 F15。\n​        2）为什么要设置暂存器 Y 和 Z?\n​        3）若 GPRs 的输入端 rs、 rd 分别为所读、 写的通用寄存器的编号， 则 GPRs 中最多有多少个通用寄存器？rs 和 rd 来自图中的哪个寄存器？已知 GPRs 内部有一个地址译码器和一个多路选择器， rd 应连接地址译码器还是多路选择器？\n​        4）取指令阶段（不考虑 PC 增量操作） 的控制信号序列是什么？若从发出主存读命令到主存读出数据并传送到 MDR 共需5个时钟周期， 则取指令阶段至少需要几个时钟周期？\n​        5）图中控制信号由什么部件产生？图中哪些寄存器的输出信号会连到该部件的输入端？ \n​        答案：\n​        1）SF 表示运算结果的正负性，所以  SF = F~15~\n​            A 加 B 时，A + B → F。若 A 和 B 都为负且 F 为正；或者，若 A 和 B 都为正且 F 为负，则溢出。所以溢出标志逻辑表达式为：\n\n​            A 减 B 时，A - B → F。若 A 为负、B 为正，同时 F 为正，则溢出；或者，若 A 为正、B 为负，同时 F 为负，则溢出。所以溢出标志逻辑表达式为：\n\n​        2）因为在单总线结构中，每个时刻总线上只有一个数据有效，而 ALU 有两个输入端和一个输出端。因此，当 ALU 运算时，首先需要用暂存器 Y 缓存其中一个输入端的数据，在通过总线传送另一个输入端的数据。当ALU的输出端产生运算结果，但由于该节拍总线被占用，因此需要暂存器 Z，用来缓存 ALU 的输出端数据。\n​        3）可以看到 rs 和 rd 的编号都为 4 位，那么 GPRs 中最多有 2^4^ = 16 个通用寄存器。\n​            寄存器编号用于在指令中表示寄存器寻址的地址，指令寄存器 IR 中存储指令，所以 rs 和 rd 来自指令寄存器IR。\n​            rd 是寄存器编号，应该连接地址译码器。多路选择器用于从多个输入信号中选择一个输出，它的输出信号取决于控制信号。\n​        4）取指阶段微操作：\n\n​            对应的控制信号序列如下：\n​            ① PCout, MARin 有效，将指令的地址写入 MAR\n​            ② Read 信号有效，读取主存数据（经系统总线写入MDR）\n​            ③ MDRout，IRin 有效，将 MDR 的内容写入指令寄存器 IR\n​            其它步骤省略。\n​            步骤 ① 需要1个时钟周期，步骤 ② 需要 5 个时钟周期，步骤 ③ 需要1个时钟周期，因此取指令阶段至少需要7 个时钟周期。\n​        5）图中控制信号由控制单元CU产生。\n​            指令寄存器 IR 和标志寄存器 FR 的输出信号会连接到控制部件的输入端。\n","slug":"计算机组成原理","date":"2024-05-31T16:00:00.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"},{"id":"eebf5774c100175fb47d65de16ffd14d","title":"个人搭建方法","content":"简介主要用于知识整理与分享，希望有用\n\n","slug":"intro","date":"2024-05-29T09:41:59.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"}]