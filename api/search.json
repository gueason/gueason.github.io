[{"id":"85d3fedd41ce5b619a50d7691e9b44cb","title":"计算机组成原理408（搬运）","content":"第一章 计算机系统概述1.1 本章大纲要求与核心考点1.1.1 大纲内容(一) 计算机系统层次结构\n\n计算机系统的基本组成\n\n计算机硬件的基本结构\n\n计算机软件和硬件的关系\n\n计算机系统的工作原理\n“存储程序”工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。\n\n\n(二) 计算机性能指标\n​        吞吐量、响应时间；\n​        CPU时钟周期、主频、CPI、CPU执行时间；\n​        MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。\n真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          计算机系统层次结构\n          6\n          0\n      \n      \n          计算机性能指标\n          9\n          2\n      \n  \n\n\n\n1.2 计算机系统简介1.2.1 计算机系统的概念和分类​        计算机系统由“硬件”和“软件”两大部分组成。\n\n“硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。\n\n“软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。\n\n\n​        计算机的软件通常又可以分为两大类：系统软件和应用软件。\n\n系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。\n应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。\n\n1.2.2 计算机的发展硬件的发展\n​        1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是”用电子管组成的电子数字积分机和计算机”。\n​        从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。\n硬件技术对计算机更新换代的影响\n\n\n\n\n\n代\n时间\n硬件技术\n速度（次/秒）\n\n\n\n\n一\n1946~1957\n电子管\n40, 000\n\n\n二\n1958~1964\n晶体管\n200, 000\n\n\n三\n1965~1971\n中、小规模集成电路\n1, 000, 000\n\n\n四\n1972~1977\n大规模集成电路\n10, 000, 000\n\n\n五\n1978~现在\n超大规模集成电路\n100, 000, 000\n\n\n\n\n摩尔定律\n​        集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。\n​        微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。\n​        摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。\n1.3 计算机系统的层次结构1.3.1 计算机系统的基本组成（一） 计算机硬件\n\n冯·诺依曼计算机\n\n​        冯·诺依曼在研究EDVAC计算机时提出了 “存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯•诺依曼计算机，其特点如下：\n\n采用“存储程序”的工作方式。\n\n计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。\n\n指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。\n\n指令和数据均用二进制代码表示。\n\n指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。\n\n\n\n\n计算机的功能部件\n\n\n存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。\n运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。\n控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。\n输入设备：用来输入原始数据和程序，如键盘、鼠标。\n输岀设备：用来输出计算机的处理结果，如显示器和打印机。\n\n​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。\n（二） 计算机软件\n\n软件的分类\n\n​        软件按其功能分类，可分为系统软件和应用软件。\n\n三个级别的计算机语言\n\n（1） 机器语言\n​        机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。\n（2） 汇编语言           \n​        汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。\n（3） 高级语言\n​        高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。\n​        由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：\n\n汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。\n解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。\n编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。\n\n1.3.2 计算机硬件的基本结构​        典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。\n\n现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。\n\n图中各部件的功能是：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；\n存储器用来存放数据和程序；\n控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；\n输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。\n\n​        由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I/O设备(Input/Output equipment) 。\n​        这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I/O设备叫作外部设备。\n\n\n主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。\nALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。\nCU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。\n\n​        ALU和CU是CPU的核心部件。I/O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。\n1.3.3 计算机系统的多级层次结构​        从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：\n\n​    从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.4 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M0 与传统机器 M1，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为虚拟机器，包括操作系统机器 M2、汇编语言机器 M3 和高级语言机器 M4。简单来说，虚拟机器就是由软件实现的机器。\n​        相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。\n1.3.5 计算机系统的工作原理1. 从源程序得到可执行程序​        用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：\n\n（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。\n​    （2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。\n​    （3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。\n​    （4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。\n2. 存储程序的基本思想​        “存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。\n\n\n程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；\n将PC的内容作为地址访问主存，取出指令；\n在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；\n当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。\n\n​        这样，计算机就可以周而复始地自动执行程序中的每一条指令了。\n3. 计算机硬件组成的细化说明\n​    （1）主存储器\n​        主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”存储字长“。\n​        主存中的每个存储单元有一个唯一的编号，叫做存储单元的”地址“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。\n​        为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。\n\nMAR（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。\nMDR（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。\n\n​    （2）运算器\n​        运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。\n\nACC： Accumulator，累加器；\nMQ： Multiplier-Quotient Register，乘商寄存器；\nX： 操作数寄存器\n\n​        这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：\n\n\n\n\n\n加法\n减法\n乘法\n除法\n\n\n\n\nACC\n被加数及和\n被减数及差\n乘积高位\n被除数及余数\n\n\nMQ\n——\n——\n乘数及乘积低位\n商\n\n\nX\n加数\n减数\n被乘数\n除数\n\n\n\n\n​        不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。\n​    （3）控制器\n​        控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。\nPC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。\nIR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。\n​        CU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。\n​    （4）I/O\n​        I/O 系统包括各种 I/O 设备及其相应的接口。每一种 I/O 设备都由 I/O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。\n4. 计算机硬件的工作过程​        总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：\n\n把程序和数据装入主存储器；\n从程序的起始地址运行程序；\n按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；\n用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。\n\n​        我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：\n​    （1）取指令： PC → MAR → M → MDR → IR\n​        根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。\n​    （2）分析指令： OP（IR） → CU\n​        指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。\n​    （3）执行指令：Ad（IR） → MAR → M → MDR → ACC\n​        取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。\n​    （4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC\n1.4 计算机性能指标1.4.1 主要性能指标\n机器字长\n\n​        机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。\n​        字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。\n\n指令字长：一条指令中包含的二进制代码的位数。\n存储字长：一个存储单元中存储的二进制代码的长度。\n\n​        指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。\n\n数据通路带宽\n\n​        数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。\n\n存储容量\n\n​        存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。\n​        主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。\n​                                                存储容量 = 存储单元个数 × 存储字长\n​        在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 216 = 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K=1024）；而如果 MDR 为32位， 那么主存的存储容量为 216 × 32 = 221 = 2Ｍ 位（1Ｍ=220）。\n​        现代计算机中常以字节的个数来描述容量的大小，一个字节（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 218 字节（Byte，简写为 B）表示，记作 218 B 或 256KB。\n​        同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G = 1KM = 230 ）。\n\n运算速度\n\n​        计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。\n1.5.2 专业术语解释​    吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。\n​    响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I/O操作等的时间）。\n​    主频（CPU 时钟频率）：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。\n​    CPU 时钟周期：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。\n​                                                            CPU 时钟周期 = 1 / 主频\n​    CPI：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。\n​    CPU 执行时间：运行一个程序所花费的时间。\n​                                                CPU 执行时间 = （指令数 × CPI）/ 主频\n​        对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。\n​        现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。\n​        MIPS：Million Instructions Per Second，每秒执行百万条指令的数目。\n​                                                            MIPS = 主频 /（CPI × 106）\n​        FLOPS：FLoating-point Operations Per Second，每秒执行浮点运算的次数。\n​        MFLOPS：百万次浮点运算每秒。 MFLOPS = 浮点操作次数 /（执行时间 * 106）\n​        GFLOPS：十亿次浮点运算每秒。 GFLOPS = 浮点操作次数 /（执行时间 * 109）\n​        TFLOPS：万亿次浮点运算每秒。 TFLOPS = 浮点操作次数 /（执行时间 * 1012）\n​        PFLOPS：千万亿次浮点运算每秒。 PFLOPS = 浮点操作次数 /（执行时间 * 1015）\n​        EFLOPS：百京次浮点运算每秒。 EFLOPS = 浮点操作次数 /（执行时间 * 1018）\n​        ZFLOPS：十万京次浮点运算每秒。 ZFLOPS = 浮点操作次数 /（执行时间 * 1021）\n​        需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB =  210 B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb/s = 103 b/s。\n1.5 章节练习一、单项选择题\n【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。\n\n​        A. 指令操作码的译码结果                B. 指令和数据的寻址方式\n​        C. 指令周期的不同阶段                    D. 指令和数据所在的数据单元\n​    答案： C\n\n【2015真题】计算机硬件能够直接执行的是 （  ）。\n\n​        I. 机器语言程序    II. 汇编语言程序    III. 硬件描述语言程序\n​        A. 仅 I             B. 仅 I、II            C. 仅 I、III            D. I、II、III\n​    答案： A\n\n【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。\n\n​        A. 汇编程序            B. 链接程序            C. 编译程序            D. 解释程序\n​    答案： C\n\n【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。\n\n​        A. 程序的功能都通过中央处理器执行指令实现            B. 指令和数据都用二进制表示，形式上无差别\n​        C. 指令按地址访问，数据都在指令中直接给出            D. 程序执行前，指令和数据需预先存放在存储器中\n​    答案： C\n\n【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。\n\n​        I. ALU        II. 指令寄存器        III. 通用寄存器        IV. 浮点寄存器\n​        A. 仅 I、II            B. 仅 I、III            C. 仅 II、III            D. 仅 II、III、IV\n​    答案： B\n\n【2010真题】下列选项中，能缩短程序执行时间的是（  ）。\n\n​        I. 提高 CPU 时钟频率    II. 优化数据通路结构    III. 对程序进行编译优化\n​        A. 仅 I 和 II            B. 仅 I 和 III            C. 仅 II 和 III            D. I、II、III\n​    答案： D\n\n【2011真题】下列选项中，描述浮点数操作速度的是（  ）。\n\n​        A. MIPS                    B. CPI                    C. IPC                    D. MFLOPS\n​    答案： D\n\n【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I/O 时间。若 CPU 速度提高 50%，I/O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。\n\n​        A. 55s                B. 60s                C. 65s                D. 70s\n​    答案： D\n\n【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。\n\n\n\n\n\n指令类型\n所占比例\nCPI\n\n\n\n\nA\n50%\n2\n\n\nB\n20%\n3\n\n\nC\n10%\n4\n\n\nD\n20%\n5\n\n\n\n\n​        该机的 MIPS 是 （  ）。\n​        A. 100                B. 200                C. 400                D. 600\n​    答案： C\n\n【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。\n\n​        A. 8.4s                B. 11.7s                C. 14s                D. 16.8s\n​    答案： D\n\n【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。\n\n​        A. 0.4                B. 0.625                C. 1.6                D. 2.5\n​    答案： C\n二、综合应用题\n说明机器字长、指令字长、存储字长的区别和联系。\n\n​    答案：\n​        机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。\n​        指令字长：一个指令字中包含二进制代码的位数。\n​        存储字长：一个存储单元存储二进制代码的长度。\n​        它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。\n\n用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 I）。\n|      指令类型      | CPI  | 指令混合比 || :————————: | :—: | :————: ||     算术和逻辑     |  1   |    60%     ||        转移        |  4   |    12%     || 高速缓存命中的访存 |  2   |    18%     || 高速缓存失效的访存 |  8   |    10%     |\n\n\n​    答案：\n​        CPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：\n​                        CPI = 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% = 0.6 + 0.48 + 0.36 +0.8 = 2.24\n​        MIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：\n​                                                    MIPS = 40 × 106 /（2.24 × 106 ）≈ 17.9\n​        程序的执行时间 T = 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：\n​                        T = CPI × 时钟周期 × 指令条数 = 2.24 ×（1 / 40MHz）× I = 5.6 × 10-8 × I  秒\n​        \n\n第二章 数据的表示和运算2.1 本章大纲要求与核心考点2.1.1 大纲内容（一）数制与编码\n\n进位计数制及其数据之间的相互转换\n定点数的表示和运算\n\n（二）运算方法和运算电路\n\n基本运算部件：加法器、算数逻辑部件（ALU）\n加/减运算：补码加/减运算器，标志位的生成\n乘/除运算：乘/除运算的基本原理，乘法电路和除法电路的基本结构\n\n（三）整数的表示和运算\n\n无符号整数的表示和运算\n有符号整数的表示和运算\n\n（四）浮点数的表示和运算\n\n浮点数的表示：IEEE 754标准\n浮点数的加/减运算\n\n2.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n真值、机器数，定点数的表示及原理\nC 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换\nALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法\nIEEE 754标准浮点数的表示和特点，浮点数的加/减运算方法\nC 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换\n数据按边界对齐方式的存储，数据按大端和小端方式存储\n\n2.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          定点数的表示与运算\n          10\n          8\n      \n      \n          IEEE 754标准浮点数，浮点数的运算\n          10\n          3\n      \n      \n          C语言中各种数据的转换\n          3\n          2\n      \n      \n          数据按边界对齐方式的存储，数据按大小端方式存储\n          4\n          0\n      \n  \n\n\n\n\n\n\n2.2 数制与编码2.2.1 进位计数制及其相互转换（一）进位计数制\n​        进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为基数；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。\n​        下表是十进制数、二进制数、十六进制数对照表。\n​        书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)16；八进制数后面加上“O”，如372O或(372)8；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)2。\n​                                        十进制数、二进制数、八进制数、十六进制数对照表\n\n\n\n\n十进制数\n二进制数\n八进制数\n十六进制数\n十进制数\n二进制数\n八进制数\n十六进制数\n\n\n\n\n0\n00000\n0\n0\n16\n10000\n20\n10\n\n\n1\n00001\n1\n1\n17\n10001\n21\n11\n\n\n2\n00010\n2\n2\n18\n10010\n22\n12\n\n\n3\n00011\n3\n3\n19\n10011\n23\n13\n\n\n4\n00100\n4\n4\n20\n10100\n24\n14\n\n\n5\n00101\n5\n5\n21\n10101\n25\n15\n\n\n6\n00110\n6\n6\n22\n10110\n26\n16\n\n\n7\n00111\n7\n7\n23\n10111\n27\n17\n\n\n8\n01000\n10\n8\n24\n11000\n30\n18\n\n\n9\n01001\n11\n9\n25\n11001\n31\n19\n\n\n10\n01010\n12\nA\n26\n11010\n32\n1A\n\n\n11\n01011\n13\nB\n27\n11011\n33\n1B\n\n\n12\n01100\n14\nC\n28\n11100\n34\n1C\n\n\n13\n01101\n15\nD\n29\n11101\n35\n1D\n\n\n14\n01110\n16\nE\n30\n11110\n36\n1E\n\n\n15\n01111\n17\nF\n31\n11111\n37\n1F\n\n\n\n\n​        计算机系统为什么要采用二进制？\n\n使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。\n二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。\n二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。\n\n\n（二）不同进制数的相互转换\n​        任意一个数 N，可以用 r 进制表示成下面的形式：\n​                                            N =（dn-1dn-2 … d1d0.d-1d-2 … d-m）\n​                                                = dn-1rn-1 + dn-2rn-2 + … + d1r1 + d0r0 + d-1r-1 + d-2r-2 + … + d-mr-m\n​                                                = ∑ diri\n​        其中，r 为基数；d 为系数，di 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；ri 叫做第 i 位上的权值。n、m 分别代表 N 的整数部分和小数部分的位数。\n（1）二进制和八进制、十六进制间的转换\n​        将二进制数1110011101.0010111转换为八进制数为：\n​                                                左侧补0                  分界点                右侧补0\n​                                                   ↓                         ↓                   ↓\n​                                                001 110 011 101 .  001 011 100\n​                                                 1       6     3      5  .    1      3      4\n​        所以 (1110011101.0010111)2 = (1635.134)8 ；\n​        同样道理，转换为十六进制数为：\n​                                                0011 1001 1101 .  0010 1110\n​                                                    3        9        D   .     2        E\n​        所以 (1110011101.0010111)2 = (39D.2E)16 ；\n\n二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。\n二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。\n八进制转换为二进制：每位都转换成对应的3位二进制数。\n十六进制转换为二进制：每位都转换成对应的4位二进制数。\n\n（2）任意进制数转换为十进制数\n​        任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 按权展开法。\n​        例如，将二进制数 11011.101 转换为十进制数为：\n​        (11011.101)2  = 1 × 24 + 1 × 23 + 0 × 22 + 1 × 21 + 1 × 20 + 1 × 2-1 + 0 × 2-2 + 1 × 2-3\n​                            = 27.625\n​        另一种方法是“按基数重复相乘/除法”，需要分整数部分和小数部分分别转换。\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n（3）十进制数转换为二进制数\n​        将十进制数转换为二进制数，一般采用 基数乘除法。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。\n\n整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）\n\n小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）\n\n\n​        例如，将十进制数 123.6875 转换为二进制数。\n​        整数部分：\n​          除2得商                            余数\n​        2 |123                …                1                最低位\n​          2  |61               …                1\n​           2 |30               …                0\n​           2 |15               …                1\n​            2  |7               …                1\n​            2  |3               …                1\n​            2  |1               …                1                最高位\n​            2  |0\n​        所以 (123)10 = (1111011)2\n​        小数部分：\n​          乘积取小数                                乘2得积                取整数部分\n​            0.6875                × 2                = 1.375                        1                        最高位\n​            0.375                  × 2                = 0.75                           0        \n​            0.75                    × 2                = 1.5                             1    \n​            0.5                      × 2                 = 1                                1                        最低位    \n​        所以 (0.6875)10 = (0.1011)2\n​        综合整数和小数部分，得到 (123.6875)10 = (1111011.1011)2\n​        另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：\n​        十进制数                位权                转换后的结果\n​            123                                            26    25    24    23    22    21    20\n​        ➖ 64                        26                1\n​              59\n​        ➖ 32                        25                        1\n​              27\n​        ➖ 16                        24                                1\n​              11\n​        ➖   8                        23                                        1\n​                3\n​        ➖   2                        21                                                        1\n​                1\n​        ➖   1                        20                                                                1\n​                0\n​        所以 (123)10 = (1111011)2 \n​        这种方法一般在转换很大的十进制数时比较方便。\n2.2.2 真值和机器数​        在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。\n​        对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。\n例如，一个有符号的小数：\n​                + 0.1011                在机器中表示为        0    1 0 1 1\n​                -  0.1011                在机器中表示为        1    1 0 1 1\n再比如，一个有符号的整数：\n​                + 1100                    在机器中表示为        0    1 1 0 0\n​                -  1100                    在机器中表示为        1    1 1 0 0\n​        把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。\n\n真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。\n机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。\n\n​        在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即定点表示和浮点表示。\n​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。\n​        在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。\n2.2.3 定点数及其编码表示​        小数点固定在某一位置的数为定点数，有以下两种格式。\n\n当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。\n​        在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。\n1. 无符号整数的表示​        当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 28-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。\n2. 带符号数的表示​        最高位用来表示符号位，而不再表示数值位。\n（1）定点整数\n​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。\n​        约定小数点在有效数值部分最低位之后。数据 x = x0x1x2…xn （其中 x0 为符号位，x1 ~ xn 是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：\n\n（2）定点小数\n​        约定小数点在有效数值部分最高位之前。数据 x = x0.x1x2…xn（其中 x0 为符号位，x1~xn 是尾数，x1 是最高有效位），在计算中的表示形式如下图所示：\n\n3. 原码、补码、反码和移码\n原码表示法\n\n​        用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:\n\n式子中 x 为真值，[ x ]原 表示原码机器数。\n​        类似，纯整数的原码定义如下：\n\n​    原码的性质：\n\n由符号位与数的绝对值组成，符号位是0为正、1为负\n\n0有 ±0 两个编码，即 [+0]原 = 00000 和 [-0]原 = 10000 \n\n\n\n补码表示法\n\n​        纯整数的补码定义为：\n\n​    这里 n 为整数的位数，真值 x 和补码机器数 [ x ]原 互为以 2n+1 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2n ≤ x ≤ 2n - 1，比原码多表示了一个数 -2n。\n​        补码的性质：\n\n补码和其真值的关系：[x]补 = 符号位 × 2n+1 + x\n0的编码唯一，因此整数补码比原码多1个数，表示 -2n\n符号位参与补码加减运算，统一采用加法操作实现\n将 [x]补 的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能\n\n​        例如，当 x = + 1010 时（n = 4），\n​        [x]补 = 0, 1010\n​        而当 x = - 1010 时，\n​        [x]补 = 2n+1 + x = 100000 - 1010 = 1, 0110\n​        补码和真值的转换：\n\n真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。\n补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。\n\n​        变形补码是采用双符号位的补码表示法，其定义为\n\n​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。\n\n反码表示法\n\n​        负数的补码可采用“数值位各位取反，末位加1”的方法得到，如果数值位各位取反而末位不加1，那么就是负数的反码表示。正数的反码定义和相应的补码（或原码）表示相同。\n​        反码表示存在以下几个方面的不足：0的表示不唯一（即存在±0）；表示范围比补码少一个最小负 数。反码在计算机中很少使用，通常用作数码变换的中间表示形式。\n​        原码、补码、反码三种编码表示总结如下：\n\n三种编码的符号位相同，正数的机器码相同。\n\n原码和反码的表示在数轴上对称，二者都存在 ±0 两个零。\n\n补码的表示在数轴上不对称，0的表示唯一，补码比原码和反码多表示一个数。\n\n负数的反码、补码末位相差1。\n\n\n\n原码很容易判断大小。而负数的补码和反码很难直接判断大小，可采用这条规则快速判断：对于一个负数，数值部分越大，它的绝对值就越小，所以真值就越大（更靠近0）。\n\n\n移码表示法\n\n​        移码是在真值 x 上加上偏置值 2n 构成的，相当于 x 在数轴上向正方向偏移了若干单位。\n\n​    移码定义为:\n\n移码的性质：\n\n0的表示唯一， [+0]移 =  2n + 0 = [-0]移 = 2n - 0 = 100…0 \n符号位“1”表示正，“0”表示负，这与其他机器数正好相反。\n一个真值的移码和补码仅差一个符号位，[x]补 的符号位取反即得 [x]移，反之亦然。\n移码全0时，对应真值的最小值- 2n ；移码全1时，对应真值的最大值 2n -1。\n保持了数据原有的大小顺序，移码大真值就大，便于进行比较操作。\n移码常用来表示浮点数的阶码。它只能表示整数。\n\n2.2.4  C 语言中的整型数据类型\nC 语言中的整型数据简介\n\n​        C 语言中的整型数据就是定点整数，一般用补码表示。根据位数的不同，可以分为 字符型(char)、短整型(short)、整型(int)、长整型(long)。\n​        C 语言中的整型数据，可以分为 无符号整型 和 有符号整型 两种类型，在定义时只要加上 signed/unsigned 就可以明确指定了。\n​        char 是整型数据中比较特殊的一种，其他如 short/int/long 等都默认是带符号整数，但 char 默认是无符号整数。无符号整数（unsigned short/int/long）的全部二进制位均为数值位，没有符号位，相当于数的绝对值。\n​        signed/unsigned 整型数据都是按补码形式存储的，在不溢出条件下的加减运算也是相同的，只是 signed 型的最高位代表符号位，而在 unsigned 型中表示数值位，而这两者体现在输出上则分别是％d 和％u。\n\n有符号数和无符号数的转换\n\n​        C 语言允许在不同的数据类型之间做类型转换。C 语言的强制类型转换格式为“TYPE b = (TYPE) a”, 强制类型转换后，返回一个具有TYPE类型的数值，这种操作并不会改变操作数本身。\n​        先看由 short 型转换到 unsigned short 型的情况。考虑如下代码片段：\n123short x = -4321;unsigned short y = (unsigned short)x;\n​        执行上述代码后，x = -4321, y = 61215，得到的 y 似乎与原来的 x 没有一点关系。不过将这两个数转化为二进制表示时，我们就会发现其中的规律。\n​        通过本例可知：强制类型转换的结果是保持每位的值不变，仅改变了解释这些位的方式。有符号数转化为等长的无符号数时，符号位解释为数据的一部分，负数转化为无符号数时数值将发生变化。同理，无符号数转化为有符号数时，最高位解释为符号位，也可能发生数值的变化。\n\n不同字长整数之间的转换\n\n​        另一种常见的运算是在不同字长的整数之间进行数值转换。\n​        先看长字长变量向短字长变量转换的情况。考虑如下代码片段：\n123int x = 165537, u = -34991;                      //int型占用4字节short y = ( short )x, v = ( short )u;            //short型占用2字节\n​        执行上述代码后，x= 165537, y=-31071, u =-34991, v = 30545。x、y、u、v 的十六进制表示分别 是0x000286a1 0x86a1 . 0xffff7751、0x7751。由本例可知：长字长整数向短字长整数转换时，系统把多余的高位部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。\n​        最后来看短字长变量向长字长变量转换的情况。考虑如下代码片段:\n1234567short x = -4321;int y = (int)x;unsigned short u = (unsigned short)x;unsigned int v = (unsigned int)u;\n​        执行上述代码后，x = -4321, y = -4321, u = 61215, v = 61215。x、y、u、v 的十六进制表示分别是0xef1f. 0xffffef1f、0xef1f、0x0000ef1f。所以，短字长整数向长字长整数转换时，仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用 0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。其实两种方式扩展的高位部分都可理解为原数字的符号位。\n​        从位值与数值的角度看，前3个例子的转换规则都是保证相应的位值相等，而短字长到长字长的转换可以理解为保证数值的相等。\n\n2.3 运算方法2.3.1 定点数的移位运算​        移位运算根据操作对象的不同，可以分为算术移位和逻辑移位。算术移位针对的是有符号数，逻辑移位针对的是机器码，可以看作无符号数。\n1. 算术移位​        算术移位的对象是有符号数，有符号数在计算机中采用补码表示。算术移位的特点是，移位后符号位保持不变；空出的位置根据正负和左右移位的情况，决定补 0 还是 1。\n\n对于正数，由于 [ x ]原 = [ x ]补 = 真值，因此移位后的空位均补 0。\n对于负数，算术左移时，高位移出，低位补 0；算术右移时，低位移出，高位补 1。\n\n​        可见，不论是正数还是负数，移位后其符号位均不变。\n​        例如，假设机器字长为 8，[4]补 = 0000 0100，[-4]补 = 1111 1100；\n\n将 4 算术左移一位，就得到了 0000 1000 = [8]补；算术右移一位，就得到了 0000 0010 = [2]补；\n\n将 -4 算术左移一位，就得到了 1111 1000 = [-8]补；算术右移一位，就得到了 1111 1110 = [-2]补；\n\n\n​        对于有符号数，左移一位若不产生溢出，相当于乘以2 （与十进制数左移一位相当于乘以10类似）; 右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。\n2. 逻辑移位​        逻辑移位不考虑符号位。\n​        移位规则：逻辑左移时，高位移出，低位补 0；逻辑右移时，低位移岀，高位补 0 。\n2.3.3 定点数的加减运算​        加减法运算是计算机中最基本的运算，由于减法可以看成是负值的加法，因此计算机中使用补码表示有符号数之后，可以将减法运算和加法运算合并在一起讨论。\n1. 补码的加减运算​        补码加减运算的规则简单，易于实现。补码加减运算的公式如下（设机器字长为 n）：​                                                                [A + B]补 = [A]补 + [B]补  (mod 2n)​                                                                [A - B]补 = [A]补 + [-B]补  (mod 2n)\n​        补码运算的特点如下：\n\n按二进制运算规则运算，逢二进一。\n如果做加法，两数的补码直接相加；如果做减法，则将被减数加上减数的机器负数。\n符号位与数值位一起参与运算，加、减运算结果的符号位也在运算中直接得出。\n最终将运算结果的高位丢弃，保留 n 位，运算结果也是补码。\n\n​        例如，假设机器字长为 8 （n = 8），那么\n​        [5]补 = 0000 0101，[4]补 = 0000 0100；\n​        [-5]补 = 1111 1011，[-4]补 = 1111 1100；\n​        [5 + 4]补 = 0000 0101 + 0000 0100 = 0000 1001 = [9]补；\n​        [5 - 4]补 = [5 + (-4)]补 = 0000 0101 + 1111 1100 = 1 0000 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0000 0100 + 1111 1011 = 1111 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1111 1011 + 1111 1100 = 1 1111 0111 = [-9]补；\n2. 溢出判别方法​        溢出 是指运算结果超出了数的表示范围。通常，大于能表示的最大正数称为正上溢，小于能表示的最小负数称为负上溢。仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。\n​        在之前的例子中，如果假设机器字长为 4（n = 4），能表示的有符号数范围为 -8 ~ 7，那么就有：\n​        [5]补 = 0101，[4]补 = 0100；\n​        [-5]补 = 1011，[-4]补 = 1100；\n​        [5 + 4]补 = 0101 + 0100 = 1001 = [-7]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 0101 + 1100 = 1 0001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 0100 + 1011 = 1111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 1011 + 1100 = 1 0111 = [7]补；        （负溢出）\n​        补码加减运算的溢出判断方法有以下 3 种：\n（1）采用一位符号位。\n​        参加操作的两个数符号相同，结果又与原操作数符号不同，就表示结果溢出。\n​        一正一负相加必然不会溢出；两正数相加得到一个负数（符号位为1），则正溢出；两负数相加得到一个正数，则负溢出。\n（2）采用双符号位。\n​        运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位就代表真正的符号。也就是说，符号位 S1S2 = 00 表示结果为正数，无溢出； S1S2 = 11 表示结果为负数，无溢出。 S1S2= 01 表示结果正溢出； S1S2 = 10 表示结果负溢出。溢出标志 OF = S1 ㊉ S2。\n​        比如上例中，如果采用双符号位，机器字长就应该扩展为 5，那么：\n​        [5]补 = 00 101，[4]补 = 00 100；\n​        [-5]补 = 11 011，[-4]补 = 11 100；\n​        [5 + 4]补 = 00 101 + 00 100 = 01 001 = [1]补；        （正溢出）\n​        [5 - 4]补 = [5 + (-4)]补 = 00 101 + 11 100 = 1 00 001 = [1]补；\n​        [4 - 5]补 = [4 + (-5)]补 = 00 100 + 11 011 = 11 111 = [-1]补；\n​        [-5 - 4]补 = [-5 + (-4)]补 = 11 011 + 11 100 = 1 10 111 = [-1]补；        （负溢出）\n2.2.4 定点数的乘法运算1. 原码一位乘法​        原码乘法运算的符号位与数值位分开计算。\n\n确定乘积的符号位。由两个乘数的符号进行异或运算得到。\n计算乘积的数值位。两个乘数的数值部分之积，可看作两个无符号数的乘积。\n\n​        原码一位乘法的基本思路，就是类似竖式乘法的做法，让被乘数 x 分别乘以乘数 y 的每一位，然后再做叠加。不过竖式乘法需要做连加运算，这在电路实现上会有一些困难；改进的做法是，借鉴进制转换的“重复相乘/除法”，对每一位进行迭代计算。\n​        回忆一下二进制数转换成十进制数的重复相乘/除法：\n​        整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：\n​        (11011)2  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27\n​        小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：\n​        (0.101)2  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625\n​        所以，两数相乘时，就可以把乘数 y 用这种方式按每一位拆开，并乘以 x 、再逐位叠加就可以了。由于每次乘以 2 就相当于左移一位、除以 2 就相当于右移一位，因此只需要反复迭代这样的 移位 和 加法 运算就可以很容易地实现乘法了。\n\n原码一位乘法的运算规则如下：\n\n被乘数和乘数均取绝对值|x| 和 |y|参加运算，看作无符号数，符号位为 x0 ㊉ y0。\n乘数的每一位 yi 乘以被乘数 |x| 得到 |x| · yi，将该结果与前面所得的结果相加，作为部分积；初始值为 0。\n从乘数的最低位 yn 开始判断：若 yn = 1，则部分积加上被乘数 |x|，然后右移一位；若 yn = 0，则部分积加上 0，然后右移一位。\n重复上一步骤，判断 n 次。\n\n​        由于参与运算的是两个数的绝对值，因此运算过程中的右移操作均为逻辑右移。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 0.1011 = (0.6875)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 0.1101 × 0.1011 =  0.10001111 = (0.55859375)10\n\n2. 补码一位乘法​        带符号数的乘法，采用相加/相减的校正操作，直接计算补码数据的乘积。\n​        补码乘法是直接对补码进行的。对于纯整数，补码表达为：\n\n而类似的，纯小数补码定义为：\n\n所以，当取不同的正负符号时，补码表达会有所不同，继而影响到逐位相乘叠加的效果。\n​        已知 [ x ]补 = x0 . x1x2…xn，[ y ]补 = y0 . y1y2…yn，那么需要分不同的情况讨论：\n​        ① 被乘数 x 和乘数 y 符号均为正，即 x0 = y0 = 0 时，\n​        [ x ]补 = x，[ y ]补 = y，所以就有：\n\n类似原码一位乘法，利用移位和加法的叠加，就可以计算出补码的乘积；这也就是最终计算结果的补码。\n​        ② 被乘数 x 为正，乘数 y 为负，即 x0 = 0，y0 = 1 时，\n​        [ y ]补 = 1. y1y2…yn = 2 + y，所以：\n\n那么两数的乘积就可以写成：\n\n这样一个计算结果，它的补码表示为：\n\n​    可以看到，当乘数为负时，可以把乘数补码 [ y ]补 直接去掉符号位，当成一个正数与 [ x ]补 相乘；得到的结果再加上 [ -x ]补 进行校正。所以这种方法也叫做“校正法”。\n\n​        例如，当 x = 0.1101 = (0.8125)10，y = 1.1011 = (-0.3125)10 时，计算 x · y。\n​        我们可以直接计算 0.1101 × 0.1011 = 0.10001111，再加上 [ -x ]补 = 1. 0011，得到 ：\n​         0.10001111 + 1. 0011 = 1.10111111 =  ( -0.25390625 )10\n\n​        ③ 被乘数 x 为负，乘数 y 为正，即 x0 = 1，y0 = 0 时，\n​        我们可以交换被乘数和乘数，直接按情况②来处理；也可以仔细分析，发现乘数 y 为正数，可以写成\n[ y ]补 = 0. y1y2…yn 的形式，同样可以借鉴情况②中的分析和原码一位乘的方法。当两数的补码相乘时：\n\n观察可以发现，与原码一位乘完全类似，补码相乘也可以将乘数展开，逐位进行相乘、右移和叠加。不过需要注意的是，这时由于被乘数 x 是负数，右移时就需要在左侧高位补 1，也就是做算术右移、而不是逻辑右移。\n​        这样一来，算术右移就实现了对真值 x 的“除以 2”操作，最终叠加之后的结果，就是 x · y 的补码了。\n​        例如，当 x = 1.1 = (-0.5)10，y = 0.011 = (0.375)10 时，计算 x · y。\n\n最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1 × 0.011 =  1.1101 = ( - 0.1875 )10        \n​        ④ 被乘数 x 和乘数 y 符号均为负，即 x0 = y0 = 1 时，\n​        通过情况②和③的分析可以看出，当乘数 y 为正时，可以直接按照原码一位乘的方式进行补码乘法，注意需要进行算术右移；而当乘数 y 为负时，则可以先不考虑 y 的符号位，同样按照原码一位乘进行补码乘法，最后的结果要再加上 [ -x ]补 进行校正。\n​        例如，当 x = 1.1 = (-0.5)10，y = 1.011 = (-0.625)10 时，计算 x · y。\n​        我们可以直接计算 1.1 × 0.011 =  1.1101，再加上 [ -x ]补 = 0.1，得到 ：\n​        1.1101 + 0.1 = 1 0.0101 =  ( 0.3125 )10\n​        可以看出，如果使用双符号位来表示正负，会更加方便。\n​        ⑤  Booth算法\n​        以上的 4 种情况需要分别讨论，根据乘数的符号来决定是否需要进行校正。\n​        如果不考虑操作数的符号，直接用统一的规则来处理所有情况，可以采用 Booth 算法。\n​        当被乘数 x 和乘数 y 符号任意时，按照之前讨论的校正法规则，可以写出一个统一的计算公式：\n\n​    容易推出，对于纯小数，在 mod 2 的前提下，[ -x ]补 = - [ x ]补，所以可以进一步推导得到：\n\n​    令 yn+1 = 0，那么就可以得到一个通项系数： di = yi+1 - yi ，上式可以进一步化简为：\n\n这样一来，补码乘法的计算方式就跟原码一位乘完全一样了，只是被乘数每次乘的不再是乘数 y 的每一位 yi，而是变成了 di = yi+1 - yi 。这样就有 1、-1 和 0 三种情况，每一次计算都由 di 来决定部分积叠加的是 [ x ]补、[ -x ]补 还是 0；然后再做一位算术右移得到新的部分积。最后一步，需要由 d0 = y1 - y0 决定是否有叠加项，但不再做位移。\n​        Booth 算法的移位规则如下表所示：\n\nBooth 算法的具体运算规则如下：\n①    符号位参与运算，运算的数均以补码表示。\n②    被乘数一般取 双符号位 参与运算，部分积取 双符号位，初值为 0，乘数取单符号位。\n③    乘数末尾增加一个“附加位” y~n+l~，初始值为 0。\n④    根据（yi，yi+1）的取值来确定操作，如上表所示。\n⑤    移位按补码右移规则（算术右移）进行。\n⑥    按照上述算法进行 n + 1 步操作，但第 n + 1 步不再移位，仅根据 y0 （符号位）与 y1 （第一位数值位）的比较结果做相应的叠加运算。所以总共需要进行 n + 1 次累加和 n 次右移。\n\n​        例如，当 x = 1.1101 = (-0.1875)10，y = 1.1011 = (-0.3125)10  时，计算 x · y。\n​        首先得到 [x]补 = 11.1101，[-x]补 = 00.0011。具体计算步骤如下：\n\n同样，最终的乘积，高位在“部分积”中，低位在“当前乘数”中，所以得到：\n​         x · y = 1.1101 × 1.1011 =  0.00001111 = (0.05859375)10\n2.2.5 定点数的除法运算1. 原码一位除法（1）恢复余数法\n​        恢复余数法的特点是：当余数为负时，需要加上除数的绝对值，将其恢复成原本的余数。\n​        由于每次得到的是商的高位，所以每轮计算可以将余数和商同时左移一位；余数加上 [- y]补 ，判断正负来决定下一位商是 1 还是 0；如果为负，还需要先加上 [y]补 恢复余数，然后再做左移。\n\n​        例如，当 x = (-0.1011)2  = (-0.6875)10，y = (-0.1101)2 = (-0.8125)10 时，计算 x / y。\n​        首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x = 0.1011，y= 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x/ y = 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n溢出判断：当该位为 1 时，表示当前除法溢出，不能进行；当该位为 0 时，当前除法合法，可以进行。\n（2）不恢复余数法（加减交替法）\n​        在恢复余数法中，每当余数为负时都需要恢复余数，这就增加了运算量，操作也不规则，电路实现会比较复杂。加减交替法就克服了这一缺点。\n​        加减交替法 又称 不恢复余数法，是对恢复余数法的一种改进。\n​        通过分析恢复余数法可以发现，如果把第 i 轮计算的余数记作 Ri，那么：\n\n如果 Ri &gt; 0，就上商 1，接下来需要将余数 Ri 左移一位，再减去除数绝对值 y，即 2Ri - y；\n如果 Ri &lt; 0，就上商 0，接下来先加上 y 恢复余数，再做左移和减法，即 2 (Ri + y) - y = 2Ri + y。\n\n​        这样一来，就不需要额外恢复余数了，每轮计算的规则完全统一起来，只是左移之后再加/减 y^*^ 就可以了；所以把这种方法叫做“加减交替法”，或者“不恢复余数法”。\n\n​        还是上面的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        同样的步骤，首先看出，商的符号为正，余数的符号为负。并且得到：\n​        x= 0.1011，y = 0.1101，[y]补 = 0.1101，[-y]补 = 1.0011\n​        具体计算过程如下：\n\n所以商值为 x / y= 0.1101；而余数由于经过了 4 次左移，所以最终还应该做 4 次右移才是真正的余数：0.0111 * 2-4 = 0.00000111，另外还要注意余数符号为负，所以最终结果为：\n​        x / y = 0.1101（商）… - 0.00000111（余数）\n2. 补码一位除法（加减交替法）\n补码一位除法的运算规则如下：\n\n符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。\n如被除数与除数同号，则被除数减去除数；如被除数与除数异号，则被除数加上除数。\n余数与除数同号，商上1，余数左移一位再减去除数；余数与除数异号， 商上 0，余数左移一位再加上除数。\n重复执行上一步操作，操作 n 次。\n如果对商的精度没有特殊要求，一般采用“末位恒置 1”法。\n\n​    同样的例子，当 x = (-0.1011)2  ，y = (-0.1101)2 时，计算 x / y。\n​        首先得到： [x]补 = 1.0101，[y]补 = 1.0011，[-y]补 = 0.1101\n​        具体计算过程如下：\n\n所以商值为\n​        x / y = 0.1101\n2.4 浮点数的表示和运算2.4.1 浮点数的表示浮点数 就是小数点的位置可以浮动的数。例如：\n​        365.242 = 3.65242 × 10^2^\n​                       = 365242.0 × 10^-3^\n​                       = 0.365242 × 10^3^\n1. 浮点数的表示格式​        在计算机中，浮点数的格式如下图所示。采用这种数据格式的机器称为 浮点机。\n\n​    浮点数由 阶码 j 和 尾数 S 两部分组成。\n\n阶码是纯整数，阶符和阶码值合起来决定了小数点的实际位置；阶码值的位数 m 再结合阶符，可以反映浮点数的表示范围。\n尾数是纯小数，数符 Sf代表了浮点数的正负，而尾数值则是有效数位，位数 n 反映了浮点数的精度。\n\n2. 浮点数的表示范围​        假设浮点数 N 的阶码 j 数值部分有 m 位，尾数 S 数值部分有 n 位。\n​        阶码是纯整数，尾数是纯小数，它们可以各自选择编码方式。对于非规格化的浮点数，如果阶码和尾数都用原码表达，各自的取值范围如下：\n\n​        那么阶码 j 和尾数 S 组合之后，能表示的浮点数最大范围就是：\n\n在数轴上表示出来，如下图所示：\n\n原码是关于原点对称的，所以浮点数的表示范围也是关于原点对称的。\n​        当运算结果大于能表示的最大正数时，称为正上溢；小于最小负数时。称为负上溢：两者统称 上溢。由于尾数的溢出可以通过移位、增加阶码来调整，因此上溢的本质就是 阶码大于最大阶码，这时机器会停止计算，进行中断溢出处理。\n​        当运算结果在 0 至最小正数之间时，称为正下溢；在 0 至最大负数之间时，称为负下溢，统称 下溢。同样道理，下溢的本质是 阶码小于最小阶码，这时溢出的数值绝对值非常小，通常可以将尾数各位直接强置为 0，按 ”机器零“ 来处理，机器可以继续正常运行。\n​        类似地，如果阶码和尾数都用补码表达，各自的取值范围如下：\n\n​    用移码来表示阶码方便进行阶数的比较和对齐，简称 “对阶”。这在进行浮点数加减运算时非常重要，尾数只有在阶数相同的时候才能做加减，采用移码直接比较两个阶码的二进制大小关系就可以了：\n\n3. 浮点数的规格化​        由于规格化数的精度最高，所以当一个非零的浮点数不是规格化数时，应该通过左右移动尾数、并同时修改阶码的方法，将它转换为规格化数。把一个非规格化数转换成规格化数的过程，叫做 规格化。\n​        规格化的本质类似于 “科学计数法” 的表达，通过保证尾数最高数位上是一个有效值，尽可能多地保留有效数字的尾数，从而提高精度。\n​        规格化可以分为 “左规” 和 “右规” 两种。以基数 r = 2 为例：\n\n左规：向左规格化。当运算结果尾数的最高数位不是有效位，即出现 0.0…01… 的形式时，需要向左规格化。左规时，尾数左移一位，阶码减 1；\n右规：向右规格化。当运算结果尾数的小数点左侧出现有效位，即整数部分不为 0 时，需要向右规格化。右规时，尾数右移一位，阶码加 1；需要右规时，只需进行一次。\n\n​        当基数不同时，规格化的原则会有相应的改变。比如，当基数 r = 4 时，阶码每次加/减 1，就相当于多乘/除以 4，也就是左/右移 2 位。所以左规就是尾数左移 2 位，阶码减 1；右规是尾数右移 2 位，阶码加 1。尾数的最高 2 位不全为 0 的数，就是规格化数。\n\n4. IEEE 754 标准浮点数​        在现代计算机中，浮点数的格式一般采用 IEEE 制定的国际标准。IEEE 754 标准规定的浮点数形式为：\n\n\nS 为数符，直接表示浮点数的正负，它与尾数所表示的有效数位是分开的。\n阶码 E 包含了阶符，用移码来表示，不过这里移码的偏移量不是 2 的整次幂，而是要再减去 1。 假设阶码 E 的位数为 m + 1，那么偏移量就是 2^m - 1。\n尾数 M 是原码表示的纯小数。\n\n​        浮点数的位数不同，可以表示不同的数值范围和精度。IEEE 标准中常用的浮点数有三种：短浮点数（单精度）、长浮点数（双精度）和临时浮点数（延伸双精度）。\n\n​    以 32 位的单精度浮点数为例，所有的机器码和对应的取值范围如下：\n\n\n​    例如，对于十进制数 178.125，把它写成 IEEE 标准的短浮点数。\n​        我们需要分整数部分和小数部分，首先转换成二进制数的表示；然后写成类似 “科学计数法” 的二进制浮点数表达。\n\n​    这是一个正数，符号位为 0；然后从二进制浮点表达中得到阶码和尾数。将 8 位二进制阶码加上偏移量 127，尾数隐藏整数位的 1 后补成 23 位，就是最终符合 IEEE 标准的 32 位短浮点数。\n\n​    \n2.4.2 浮点数的加/减运算​    （1）对阶\n​        对阶的目的是使两个操作数的小数点位置对齐，使两个数的阶码相等。先求阶差，然后以 “小阶向大阶看齐” 的原则，将阶码小的尾数右移一位（基数为2），阶码加1，直到两个数的阶码相等为止。\n​    （2）尾数求和\n​        将对阶后的尾数，按定点数加/减运算规则运算。\n​    （3）规格化\n​        IEEE 754 规格化尾数的形式为 ±1.×…×，所以当计算结果为非规格化数时，需要进行规格化处理。\n\n左规：当结果为 ±0.0…01x…x 时，需进行左规。尾数每左移一位，阶码减 1。可能需要左规多次，直到将第一位 1移到小数点左边。\n右规：当结果为 ±1x.x…x 时，出现了尾数的溢出，需进行右规。尾数右移一位，阶码加 1。当尾数右移时，最高位 1 被移到小数点前一位作为隐藏位；当最后一位移出时，要考虑舍入。\n\n​        左规一次相当于乘以2，右规一次相当于除以2；需要右规时，只需进行一次。\n​    （4）舍入\n​        在对阶和尾数右规时，尾数右移可能会将低位丢失，影响精度，IEEE 754有以下4种舍入方式：\n\n就近舍入：舍入为最近的那个数，类似于 “四舍五入”，一般被叫做 “ 0 舍 1 入” 法；如果被舍入的值恰好是 100…0 形式，选择舍入为最近的偶数；\n正向舍入：向 +∞ 方向舍入，即取右边那个数，也叫 “向上舍入”；\n负向舍入：向 -∞ 方向舍入，即取左边那个数，也叫 “向下舍入”；\n截断：朝 0 方向舍入，即取绝对值较小的那个数。\n\n​    （5）溢出判断\n​        浮点数的溢出，并不是以尾数溢岀来判断的；尾数溢出可以通过右规操作得到纠正。运算结果是否溢出，主要看结果的指数是否发生了溢出，因此是由阶码来判断的。\n\n若一个正阶码超出了最大允许值（127 或 1023），则发生上溢，产生异常；\n若一个负阶码超出了最小允许值（-149 或 -1074），则发生下溢，通常把结果按机器零处理。\n\n\n​        例如，两个数 x = 29/32 × 210，y = 5/8 × 25，用浮点加法计算 x + y。假设浮点数的阶码和尾数均用补码表示，且阶码为 5 位（含 2 位阶符），尾数为 7 位（含 2 位数符）。\n​        首先，将浮点数写成下面的规格化二进制形式：\n​        x = 0.11101 × 2111，y = 0.101 × 2101\n​        具体计算过程如下：\n​        （1）对阶\n​        阶码相减 00, 111 - 00, 101 = 00, 010，说明 x 的阶码比 y 的大 2，需要将 y 的尾数右移两位，阶码加 2：\n​        y = 0.00101 × 2111\n​        （2）尾数求和\n​        尾数相加 00.11101 + 00.00101 = 01.00010\n​        （3）规格化\n​        运算结果的尾数出现溢出，需要进行右规：尾数右移一位，阶码加 1：\n​        1.00010 × 22111 = 0.100010 × 221000，即计算结果为 01, 000; 00, 10001\n​        （4）舍入\n​        结果的尾数用补码表示为：00 10001，不需要舍入。\n​        （5）溢出判断\n​        结果的阶码用补码表示为：01 000，由于阶符为 01，说明结果溢出。\n\n2.5 数据的存储和排列2.5.1 数据按“边界对齐”方式存储​        可以假设字长为 32 位，可按字节、半字、字寻址。在对准边界的 32 位计算机中，半字地址是 2 的整数 倍，字地址是 4 的整数倍，当所存数据不满足此要求时，可填充一个或多个空白字节。这种存储方式称为 “边界对齐” 。这样无论所存的数据是字节、半字还是字，均可一次访存取出。虽然浪费了一些存储空间，但可提高存取速度。\n​        数据不按边界对齐方式存储时，半字长或字长的数据可能在两个存储字中，此时需要两次访存，并对高低字节的位置进行调整后才能取得所需数据，从而影响系统的效率。\n\n\n在 C 语言的 struct 类型中，边界对齐方式存储有两个重要要求：\n​        （1）每个成员按其类型的方式对齐，比如 char 类型的对齐值为 1，short 为 2，int 为 4（单位为字节）。\n​        （2）struct 的长度必须是成员中最大对齐值的整数倍（不够就补空字节），以便在处理 struct 数组时保证每项都满足边界对齐的条件。\n​        例如，下面是两个成员完全一样的结构体：\n12345678910struct A &#123;\tint i;\tchar c;\tshort s;&#125;struct B &#123;\tchar c;\tint i;\tshort s;&#125;\n​        但两者在内存中占据的空间却不同。这是因为结构体成员是按定义的先后顺序排列的，编译器要使它们在空间上对齐，所以应该有：\n​        每个成员存储的起始地址 ％ 该成员的长度 = 0\n​        同时，还需要让结构体的长度是最大成员长度的整数倍。\n\n2.5.2 数据的“大端方式”和“小端方式”存储​        在存储数据时，通常用 最低有效字节（LSB）和 最高有效字节（MSB）来分别表示数据的低位和高位。例如，在 32 位机器中定义了一个 int 类型的变量 i，机器数为 18 0B C5 F3H，那么它的 MSB = 18H，LSB = F3H。\n​        现代计算机基本都采用字节编址，也就是每个地址编号对应存放 1 个字节。不同类型的数据占用的字节数不 同，而程序中对每个数据只给定一个地址。变量 i 占据连续的四个字节，它们各有一个内存地址，而变量 i 的地址就是开始的那个字节的地址。假设 i 的地址为 6C 00H，那么 i 具体存放的四个字节的地址就是：6C 00H、6C 01H、6C 02H、6C 03H。而具体每个字节存放什么内容，可以有不同的定义方式。\n​        多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，分为两种排列方式：大端方式（big endian）和 小端方式（little endian）。\n\n\n大端方式：先存储高位字节，后存储低位字节。高位字节存储在低位地址中，字中的字节顺序和原序列相同。\n\n\n小端方式：先存储低位字节，后存储高位字节。低位字节存储在低位地址中，字中的字节顺序和原序列相反。\n\n2.6 章节练习一、单项选择题​    1. 【2018真题】冯·诺伊曼结构计算机中的数据采用二进制编码表示，其主要原因是（  ）。\n​        I. 二进制的运算规则简单                II. 制造两个稳态的物理器件较容易\n​        III. 便于用逻辑门电路实现算术运算\n​        A. 仅 I、II                B. 仅 I、III                C. 仅 II、III                D. I、II 和 III\n​        答案： D\n\n【 2015真题】由 3个“1”和 5个“0”组成的8位二进制补码，能表示的最小整数是  （   ）。\n\n​        A． -126                B． -125                C． -32                D． -3\n​        答案：B\n\n【2022真题】32 位补码所能表示的整数范围是    （   ）。\n\n​        A. -232~231-1         B. -231~231-1         C. -232~232-1         D. -231~232-1 \n​        答案：B\n\n【2021真题】已知带符号整数用补码表示，变量 x、y、z 的机器数分别为 FFFDH、FFDFH、7FFCH，下列结论中，正确的是    （   ）。\n\n​        A. 若x、y和z为无符号整数,则z&lt;x&lt;y        B. 若x、y和z为无符号整数,则x&lt;y&lt;z\n​        C. 若x、y和z为带符号整数,则x&lt;y&lt;z        D. 若x、y和z为带符号整数,则y&lt;x&lt;z\n​        答案：D\n​    5. 【2016真题】有如下 C 语言程序段 \n12short si = -32767;unsigned short usi = si;\n​        执行上述两条语句后， usi 的值为     （   ）。\n​        A． -32767         B． 32767         C． 32768         D． 32769 \n​        答案：D\n​    6. 【2019真题】考虑以下 C 语言代码： \n12unsigned short usi = 65535;short si = usi;\n​        执行上述程序段后， si 的值是     （   ）。 \n​        A．-1         B．-32767         C．-32768         D．-65535 \n​        答案：A\n​    7. 【2012真题】假定编译器规定 int 和 short 型长度分别为 32 位和 16 位，执行下列 C 语言语句： \n12unsigned short x=65530;unsigned int y=x;\n​        得到 y 的机器数为     （   ）。\n​        A． 0000 7FFAH       B． 0000 FFFAH         C． FFFF 7FFAH         D． FFFF FFFAH\n​        答案：B\n\n【2009真题】一个 C 语言程序在一台 32 位机器上运行。程序中定义了三个变量 x、 y 和 z，其中 x 和 z 为 int 型， y 为 short 型。当 x=127， y=-9 时，执行赋值语句 z=x+y 后， x、 y 和 z 的值分别是 （   ）。\n\n​    A． x=0000007FH， y=FFF9H， z=00000076H            B． x=0000007FH， y=FFF9H， z=FFFF0076H​    C． x=0000007FH， y=FFF7H， z=FFFF0076H            D． x=0000007FH， y=FFF7H， z=00000076H \n​    答案：D\n​    9. 【2018真题】整数x的机器数为1101 1000，分别对x进行逻辑右移1位和算术右移1位操作，得到的机器数各    是    （   ）。\n​    A.1110 1100、1110 1100                B. 0110 1100、1110 1100\n​    C.1110 1100、0110 1100                D. 0110 1100、 01101100\n​    答案：B\n\n【2013真题】某字长为 8 位的计算机中，已知整型变量 x、y的机器数分别为$[x]_补=1 {\\quad} 1110100，[y]补=1 {\\quad}0110000$。若整型变量 $z=2*x+y/2$，则 z 的机器数为    （   ）。\n\n​    A.  1 1000000            B.  0 0100100            C.  1 0101010            D.  溢出\n​    答案：A\n\n【2018真题】假定带符号整数采用补码表示，若 int 型变量 x 和 y 的机器数分别是 FFFF FFDFH 和 0000 0041H，则 x、y 的值以及 x-y 的机器数分别是    （   ）。\n\n​    A.x=-65，y=41，x-y 的机器数溢出                                B.x=-33，y=65，x-y 的机器数为FFFF FF9DH\n​    C.x=-33，y=65，x-y 的机器数为FFFF FF9EH                D. x = -65，y = 41，x-y 的机器数为FFFF FF96H \n​    答案：C\n\n【2016真题】某计算机字长为 32 位，按字节编址，采用小端（Little Endian）方式存放数据。假定有一个 double 型变量，其机器数表示为 1122 3344 5566 7788H，存放在 0000 8040H 开始的连续存储单元中，则存储单元 0000 8046H 中存放的是     （   ）。\n\n​    A． 22H                     B． 33H                     C． 66H                     D． 77H \n​    答案：A\n\n【2018真题】某32位计算机按字节编址，采用小端(Little Endian)方式。若语句 “inti=0;” 对应指令的机器代码为 “C7 45 FC 00 00 00 00”，则语句 “int i = -64;” 对应指令的机器代码是    （   ）。\n\n​    A.C7 45 FC C0 FF FF FF        B.C7 45 FC 0C FF FF FF        C.C7 45 FC FF FF FF C0        D.C7 45 FC FF FF FF 0C\n​    答案：A\n\n【2012真题】某计算机存储器按字节编址，采用小端方式存放数据。假定编译器规定 int 型和 short型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下： \n\n123456struct&#123;\tint a;\tchar b;\tshort c;&#125; record;record.a=273;\n​        若 record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址分别为     （   ）。\n​    A. 0x00、 0xC00D         B. 0x00、 0xC00E        C. 0x11、 0xC00D         D. 0x11、 0xC00E \n​    答案：D\n\n【2020真题】在按字节编址，采用小端方式的 32 位计算机中，按边界对齐方式为以下 C语言结构型变量a分配存储空间。\n\n1234Struct record&#123;\tshort   x1;\tint   x2;&#125; a;\n​        若a的首地址为 2020 FE00H，a的成员变量x2的机器数为1234  0000H，则其中34H所在存储单元的地址是    （   ）。\n​    A. 2020 FE03H                B. 2020 FE04H                C.2020 FE05H                D. 2020 FE06H\n​    答案：D\n\n【2012真题】 float 类型（即 IEEE754 单精度浮点数格式）能表示的最大正整数是     （   ）。\n\n​    A． 2126-2103               B． 2127-2104               C． 2127-2103               D． 2128-2104\n​    答案：D\n\n【2013真题】某数采用 IEEE 754 单精度浮点数格式表示为C640 0000H，则该数的值是    （   ）。\n\n​    A. $-1.5×2^{13}$                B. $-1.5 × 2^{12}$                C. $-0.5×2^{13}$                D. $-0.5×2^{12}$\n​    答案：A\n\n【2014真题】ﬂoat 型数据常用 IEEE 754 单精度浮点格式表示。 假设两个 ﬂoat 型变量 x 和 y 分别存放在32位寄存器 f1 和 f2 中，若(f1)=CC90 0000H, (f2)= B0C0 0000H, 则 x 和 y 之间的关系为    （   ）。\n\n​    A. xy且符号相同           D. x&gt;y且符号不同\n​    答案：A\n\n【2015真题】下列有关浮点数加减运算的叙述中，正确的是    （   ）。Ⅰ ．对阶操作不会引起阶码上溢或下溢Ⅱ ．右规和尾数舍入都可能引起阶码上溢Ⅲ．左规时可能引起阶码下溢Ⅳ．尾数溢出时结果不一定溢出\n\n​    A．仅Ⅱ 、 Ⅲ                 B． 仅Ⅰ 、 Ⅱ 、 Ⅳ                C．仅Ⅰ 、 Ⅲ、 Ⅳ                D． Ⅰ 、 Ⅱ 、 Ⅲ、 Ⅳ \n​    答案： D\n\n【2018真题】IEEE 754 单精度浮点格式表示的数中，最小的规格化正数是    （   ）。\n\n​    A.1.0x2-126                    B. 1.0x2-127                    C.1.0x2-128                    D.1.0x2-149\n​    答案：A\n\n【2020真题】已知带符号整数用补码表示，float 型数据用 IEEE 754 标准表示，假定变量 x 的类型只可能是 int 或 float，当 x 的机器数为 C800 0000H时，x 的值可能是    （   ）。\n\n​    A.-7x227                        B.-216                        C. 217                        D. 25x227\n​    答案：A\n\n【2021真题】下列数值中,不能用 IEEE 754 浮点格式精确表示的是    （   ）。\n\n​    A.1.2                                B.1.25                                C.2.0                                    D.2.5\n​    答案：A\n\n【2022真题】-0.4375 的 IEEE 754 单精度浮点数表示为（ ）。\n\n​    A. BEE0 0000H             B. BF60 0000H             C. BF70 0000H             D. C0E0 0000H \n​    答案：A\n二、综合应用题\n【2020真题】有实现 x*y 的两个 C 语言函数如下:\n\n12unsigned umul (unsigned x, unsigned y)&#123;return x*y; &#125;int imul (int x,int y) &#123;return x* y;&#125;\n​    假定某计算机 M 中 ALU 只能进行加运算和逻辑运算。请回答下列问题。\n​    （1）若 M 的指令系统中没有乘法指令，但有加法、减法和位移等指令，则在 M 上也能实现上述两个函数中的乘法运算，为什么?\n​    （2）若 M 的指令系统中有乘法指令，则基于 ALU、位移器、寄存器以及相应控制逻辑实现乘法指令时，控制逻辑的作用是什么?\n​    （3）针对以下三种情况：a）没有乘法指令；b）有使用ALU和位移器实现的乘法指令；c）有使用阵列乘法器实现的乘法指令，函数 umul() 在哪种情况下执行时间最长？哪种情况下执行的时间最短？说明理由。\n​    （4）n 位整数乘法指令可保存 2n 位乘积，当仅取低 n 位作为乘积时，其结果可能会发生溢出。当 n=32、x=231-1、y=2 时，带符号整数乘法指令和无符号整数乘法指令得到的 x*y 的 2n 位乘积分别是什么（用十六进制表示）？此时函数 umul() 和 imul() 的返回结果是否溢出？对于无符号整数乘法运算，当仅取乘积的低 n 位作为乘法结果时，如何用 2n 位乘积进行溢出判断？\n​    答案：\n​    （1）编译器可以将乘法运算转换为一个循环代码段，在循环代码段中通过比较、加法、移位等指令实现乘法运算。\n​    （2）控制逻辑的作用为： 控制循环次数，控制加法和移位操作。\n​    （3）a）最长， c）最短。\n​        对于 a）， 需要用循环代码段（软件）实现乘法操作，因而需反复执行很多条指令， 而每条指令都需要取指令、译码、取数、执行并保存结果，所以执行时间很长； 对于 b）和 c）， 都只要用一条乘法指令实现乘法操作，不过， b）中的乘法指令需要多个时钟周期才能完成，而 c）中的乘法指令可以在一个时钟周期内完成， 所以 c）执行时间最短。\n​    （4）当 n=32、 x=231-1、 y=2 时，带符号整数和无符号整数乘法指令得到的 64 位乘积都为 0000 0000 FFFF FFFEH。\n​        函数 imul 的结果溢出，而函数 umul 结果不溢出。对于无符号整数乘法，若乘积高 n 位全为 0， 则不溢出，否则溢出。\n【2017真题】 已知\n\n计算 f(n) 的 C 语言函数 f1 如下： \n12345678int f1(unsigned n)&#123;\tint sum=1, power=1;\tfor(unsigned i=0;i&lt;=n-1;i++)&#123;\t\tpower *= 2;\t\tsum += power;\t&#125;\treturn sum;&#125;\n​        将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位， float 采用 IEEE 754 单精度标准。请回答下列问题。\n​    （1）当 n=0 时， f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为什么？\n​    （2）f1(23) 和 f2(23) 的返回值是否相等？机器数各是什么（用十六进制表示）？\n​    （3）f1(24)和 f2(24)的返回值分别为 33 554 431 和 33 554 432.0， 为什么不相等？\n​    （4）f(31)=232-1， 而 f1(31) 的返回值却为 -1，为什么？若使  f1(n) 的返回值与 f(n) 相等，则最大的 n 是多少？\n​    （5）f2(127) 的机器数为 7F80 0000H， 对应的值是什么？若使 f2(n) 的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？ \n​        答案：\n​    （1）由于 i 和 n 是 unsigned 型，故“i&lt;=n-1”是无符号数比较； n=0 时， n-1 的机器数为全1，值是 232-1，为 unsigned 型可表示的最大数，条件“i&lt;=n-1”永真，因此出现死循环。\n​        若 i 和 n 改为 int 类型，则不会出现死循环。因为“i&lt;=n-1”是带符号整数比较， n=0 时， n-1 的值是-1，当 i=0 时条件“i&lt;=n-1”不成立，此时退出 for 循环。\n​    （2）f1(23)与 f2(23)的返回值相等。\n​        f(23) = 223+1-1 = 224-1，它的二进制形式是 24 个1。 int 占 32 位，没有溢出。 float 有 1 个符号位， 8 个指数（阶码）位， 23 个底数（尾数）位， 23 个底数位可以表示 24 位的底数。所以两者返回值相等。\n​        f1(23)的机器数是 00FF FFFFH；f2(23)的机器数是 4B7F FFFFH。显而易见前者是 24 个 1，即 0000 0000 1111 1111 1111 1111 1111 1111（2），后者符号位是 0，指数位为 23+127(10) = 1001 0110（2），底数位是 111 1111 1111 1111 1111 1111（2）。\n​    （3）当 n=24 时， f(24) = 1 1111 1111 1111 1111 1111 1111 B，而 float 型数只有 24 位有效位，舍入后数值增大，所以 f2(24) 比 f1(24) 大 1。\n​    （4）f(31) 已超出了 int 型数据的表示范围，用 f1(31) 实现时得到的机器数为 32 个 1，作为 int 型数解释时其值为-1，所以 f1(31) 的返回值为-1。 \n​        因为 int 型最大可表示数是 0 后面加 31 个 1，故使 f1(n)的返回值与 f(n)相等的最大 n 值是 30。\n​    （5） f2 返回值为 float 型，7F80 0000H 中数符为0，阶码全为1，尾数为0。IEEE 754 标准用“阶码全 1、尾数全 0”表示无穷大。所以机器数 7F80 0000H 对应的值是+∞。\n​        当 n=126 时， f(126) = 2127-1 = 1.1…1×2126，对应阶码为 127+126=253，尾数部分舍入后阶码加 1，最终阶码为 254，是 IEEE 754 单精度格式表示的最大阶码。故使 f2 结果不溢出的最大 n 值为 126。\n​        当 n=23 时， f(23) 为 24 位 1， float 型数有 24 位有效位，所以不需舍入，结果精确。所以使 f2 获得精确结果的最大 n 值为 23。\n第三章 存储器3.1 本章大纲要求与核心考点3.1.1 大纲内容（一）存储器的分类\n（二）层次化存储器的基本结构\n（三）半导体随机存储器\n\nSRAM 存储器\nDRAM 存储器\nFlash 存储器\n\n（四）主存储器\n\nDRAM 芯片和内存条\n多模块存储器\n主存和CPU之间的连接\n\n（五）外部存储器\n\n磁盘存储器\n固态硬盘（SSD）\n\n（六）高速缓冲存储器（Cache）\n\nCache 的基本工作原理\nCache 和主存之间的映射方式\nCache 中主存块的替换算法\nCache 写策略\n\n（七）虚拟存储器\n\n虚拟存储器的基本概念\n\n页式虚拟存储器\n基本原理，页表，地址转换，TLB（快表）\n\n段式虚拟存储器\n\n段页式虚拟存储器\n\n\n3.1.2 核心考点​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。\n​        需要重点掌握的内容包括：\n\n半导体存储芯片的特性、工作原理、扩展技术及与 CPU 的连接，多模块存储器的原理。\n磁盘存储器的原理、特点、性能指标，RAID 的原理，固态硬盘的特点和原理。\n程序访问的局部性原理，Cache 的工作原理及性能计算，Cache 和主存的三种映射方式的原理、 特点、地址结构、访存过程，Cache 替换算法（常考 LRU） , Cache 写策略，Cache 块中的标记项。\n虚拟存储器的基本原理，页表机制（二级页表结合操作系统考查），快表的原理，具有快表和 Cache 的多级页式存储系统的工作原理（综合性较强），段式和段页式虚拟存储器的基本原理。\n\n3.1.3 真题分布  \n      \n          考点\n          考查次数\n      \n      \n          单项选择题\n          综合应用题\n      \n      \n          高速缓冲存储器（Cache）\n          12\n          9\n      \n      \n          虚拟存储器\n          5\n          9\n      \n      \n          半导体存储器\n          6\n          1\n      \n      \n          主存的扩展及与 CPU 的连接\n          6\n          1\n      \n      \n          磁盘存储器\n          4\n          0\n           \n      \n          低位交叉存储器\n          2\n          1\n      \n  \n\n\n\n\n\n\n\n3.2 存储器概述3.2.1 存储器的分类​        \n\n1. 按存储介质分类​        存储介质是指能寄存“0”、“1”两种代码并能区别两种状态的物质或元器件。存储介质主要有半导体器件、磁性材料和光盘等。\n\n半导体存储器\n\n​        存储元件由半导体器件组成的存储器称为半导体存储器。现代半导体存储器都用超大规模集成电路工艺制成芯片，其优点是体积小、功耗低、存取时间短。\n​        半导体存储器又可按其材料的不同， 分为双极型（TTL）半导体存储器和 MOS 半导体存储器两种。前者具有高速的特点；后者具有高集成度的特点，并且制造简单，成本低廉，功耗小，所以 MOS 半导体存储器被广泛用。\n\n磁性材料存储器\n\n​        磁性材料存储器主要依靠磁性材料作为记录的介质，是不易失的永久记忆存储器。又可以分为磁表面存储器和磁芯存储器。\n​        磁表面存储器是在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作，故称为磁表面存储器。按载磁体形状的不同，可分为磁盘、磁带和磁鼓。\n​        磁芯是由硬磁材料做成的环状元件，在磁芯中穿有驱动线(通电流)和读出线，这样便可进行读/写操作，这种存储器称为磁芯存储器。磁芯属磁性材料，故它也。不过，磁芯存储器的体积过大、工艺复杂、功耗太大，目前几乎已不被采用。\n\n光盘存储器\n\n​        光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器，具有非易失性的特点。光盘具有记录密度高、耐用性好、可靠性高和可互换性强等特点。\n2. 按存取方式分类​        按存取方式可把存储器分为随机存储器、只读存储器、顺序存取存储器和直接存取存储器。\n\n随机存储器（Random Access Memory， RAM）\n\n​        RAM是一种可读/写存储器， 其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        由于存储信息原理的不同， RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充放电原理寄存信息）。\n\n只读存储器（Read Only Memory， ROM）\n\n​        只读存储器是能对其存储的内容读出，而不能对其重新写人的存储器。这种存储器一旦存入了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写人新的信息去改变原始信息。\n​        所以 ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n\n串行访问存储器\n\n​        如果对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址，则这种存储器称为串行访问存储器，也称为顺序存取存储器。显然这种存储器由于信息所在位置不同，使得读/写时间均不相同，比如磁带存储器就是一种顺序存取存储器。\n\n直接存取存储器\n\n​        还有一种属于部分串行访问的存储器，比如磁盘。在对磁盘读/写时，首先直接指出该存储器中的某个小区域(磁道)，然后再顺序寻访，直至找到位置。故其前段是直接访问，后段是串行访问，称为直接存取存储器。\n3. 按在计算机中的作用分类​        按在计算机系统中的作用不同，存储器可以分为主存储器、辅助存储器、缓冲存储器。\n\n主存储器（简称主存）：用来存放程序和数据，可以和CPU直接交换信息。\n\n辅助存储器（简称辅存）：主存储器的后援存储器， 用来存放当前暂时不用的程序和数据， 它不能与CPU直接交换信息。两者相比，主存速度快、容量小、每位价格高；辅存速度慢、容量大、每位价格低。\n\n缓冲存储器（简称缓存，Cache） 用在两个速度不同的部件之中。\n\n\n\n3.2.2 存储器的性能指标1.存储速度​    （1）存取时间\n​        要想衡量存储速度，最直观的指标就是完成一次存储器读/写操作所需要的时间，这叫做 存取时间，又称为 访问时间（Memory Access Time）。\n​        存取时间又分为读出时间和写入时间。读出时间是从存储器接受到有效地址开始，到产生有效输出所需的全部时间；写入时间是从存储器接受到有效地址开始，到数据写入被选中存储单元为止的全部时间。\n​    （2）存储器周期\n​        存储器周期 （Memory Cycle Time）指连续进行两次独立的存储器操作（读或者写）需要的最小时间间隔，也叫 存取周期。需要注意的是，存储器周期并不等同于完成一次读写操作的时间，而是要更大；因为存储器经过一次读写操作后，并不能立即进行下一次读写，中间还需要一段时间来恢复内部状态。所以，\n​                                                            存储器周期 = 存取时间 + 恢复时间\n​    （3）存储器带宽\n​        一般来说，存储器周期越短，存储器的速度就越快；这前提是存储器的每次读写操作处理的数据位数相同。通常情况下，存储器每次读写的位数是跟存储字长相关的，字长越长，一个存取周期处理的数据就越多。\n​        所以可以用 数据传输率 来表示存储速度，而 存储器带宽 就是衡量数据传输率重要指标。存储器带宽指单位时间内存储器存取的数据量。单位为位/秒（b/s），或者字节/秒（B/s）、字/秒。\n​                                                            存储器带宽 = 数据宽度 / 存储周期\n​        例如，存储器周期为 500 ns，每个存取周期可以访问 16 位，那么带宽就是：\n​                                                                16 bit ÷ 500 ns = 32 Mb/s\n2. 存储容量​        存储容量指存储器能存放的数据总量，一般用二进制代码的总位数（bit）来表示。\n​                                                    存储容量 = 存储字数 × 存储字长\n​        存储字数代表了存储器地址空间的大小，由地址线的位数决定。容量一般也可以用字节总数（Byte）来表示，也就是：\n​                                            存储容量（字节数） = 存储字数 × 存储字长 / 8\n​        例如，某机器存储字长为 8 位，地址线有 28 位，那么它的主存最大存储容量为：\n​                                                        2^28^ × 8 / 8 = 2^28^ B = 256 MB\n3. 位价​        每位价格也就是存储器的单位成本。\n​                                                    位价 = 总成本 / 总容量\n​        一般来说，速度越高，位价就越高；容量越大，位价就越低；而且容量越大，速度也会越低。\n3.2.3 层次化存储器的基本结构​        \n\n\n寄存器通常都制作在 CPU 芯片内。寄存器中的数直接在 CPU 内部参与运算， CPU 内可以有十几个、几十个寄存器，它们的速度最快，位价最高，容量最小。\n主存用来存放将要参与运行的程序和数据，它与 CPU 速度差距较大。\n为了使主存和 CPU 之间速度更好地匹配， 需要在主存与 CPU 之间插入一种比主存速度更快、容量更小的高速缓冲存储器 Cache，其位价要高于主存。\n\n\n\n缓存-主存层次\n\n​        这一层次主要解决 CPU 和主存速度不匹配的问题。由于缓存的速度比主存的速度高， 只要将CPU近期要用的信息调人缓存， CPU 便可以直接从缓存中获取信息， 从而提高访存速度。但由于缓存的容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换掉。主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。\n\n主存-辅存层次\n\n​        这一层次主要解决存储系统的容量问题。辅存的速度比主存的速度低，而且不能和 CPU 直接交换信息， 但它的容量比主存大得多， 可以存放大量暂时未用到的信息。当CPU需要用到这些信息时， 再将辅存的内容调人主存， 供CPU直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的。\n3.3 半导体存储器​        半导体存储器分为 随机存取存储器（RAM）和 只读存储器（ROM）。\n​        RAM 是一种可读/写存储器，其特点是存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。计算机系统中的主存都采用这种随机存储器。\n​        RAM 按照存储信息的原理不同，又可以分为静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM），主存储器主要由 DRAM 实现，靠近处理器的那一层缓存 （Cache）则由 SRAM 实现，它们都是易失性存储器。ROM 是非易失性存储器。\n\n主存中各个存储单元的空间位置，是由一个地址号来表示的；通过地址总线可以给定一个存储单元的地址号，从而根据地址读出或者写入一个存储字。\n\n译码驱动：将地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作。\n读/写电路：包括读出放大器和写入电路，用来完成读/写操作。\n\n​        存储芯片通过地址总线、数据总线和控制总线与外部连接。地址线和数据共同反映了芯片的存储容量。比如，10 根地址线，4 根数据线，表示芯片的存储容量为：2^10^ × 4 = 4 Kb。\n\n地址线是单向输入的，其位数与芯片存储容量有关。\n数据线是双向输入的，其位数与芯片每次可读出或写入的数据位数有关，从而也影响到存储容量。\n控制线包括了读/写控制线和片选线。读/写控制线决定芯片进行的具体操作，片选线用来选择芯片。\n\n\n半导体存储芯片的译码驱动，主要有两种方式：线选法 和 重合法。\n\n线选法：是用一根字选择线（字线），直接选中一个存储单元的各位。这种方式结构比较简单，不过只适合用于容量不大的存储芯片。\n\n采用线选法译码驱动的存储芯片结构示意图。这个芯片有 8 位地址线和 8 位数据线，所以有 28 = 256 个存储字，需要 256 根字线来实现选中每个存储字。\n\n\n重合法：用两个方向的地址，共同决定选中存储矩阵中的一个存储单元。相比 “一维” 的线选法，重合法就升级到了 “二维”，可以用更少的选择线实现对所有存储单元的选择。\n\n使用 X、Y 两个方向的地址译码器分别对 4 位地址进行译码，只需要两个方向各 16 根选择线，就可以直接选中 16 × 16 存储矩阵中的每一位。\n\n3.3.1 SRAM​        通常把存放一个二进制位的物理器件称为存储元，它是存储器最基本的构件。地址码相同的多个存储元构成一个存储单元。存储单元的集合构成存储体。\n​        静态 RAM（Static RAM，SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此信息被读出后，它仍保持其原状态而不需要刷新；这种读特性被称为“非破坏性读出”。\n\n下面是 Intel 2114 RAM 芯片的存储矩阵结构示意图。2114 芯片有 10 根地址线，其中 6 根行地址线、4 根列地址线，存储矩阵由 64 × 64 个基本单元电路组成，总容量为 1K × 4 位。\n\nSRAM 使用触发器工作原理存储信息，因此在读出信息后，它仍会保持原来的状态，不需要刷新。不过如果电源掉电，存储的信息就会丢失，所以它属于易失性半导体存储器。\n​        SRAM 的存取速度快，但集成度低，功耗较大，价格昂贵，一般用于 Cache。\n3.3.2 DRAM​        动态 RAM（Dynamic RAM，DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的。若电容上存有足够多的电荷表示存 “1”，电容上无电荷则表示存 “0”。\n​        常见的动态 RAM 基本单元电路有三管式和单管式两种。单管式只需要一个 MOS 管和一个电容，因此可以极大地提高集成度。\n\n可以看到，DRAM 的基本存储元可以只使用一个晶体管, 所以它比 SRAM 的密度要高很多。为了进一步提高集成度，DRAM 采用 地址复用技术，地址信号分行、列两次传送，这样地址线是原来的一半，地址引脚数也可以减少一半，就能够进一步减小芯片的体积。\n​        下面是 Intel 4116 RAM 芯片的整体结构和存储矩阵示意图。4116 芯片的存储矩阵为 128 × 128，共有 16 K 个单管 MOS 基本单元电路，容量为 16K × 1 位。本来芯片应该有 14 根地址线，不过为了减少芯片封装的引脚数，地址线只有 7 根。这就需要将完整的地址信息分成行地址、列地址两部分（各自 7 位），分两次传送。\n\n\n​        相对 SRAM 来说，DRAM 具有容易集成、价位低、容量大和功耗低等优点，但 DRAM 的存取速度比 SRAM慢，一般用于大容量的主存系统。\nDRAM 的刷新​        由于电容上的电荷一般只能维持1 ~2ms，因此即使电源不掉电，信息也会自动消失。为此，必须在 2ms 内对所有存储单元恢复一次原状态，这个过程称为 再生 或者 刷新。\n​        刷新的过程，实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。由于存储单元是被随机访问的，有些存储单元可能一直不会被访问，因此其存储的原信息将会慢慢消失。因此，必须进行定时刷新。一般要求在一定的时间内，对动态 RAM 的全部基本单元必须作一次刷新，这个时间称为 刷新周期，也叫 再生周期，一般取 2ms。\n​        通常有三种刷新方式：集中刷新、分散刷新和异步刷新。\n​    （1）集中刷新\n​        在规定的一个刷新周期内，对全部存储单元集中一段时间进行逐行刷新；刷新时必须停止读/写操作。\n​        例如，我们有一个芯片的存储矩阵为 128 × 128，它的存取周期为 0.5 μs，刷新周期为 2 ms（4000 个存取周期），那么对它的 128 行存储单元进行集中刷新需要：\n​                                                                        0.5 μs × 128 = 64 μs\n​        那剩余的 1936 μs（3872个存取周期）就可以用来读/写或者维持信息。由于在这 64 μs 内无法进行读/写操作，所以这段刷新时间被称为 “死时间”，也叫访存 “死区”。死时间占据存取周期的比例 64 μs / 2 ms × 100% = 3.2%，称为死时间率。\n\n2）分散刷新\n​        对每行存储单元的刷新，分散到每个存取周期内完成。这样，每个存储周期 tC 就分成了两段：前半段 tM用来读/写或者维持信息，后半段 tR 用来刷新。所以：\n​                                                                                    tM = tM + tR\n​        同样以 128 × 128 存储矩阵的芯片为例，读/写周期 tM = tR = 0.5 μs，那么存取周期 tC = 1 μs。逐行进行刷新，每隔 128 μs 就可以将存储芯片全部刷新一遍。\n\n这样的好处是不存在停止读/写操作的死时间，而且刷新间隔比要求的刷新周期 2ms 短得多；缺点在于存取周期 tC 变长了，使得整个系统速度变慢。 \n​    （3）异步刷新\n​        异步刷新是前两种方式的结合，它既可以缩短 “死时间”，又能充分利用最大的刷新间隔 2ms。\n​        还是之前的例子，对于 128 × 128 存储矩阵的芯片，存取周期 tC = 0.5 μs，可以让它把对 128 行的刷新平均分配到 2ms 的刷新周期内。也就是说，每隔 2ms ÷ 128 ≈ 15.6 μs 刷新一行，每次刷新的时间还是一个存取周期 tR = 0.5 μs。\n\n这样一来，2ms 内用于刷新的时间仍然是 128 tR = 64 μs，而由于分散到了整个刷新周期内，每次刷新一行只停了一个存取周期；所以对于每行来说，刷新的间隔还是 2ms，而 “死时间” 缩短为 0.5 μs。\n​        如果将 DRAM 的刷新安排在 CPU 对指令的译码阶段，由于这个阶段 CPU 不会访问存储器，所以这样就完全避免了 “死时间” 的问题，从根本上提高了机器效率。\nDRAM 和 SRAM 的比较​        目前，随着 DRAM 的容量不断扩大，速度不断提高，它的应用要比 SRAM 更加广泛。DRAM 主要用在计算机的主存中，而 SRAM 通常用于容量不大的高速缓存（Cache）中。\n​        两者的特点可以比较如下：\n\n3.3.3 ROM​        ROM （Read Only Memory）最原始的定义是 “只读存储器”，一旦写入原始信息后就不能更改。所以ROM 通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。\n​        不过随着用户的需要和技术的发展，又出现了更多类型的 ROM，让用户拥有了修改数据的能力。\n​        根据制造工艺不同，ROM 可分为固定掩模型 ROM（MROM）、一次可改写 ROM （PROM）、紫外线擦除电可编程 ROM（EPROM）、电擦除电可编程 ROM （EEPROM）、快擦写（Flash）存储器。\n​    \n​        SRAM、DRAM 和 ROM 这 3 种存储器的特点可以总结如下。\n\n3.4 主存储器3.4.1 主存储器的基本组成​        主存储器简称主存或内存，是计算机中存储程序和数据的重要部件。主存内包含了存储体、各种逻辑部件以及控制电路等。\n​        主存是通过按地址访问的方式，对存储体内的存储单元进行读写操作的。因此主存首先需要从 MAR 中获取地址，由译码器进行地址译码、再经过驱动电路，进而通过选择线选中所需访问的单元。读出时，需要经过读出放大器才能将被选中存储单元的内容送到 MDR；写入时，MDR 中的数据也需要经过写入电路才能真正存入被选中的单元。所以主存实际结构的基本组成如下：\n\n译码器、驱动器和读写电路都集成在 DRAM 存储芯片中，而 MAR 和 MDR 则集成在 CPU 芯片内。存储芯片可以通过总线与 CPU 相连。\n\n当要从主存中读某个数据字时，首先由 CPU 将字的地址送到 MAR，通过地址总线送至主存，然后发出读命令；主存的译码器将地址总线送来的地址译码，导通对应存储单元的选择线，收到读信号后，便将该单元的内容送到数据总线上，进而交给 MDR。\n​        如果要向主存写入一个数据字，仍然需要 CPU 先把地址送到 MAR，并把要写的数据送到 MDR，然后发出写命令；主存译码器依然从地址总线读取地址进行译码，接到写命令后，就把数据线上的信息写入对应的存储单元。\n主存中地址的分配​        主存中各存储单元的空间位置，都是由存储单元的地址号表示的；地址总线的作用就是给出要访问的存储单元的地址。每次访问存储单元，可以读出或者写入一个存储字。\n​        存储字长必须是字节（8位）的整数倍，不同机器的存储字长不同。计算机一般既可以按字来寻址，也可以按字节寻址。例如，一台机器的存储字长为 32 位，并且可以按字节寻址，那么它的每个存储字都包含了 4 个具有独立地址的字节，地址的分配方式如下：\n\n如果这台机器的地址线为 24 位，那么按字节寻址的范围是 2^24^ = 16M，按字寻址的范围为 16M / 4 = 4 M。\n3.4.2 主存和 CPU 之间的连接1. 主存容量扩展​        单片存储芯片的容量有限，所以主存需要将多个存储芯片连在一起扩展成更大的存储器。这称为 存储容量的扩展，主要的方法有 位扩展 和 字扩展。\n（1）位扩展\n​        位扩展是指对字长进行扩展，也就是增加存储字长。这种情况下，系统地址线位数等于芯片地址线位数，而系统数据线位数多于芯片数据线位数。\n​        位扩展的连接方式：各芯片的地址线、片选线和读写控制线与系统总线相应 并联；各芯片的 数据线单独引出，分别连接系统数据线。各芯片同时工作。\n​        以之前介绍过的 SRAM 芯片 2114 为例，它的存储容量为 1K × 4，那么用 2 片 2114 采用位扩展的方式可以组成 1K × 8 的存储器。如下所示：        \n\n（2）字扩展  \n​        字扩展是指对存储字的数量进行扩展，而存储字的位数满足系统要求。这种情况下，系统数据线位数等于芯片数据线位数，系统地址线位数多于芯片地址线位数。\n​        字扩展的连接方式：各芯片的地址线与系统地址线的 低位对应相连，芯片的数据线和读写控制线与系统总线相应 并联；由系统地址线的 高位译码 得到各芯片的片选信号。各芯片分时工作，同一时间只能有一个芯片被选中。\n​        例如，用 2 片容量为 1K × 4 的 2114 芯片，采用字扩展的方式可以组成 2K × 4 的存储器。如下所示：\n\n​    扩展之后的地址线为 11 位，共有 2^11^ = 2 K 个地址。其中：\n\n第一片 2114 的地址范围为 000 0000 0000 ~ 011 1111 1111；\n第二片 2114 的地址范围为 100 0000 0000 ~ 111 1111 1111。\n（3）字和位同时扩展\n\n\n​        字和位同时扩展是前两种扩展的组合，这种方式既增加存储字的数量，又增加存储字长。\n​        字和位同时扩展的连接方式：将进行位扩展的芯片作为一组，各组的连接方式与位扩展相同；由系统地址线高位译码产生若干个片选信号，分别接到各组芯片的片选信号。\n​        例如，用 8 片容量为 1K × 4 的 2114 芯片，字和位同时扩展之后可以组成 4K × 8 的存储器。如下所示：\n\n扩展之后的地址线为 12 位，共有 2212 = 4 K 个地址。其中：\n\n第一、二片 2114 通过位扩展构成第一组，地址范围为 0000 0000 0000 ~ 0011 1111 1111；\n第三、四片 2114 通过位扩展构成第二组，地址范围为 0100 0000 0000 ~ 0111 1111 1111；\n第五、六片 2114 通过位扩展构成第三组，地址范围为 1000 0000 0000 ~ 1011 1111 1111；\n第七、八片 2114 通过位扩展构成第四组，地址范围为 1100 0000 0000 ~ 1111 1111 1111。\n\n2. 主存与CPU的连接（1）合理选择存储芯片。通常选用 ROM 存放系统程序，选用 RAM 组成用户区。\n（2）地址线的连接。CPU 地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）；CPU 地址线的高位在扩充存储芯片时用，以选择存储芯片（片选）。\n（3）数据线的连接。比较CPU的数据线数与存储芯片的数据位数。如果相等可以直接相连；如果不等，必须对存储芯片进行扩位，使其数据位数与 CPU 的数据线数量相等。\n（4）读/写命令线的连接。CPU 的读/写命令线一般可以直接与存储芯片的读/写控制端相连。\n（5）片选线的连接。片选信号一般由系统地址线高位译码，它是主存与 CPU 连接的关键。\n3.4.3 多模块存储器1. 单体多字存储器​        在主存中，程序和数据是连续存放的，所以 CPU 访存取出的信息也是连续的。如果将存储器的存储单元进行扩展，让它能够存储更多的字，那么就可以在一个存取周期内，从同一地址取出更多的指令。将多条指令逐条送至 CPU 执行，由于 CPU 的速度远高于主存，这样就相当于增大了主存的带宽，提高了速度。\n​        这种方式是对单独的存储器进行了扩展，类似于位扩展的思路，不过是将一个地址对应的数据扩展到了多个存储字。所以这种结构的存储器称为 单体多字存储器。\n​        例如，对于一个单体四字存储器，可以在一个存取周期取出四个字的信息。假设指令字长就是一个存储字，那么原先一个存取周期拿到一条指令，现在就可以拿到 4 条；逐条传给 CPU 进行处理，就相当于每隔 1/4 周期，主存就向 CPU 传送了一条指令，带宽变成了 4 倍。\n\n\n结构特点：存储器中只有一个存储体，每个存储单元存储 m 个字，总线宽度也为 m 个字。\n访问方式：一次并行读出 m 个字，地址必须顺序排列并处于同一存储单元。\n\n优点：宽度为单体单字存储器的近 m 倍（访问的内容在同一行时）。\n\n缺点：如果出现访问冲突（需要的内容不在同一行）或遇到转移指令，效率会显著降低。\n\n2. 多体并行系统​        另一种思路是采用多模块组成存储器，各个模块可以并行读写，这就是多体并行系统。每个模块有相同的容量和存取速度，各模块都有自己独立的地址寄存器（MAR）、数据寄存器（MDR）、地址译码、驱动电路和读/写电路，它们能并行工作，也能交叉工作。\n​        所谓的 “并行工作”，就是 CPU 可以同时访问 N 个模块，同时启动，同时读出；当然，由于总线是公共的，同时读出的 N 个字需要在总线上分时传送。\n​        根据对这 N 个模块中存储单元的不同编址方式，多体并行系统又可以分为 多体高位交叉存储器 和 多体低位交叉存储器。\n（1）多体高位交叉存储器\n​        多体高位交叉存储器中，各模块采用 高位交叉方式编址。\n​        高位交叉方式编址时，地址分为两部分，高位地址表示体号，低位地址为体内地址。这种编址方式下，一个模块（也就是 “体”）内的地址是连续的，程序存储时会按照体内地址的顺序存放，也就是先存一个模块，存满之后再存下一个；所以这种方式也叫 “顺序存储”。\n\n只要调动合理，使不同的请求源同时去访问不同的模块，就可以实现并行工作。比如，CPU 在访问一个模块的同时，外部设备可以以直接存储器访问（DMA）的方式访问另一个模块，这样两个体就是并行工作的。\n（2）多体低位交叉存储器\n​        多体低位交叉存储器中，各模块采用 低位交叉方式编址。\n​        低位交叉编址是指用主存地址的低位来指明存储器模块，高位指明模块内的字地址。这种编址方式下，连续的地址分布在相邻的模块中，同一模块内的地址是不连续的，因此也叫做 “交叉存储”。有 M 个模块的低位交叉编址，又叫 模 M 编址。\n\n​       上面是一个模 4 交叉编址的存储器，存储体模块个数为 4，所以第一个模块中所有存储单元的地址号，对 4 取模都为 0；同样道理，第二、三、四个模块的地址号，对 4 取模结果分别为 1、2、3。具体的编址地址号如下所示：\n\n​        程序按照地址连续存放在相邻模块中，采用低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用 流水线 方式并行存取，提高存储器的带宽。\n​        在一个存取周期 T 内，m 个模块按一定的顺序分时启动；如果分时启动的时间间隔为 t = T/m，那么在一个存取周期内，CPU 交叉访问各个模块，从而使各模块的读/写操作交错重叠进行，最终向 CPU 可以传送 m 个字。这样，存储器的带宽提升为 m 倍。\n​        由于各个模块传送取出的字共享总线，因此假设总线传输周期为 τ，当 t 小于等于 τ 时，就可以获得最大的存储器带宽。所以：\n​                                                                                t = T/m ≤ τ\n​        所以，对于一个存取周期为 T、总线传输周期为 τ 的机器，设计多体低位交叉存储器时应该有 m ≥ T / τ。一般取最小值即可，在采用流水线方式时应该满足 \n​                                                                                    T = m τ\n​        对于四体低位交叉编址存储器 T = 4 τ，按流水线方式工作时不同模块访问字的时间顺序如下：\n\n​    可以看出，对于流水线工作的低位交叉存储器，连续读取 n 个字所需的时间为：\n​                                                                            t1 = T + ( n - 1 ) τ \n​        而如果是高位交叉存储器，对应的时间为：\n​                                                                                    t2 = n T\n​        对于上面的四字低位交叉存储器，τ = T / 4，所以 t1 = ( n + 3 ) T / 4，明显要低于 t2；当 n 非常大时，t1 趋近于 T / 4，即速度提升了 4 倍。\n3.5 外部存储器​        外部存储器是主存的后援设备，也叫做辅助存储器，简称 外存 或 辅存，与主存一起构成了存储器系统的主存-辅存层次。与主存相比，外存容量大、速度慢、价格低，可以脱机保存信息，属于 非易失性存储器。\n​        用于计算机系统的外存主要有磁盘、磁带、光盘；磁盘和磁带都属于 磁表面存储器。而目前广泛应用的 固态硬盘（SSD）主体由闪存芯片构成，属于半导体存储器。\n3.5.1 磁盘存储器​        磁盘是应用最为广泛的外存设备。磁盘根据结构和盘片材质的不同，可以分为 硬磁盘 和 软磁盘，如今随着存储技术的发展，软磁盘存储器已渐渐不再使用，而硬磁盘存储器依然在外存中占据着重要的比例。\n​        磁盘存储器具有外存设备普遍的优缺点：\n\n优点：存储容量大，位价低；记录介质可重复使用；记录信息可长期保存而不丢失, 甚至可脱机存档；非破坏性读出，读出时不需要再生。\n缺点：存取速度慢，机械结构复杂。\n\n1. 磁表面存储器和磁记录原理​        磁表面存储器在不同形状（盘状、带状）的载体上涂有磁性材料层，这磁层就是记录信息的存储介质。存储器工作时，依靠载体的机械运动，由磁头在磁层上进行读/写操作；信息就记录在磁层上，这些信息的轨迹叫做 磁道。磁盘的磁道是一个个同心圆，磁带的磁道则是一条条直线。\n\n磁记录原理：磁表面存储器在磁头和磁性记录介质做相对运动时，通过电磁转换完成读/写操作。\n磁记录方式：又称为编码方法，就是按某种规律把一连串的二进制信息转换成磁表面相应的磁化状态。通常采用调频制（FM）和改进型调频制（MFM）的记录方式。    \n\n\n2. 硬磁盘的分类和基本结构（1）硬磁盘存储器的类型\n​        硬磁盘中的存储载体是盘片，它是由硬质铝合金材料制成的，其表面涂有一层硬磁特性材料，可以被磁化从而完成信息的存储。通过磁头和盘片的相对运动，就可以实现信息的读取和写入。\n\n根据能否更换盘片，硬磁盘可以分为 可换盘磁盘 和 固定盘磁盘。\n\n​        可换盘磁盘的盘片可以脱机保存，所以更换的时候可以只换单片，方便维护和扩容；固定盘磁盘的盘片则不能从驱动器中取下，更换的时候需要整体更换，可靠性更高。\n\n按照磁头的工作方式，硬磁盘可以分为 固定磁头磁盘 和 移动磁头磁盘。\n\n\n\n固定磁头的磁盘存储器，磁头位置是固定不动的，磁盘上的每一个磁道都对应着一个磁头，盘片也不可以更换；这样省去了磁头在盘片上移动寻找磁道的时间，存取速度更快。\n移动磁头的磁盘存储器，存取数据时磁头需要在盘面上做径向运动；这类存储器可以只有一个盘片，也可以有多个盘片。多个盘片会装在一个同心主轴上，每个记录面各有一个磁头。所有这些磁头连成一体，固定在支架上移动；任何时刻所有磁头和主轴的距离都相等，它们位于和圆心相等距离的一组磁道上，这组磁道称为一个 柱面。\n\n（2）硬磁盘存储器的组成\n​        硬磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成。\n\n\n磁盘驱动器\n\n​        磁盘驱动器是主机之外的一个独立装置，又称作 磁盘机。驱动器主要包括主轴、定位驱动和数据控制 3 个部分。\n\n\n磁盘控制器\n\n​        磁盘控制器是磁盘存储器和主机的接口，通常就是一块电路板，插在主机总线插槽中。它的作用是接收由主机发来的命令，将其转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送，并且控制驱动器的读/写操作。一个磁盘控制器可以控制多台驱动器。\n​        将磁盘控制器的功能全部内置在磁盘设备中，主机和设备之间就可以采用标准的通用接口了。最初这种接口就称为 IDE（Integrated Drive Electronics）接口，同时期还有更高性能的 SCSI（Small Computer System Interface）接口；之后又发展出了采用串行传输技术的接口，这就是 SATA（Serial Advanced Technology Attachment）和 SAS（Serial Attached SCSI）。目前我们的个人电脑中，大多都是采用 SATA 接口的硬盘。\n\n盘片\n\n​        盘片是磁盘中存储信息的载体，由驱动器控制它的转动并读/写数据；有时也会直接把盘片当作驱动器的一部分。目前硬盘的盘片正朝着小体积大容量的方向发展，记录密度越来越高。\n3. 磁盘的工作原理（1）磁盘存储区域\n​        一块磁盘划分为若干个记录面，每个记录面划分为若干条 磁道，而每条磁道又划分为若干个 扇区，扇区（也称块、扇段）是磁盘读写的最小单位，即磁盘按块存取。一个具有多盘片的磁盘组，可将其 n 个面上所有同一半径的磁道看成一个圆柱面，称为 柱面；在移动磁头的组合盘中，多个磁头一次定位的磁道集合就是一个柱面。    \n\n\n\n磁头数：表示磁盘总共有几个磁头，一般来说一个记录面对应一个磁头，所以等于记录面数。\n\n柱面数：表示磁盘中柱面的个数，等于每个记录面上的磁道数。\n\n扇区数：表示每条磁道上有几个扇区。\n\n\n（2）磁盘地址\n​         一个磁盘存储器可以有多台驱动器，不同的驱动器可以用一个编号（驱动器号，或者台号）来区分。当驱动器号确定后，磁盘进行寻址定位时，首先需要整体移动磁头找到对应柱面（磁道）、再选定磁头，最后转动盘片找到扇区。所以寻址所需要的磁盘地址，一般由 驱动器号、柱面（磁道）号、盘面号、扇区号 组成。\n​        磁盘的地址格式如下所示:\n\n\n\n\n驱动器号\n柱面（磁道）号\n盘面号\n扇区号\n\n\n\n\n\n\n\n\n\n​        例如，系统中有 4 个驱动器，每个驱动器带一个磁盘组，其中有 11 个盘片（最外层上下侧为保护面），每个盘面有 203 个磁道、划分为 16 个扇区。则可以算出，驱动器号需要 2 位；柱面号需要 8 位（ 27 &lt; 203 &lt; 28 ）；而 11 个盘片有 20 个盘面，所以盘面号需要 5 位；扇区号需要 4 位。最终每个磁盘地址要 19 位二进制代码。\n\n\n\n\n驱动器号（2位）\n柱面（磁道）号（8位）\n盘面号（5位）\n扇区号（4位）\n\n\n\n\n\n\n\n\n\n（3）磁盘的工作过程\n​        磁盘的主要操作是寻址、读盘、写盘。磁盘属于机械式部件，其读/写操作是串行的，不可能在同一 时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。\n\n磁盘的性能指标\n\n（1）记录密度\n​        记录密度通常是指单位长度内所存储的二进制信息量。磁盘存储器用 道密度、位密度 和 面密度 来表示。\n（2）存储容量\n​        存储容量指磁盘能存储的二进制信息的总数量，一般以位或者字节为单位。磁盘存储容量 C 可以计算为：\n\n​        其中 n 为 盘面数，k 为每个盘面的磁道数，s 为每条磁道上记录的二进制代码数。\n（3）平均寻址时间\n​        磁盘的存取方式是直接存取，它的寻址时间分为两个部分：磁头寻找目标磁道的时间 t~s~；和找到磁道后，磁头等待要读写的磁道区段（扇区）旋转到磁头下方的时间 tw。由于寻找相邻磁道和不相邻磁道的时间不同，磁头等待不同扇区的时间也不同，所以应该取平均值，称为 平均寻址时间；它是 平均寻道时间 tsa 和 平均等待时间     twa之和。\n\n​        平均寻址时间再加上数据传输时间，就是磁盘的 平均访问时间。\n（4）数据传输率\n​        数据传输率是指单位时间内，磁盘向主机传送数据的位数或字节数。数据传输率 DR 与记录位密度 D~b~ 和磁道运动速度 V 有关；\n\n​        对于磁盘来说，“磁道运动速度” 一般用磁盘的转速 r （单位 转/s）表示，那么\n\n（5）误码率\n​        误码率是衡量磁盘出错概率的参数，等于从磁盘读出信息时，出错信息位数和读出信息总位数之比。为了减少出错率，磁盘一般采用循环冗余校验（CRC）码来发现和纠正错误。\n5. 冗余磁盘阵列 RAID​        冗余磁盘阵列（Redundant Array of Independent Disks，RAID）是将多个独立的物理磁盘组成一个磁盘阵列，引入并行处理技术，让数据在多个物理盘上分割交叉存储、并行访问。 \n​        根据不同的目的，可以采用不同的 RAID 方案；在 RAID1 ~ RAID5 的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。RAID 的分级如下所示：\n\nRAID0：无冗余和无校验的磁盘阵列。\n\nRAID1：镜像磁盘阵列，无校验。\n\nRAID2：采用纠错的海明码的磁盘阵列。\n\nRAID3：位交叉奇偶校验的磁盘阵列。\n\nRAID4：块交叉奇偶校验的磁盘阵列。\n\nRAID5：无独立校验的奇偶校验磁盘阵列。\n\n​        其中，RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但 RAID0 没有容错能力。\n​        RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另 一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。\n​        总之，RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高吞吐量；通过镜像功能，提高了安全性、可靠性；通过数据校验，提供容错能力。\n3.5.2 固态硬盘（SSD）​        固态硬盘（Solid State Disk，SSD）是基于闪存（Flash）技术的半导体存储器，它与 U 盘并没有本质差别。SSD 由闪存芯片和闪存翻译层组成，闪存芯片代替了传统磁盘中的磁盘驱动器，闪存翻译层则将来自 CPU 的读写请求翻译成对芯片的读写控制信号，相当于磁盘中的磁盘控制器。    \n\n固态硬盘有很多优点。它由半导体存储器构成，没有机械部件，所以随机访问速度比磁盘快很多，也没有任何机械噪声和震动。另外，SSD 还具有能耗低、抗震性好、安全性高等优点。\n​        当然，固态硬盘也有缺点。它最大的问题是依然基于 EEPROM 的擦除原理，随机写入比较慢。\n​        固态硬盘的数据都存放在闪存芯片中。一个闪存芯片内包含了多个 “块”，每个块又由若干 “页” 组成。数据以页为单位进行读写，但是需要以块为单位进行擦除；所以只有一页所属的块整个被擦除之后，才能重新写这一页。一旦一个块被擦除了，块中的每一页都可以再写一次。一般某个块进行了数千次重复写之后，就会损坏。\n\n​    因此随机写很慢，有两个原因：首先，擦除块本身就比较慢；其次，如果试图写的页所在块已经有数据了，那么这个块中其它所有有数据的页都必须被复制到一个新块（擦除过的块），然后才能进行写操作。\n​        因此，闪存的擦写寿命是有限的，读/写数据通常会集中在 SSD 的一部分闪存，这部分闪存就会损坏得特别快；在磨损不均衡的情况下，数个闪存块的损坏，会导致整个 SSD 损坏。为弥补 SSD 的寿命缺陷，引入了 磨损均衡技术，SSD 磨损均衡技术大致分为两种：\n\n动态磨损均衡：写入数据时，自动选择较新的闪存块。\n静态磨损均衡：监测并自动进行数据分配，让旧的闪存块承担无须写数据的储存任务，同时让较新的闪存块空出来；平常的读/写操作都在较新的闪存块中进行，这样就使各闪存块的损耗更为均衡。\n\n​        有了磨损均衡技术，SSD 的寿命就比较可观了。例如，对于一个 256 GB 的 SSD，闪存的擦写寿命是 500 次的话，那么就需要写入125 TB 数据才可能损坏；而目前的 Flash 芯片已经做到至少可以擦写上万次了。\n3.6 高速缓冲存储器（Cache）​        为了解决 CPU 和主存之间速度不匹配的问题，计算机系统中引入了高速缓存（Cache）的概念。基本想法就是使用速度更快但容量更小、价格更高的 SRAM 制作一个缓冲存储器，用来存放经常用到的信息；这样一来，CPU 就可以直接与 Cache 交换数据，而不用访问主存了。\n​        这种方案之所以有效，是因为通过对大量典型程序分析发现，在一定时间内，CPU 要从主存取指令或者数据，只会访问主存局部的地址区域。这是由于指令和数据在内存中都是连续存放的，而且有些指令和数据会被多次调用（比如常用函数、循环代码段、数组和一些常数）；也就是说，指令和数据在主存中地址分布不是随机的，而是相对的簇聚。这使得 CPU 执行程序时，访存具有相对的局部性；这称为程序访问的 局部性原理。\n\n时间局部性：如果一个数据现在被访问了，那么以后很有可能也会被访问\n空间局部性：如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问\n\n​        局部性原理是 Cache 高效工作的理论基础。\n3.6.1 Cache 的基本工作原理​        为了便于 Cache 与主存交换信息，Cache 和主存都被划分为相等的块。Cache 块又称 Cache 行，每块由若干字节组成，块的长度称为块长。由于 Cache 的容量远小于主存的容量，所以 Cache 中的块数要远少于主存中的块数，Cache 中仅保存主存中最活跃的若干块的副本。\n1. Cache 工作原理​        假设主存按字节编址，地址用 n 位二进制码表示，那么主存容量为 2n B；块的大小为 16 个字节，那么主存中块的个数为：2n / 16 = 2n-4。那么如果对每个块也做一个编号，其实就对应着地址中的前 n - 4 位。\n\n这样，主存地址就分成了两部分：高 n - 4 位表示主存中的 “块地址”，低 4 位表示 “块内地址”，块内地址其实就是具体存储字在块内的 “偏移量”。类似，Cache 中地址也可以分成这样的两部分，由于 Cache 中块长与主存一致，所以低 4 位同样是块内地址；剩余的高位则为 Cache 的块号。Cache 的块号位数小于 n - 4。\n\n所以，可按照某种策略预测 CPU 在 未来一段时间内要访存的数据，将其装入 Cache。当 CPU 要读取主存中的某个字时，分为两种情况：\n\nCache 命中：需要的字已经在缓存中，就将其地址转换为缓存地址，直接访问 Cache，与主存无关；\nCache 未命中：需要的字不在缓存中，仍需访问主存，并将该字所在的块一次性地从主存调入 Cache。\n\n​        如果某个主存块已经调入 Cache，就称该主存块和 Cache 中的缓存块建立了对应关系。由于 Cache 容量有限，当 Cache 已满时，就需要根据某种替换算法，让需要调入 Cache 的块替换之前某个缓存块的内容。所以，一个缓存块不可能永远只对应一个主存块；需要给每个缓存块设置一个标记，写入当前对应的主存块号，表示它当前存放了哪个主存块。\n​        CPU 与 Cache 之间的数据交换，通常是以字为单位；而 Cache 与主存之间的数据交换则以块为单位。\n2. 命中率​        Cache 的效率，通常用 命中率 来衡量。命中率是指 CPU 要访问的信息已经在 Cache 中的比率。Cache 的容量和块长都是影响命中率的重要因素。\n​        假设一个程序执行期间，访问 Cache 的总命中次数为 NC，访问主存的总次数为 NM~，那么命中率为：\n\n​        设 tC 为命中时的 Cache 访问时间，tM~ 为未命中时的主存访问时间，那么 Cache - 主存系统的平均访问时间   ta 为：\n\n​        由于 tC 远小于 tM~，因此平均访问时间 ta 越接近 tC 就说明 Cache 效率越高。用 e 表示访问效率，则有：\n\n​        命中率 h 越接近 1，访问效率就高。一般来说，Cache 容量越大，命中率就越高；而块长与命中率的关系较为复杂，它取决于程序的局部特性，一般取每块 4 ~ 8 个可编址单位（字或字节）效果较好。\n3. Cache 的基本结构​        Cache 主要由 Cache 存储体、主存 - Cache 地址映射变换机构、Cache 替换机构几大模块组成。\n\n（1）Cache 存储体\n​        Cache 存储体以块为单位与主存交换信息，Cache 访存的优先级最高。\n​    （2）主存 - Cache 地址映射变换机构\n​        地址映射变换机构会将 CPU 送来的主存地址转换为 Cache 地址。由于主存和 Cache 块长相同，所以块内地址是不变的，地址变换主要就是主存的块号（高位地址）到 Cache 块号之间的转换。这涉及到一个函数的映射关系，被称为 地址映射。\n​    （3）Cache 替换机构\n​        地址转化之后，如果 Cache 命中，CPU 就直接访问 Cache 存储体；如果不命中，CPU 需要访问主存将需要的字取出，并把它所在的主存块调入 Cache。如果 Cache 已满，无法将主存块直接调入 Cache，就需要 Cache 内的替换机构执行替换策略。\n​        所谓替换策略，就是按一定的替换算法，确定从 Cache 中移出哪个块返回主存，并把新的主存块调入 Cache 进行替换。\n​        在执行写操作时，还需要考虑如何使 Cache 如何与主存的内容保持一致。这就需要用某种 Cache 写策略。\n4. Cache 的改进​        Cache 的改进，主要就是由一个缓存改为使用多个缓存。主要有两个方向：增加 Cache 级数；将统一的 Cache 变为分立的 Cache。\n​    （1）两级缓存\n​        最初在 CPU 和主存之间只设一个缓存，称为 单一缓存。随着集成电路密度的提高，这个缓存就直接与 CPU 集成在了一个芯片中，所以又称为 片内缓存（片载缓存）。\n​        由于片内缓存容量无法做到很大，所以可以考虑在片内缓存和主存之间再加一级缓存，称为 片外缓存，也由 SRAM 组成。这种由片外缓存和片内缓存构成的 Cache 系统被称为 “两级缓存”，片内缓存作为第一级（L1 Cache），片外缓存作为第二级（L2 Cache）。\n​    （2）分立缓存\n​        指令和数据都存放在同一缓存内的 Cache，称为 统一缓存；而 分立缓存 则将指令和数据分别存放在两个缓存中，一个叫指令 Cache，另一个叫数据 Cache。这两种缓存的选择主要考虑两个因素：\n\n主存结构。如果计算机主存中指令、数据是统一存储的，则相应的 Cache 采用统一缓存；如果主存指令、数据分开存储，则相应的 Cache 采用分立缓存。\n机器对指令执行的控制方式。如果采用了超前控制或者流水线控制方式，一般都采用分立缓存。所谓超前控制，是指在当前指令执行尚未结束时就提前把下一条准备执行的指令取出；而所谓流水线控制，就是多条指令同时分阶段执行。\n\n3.6.2 Cache 和主存之间的映射方式​        Cache 块中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，这相当于定义了一个函数：\n​                                                                    Cache 地址 = f ( 主存地址 )\n​        当然，由于 Cache 和主存块长一样，而块内地址只是字在当前块内的 “偏移量”，所以映射转换之后块内地址是不变的。我们需要的其实只是 Cache 块号和主存块号之间的函数关系：\n​                                                                    Cache 块号 = f ( 主存块号 )\n​        Cache 块远少于主存块，所以 Cache 块不可能永远对应唯一的主存块，需要在 Cache 中为每一个块加一个 标记，指明它是主存中哪一块的副本。这个标记的内容，应该能够唯一确定对应主存块的编号。另外，为了说明 Cache 行中的信息是否有效，每个 Cache 行还需要有一个 有效位，该位为 1 时，表示 Cache 中该映射的主存块数据有效；为 0 则无效。\n​        地址映射的方法有以下 3 种。\n1. 直接映射​        直接映射 的思路非常简单，就是 “挨个对应”，主存中的每一块只能装入 Cache 中的唯一位置。由于 Cache 容量很小，当主存中的块已经 “遍历” 完所有 Cache 地址后，下一个主存块的对应位置就又成了 Cache 中的第一行（第一个块）。\n​        很明显，这跟 “顺序存储” 的思路是一样的，用主存块号对 Cache 的总行数取模，就可以得到对应 Cache 的行号了：\n​                                                                Cache行号 = 主存块号  mod  Cache总行数\n​        例如，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 只有 4 行（4 个块），那么采用直接映射方式的对应关系如下：\n\n \n​      而在缓存（Cache）设计中，一行（line）通常等同于一块（block）。每一行缓存存储一个块的数据，这个块对应于主存中的一个相同大小的数据块。具体解释如下：\n\n缓存行（Cache Line）：\n一行缓存包含的数据单位，包含一个数据块、一个标记（tag）、有效位（valid bit）和可能的脏位（dirty bit）。\n在直接映射缓存中，每个缓存行唯一对应一个特定的主存块。\n\n\n块（Block）：\n块是从主存中提取的一组连续字节。主存中的块被映射到缓存中的行。\n缓存行的数据部分存储主存块的内容。\n\n\n\n假设我们有以下参数：\n\n主存地址位数：32位\n主存块大小：4个字，每字32位（即每块16字节）\n缓存数据容量：4K字（16KB）\n\n\n对于采用回写策略的缓存，每行缓存不仅存储数据块，还需要附加的元数据：\n\n数据位数：16字节（128位）\n标记位数：\n偏移位数（块内地址）：log2(16) =4 位\n索引位数（块数/行数）：log2(1024) =10 位\n标记位数（剩下的位数用于标记，以确定缓存行对应的具体主存块。将主存中所有228块全部映射到缓存的1024行中，则还需要18位来确定218中的哪个。）：32 - (10 + 4) = 18 位\n\n\n有效位（Valid Bit）：1位\n脏位（Dirty Bit）：1位\n\n主存至缓存的具体映射关系如下：\n\n\n主存中的每个块根据索引部分映射到缓存中的一个行。\n多个主存块可以具有相同的索引，从而映射到同一个缓存行，但它们的标记不同。\n\n采用回写策略的缓存行的总位数分解如下：\n\n每行的总位数：\n\n\n​           更加一般化，假设 Cache 共有 2c 行，主存有 2m 个块，那么 Cache 行号有 c 位，主存块号有 m 位。在直接映射方式中，主存块号为 0、2c、2c+1… 的块，都映射到 Cache 的第 0 行；而主存中块号为 1、2c + 1、2c+1 + 1… 的块，映射到 Cache 的第 1 行；以此类推。\n​        这样一来，主存块号的低 c 位就对应了 Cache 中的行号；当一个块存放在 Cache 中，只需要高 m - c 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - c 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        所以直接映射方式下，主存地址结构为：\n\n​        访存过程：\n​        ① 根据访存地址中间的 c 位，找到对应的 Cache 行。\n​        ② 将该 Cache 行中的标记和主存地址的高 t 位标记进行比较。\n​        ③ 若相等且有效位为1，则 Cache 命中，此时根据主存地址中低位的块内地址，在对应的 Cache 行中存取信息；若不相等或有效位为 0，则 Cache 未命中，此时 CPU 从主存中读出该地址所在的一块信息，并送至对应的 Cache 行中，将有效位置 1，并置标记为地址中的高 t 位。\n\n​    直接映射实现简单，但不够灵活，即使 Cache 的其他许多地址空着也不能占用，这使得直接映射的块冲突概率高，空间利用率低。\n2. 全相联映射​        直接映射的问题在于，我们找到的是从主存块到缓存行的一种 “多对一” 的关系，每一个主存块只能对应唯一的缓存行，从而导致冲突概率高。如果让一个主存块，可以映射到多个缓存块上，变成 “多对多” 的关系，明显就可以减少冲突了。\n​        最简单的情况，就是不加任何条件限制，让主存的每一个块都可以映射到 Cache 的任意位置；简单来说就是 “有空就填”，放在哪里都可以。这就是 全相联映射 方式。        \n\n由于没有任何规律，所以当一个块存放在 Cache 中，无法根据 Cache 行号推出它对应主存块的任何信息；因此必须在每行的标记中明确指出该行取自主存的哪一块，这样标记就需要完整的 m 位主存块号。CPU 访存时，需要与所有 Cache 行的标记进行比较。\n​        全相联映射方式下，主存的地址结构为：\n\n  全相联映射方式的优点是灵活，Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。\n3. 组相联映射​        把直接映射和全相联映射两种方式结合起来，就是 组相联映射 方式。\n​        组相联的思路是将 Cache 分成 Q 个大小相等的组，每个主存块可装入对应组的任意一行；它所在的组则按顺序依次排列得到。也就是 组间采用直接映射、而 组内采用全相联映射 的方式。当 Q=1 时，变为全相联映射；当 Q = Cache 行数时变为直接映射。\n​        假设每组有 R 个 Cache 行，则称之为 R 路组相联；例如每组有 2 个 Cache 行时称为 2 路组相联。\n​        类似的例子，假设主存地址为 32 位，按字节编址，主存块大小为 64 B，所以主存块共有 232 / 64 = 226 个；如果 Cache 有 8 行（8 个块），采用 2 路组相联映射方式，那么共有 Q = 8 / 2 = 4 组。对应关系如下：\n\n​    可以看出，现在的 “组号” 就相当于直接映射方式下的行号，可以由主存块号对组数 Q 取模得到：\n​                                                        Cache组号 = 主存块号  mod  Cache组数\n​        更加一般化，假设 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q ，行号的低 c - q 位就代表了 Cache 行在组内的序号。\n​        在 R 路组相联映射方式中，主存块号为 0、2q、2q+1… 的块，都映射到 Cache 的第 0 组，可以选择组内 2c-q 行的任一行；而主存中块号为 1、2q + 1、2q+1 + 1… 的块，映射到 Cache 的第 1 组，同样可以任选组内的 Cache 行；以此类推。\n​        这样一来，主存块号的低 q 位就对应了 Cache 中的组号；当一个块存放在 Cache 中，只需要高 m - q 位就可以指明它对应的主存中的块号。给每个 Cache 行设置一个 t = m - q 位的标记，那么当主存某块调入 Cache 后，就将其块号的高 t 位设置在对应 Cache 行的标记中。\n​        可以将以上 3 中映射方式对比如下：\n\n3.6.3 Cache 中主存块的替换算法​        如果有新的主存块需要调入 Cache，而可用空间又已经占满，这时就需要替换掉某个旧块，这就产生了替换策略（替换算法）的问题。当采用直接映射时，替换的位置是固定的，无须考虑替换算法；而在采用全相联映射或组相联映射时，就需要使用替换算法来确定到底置换哪个 Cache 行。\n​        常用的替换算法有 随机（RAND）算法、先进先出（FIFO）算法、最近最少使用（LRU）算法 和 最不经常使用（LFU）算法。其中最常考查的是 LRU 算法。\n\n随机算法：随机地确定替换的 Cache 块。实现简单，但未依据局部性原理，命中率较低。\n先进先出算法（Fisrt In First Out，FIFO）：选择最早调入的行进行替换。实现简单，但也未依据局部性原理。\n最近最少使用算法（Least Recently Used，LRU）：依据局部性原理，选择近期最久未访问过的 Cache 行作为被替换的行。LRU 算法为每个 Cache 行设置一个计数器，用来记录每个块的使用情况，并根据计数值选择淘汰某个块。\n最不经常使用算法（Least Frequently Used，LFU）：将一段时间内访问次数最少的 Cache 行换出。与 LRU 类似，也设置一个计数器，Cache 行建立后从 0 开始计数，每访问一次计数器加 1，需要替换时将计数值最小的行换出。\n\n​        例如，假设一台机器 Cache 有 8 个行，初始值为空，采用 4 路组相联映射方式和 LRU 替换策略，当顺序访问主存块号为 0，4，8，3，0，6，12，0，4，8 时，缓存的命中和替换情况如下：\n\nLRU 算法中利用计数器来表示 Cache 行未被访问的时间。整体原则是：当 Cache 行有新的主存块调入时，计数器开始计数，初始值为 0，此后每遇到一次对 Cache（或 Cache 组）的访问就加 1；如果一次访问 Cache 命中了这一行，就将计数器清 0；每次有 Cache 行计数器清 0，其它行的计数器依然要加 1，不过只需要计数值比当前行更小的那些继续加 1 就可以了。\n​        需要替换时，直接选择计数值最大的行，调入新的块并将计数器置 0。这是由于不同的 Cache 行不会同时开始计数，且每次都同步加 1，所以所有 Cache 行的计数值都不会相同，每次发生替换时必然能够找到一个最大值；而一旦有计数器清 0，比它计数值更大的那些也是都不加 1，依然保持着原有的大小顺序。\n​        这样一来，如果当前 Cache 共有 2c 行，分为 Q = 2q 组，每组行数为 R = 2c / Q = 2c-q ，那么计数器的值就不会超过 R；只要用 c - q 位就可以表示计数器了，这被叫做 LRU 位。因此，计数值的位数与 Cache 组的大小有关。当为 2 路时有 1 位 LRU 位，4 路时有 2 位 LRU 位。LRU 位会同标记、有效位一同作为 Cache 的一部分。\n3.6.4 Cache 写策略​        因为 Cache 中的内容是主存块内容的副本，当对 Cache 中的内容进行更新时，就需选用写操作策略使 Cache内容和主存内容保持一致。此时分两种情况：\n（1）Cache 写命中（要修改的单元在 Cache 中）\n​        这种情况有两种处理方法：\n\n写直达法\n\n​        也叫全写法、写穿透法。将数据同时写入 Cache 和主存。这种方法实现简单，一致性好。缺点是降低了速度，时间开销为访存时间。为了减少写入主存的开销，可以在 Cache 和主存之间加一个写缓冲。\n\n写回法\n\n​        也叫回写法、写返回法。数据只写入 Cache，而不立即写入主存，只有当此块被换出时才写回主存。这种方法效率很高，但一致性较差。在每个 Cache 行中设置一个修改位（脏位），若修改位为 1（“脏”），则说明对应 Cache 行中的块被修改过，替换时须写回主存；若修改位为 0（“净”），则替换时无须写回主存。\n（2） Cache 写未命中（要修改的单元不在 Cache中 ）\n​        这种情况也有两种处理方法：\n\n写分配法\n\n​        把数据写入主存，同时将该块调入Cache。这种方法依据了空间局部性原理。\n\n非写分配法\n\n​        只把数据写入主存，不进行调块。\n​        非写分配法通常与全写法合用，写分配法通常与回写法合用。\n​        这样，还是之前的机器，采用组相联映射的 Cache 共有 2c 行，分为 Q = 2q 组，主存有 2m 个块；那么 Cache 行号有 c 位，其中高 q 位是组号，主存块号有 m 位。这时每组中的 Cache 行数为 R = 2c / Q = 2c-q  ，即采用 R 路组相联映射，假如还采用了 LRU 替换策略和回写法，那 Cache 行应该包含以下部分：\n\n​        现代计算机通常设立多级 Cache，一般两级 Cache 按离 CPU 的远近分别命名为 L1 Cache、L2 Cache，离 CPU 越近则速度越快、容量越小。指令 Cache 与数据 Cache 分离一般在 L1 级，LI Cache 对 L2 Cache 使用全写法，L2 Cache 对主存使用回写法。由于L2 Cache的存在，避免了因频繁写而造成写缓冲溢出的情况。\n3.7 虚拟存储器​        早期的计算机，CPU 是直接操作主存的，也就是运行程序时，直接给出要访问的实际主存地址。这种方式简单直接，但是会有一些问题：\n\n不同的程序之间需要共享内存，它们的内存地址空间很难隔离，从而导致程序运行的稳定性和安全性降低；\n主存容量有限，如果同时执行的程序太多、使用内存太大容易超出容量限制而崩溃。\n\n\n为了解决这些问题，在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统。\n​        主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。\n3.7.1 虚拟存储器的基本概念​        虚拟存储器将主存和辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存的实际存放位置。用户编程允许涉及的地址称为 虚地址 或 逻辑地址，虚地址对应的存储空间称为虚拟空间。实际的主存地址称为 实地址 或 物理地址，实地址对应的是主存地址空间。虚地址比实地址要大很多。\n​        使用虚拟存储器之后，程序中看到的地址都是逻辑地址。在访存时，逻辑地址首先会被转换成物理地址，然后再访问实际物理内存。\n\n这样一来，每一个程序都有独立的虚拟地址空间，不同进程的虚拟地址空间互相不干扰，提高了安全性。在每个进程看来，就像它自己独享了整个内存。当物理内存不够时，可以将一部分不常使用的内存块换出（Swap-out）到磁盘中，下次使用时再换入到内存中（Swap-in），这样程序就可以使用超过实际物理内存大小的地址空间了。\n\nCPU 使用逻辑地址时，先判断这个逻辑地址对应的内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问。若主存已满，则采用 替换算法 置换主存中的页。\n​        虚拟存储器采用了和 Cache 类似的技术，将辅存中经常被访问的数据副本存放到主存中。但缺页 （或段）而访问辅存的代价很大，因此虚存机制采用 全相联映射，每个页可以存放到主存区域的任意一个空闲页位置。此外，当进行写操作时，不能每次写操作都同时写回磁盘，因而采用 回写法。    \n3.7.2 页式虚拟存储器​        页式虚拟存储器 以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为 实页 或 页框，虚存的页称为 虚页。这样，一个逻辑地址可以分为两段：虚页号 和 页内地址。\n\n虚页和实页之间采用全相联映射，所以从主存中依次查找要访问的虚页号比较困难。所以我们专门引入一个数据结构，用来保存虚页号和实页号的映射关系，这就是 页表。页表可以实现从逻辑地址到物理地址的转换。\n1. 页表​        页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。每个程序都有自己的页表，页表一般长久地保存在内存中。\n​        页表中的每一项，都包含以下几部分：\n\n有效位：也称 装入位，用来表示对应页面是否在主存，若为 1，则表示该虚页已从外存调入主存，此时页表项存放该页的物理页号；若为 0，则表示页面没有调入主存，此时页表项可以存放该页的磁盘地址。\n脏位：也称 修改位，用来表示页面是否被修改过，虚拟存储机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。\n引用位：也称 使用位，用来配合替换策略进行设置，例如是否使用先进先出（FIFO）或近期最少使用（LRU）策略等。\n\n\n​        CPU 执行指令时，需要先将逻辑地址转换为主存物理地址。每个进程都有一个 页表基址寄存器，存放该进程的页表首地址，然后根据逻辑地址高位部分的虚页号找到对应的页表项。若装入位为 1，则取出物理页号，和逻辑地址低位部分的页内地址拼接，形成物理地址；若装入位为 0，则说明缺页，需要操作系统进行 缺页处理。缺页时会由 CPU 的内存管理单元（MMU）发出中断，操作系统需要将相应的页从磁盘取回调入主存，并将物理页的地址填入页表中。\n​        页式虚拟存储器的优点是：页的长度固定，页表简单，调入方便。缺点是：最后一页的零头无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。\n2. 快表（TLB）​        有了虚拟存储器之后，CPU 在寻址时所生成的都是虚拟地址。于是 CPU 在取指或者执行访存指令的时候，都需要进行地址翻译，而每次地址翻译都要访问主存中的页表，会产生严重的开销。\n​        依据程序执行的局部性原理，当 CPU 在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在 Cache 中，就可以不访问主存直接进行地址翻译了；这样明显能提高效率。\n​        在 CPU 芯片中，加入一个专门存放最常访问的页表项的 Cache，就叫做 转址旁路缓存（Translation Lookaside Buffer，TLB），一般简称为 “快表”。TLB 实质上就是 “页表的 Cache”，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本；所以 TLB 又被称为 页表缓存。\n\n​        相应地，把放在主存中的页表称为 慢表（Page）。 在地址转换时，先查找快表，若命中，则无须再访问主存中的页表（慢表）。\n​        TLB 通常采用 全相联映射。每个 TLB 项由页表表项内容加上一个 TLB 标记字段以及有效位等标志位组成，TLB 标记用来表示该表项取自页表中哪个虚页号对应的页表项，其内容就是该页表项对应的虚页号。\n\n3. 具有 TLB 和 Cache 的多级存储系统​        TLB 和 Cache 都属于缓存，不过它们的用途不同：\n\nTLB 用来保存最近经常访问的页表项，是对 地址映射 的缓存。\nCache 用来保存最近经常访问的主存块，是对 数据内容 的缓存。\n\n​        所以对于一个有虚拟存储器的计算机系统，可以先通过 TLB 对逻辑地址的翻译进行加速，快速得到一个物理地址；然后再通过 Cache 的地址转换判断是否 Cache 命中，从而对数据的访问进行加速。\n​        这样就将 Cache 和 TLB 结合起来，构成了多级存储系统。下面就是一个具有 2 路组相联映射 Cache 和 TLB 的多级存储系统；CPU 给出的是一个 32 位的逻辑地址，TLB 采用全相联映射，每一项都有一个比较器。\n\n\n查找时将虚页号与每个 TLB 标记同时进行比较，若有某一项相等且对应有效位为 1，则 TLB 命中，此时可直接通过TLB进行地址转换；若未命中，则 TLB 缺失，需要访问主存去査页表。\n图中所示是 两级页表方式，虚页号被分成 页目录索引 和 页表索引 两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB。若 TLB 已满，则还需要采用替换策略。\n完成由逻辑地址到物理地址的转换后，Cache 机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的 Cache 行或组，将对应 Cache 行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则 Cache 命中，此时根据块内地址取岀对应的字送 CPU。\n\n​        查找时，快表和慢表也可以同步进行。若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器，但访问主存速度几乎没有下降。\n​        在一个具有 Cache 和 TLB 的虚拟存储系统中，CPU —次访存操作可能涉及对 TLB、页表（Page）、Cache、主存和磁盘的访问。CPU 在访存过程中存在 3 种缺失情况：\n​        ① TLB 缺失：要访问页面的页表项不在 TLB 中；\n​        ② Page 缺失：要访问的页面不在主存中。\n​        ③ Cache 缺失：要访问的主存块不在 Cache 中；\n​        需要注意，如果 TLB 命中，那么 Page 一定命中；如果 Page 缺失，那么 Cache 一定缺失。所以有如下一些组合情况：\n\n\n第 1 种情况下，无须访问主存，地址转换和访问数据都可以通过高速缓存完成；\n第 2 种和第 3 种情况都 需要访问一次主存，第 2 种是访问主存取数据，第 3 种是访问页表转换物理地址；\n第 4 种情况需要访问两次主存，访问页表转换物理地址一次、访存取数据一次；\n第 5 种情况就是 “缺页异常”，需要访问磁盘，并且至少访问两次主存。\n\n​        Cache 缺失处理由硬件完成；缺页处理由软件完成，操作系统通过 “缺页异常处理程序” 实现；而 TLB 缺失既可以用硬件也可以用软件来处理。\n3.7.3 段式虚拟存储器​        在段式虚拟存储器中，将虚拟空间用 “段” 进行分割；而段是按程序的逻辑结构划分的，各段的长度因程序而异。虚地址分为两部分：段号 和 段内地址。虚地址到实地址之间的变换是由 段表 来实现的。段表的每行记录与某个段对应的段号、 装入位和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。\n\n​        CPU 用逻辑地址访存时，先根据段号与段表基地址拼接成对应的段表项，再根据该段表项的装入位判断该段是否已调入主存（装入位为 “1”，表示该段已调入主存）。当已调入主存时，从段表读岀该段在主存的起始地址，与段内地址相加，得到对应的主存物理地址。\n​        段式虚拟存储器的优点是，段的分界与程序的逻辑分界相对应，这使得程序易于编译、修改和保护，也便于多道程序共享；缺点是因为段长度可变，分配空间不便，容易留下碎片，造成浪费。\n3.7.4 段页式虚拟存储器​        把程序按逻辑块分段，段内再分页，主存空间也划分为大小相等的页，程序对主存的调入调出仍以 页 为基本单位，这样的虚拟存储器称为 段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个 段表，每段对应一个 页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。\n\n​        虚地址分为 段号、段内页号、页内地址 3 部分。CPU 根据虚地址访存时，首先根据段号得到段表地址，然后从段表中取出该段的页表起始地址，与虚地址段内页号拼接，得到页表地址；最后从页表中取出实页号，与页内地址拼接成主存实地址。\n​        段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护；缺点是在地址变换过程中需要两次查表，系统开销较大。\n3.7.5 虚拟存储器与 Cache 的比较​        相同点：\n\n目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。\n都把数据划分为信息块，作为基本的传送单位，虚拟存储器系统的信息块更大。\n都有地址的映射算法、替换算法、更新策略等问题。\n依据局部性原理，应用“快速缓存”思想，将活跃的数据放在相对高速的部件中。\n\n​        不同点：\n\nCache主要是为了提高系统速度，而虚拟存储器是为了解决主存容量不足的问题。\nCache由硬件实现，对所有程序员透明；虚拟存储器由操作系统和硬件共同实现，对应用程序员透明。\n在不命中时对性能的影响不同。因为 CPU 的速度约为 Cache 的 10 倍，而主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统在不命中时对系统性能的影响更大。\nCPU 与 Cache 和主存有直接通路，而辅存与 CPU 没有直接通路。在 Cache 不命中时，CPU 能和主存直接通信；而虚拟存储器系统在不命中时，须先将数据从硬盘调入主存，CPU 才能访问。\n\n3.8 章节练习一、单项选择题\n【2010真题】下列有关 RAM 和 ROM 的叙述中，正确的是    （    ）。\n\n​        Ⅰ ． RAM 是易失性存储器， ROM 是非易失性存储器​        Ⅱ ． RAM 和 ROM 都采用随机存取方式进行信息访问​        Ⅲ． RAM 和 ROM 都可用作 Cache​        Ⅳ． RAM 和 ROM 都需要进行刷新\n​        A．仅Ⅰ 和Ⅱ                     B．仅Ⅱ 和Ⅲ                    C．仅Ⅰ 、 Ⅱ 和Ⅳ                     D．仅Ⅱ 、 Ⅲ和Ⅳ\n​        答案：A\n\n【2011真题】下列各类存储器中，不采用随机存取方式的是    （    ）。\n\n​        A． EPROM                       B． CDROM                       C． DRAM                           D． SRAM\n​        答案：B\n\n【2015真题】下列存储器中，在工作期间需要周期性刷新的是    （    ）。        \n\n​        A． SRAM                        B． SDRAM                            C． ROM                         D． FLASH \n​        答案：B\n\n【2012真题】下列关于闪存（Flash Memory）的叙述中，错误的是     （    ）。\n\n​        A． 信息可读可写，并且读、写速度一样快\n​        B． 存储元由 MOS 管组成，是一种半导体存储器\n​        C． 掉电后信息不丢失，是一种非易失性存储器\n​        D． 采用随机访问方式，可替代计算机外部存储器 \n​        答案：A\n\n【2011真题】某计算机存储器按字节编址，主存地址空间大小为 64MB，现用 4MB×8 位的 RAM芯片组成 32MB 的主存储器，则存储器地址寄存器 MAR 的位数至少是     （    ）。\n\n​        A． 22 位                       B． 23 位                       C． 25 位                       D． 26 位\n​        答案：D\n​        要点：MAR 的位数跟主存地址空间有关，与主存实际容量无关。\n\n【2010真题】假定用若干个 2K×4 位的芯片组成一个 8K×8 位的存储器，则地址 0B1FH 所在芯片的最小地址是    （   ）。\n\n​        A． 0000H                     B． 0600H                     C． 0700H                     D． 0800H\n​        答案：D\n\n【2014真题】某容量为 256MB 的存储器由若干 4Mx8 位的 DRAM 芯片构成， 该 DRAM 芯片的地址引脚和数据引脚总数是    （    ） 。\n\n​        A. 19                             B. 22                         C. 30                         D. 36 \n​        答案：A        \n​        要点：DRAM 采用地址复用技术，地址线为正常的一半。 \n\n【2016真题】某存储器容量为 64KB，按字节编址，地址 4000H~5FFFH 为 ROM 区，其余为 RAM 区。若采用 8K× 4 位的 SRAM 芯片进行设计，则需要该芯片的数量是     （    ）。\n\n​        A． 7                             B． 8                          C． 14                         D． 16 \n​        答案：C\n\n【2018真题】假定 DRAM 芯片中存储阵列的行数为 r、列数为 c，对于一个2Kx1 位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 r、c的取值分别是    （    ）。\n\n​        A. 2048、1                    B. 64、32                    C. 32、64                    D. 1、2048\n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，按行刷新。\n\n【2017真题】某计算机主存按字节编址，由 4 个 64M × 8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是    （    ）。\n\n​        A． 1                             B． 2                             C． 3                             D． 4 \n​        答案：C\n​        要点：多体低位交叉存储器可增大带宽，每个存储周期对所有芯片各读取一次；double 型变量占 8 个字节。\n\n【2021真题】某计算机的存储器总线中有 24 位地址线和 32 位数据线，按字编址，字长为 32 位。若 00 0000H~3F FFFFH 为 RAM 区，则需要 512K x 8 位的 RAM 芯片数为    （    ）。\n\n​        A.8                                B.16                                C.32                                D.64\n​        答案：C\n\n【2022真题】某内存条包含 8 个 8192 x 8192 x 8 位的 DRAM 芯片，按字节编址，支持突发 (burst) 传送方式，对应存储器总线宽度为 64 位，每个 DRAM 芯片内有一个行缓冲区 (row buﬀer)。 下列关于该内存条的叙述中，不正确的是    （   ）。\n\n​        A. 内存条的容量为 512 M                             B. 采用多模块交叉编址方式\n​        C. 芯片的地址引脚为 26 位                           D. 芯片内行缓冲有 8192 x 8 位 \n​        答案：C\n​        要点：DRAM 芯片采用地址复用技术，地址引脚为正常的一半；行缓冲区的大小就是一行的大小。\n\n【2013真题】下列选项中，用于提高 RAID 可靠性的措施有    （    ）。\n\n​        I.磁盘镜像        II. 条带化        III.奇偶校验        IV.增加 Cache机制\n​        A.仅I、II            B.仅I、III            C.仅I、III和IV            D.仅II、III和IV\n​        答案：B\n​        要点：RAID 通过条带化来实现并行读写；通过磁盘镜像和校验增加可靠性。\n\n【2013真题】某磁盘的转速为 10000 转/分，平均寻道时间是 6ms，磁盘传输速率是 20MB/s，磁盘控制器延迟为 0.2ms，读取一个 4KB 的扇区所需的平均时间约为    （    ）。\n\n​        A.9ms                    B.9.4 ms                    C.12 ms                    D. 12.4 ms\n​        答案：B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间 + 控制器延迟  。\n\n【2015真题】若磁盘转速为 7200 转/分，平均寻道时间为 8 ms，每个磁道包含 1000 个扇区，则访问一个扇区的平均存取时间大约是     （    ）。\n\n​        A． 8.1 ms                     B． 12.2 ms                 C． 16.3 ms                     D． 20.5 ms\n​        答案： B\n​        要点：平均访问时间 =  平均寻道时间 + 平均等待时间 + 数据传输时间  。\n\n【2019真题】下列关于磁盘存储器的叙述中，错误的是     （    ）。\n\n​        A．磁盘的格式化容量比非格式化容量小                B．扇区中包含数据、地址和校验等信息\n​        C．磁盘存储器的最小读写单位为一字节                D．磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成 \n​        答案：C\n​        要点：磁盘最小读写单位为一个扇区。\n\n【2014真题】采用指令 Cache 与数据 Cache 分离的主要目的是    （    ） 。\n\n​        A. 降低 Cache 的缺失损失                 B. 提高 Cache 的命中率                \n​        C. 降低 CPU 平均访存时间                 D. 减少指令流水线资源冲突\n​        答案：D\n\n【2017真题】某C语言程序段如下：\n\n123456for(i=0; i&lt;=9; i++)&#123;     temp=1;    for(j=0； j&lt;=i； j++)temp * =a[j];    sum + =temp；&#125;\n​        下列关于数组 a 的访问局部性的描述中，正确的是     （    ）。\n​        A．时间局部性和空间局部性皆有\n​        B．无时间局部性，有空间局部性\n​        C．有时间局部性，无空间局部性\n​        D．时间局部性和空间局部性皆无 \n​        答案：A\n\n【2015真题】假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写（Write Back）方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是         （    ）。\n\n​        A． 146K                             B． 147K                        C． 148K                         D． 158K\n​        答案：C\n​        要点：直接映射方式下，主存块号位数 m = 标记位数 t + Cache 行号位数 c ；\n​                    回写策略下，每个 Cache 行需要另加 1 位修改位（脏位）；\n​                    Cache 行总位数 = 1位有效位 + 1位修改位 +（LRU位）+ 标记 + 数据。\n\n【2022真题】若计算机主存地址为 32 位，按字节编址，某 Cache 的数据区容量为 32KB, 主存块大小为 64B, 采用 8 路组相联映射方式，该 Cache 中比较器的个数和位数分别为     （    ）。\n\n​        A. 8, 20                     B. 8, 23                     C. 64, 20                     D. 64, 23 \n​        答案：A\n​        要点：Cache 中比较器的个数就是组相联的路数 R，比较器的位数就是标记 t 的位数。\n​                    组相联映射方式下，主存块号位数 m = 标记位数 t + Cache 组号位数 q\n\n【2016真题】有如下 C 语言程序段：\n\n12for(k=0; k&lt;1000; k++)    a[k] = a[k]+32;\n​        若数组 a 及变量 k 均为 int 型， int 型数据占 4B，数据 Cache 采用直接映射方式，数据区大小为 1KB、块大小为 16B，该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为     （    ）。\n​        A． 1.25%                     B． 2.5%                     C． 12.5%                     D． 25% \n​        答案：C\n​        要点：循环内语句需要对 a[k] 访问两次，第一次未命中，并将其所在块调入主存；第二次命中；在该块中的后面三个元素的 6 次访问也都命中。\n\n【2010真题】下列命中组合情况中，一次访存过程中不可能发生的是     （    ）。\n\n​        A． TLB 未命中， Cache 未命中， Page 未命中\n​        B． TLB 未命中， Cache 命中， Page 命中\n​        C． TLB 命中， Cache 未命中， Page 命中\n​        D． TLB 命中， Cache 命中， Page 未命中 \n​        答案：D\n​        要点：TLB 命中，Page 必命中；Page 缺失，Cache 必缺失。\n\n【2019真题】下列关于缺页处理的叙述中，错误的是     （    ）。A．缺页是在地址转换时 CPU 检测到的一种异常B．缺页处理由操作系统提供的缺页处理程序来完成C．缺页处理程序根据页故障地址从外存读入所缺失的页D．缺页处理完成后回到发生缺页的指令的下一条指令执行 \n\n​        答案：D\n​        要点：缺页处理完成后回到发生缺页的指令继续执行。\n\n【2020真题】下列关于 TLB 和 Cache 的叙述中，错误的是    （    ）。\n\n​        A.命中率都与程序局部性有关                            B.缺失后都需要去访问主存\n​        C.缺失处理都可以由硬件实现                            D.都由 DRAM 存储器组成\n​        答案：D\n\n【2015真题】假定编译器将赋值语句 “ x=x+3; ” 转换为指令 “add xaddr, 3”，其中， xaddr 是 x 对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是    （    ）。\n\n​        A． 0                                 B． 1                            C． 2                             D． 3 \n​        答案：B\n​        要点：直写方式下，每次写入都必须将数据同时写入 Cache 和主存。\n\n【2013真题】某计算机主存地址空间大小为256 MB，按字节编址。虚拟地址空间大小为 4GB，采用页式存储管理，页面大小为 4KB，TLB (快表)采用全相联映射，有 4 个页表项，内容如下表所示\n\n\n​        则对虚拟地址 03FF F180H 进行虚实地址变换的结果是    （   ）。\n​        A.015 3180H                    B.003 5180H                    C.TLB缺失                    D.缺页\n​        答案：A\n​        要点：虚页号的位数，可以由虚页的个数推出；TLB 中保存的标记就是虚页号。\n\n【2022真题】某计算机主存地址为 24 位，采用分页虚拟存储管理方式，虚拟地址空间大小为 4GB, 页大小为4KB, 按字节编址。 某进程的页表部分内容如下表所示。 \n\n\n​        当 CPU 访问虚拟地址 0008 2840H 时，虚－实地址转换的结果是     （    ）。\n​        A. 得到主存地址 02 4840H                         B. 得到主存地址 18 0840H \n​        C. 得到主存地址 01 8840H                         D. 检测到缺页异常 \n​        答案：C\n二、综合应用题\n【2016真题】某计算机采用页式虚拟存储管理方式，按字节编址，虚拟地址为 32 位，物理地址为 24 位，页大小为 8KB；TLB 采用全相联映射； Cache 数据区大小为 64KB，按 2 路组相联方式组织，主存块大小为 64B。存储访问过程的示意图如下。 \n\n\n​        请回答下列问题。\n​    （1）图中字段 A~G 的位数各是多少？ TLB 标记字段 B 中存放的是什么信息？\n​    （2）将块号为 4099 的主存块装入到 Cache 中时，所映射的 Cache 组号是多少？对应的 H 字段内容是什么？\n​    （3) Cache 缺失处理的时间开销大还是缺页处理的时间开销大？为什么？ \n​        答案：\n​    （1）页大小为 8KB，页内偏移地址为 13 位，故 A=B=32-13=19； D=13； C=24-13=11；\n​        主存块大小为 64B，故 G=6。 \n​        2 路组相联，每组数据区容量有 64 B×2=128B，共有 64KB/128B=512 组，故 F=9；\n​        E = 24-G-F = 24-6-9 = 9。\n​        因而  A=19， B=19， C=11， D=13， E=9， F=9， G=6。\n​        TLB 中标记字段 B 的内容是虚页号，表示该 TLB 项对应哪个虚页的页表项。\n​    （2）块号 4099=00 0001 0000 0000 0011B，因此，所映射的 Cache 组号为 0 0000 0011B=3，对应的 H 字段内容为 0 0000 1000B。 \n​    （3） Cache 缺失带来的开销小，而处理缺页的开销大。 因为缺页处理需要访问磁盘，而 Cache 缺失只要访问主存。\n\n【2018真题】某计算机采用页式虚拟存储管理方式，按字节编址。CPU 进行存储访问的过程如图所示。\n\n\n​        根据上图回答下列问题。\n​        (1) 主存物理地址占多少位？\n​        (2) TLB 采用什么映射方式？TLB 用 SRAM 还是 DRAM 实现?\n​        (3) Cache 采用什么映射方式？若 Cache 采用 LRU 替换算法和回写（Write Back）策略，则 Cache 每行中除数据（Data）、Tag 和有效位外，还应有哪些附加位？Cache 总容量是多少？Cache 中有效位的作用是什么？\n​        (4) 若 CPU 给出的虚拟地址为 0008 C040H，则对应的物理地址是多少？是否在 Cache 中命中？说明理由，若 CPU 给出的虚拟地址为 0007 C260H，则该地址所在主存块映射到的 Cache 组号是多少?\n​        答案：\n​    （1）物理地址由实页号和页内地址拼接，因此其位数为 16+12 = 28；或直接可得 20+3+5 = 28。\n​    （2） TLB 采用全相联映射，可以把页表内容调入任一块空 TLB 项中， TLB 中每项都有一个比较器，没有映射规则，只要空闲就行。 TLB 采用静态存储器 SRAM，读写速度快，但成本高，多用于容量较小的高速缓冲存器。\n​    （3）图中可以看到， Cache 中每组有两行，故采用 2 路组相联映射方式。\n​        因为是 2 路组相联并采用 LRU 替换算法，所以每行（或每组）需要 1 位 LRU 位；因为采用回写策略，所以每行有 1 位修改位（脏位），根据脏位判断数据是否被更新，如果脏位为 1 则需要写回内存。\n​        28 位物理地址中 Tag 字段占 20 位，组索引字段占 3 位，块内偏移地址占 5 位，故 Cache 共有 23 = 8组，每组 2 行，每行有 25 = 32B；故 Cache 总容量为 8×2×(20+1+1+1+32×8) = 4464 位 = 558 字节。\n​        Cache 中有效位用来指出所在 Cache 行中的信息是否有效。\n​    （4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。\n​        利用虚拟地址的虚页号部分去查找 TLB 表（缺失时从页表调入），将实页号取出后和虚拟地址的页内地址拼接，就形成了物理地址。\n​        虚页号 008CH 恰好在 TLB 表中对应实页号 0040H（有效位为 1，说明存在），虚拟地址的后 3 位为页内地址 040H，则对应的物理地址是 0040040H。物理地址为 0040040H，其中高 20 位 00400H 为标志字段，低 5 位 00000B 为块内偏移量，中间 3 位 010B 为组号 2，因此将 00400H 与 Cache 中的第 2 组两行中的标志字段同时比较，可以看出，虽然有一个 Cache 行中的标志字段与 00400H 相等，但对应的有效位为 0，而另一 Cache 行的标志字段与 00400H 不相等，故访问 Cache 不命中。\n​        因为物理地址的低 12 位与虚拟地址低 12 位相同，即为 0010 0110 0000B。根据物理地址的结构，物理地址的后八位 01100000B 的前三位 011B 是组号，因此该地址所在的主存映射到 Cache 组号为 3。 \n\n【2020真题】假定主存地址为 32 位，按字节编址，指令 Cache 和数据 Cache 与主存之间均采用 8 路组相联映射方式，直写（WriteThrough）写策略和 LRU 替换算法，主存块大小为 64B，数据区容量各为 32KB。开始时 Cache 均为空。请回答下列问题。(1) Cache 每一行中标记（Tag）、LRU 位各占几位？是否有修改位？(2) 有如下 C 语言程序段:\n\n12for (k=0; k&lt;1024 ;k++)    s[k]=2*s[k];\n​        若数组 s 及其变量 k 均为 int 型，int 型数据占 4B，变量 k 分配在寄存器中，数组 s 在主存中的起始地址为0080 00C0H，则该程序段执行过程中，访问数组 s 的数据 Cache 缺失次数为多少？\n​        (3) 若 CPU 最先开始的访问操作是选取主存单元 0001 0003H 中的指令，简要说明从 Cache 中访问该指令的过程，包括 Cache 缺失处理过程。\n​        答案：\n​    （1）主存块大小为 64B=26 字节，故主存地址低 6 位为块内地址， Cache 组数为 32KB/(64B×8) = 64=26， 故主存地址中间 6 位为 Cache 组号， 主存地址中高 32-6-6=20 位为标记；\n​        采用 8 路组相联映射， 故每行中 LRU 位占 3 位；\n​        采用直写方式，故没有修改位。\n​    （2）因为数组s的起始地址最后 6 位全为 0， 故 s 位于一个主存块开始处，共占 1024×4B/64B=64 个主存块；\n​        执行程序段过程中，每个主存块中的 64B/4B=16 个数组元素依次读、写 1 次， 因而对于每个主存块，总是第一次访问缺失，以后每次命中。\n​        综上， 数组 s 的数据 Cache 访问缺失次数为 64 次。（3） 0001 0003H = 0000 0000 0000 0001 0000  000000  000011B， 根据主存地址划分可知，组索引为 0， 故该地址所在主存块被映射到指令 Cache 第 0 组； \n​        因为 Cache 初始为空，所有 Cache 行的有效位均为 0， 所以 Cache 访问缺失。此时，将该主存块取出后存入指令 Cache 第 0 组的任意一行，并将主存地址高 20 位（00010H）填人该行标记字段，设置有效位，修改 LRU 位， 最后根据块内地址 000011B 从该行中取出相应内容。\n\n【2021真题】假设计算机 M 的主存地址为 24 位，按字节编址；采用分页存储管理方式，虚拟地址为 30 位,页大小为 4 KB；TLB 采用 2 路组相联方式和 LRU 替换策略，共 8 组。请回答下列问题。\n\n​        (1) 虚拟地址中哪几位表示虚页号？哪几位表示页内地址？\n​        (2) 已知访问 TLB 时虚页号高位部分用作 TLB 标记，低位部分用作 TLB 组号，M 的虚拟地址中哪几位是 TLB 标记？哪几位是 TLB 组号？\n​        (3) 假设 TLB 初始时为空，访问的虚页号依次为 10、12、16、7、26、4、12 和 20，在此过程中，哪一个虚页号对应的 TLB 表项被替换？说明理由。\n​        (4) 若将 M 中的虚拟地址位数增加到 32 位，则 TLB 表项的位数增加几位？\n​        答案：\n​        注意：对于本题的 TLB，需要采用处理 Cache 的方式求解。\n​    （1）按字节编址， 页面大小为 4 KB=212B，所以页内地址为 12 位。 虚拟地址中高 30-12=18 位表示虚页号， 虚拟地址中低 12 位表示页内地址。\n​    （2）TLB 采用 2 路组相联方式，共 8=23 组，用 3 位来 标记组号。 虚拟地址（或虚页号）中高18-3=15 位为 TLB 标记， 虚拟地址中随后 3 位（或虚页号中低 3 位）为 TLB 组号。\n​    （3）虚页号 4 对应的 TLB 表项被替换。 因为虚页号与 TLB 组号的映射关系为\n​                        TLB 组号＝虚页号 mod TLB 组数＝虚页号 mod 8, \n​        因此，虚页号 10,12,16, 7,26,4,12,20 映射到的 TLB 组号依次为 2,4,0,7,2,4,4,4。\n​        TLB 采用 2 路组相联方式， 从上述映射到的TLB 组号序列可以看出，只有映射到 4 号组的虚页号数量大于 2, 相应虚页号依次是 12,4,12 和 20。根据 LRU 替换策略， 当访问第 20 页时， 虚页号 4 对应的TLB 表项被替换出来。\n​    （4）虚拟地址位数增加到 32 位时， 虚页号增加了 32-30=2 位， 使得每个TLB 表项中的标记字段增加 2 位， 因此，每个TLB 表项的位数增加 2 位。\n","slug":"计算机组成原理","date":"2024-05-31T16:00:00.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"},{"id":"eebf5774c100175fb47d65de16ffd14d","title":"个人搭建方法","content":"简介主要用于知识整理与分享，希望有用\n\n","slug":"intro","date":"2024-05-29T09:41:59.000Z","categories_index":"","tags_index":"个人","author_index":"Gueason"}]