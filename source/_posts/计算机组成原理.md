---
title: 计算机组成原理
date: 2024-05-29 17:39:27
tags: 个人
typora-root-url: ..
---



## 第一章 计算机系统概述

### 1.1 本章大纲要求与核心考点

#### 1.1.1 大纲内容

(一) 计算机系统层次结构

1. 计算机系统的基本组成

2. 计算机硬件的基本结构

3. 计算机软件和硬件的关系

4. 计算机系统的工作原理

   “存储程序"工作方式，高级语言程序与机器语言程序之间的转换,程序和指令的执行过程。

(二) 计算机性能指标

​		吞吐量、响应时间；

​		CPU时钟周期、主频、CPI、CPU执行时间；

​		MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。

####  真题分布

  <table style="text-align:center">
      <tr>
          <th rowspan="2">考点</th>
          <th colspan="2">考查次数</th>
      </tr>
      <tr>
          <th>单项选择题</th>
          <th>综合应用题</th>
      </tr>
      <tr>
          <td>计算机系统层次结构</td>
          <td>6</td>
          <td>0</td>
      </tr>
      <tr>
          <td>计算机性能指标</td>
          <td>9</td>
          <td>2</td>
      </tr>
  </table>


***

### 1.2 计算机系统简介

#### 1.2.1 计算机系统的概念和分类

​        计算机系统由“硬件”和“软件”两大部分组成。

- “硬件”，指计算机的实体部分，它由各种电子元器件、各类光、电、机设备的实物组成，如主机、外设等。

- “软件”，由人们事先编制成具有各类特殊功能的信息组成。通常把这些信息，诸如各类程序寄寓于各类媒体中， 如RAM、ROM、磁带、磁盘、光盘等。

​        计算机的软件通常又可以分为两大类：系统软件和应用软件。

- 系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，确保高效运行。它包括：标准程序库、语言处理程序(如将汇编语言翻译成机器语言的汇编程序；将高级语言翻译成机器语言的编译程序)、操作系统(如批处理系统、分时系统、实时系统)、服务性程序(如诊断程序、调试程序、连接程序等)、数据库管理系统、网络软件等等。
- 应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序。如科学计算程序，数据处理程序，过程控制程序，事务管理程序等等。

#### 1.2.2 计算机的发展

硬件的发展

​		1943 年，第二次世界大战进入后期，因战争的需要，美国国防部主导建造了第一台计算机ENIAC(Electronic Numerical Integrator And Computer,ENIAC)，它的全称是"用电子管组成的电子数字积分机和计算机”。

​		从此以后，计算机的发展经历了电子管、晶体管、集成电路的世代发展，体积越来越小、性能越来越强，并从军事领域迅速扩展应用到生活生产的各个行业，成为了现代信息社会不可或缺的基础设备。

<center>硬件技术对计算机更新换代的影响</center>

|  代  |   时间    |      硬件技术      | 速度（次/秒） |
| :--: | :-------: | :----------------: | :-----------: |
|  一  | 1946~1957 |       电子管       |    40, 000    |
|  二  | 1958~1964 |       晶体管       |   200, 000    |
|  三  | 1965~1971 | 中、小规模集成电路 |  1, 000, 000  |
|  四  | 1972~1977 |   大规模集成电路   | 10, 000, 000  |
|  五  | 1978~现在 |  超大规模集成电路  | 100, 000, 000 |

**摩尔定律**

​		集成电路出现之后，芯片集成度不断提高，从在一个芯片上集成成百上千个晶体管的中、小规模集成电路，逐渐发展到能集成成千上万个晶体管的大规模集成电路(LSI)和能容纳百万个以上晶体管的超大规模集成电路(VLSI)。

​		微芯片集成晶体管的数目增长非常迅速，其规律被总结为“微芯片上集成的晶体管数目每3年翻两番”，这就是所谓的“摩尔定律”。

​		摩尔定律的另一个常见表述是：每平方英寸电路板上的晶体管数量，每18个月翻一倍。

### 1.3 计算机系统的层次结构

#### 1.3.1 计算机系统的基本组成

（一） 计算机硬件

1. 冯·诺依曼计算机

​        冯·诺依曼在研究EDVAC计算机时提出了 “**存储程序**”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为**冯•诺依曼计算机**，其特点如下：

- 采用“存储程序”的工作方式。

- 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。

- 指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们。

- 指令和数据均用二进制代码表示。

- 指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。

  ![1_1_计算机基本组成](/img/1_1_计算机基本组成.png)

2. 计算机的功能部件

- 存储器：分为主存和辅存，中央处理器可以直接访问的程序和数据存放在主存中。
- 运算器：完成对信息或数据的处理和运算，如算术和逻辑运算。
- 控制器：完成对计算机各部件协同运行的指挥控制，即保证指令按预定的次序执行，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。
- 输入设备：用来输入原始数据和程序，如键盘、鼠标。
- 输岀设备：用来输出计算机的处理结果，如显示器和打印机。

​        一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器（内存）共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。

（二） 计算机软件

1. 软件的分类

​        软件按其功能分类，可分为系统软件和应用软件。

2. 三个级别的计算机语言

（1） 机器语言

​		机器语言由二进制编码组成，它是计算机唯一可以直接识别和执行的语言。

（2） 汇编语言           

​		汇编语言是用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。汇编语言程序必须经过汇编操作，转换为机器语言后，才能在计算机硬件上执行。

（3） 高级语言

​		高级语言（如C、C++、Java等）程序需要先经过编译程序编译成汇编语言程序，再经过汇编操作 成为机器语言程序。高级语言程序也可直接通过解释的方式“翻译”成机器语言程序。

​		由于计算机无法直接理解和执行高级语言程序，因此需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：

- 汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。
- 解释程序（解释器）：将高级语言源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。
- 编译程序（编译器）：将高级语言源程序翻译成汇编语言程序或机器语言程序。

#### 1.3.2 计算机硬件的基本结构

​		典型的冯·诺依曼计算机是以运算器为中心的，如下图所示。其中，输入、输出设备与存储器之间的数据传送都需通过运算器。图中实线为数据线，虚线为控制线和反馈线。

![1_3_典型的冯诺依曼计算机结构框图](/img/1_3_典型的冯诺依曼计算机结构框图.png)

现代的计算机已转化为以存储器为中心，如下图所示。图中实线为控制线，虚线为反馈线，双线为数据线。

![1_3_典型的冯诺依曼计算机结构框图](/img/1_3_典型的冯诺依曼计算机结构框图-17170535066181.png)

图中各部件的功能是：

* 运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内；
* 存储器用来存放数据和程序；
* 控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果；
* 输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。
* 输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。

​		由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，尤其在大规模集成电路制作工艺出现后，这两大部件往往制作在同一芯片上，因此，通常将它们合起来统称为中央处理器(Central Processing Unit) ， 简称CPU。把输入设备与输出设备简称为I/O设备(Input/Output equipment) 。

​		这样， 现代计算机可认为由三大部分组成：CPU、IO设备及主存储器(Main Memory，MM) 。CPU与主存储器合起来又可称为主机， I/O设备叫作外部设备。

![1_3_典型的冯诺依曼计算机结构框图](/img/1_3_典型的冯诺依曼计算机结构框图-17170535144652.png)

- 主存储器是存储器子系统中的一类，用来存放程序和数据， 它可以直接与CPU交换信息。另一类叫辅助存储器， 简称辅存， 又叫外存。
- ALU(Arithmetic Logic Unit) 算术逻辑运算单元，用来完成算术逻辑运算。
- CU(Control Unit) 控制单元， 用来解释存储器中的指令， 并发出各种操作命令来执行指令。

​		ALU和CU是CPU的核心部件。I/O设备也受CU控制，用来完成相应的输入、输出操作。可见，计算机有条不紊地自动工作，都是在控制器统一指挥下完成的。

#### 1.3.3 计算机系统的多级层次结构

​		从用户的角度看，人们在操作系统提供的运行环境下，首先用高级语言编写程序（称为源程序），然后将源程序翻译成汇编语言程序，再将其翻译成机器能识别的机器语言程序（称为目标程序），最后用微程序解释每条机器指令。这样，就构成一个常见的计算机系统的5级层次结构，如下图所示：

![1_3_典型的冯诺依曼计算机结构框图](/img/1_3_典型的冯诺依曼计算机结构框图-17170535209243.png)

​	从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M<sub>0</sub> 与传统机器 M<sub>1</sub>，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为**虚拟机器**，包括操作系统机器 M<sub>2</sub>、汇编语言机器 M<sub>3</sub> 和高级语言机器 M<sub>4</sub>。简单来说，虚拟机器就是由软件实现的机器。

​		相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。

#### 1.3.4 计算机系统的工作原理

##### 1. 从源程序得到可执行程序

​		用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：

![1_6_计算机系统5级层次结构](/img/1_6_计算机系统5级层次结构-17170543616504.png)

从计算机系统的5级层次结构来看，可以将硬件研究的对象归结为微程序机器 M<sub>0</sub> 与传统机器 M<sub>1</sub>，也就是实际机器。而软件研究的对象主要是操作系统及其以上的各级虚拟机器。通常将除硬件系统外的其余层级称为**虚拟机器**，包括操作系统机器 M<sub>2</sub>、汇编语言机器 M<sub>3</sub> 和高级语言机器 M<sub>4</sub>。简单来说，虚拟机器就是由软件实现的机器。

​		相邻层级之间的关系，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能可以由硬件来实现，所以软/硬件交界面的划分也不是绝对的。

#### 1.3.5 计算机系统的工作原理

##### 1. 从源程序得到可执行程序

​		用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用C语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用GCC编译器可以将它翻译成一个可执行目标程序 hello。具体的过程可以分为4个阶段，如下图所示：

![1_7_源程序转换为可执行程序的过程](/img/1_7_源程序转换为可执行程序的过程.png)

（1）预处理阶段：预处理器（cpp）对源程序中以 ”#“ 开头的命令进行处理，输出结果是一个以 ”.i“ 为扩展名的文件 hello.i。例如 ”#include“ 就会将后面的头文件内容插入程序文件中。

​	（2）编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s。汇编语言源程序中的每条语句，都用文本格式描述了一条机器语言指令。

​	（3）汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个”可重定位目标程序“ hello.o，它是一个二进制文件，用文本编辑器打开会显示乱码。

​	（4）链接阶段：链接器（ld）将多个可重定位目标程序和标准库函数合并成一个可执行目标程序。上面的例子中，链接器将 hello.o 和标准库函数 printf 所在的可重定位目标模块 printf.o 合并，生成可执行程序 hello。最终生成的可执行程序被保存在磁盘上。

##### 2. 存储程序的基本思想		

​		“存储程序”的基本思想，就是将程序和数据一样，存放在主存中；运行时通过地址访问到程序的内容，解析出对应的指令进行执行。

![1_8_存储程序的基本思想](/img/1_8_存储程序的基本思想.png)

- 程序执行前，先将第一条指令的地址存放在程序计数器（PC）中；
- 将PC的内容作为地址访问主存，取出指令；
- 在每条指令执行过程中，都需要计算下一条将执行指令的地址，并送至PC。如果当前指令是顺序执行的，则下一条指令地址是PC的内容加上当前指令的长度；如果是跳转指令，则下一条指令的地址是指定的目标地址；
- 当前指令执行完毕后，再根据PC的值作为地址访问主存，取出的是下一条将要执行的指令。

​		这样，计算机就可以周而复始地自动执行程序中的每一条指令了。

##### 3. 计算机硬件组成的细化说明

![1_9_细化的计算机组成框图](/img/1_9_细化的计算机组成框图.png)

​	（1）主存储器

​		主存储器（简称主存或内存）包括了存储体M、各种逻辑部件以及控制电路等。存储体由许多存储单元组成，每个存储单元又包含若干个存储元件；每个存储元件能存放一位二进制代码（0或者1）。这样，每个存储单元可以存储一串二进制代码，这就被称为一个”存储字“；存储字的二进制位数称为”**存储字长**“。

​		主存中的每个存储单元有一个唯一的编号，叫做存储单元的”**地址**“（Address）。主存的工作方式就是按照存储单元的地址，来实现对存储字各位的存（写入）取（读出）。这种存取方式叫做”按地址访问存储器“。

​		为了实现按地址访问的方式，主存中还必须配置两个寄存器：MAR 和 MDR。

- **MAR**（Memory Address Register，存储器地址寄存器）：用来存放想要访问的存储单元的地址，它的位数决定了能访问的存储单元的最大个数。
- **MDR**（Memory Data Register，存储器数据寄存器）：用来存放从存储体单元中取出，或者准备向存储体单元存入的数据，它的位数和存储字相等。

​	（2）运算器

​		运算器包括了一个算术逻辑单元（ALU）和最少三个寄存器。

- **ACC**： Accumulator，累加器；
- **MQ**： Multiplier-Quotient Register，乘商寄存器；
- **X**： 操作数寄存器

​		这三个寄存器在完成不同的算术运算时，所存放的操作数也各不相同。具体的情况如下表所示：

|      |    加法    |    减法    |      乘法      |     除法     |
| :--: | :--------: | :--------: | :------------: | :----------: |
| ACC  | 被加数及和 | 被减数及差 |    乘积高位    | 被除数及余数 |
|  MQ  |     ——     |     ——     | 乘数及乘积低位 |      商      |
|  X   |    加数    |    减数    |     被乘数     |     除数     |

​		不同机器的运算器结构也有所不同，有的机器用 MDR 取代 X 寄存器。

​	（3）控制器

​		控制器由控制单元（CU）和程序计数器（PC）、指令寄存器（IR）组成。

PC： Program Counter，程序计数器，用来存放当前将要执行指令的地址。它与主存的 MAR 之间之间有一条直接通路，且具有自动加1的功能，也就是可以自动形成下一条指令的地址。

IR： Instruction Register，指令寄存器，用来存放当前的指令。IR 的内容来自主存的 MDR，包含了操作码和地址码。IR 中的操作码 OP（IR）会送至 CU，可以记作 OP（IR） → CU，用来分析指令；而地址码 Ad（IR）作为操作数的地址送至存储器的 MAR，可以记作 Ad（IR） → MAR。

​		CU 是控制器的核心组件，用来分析当前指令所需完成的操作，并发出各种微操作命令序列，从而控制所有被控对象。控制器是计算机的神经中枢，由它指挥各部件自动协调地工作；完成一条指令操作，需要取指、分析和执行3个阶段。

​	（4）I/O

​		I/O 系统包括各种 I/O 设备及其相应的接口。每一种 I/O 设备都由 I/O 接口与主机联系，它接收 CU 发出的各种控制命令，并完成相应的操作。

##### 4. 计算机硬件的工作过程

​		总结一下，当计算机接收到机器语言程序后，硬件的工作过程分为以下几步：

- 把程序和数据装入主存储器；
- 从程序的起始地址运行程序；
- 按照程序的首地址从存储器中取出第一条指令，经过译码等步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址；
- 用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。每条指令都是在取指、译码和执行的循环过程中完成的。

​		我们现在以从主存中取数据的指令为例，详细分析一下它的执行过程：

​	（1）取指令： PC → MAR → M → MDR → IR

​		根据 PC 取指令到 IR。将 PC 的内容送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出指令，并通过数据线送至 MDR，再传送至 IR。

​	（2）分析指令： OP（IR） → CU

​		指令译码并送出控制信号。控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件。这里 IR 中是取数指令，所以读控制信号被送到总线的控制线上。

​	（3）执行指令：Ad（IR） → MAR → M → MDR → ACC

​		取数操作。将 IR 中指令的地址码送至 MAR，将 MAR 的内容送至地址线，同时控制器将读信号送至读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。

​	（4）每取完一条指令，还必须计算下一条指令的地址，为取下一条指令做准备：（PC）+ 1 → PC

### 1.4 计算机性能指标

#### 1.4.1 主要性能指标

1. **机器字长**

​		机器字长，是指 CPU 一次能处理数据的位数，也就是 CPU 内部用于整数运算的数据通路的宽度。字长通常就等于 CPU 的通用寄存器宽度，也就是 CPU 内用于整数运算的运算器位数，它反映了计算机处理信息的能力。我们平常所说”一台64位或32位的机器“，这里的64、32就是指字长。

​		字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短， 又要运算位数较多的数据， 那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。当然，机器字长对硬件的造价也有较大的影响。它将直接影响加法器(或ALU) 、数据总线以及存储字长的位数。

- 指令字长：一条指令中包含的二进制代码的位数。
- 存储字长：一个存储单元中存储的二进制代码的长度。

​		指令字长和存储字长，都必须是字节（Byte）的整数倍。指令字长一般取存储字长的整数倍：如果指令字长等于存储字长的2倍，那么取一条指令就需要2个机器周期；如果指令字长等于存储字长，那么取指周期就等于机器周期。

2. **数据通路带宽**

​		数据通路带宽，是指数据总线一次所能并行传送信息的位数，它关系到数据的传送能力。这里所说的数据通路带宽是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（机器字长）可能不同。

3. **存储容量**

​		存储器的容量，包括主存容量和辅存容量。我们一般主要关心主存容量。

​		主存容量是指主存中所能存储信息（二进制代码）的最大容量，通常以字节数来衡量。

​												存储容量 = 存储单元个数 × 存储字长

​		在主存储器中，MAR 的位数反映了存储单元的个数， MDR 的位数则反映了存储字的长度。例如， MAR 为16位， 表示 2<sup>16</sup> = 65536， 也就是说对应的存储体内有65536个存储单元（一般称为64K内存， 1K=1024）；而如果 MDR 为32位， 那么主存的存储容量为 2<sup>16</sup> × 32 = 2<sup>21</sup> = 2Ｍ 位（1Ｍ=2<sup>20</sup>）。

​		现代计算机中常以字节的个数来描述容量的大小，一个**字节**（Byte）被定义位8位二进制代码。所以上述存储容量是 2M 位（bit），也可用 2<sup>18 </sup>字节（Byte，简写为 B）表示，记作 2<sup>18 </sup>B 或 256KB。

​		同理，辅存容量也可用字节数来表示，例如，某机辅存（如硬盘）容量为 128 GB（1G = 1KM = 2<sup>30 </sup>）。

4. **运算速度**

​		计算机的运算速度与许多因素有关，如机器的主频、CPU 的结构、执行什么样的操作、主存本身的速度（主存速度快，取指、取数就快）等等都有关。

#### 1.5.2 专业术语解释

​	**吞吐量**：系统在单位时间内处理请求的数量，主要取决于主存的存取周期。

​	**响应时间**：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的时间。通常包括 CPU 时间（计算机执行程序的时间）和等待时间（用于磁盘访问、存储器访问、I/O操作等的时间）。

​	**主频（CPU 时钟频率）**：机器内部主时钟的频率，它是衡量机器速度的重要参数。对统一型号的计算机，主频越高，完成指令的一个步骤所用的时间越短，执行指令的速度越快。通常以赫兹（Hz）为单位。

​	**CPU 时钟周期**：节拍脉冲的宽度或周期，也就是主频的倒数，它是 CPU 中最小的时间单位。

​															**CPU 时钟周期 = 1 / 主频**

​	**CPI**：Clock cycle Per Instruction，执行一条指令所需的时钟周期数。对一个程序或一台机器来说，CPI 指的是该程序或该机器指令集中所有指令执行所需要的平均时钟周期数。

​	**CPU 执行时间**：运行一个程序所花费的时间。

​												**CPU 执行时间 = （指令数 × CPI）/ 主频**

​		对于同一个程序，CPU 的执行时间就代表了 CPU 的性能，它主要取决于三个要素：主频、CPI 和 指令数。这三者是相互制约的。不同的机器可以有不同的指令集，更改指令集可以让程序的指令数更少，但 CPI 可能就会增大；同时可能引起 CPU 结构的调整，从而造成主频的降低。

​		现在机器的运算速度，普遍采用单位时间内执行指令的平均条数来衡量，并用 MIPS（Million Instruction Per Second）作为计量单位， 即每秒执行百万条指令。比如，某机每秒能执行200万条指令， 则记作2 MIPS。

​		**MIPS**：Million Instructions Per Second，每秒执行百万条指令的数目。

​															**MIPS = 主频 /（CPI × 10<sup>6</sup>）**

​		**FLOPS**：FLoating-point Operations Per Second，每秒执行浮点运算的次数。

​		**MFLOPS**：百万次浮点运算每秒。 MFLOPS = 浮点操作次数 /（执行时间 * 10<sup>6</sup>）

​		**GFLOPS**：十亿次浮点运算每秒。 GFLOPS = 浮点操作次数 /（执行时间 * 10<sup>9</sup>）

​		**TFLOPS**：万亿次浮点运算每秒。 TFLOPS = 浮点操作次数 /（执行时间 * 10<sup>12</sup>）

​		**PFLOPS**：千万亿次浮点运算每秒。 PFLOPS = 浮点操作次数 /（执行时间 * 10<sup>15</sup>）

​		**EFLOPS**：百京次浮点运算每秒。 EFLOPS = 浮点操作次数 /（执行时间 * 10<sup>18</sup>）

​		**ZFLOPS**：十万京次浮点运算每秒。 ZFLOPS = 浮点操作次数 /（执行时间 * 10<sup>21</sup>）

​		*需要注意，在计算机中，描述存储容量、文件大小时，K、M、G、T 等数量单位通常用2的幂次表示，比如 1 KB =  2<sup>10</sup> B；而在描述速率、频率等概念时，通常用10的幂次表示，比如 1 kb/s = 10<sup>3</sup> b/s。*


### 1.5 章节练习

#### 一、单项选择题

1. 【2009真题】冯 · 诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是 （  ）。

​		A. 指令操作码的译码结果				B. 指令和数据的寻址方式

​		C. 指令周期的不同阶段					D. 指令和数据所在的数据单元

​	答案： C

2. 【2015真题】计算机硬件能够直接执行的是 （  ）。

​		I. 机器语言程序	II. 汇编语言程序	III. 硬件描述语言程序

​		A. 仅 I 			B. 仅 I、II			C. 仅 I、III			D. I、II、III

​	答案： A

3. 【2016真题】将高级语言源程序转换为机器级目标代码文件的程序是 （  ）。

​		A. 汇编程序			B. 链接程序			C. 编译程序			D. 解释程序

​	答案： C

4. 【2019真题】下列关于冯 · 诺依曼结构计算机基本思想的叙述中，错误的是 （  ）。

​		A. 程序的功能都通过中央处理器执行指令实现			B. 指令和数据都用二进制表示，形式上无差别

​		C. 指令按地址访问，数据都在指令中直接给出			D. 程序执行前，指令和数据需预先存放在存储器中

​	答案： C

5. 【2020真题】下列给出的部件中，其位数（宽度）一定与机器字长相同的是 （  ）。

​		I. ALU		II. 指令寄存器		III. 通用寄存器		IV. 浮点寄存器

​		A. 仅 I、II			B. 仅 I、III			C. 仅 II、III			D. 仅 II、III、IV

​	答案： B

6. 【2010真题】下列选项中，能缩短程序执行时间的是（  ）。

​		I. 提高 CPU 时钟频率	II. 优化数据通路结构	III. 对程序进行编译优化

​		A. 仅 I 和 II			B. 仅 I 和 III			C. 仅 II 和 III			D. I、II、III

​	答案： D

7. 【2011真题】下列选项中，描述浮点数操作速度的是（  ）。

​		A. MIPS					B. CPI					C. IPC					D. MFLOPS

​	答案： D

8. 【2012真题】假定基准程序 A 在某计算机上的运行时间为 100s，其中 90s 为 CPU 时间，其余为 I/O 时间。若 CPU 速度提高 50%，I/O 速度不变，则运行基准程序 A 所耗费的时间是 （  ）。

​		A. 55s				B. 60s				C. 65s				D. 70s

​	答案： D

9. 【2013真题】某计算机的主频为 1.2 GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示。

| 指令类型 | 所占比例 | CPI  |
| :------: | :------: | :--: |
|    A     |   50%    |  2   |
|    B     |   20%    |  3   |
|    C     |   10%    |  4   |
|    D     |   20%    |  5   |

​		该机的 MIPS 是 （  ）。

​		A. 100				B. 200				C. 400				D. 600

​	答案： C

10. 【2014真题】程序 P 在机器 M 上的执行时间是 20s，编译优化后，P 执行的指令数减少到原来的70%，而 CPI 增加到原来的1.2倍，则 P 在 M 上的执行时间是 （  ）。

​		A. 8.4s				B. 11.7s				C. 14s				D. 16.8s

​	答案： D

11. 【2017真题】假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA），主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是     （  ）。

​		A. 0.4				B. 0.625				C. 1.6				D. 2.5

​	答案： C

#### 二、综合应用题

1. 说明机器字长、指令字长、存储字长的区别和联系。

​	答案：

​		机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。

​		指令字长：一个指令字中包含二进制代码的位数。

​		存储字长：一个存储单元存储二进制代码的长度。

​		它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，如果指令字长等 于存储字长的2倍，就需要2次访存来取出一条指令，因此，取指周期为机器周期的2倍；如果指令字长等于存储字长，则取指周期等于机器周期。早期的计算机存储字长一般和机器的指令字长与数据字长相等，故访问一次主存便可以取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们都必须是字节的整数倍。

2. 用一台 40MHz 的处理器执行基准程序，它所包含的混合指令数和响应所需的时钟周期见下表。求有效的 CPI、MIPS 和程序的执行时间（程序的指令条数为 *I*）。

   |      指令类型      | CPI  | 指令混合比 |
   | :----------------: | :--: | :--------: |
   |     算术和逻辑     |  1   |    60%     |
   |        转移        |  4   |    12%     |
   | 高速缓存命中的访存 |  2   |    18%     |
   | 高速缓存失效的访存 |  8   |    10%     |

​	答案：

​		CPI 是执行一条指令所需的平均时钟周期数。本程序中包含4种指令，根据它们不同的占比，CPI 就是这4种指令的数学期望：

​						CPI = 1 × 60% + 4 × 12% + 2 × 18% + 8 × 10% = 0.6 + 0.48 + 0.36 +0.8 = 2.24

​		MIPS 是每秒执行的百万条指令数。已知时钟频率为 40MHz，也就是每秒有 40M 个时钟周期，所以：

​													MIPS = 40 × 10<sup>6</sup> /（2.24 × 10<sup>6</sup> ）≈ 17.9

​		程序的执行时间 T = 平均每条指令执行时间 × 指令条数，而平均每条指令执行的时间，就是 CPI × 时钟周期：

​						T = CPI × 时钟周期 × 指令条数 = 2.24 ×（1 / 40MHz）× *I* = 5.6 × 10<sup>-8</sup> × *I*  秒

​		

***


## 第二章 数据的表示和运算

### 2.1 本章大纲要求与核心考点

#### 2.1.1 大纲内容

（一）数制与编码

1. 进位计数制及其数据之间的相互转换
2. 定点数的表示和运算

（二）运算方法和运算电路

1. 基本运算部件：加法器、算数逻辑部件（ALU）
2. 加/减运算：补码加/减运算器，标志位的生成
3. 乘/除运算：乘/除运算的基本原理，乘法电路和除法电路的基本结构

（三）整数的表示和运算

1. 无符号整数的表示和运算
2. 有符号整数的表示和运算

（四）浮点数的表示和运算

1. 浮点数的表示：IEEE 754标准
2. 浮点数的加/减运算

#### 2.1.2 核心考点

​        本章内容是考研考察的一个重点和难点，往往会有综合应用题出现。

​        需要重点掌握的内容包括：

- 真值、机器数，定点数的表示及原理
- C 语言中的整型数据，有符号数与无符号数、不同字长整数之间的类型转换
- ALU 的基本组成，标志位的产生，定点数的运算及相关电路，溢出概念与判断方法
- IEEE 754标准浮点数的表示和特点，浮点数的加/减运算方法
- C 语言中的浮点型数据，浮点型与整型、浮点型之间的类型转换，隐式类型转换
- 数据按边界对齐方式的存储，数据按大端和小端方式存储

#### 2.1.3 真题分布

  <table style="text-align:center">
      <tr>
          <th rowspan="2">考点</th>
          <th colspan="2">考查次数</th>
      </tr>
      <tr>
          <th>单项选择题</th>
          <th>综合应用题</th>
      </tr>
      <tr>
          <td>定点数的表示与运算</td>
          <td>10</td>
          <td>8</td>
      </tr>
      <tr>
          <td>IEEE 754标准浮点数，浮点数的运算</td>
          <td>10</td>
          <td>3</td>
      </tr>
      <tr>
          <td>C语言中各种数据的转换</td>
          <td>3</td>
          <td>2</td>
      </tr>
      <tr>
          <td>数据按边界对齐方式的存储，数据按大小端方式存储</td>
          <td>4</td>
          <td>0</td>
      </tr>
  </table>





***

### 2.2 数制与编码

#### 2.2.1 进位计数制及其相互转换

**（一）进位计数制**

​		进位计数制简称“进制”，是人为定义的一种带进位的计数方法，可以用有限的数字符号表示所有的数。定义好的数字符号的个数，称为**基数**；当计数超出基数个数时，就需要向前进位。基数为n的进位计数制，就被称为“n进制”，特点是“逢n进一”。

​		下表是十进制数、二进制数、十六进制数对照表。

​		书写时，可在十六进制数后面加上“H”，如17DBH 或(17DB)<sub>16</sub>；八进制数后面加上“O”，如372O或(372)<sub>8</sub>；若在数的后面加上“B”，如10101100B，即表示此数为二进制数，或写成(10101100)<sub>2</sub>。

​										*十进制数、二进制数、八进制数、十六进制数对照表*

| 十进制数 | 二进制数 | 八进制数 | 十六进制数 | 十进制数 | 二进制数 | 八进制数 | 十六进制数 |
| :------: | :------: | :------: | :--------: | :------: | :------: | :------: | :--------: |
|    0     |  00000   |    0     |     0      |    16    |  10000   |    20    |     10     |
|    1     |  00001   |    1     |     1      |    17    |  10001   |    21    |     11     |
|    2     |  00010   |    2     |     2      |    18    |  10010   |    22    |     12     |
|    3     |  00011   |    3     |     3      |    19    |  10011   |    23    |     13     |
|    4     |  00100   |    4     |     4      |    20    |  10100   |    24    |     14     |
|    5     |  00101   |    5     |     5      |    21    |  10101   |    25    |     15     |
|    6     |  00110   |    6     |     6      |    22    |  10110   |    26    |     16     |
|    7     |  00111   |    7     |     7      |    23    |  10111   |    27    |     17     |
|    8     |  01000   |    10    |     8      |    24    |  11000   |    30    |     18     |
|    9     |  01001   |    11    |     9      |    25    |  11001   |    31    |     19     |
|    10    |  01010   |    12    |     A      |    26    |  11010   |    32    |     1A     |
|    11    |  01011   |    13    |     B      |    27    |  11011   |    33    |     1B     |
|    12    |  01100   |    14    |     C      |    28    |  11100   |    34    |     1C     |
|    13    |  01101   |    15    |     D      |    29    |  11101   |    35    |     1D     |
|    14    |  01110   |    16    |     E      |    30    |  11110   |    36    |     1E     |
|    15    |  01111   |    17    |     F      |    31    |  11111   |    37    |     1F     |

​		计算机系统为什么要采用二进制？

- 使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低。
- 二进制的1和0正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算提供了便利。
- 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

----------------------------------------

**（二）不同进制数的相互转换**

​		任意一个数 N，可以用 r 进制表示成下面的形式：

​											N =（d<sub>n-1</sub>d<sub>n-2</sub> … d<sub>1</sub>d<sub>0</sub>.d<sub>-1</sub>d<sub>-2</sub> … d<sub>-m</sub>）

​												= d<sub>n-1</sub>r<sup>n-1</sup> + d<sub>n-2</sub>r<sup>n-2</sup> + … + d<sub>1</sub>r<sup>1</sup> + d<sub>0</sub>r<sup>0</sup> + d<sub>-1</sub>r<sup>-1</sup> + d<sub>-2</sub>r<sup>-2</sup> + … + d<sub>-m</sub>r<sup>-m</sup>

​												= ∑ d<sub>i</sub>r<sup>i</sup>

​		其中，r 为**基数**；d 为系数，d<sub>i</sub> 代表第 i 位上的数，可以是 0 ~ (r-1) 中的任意一个数字；r<sup>i</sup> 叫做第 i 位上的**权值**。n、m 分别代表 N 的整数部分和小数部分的位数。

**（1）二进制和八进制、十六进制间的转换**



​		将二进制数1110011101.0010111转换为八进制数为：

​												<font size=2>左侧补0                  分界点                右侧补0</font>

​					 							  ↓                         ↓                   ↓

​												<u>001</u> <u>110</u> <u>011</u> <u>101</u> .  <u>001</u> <u>011</u> <u>100</u>

​												 1       6     3      5  .    1      3      4

​		所以 (1110011101.0010111)<sub>2</sub> = (1635.134)<sub>8</sub> ；

​		同样道理，转换为十六进制数为：

​												<u>0011</u> <u>1001</u> <u>1101</u> .  <u>0010</u> <u>1110</u>

​													3        9        D   .     2        E

​		所以 (1110011101.0010111)<sub>2</sub> = (39D.2E)<sub>16</sub> ；

- 二进制转换为八进制：每数三位就转换成对应的八进制数，位数不够则补0。
- 二进制转换为十六进制：每数四位就转换成对应的十六进制数，位数不够则补0。
- 八进制转换为二进制：每位都转换成对应的3位二进制数。
- 十六进制转换为二进制：每位都转换成对应的4位二进制数。

**（2）任意进制数转换为十进制数**

​		任意进制数的各位数码与它的权值相乘，再把乘积相加，即得到相应的十进制数。这种转换方式称为 **按权展开法**。

​		例如，将二进制数 11011.101 转换为十进制数为：

​		(11011.101)<sub>2</sub>  = 1 × 2<sup>4</sup> + 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 1 × 2<sup>1</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>-1</sup> + 0 × 2<sup>-2</sup> + 1 × 2<sup>-3</sup>

​							= 27.625

​		另一种方法是“**按基数重复相乘/除法**”，需要分整数部分和小数部分分别转换。

​		整数部分从高到低，将每一位乘以基数值、再加上后一位，进行“重复相乘”：

​		(11011)<sub>2</sub>  =  (((1 × 2 + 1) × 2 + 0 ) × 2 + 1) × 2 + 1 = 27

​		小数部分从低到高，将每一位除以基数值、再加上前一位，进行“重复相除”：

​		(0.101)<sub>2</sub>  =  ((1 ÷ 2 + 0) ÷ 2 + 1 ) ÷ 2 + 0 = 0.625

**（3）十进制数转换为二进制数**

​		将十进制数转换为二进制数，一般采用 **基数乘除法**。整数部分和小数部分分别处理，最后将整数部 分与小数部分的转换结果拼接起来。

- 整数部分的转换规则：除2取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位，商为0时结束。 （即除2取余，先余为低，后余为高）

- 小数部分的转换规则：乘2取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位，乘积为0或精度满足要求时结束。（即乘2取整，先整为高，后整为低）


​		例如，将十进制数 123.6875 转换为二进制数。

​		**整数部分：**

​		  除2得商							余数

​		2 |<u>123</u>				…				1				最低位

​		  2  |<u>61</u>			   …				1

​		   2 |<u>30</u>			   …				0

​		   2 |<u>15</u>			   …				1

​		    2  |<u>7</u>			   …				1

​		    2  |<u>3</u>			   …				1

​		    2  |<u>1</u>			   …				1				最高位

​		    2  |<u>0</u>

​		所以 (123)<sub>10</sub> = (1111011)<sub>2</sub>

​		**小数部分：**

​		  乘积取小数								乘2得积				取整数部分

​			0.6875				× 2				= 1.375						1						最高位

​			0.375				  × 2				= 0.75						   0		

​			0.75				    × 2				= 1.5						     1	

​			0.5				      × 2				 = 1								1						最低位	

​		所以 (0.6875)<sub>10</sub> = (0.1011)<sub>2</sub>

​		综合整数和小数部分，得到 (123.6875)<sub>10</sub> = (1111011.1011)<sub>2</sub>

​		另一种方法是“减权定位法”，利用记忆好的2的幂次的十进制表示，从原始数中依次减去所含最大的2的幂次，就可以快速得到对应的结果。例如，对于十进制数123：

​		十进制数				位权				转换后的结果

​			123											2<sup>6</sup>	2<sup>5</sup>	2<sup>4</sup>	2<sup>3</sup>	2<sup>2</sup>	2<sup>1</sup>	2<sup>0</sup>

​		<u>➖ 64</u>						2<sup>6</sup>				1

​			  59

​		<u>➖ 32</u>						2<sup>5</sup>						1

​			  27

​		<u>➖ 16</u>						2<sup>4</sup>								1

​			  11

​		<u>➖   8</u>						2<sup>3</sup>										1

​			    3

​		<u>➖   2</u>						2<sup>1</sup>														1

​				1

​		<u>➖   1</u>						2<sup>0</sup>																1

​				0

​		所以 (123)<sub>10</sub> = (1111011)<sub>2</sub> 

​		这种方法一般在转换很大的十进制数时比较方便。

#### 2.2.2 真值和机器数

​		在计算机中，如果不加特别的定义，用二进制存储的数都是非负数，不需要加正负号，也就是“无符号数”。

​		对有符号数而言，符号的“正”、“负”机器本身是无法识别的；不过由于“正”、“负”恰好是两种截然不同的状态，我们可以用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。

例如，一个有符号的小数：

​				+ 0.1011				在机器中表示为		0	1 0 1 1

​				-  0.1011				在机器中表示为		1	1 0 1 1

再比如，一个有符号的整数：

​				+ 1100					在机器中表示为		0	1 1 0 0

​				-  1100					在机器中表示为		1	1 1 0 0

​		把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。一旦符号数字化后，符号和数值就形成了一种新的编码。

- 真值：正、负号加某进制数绝对值的形式，即机器数所代表的实际值。
- 机器数：一个数值数据的机内编码，即符号和数值都数码化的数。常用的有原码和补码表示法等，这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。

​		在计算机中，小数点不用专门的器件表示，而是按约定的方式标出。根据小数点位置是否固定，可以分为两种方法表示小数点的存在，即**定点**表示和**浮点**表示。

​        在运算过程中，符号位和数值部分一起参加运算，符号位不作处理。

​		在现代计算机中，通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分。

#### 2.2.3 定点数及其编码表示

​		小数点固定在某一位置的数为定点数，有以下两种格式。

![2_1_两种定点数的格式](/img/2_1_两种定点数的格式.png)

当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。

​		在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。

##### 1. **无符号整数的表示**

​		当一个编码的全部二进制位均为数值位时，相当于数的绝对值，该编码表示无符号整数。在字长相同的情况下，它能表示的最大数比带符号整数大。例如，8位无符号整数的表示范围为 0 ~ 2<sup>8</sup>-1，也就是能表示的最大数为255；而8位带符号整数的最大数是127。通常，在全部是正数运算且不出现负值结果的情况下，使用无符号整数表示。例如，可用无符号整数进行地址运算，或用它来表示指针。

##### 2. **带符号数的表示**

​		最高位用来表示符号位，而不再表示数值位。

**（1）定点整数**

​        在计算机中，并没有小数点的表示，只是认为约定了小数点的位置。

​		约定小数点在有效数值部分最低位之后。数据 x = x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>…x<sub>n</sub> （其中 x<sub>0</sub> 为符号位，x<sub>1</sub> ~ x<sub>n </sub>是数值的有效部分，也称尾数），在计算机中的表示形式如图所示：

![2_2_定点整数的表示](/img/2_2_定点整数的表示.png)

**（2）定点小数**

​		约定小数点在有效数值部分最高位之前。数据 x = x<sub>0</sub>.x<sub>1</sub>x<sub>2</sub>...x<sub>n</sub>（其中 x<sub>0 </sub>为符号位，x<sub>1</sub>~x<sub>n</sub> 是尾数，x<sub>1</sub> 是最高有效位），在计算中的表示形式如下图所示：

![2_3_定点小数的表示](/img/2_3_定点小数的表示.png)

##### 3. **原码、补码、反码和移码**

1. **原码表示法**

​		用机器数的最高位表示数的符号，其余各位表示数的绝对值。纯小数的原码定义如下:

![2_4_定点小数的原码表示](/img/2_4_定点小数的原码表示.png)

式子中 x 为真值，[ x ]<sub>原</sub> 表示原码机器数。

​		类似，纯整数的原码定义如下：

![2_5_整数的原码表示](/img/2_5_整数的原码表示.png)

​	原码的性质：

- 由符号位与数的绝对值组成，符号位是0为正、1为负

- 0有 ±0 两个编码，即 [+0]<sub>原</sub> = 00000 和 [-0]<sub>原</sub> = 10000 

  

2. **补码表示法**

​		纯整数的补码定义为：

![2_6_整数的补码表示](/img/2_6_整数的补码表示.png)

​	这里 n 为整数的位数，真值 x 和补码机器数 [ x ]<sub>原</sub> 互为以 2<sup>n+1</sup> 为模的补数。如果字长为 n+1，那么补码的表示范围为 -2<sup>n</sup> ≤ x ≤ 2<sup>n</sup> - 1，比原码多表示了一个数 -2<sup>n</sup>。

​		补码的性质：

- 补码和其真值的关系：[x]<sub>补</sub> = 符号位 × 2<sup>n+1</sup> + x
- 0的编码唯一，因此整数补码比原码多1个数，表示 -2<sup>n</sup>
- 符号位参与补码加减运算，统一采用加法操作实现
- 将 [x]<sub>补 </sub>的符号位与数值位一起右移并保持原符号位的值不变，可实现除法功能

​		例如，当 x = + 1010 时（n = 4），

​		[x]<sub>补</sub> = 0, 1010

​		而当 x = - 1010 时，

​		[x]<sub>补</sub> = 2<sup>n+1</sup> + x = 100000 - 1010 = 1, 0110

​		补码和真值的转换：

- 真值转为补码：对于正数， 与原码的转换方式一样；对于负数，符号位为1，其余各位由真值“取反加1”得到。
- 补码转为真值：若符号位为0，真值为正，跟原码的转换一样；若符号位为1，真值为负，其数值部分（绝对值）各位由补码“取反加1”得到。

​		**变形补码**是采用双符号位的补码表示法，其定义为

![2_7_变形补码](/img/2_7_变形补码.png)

​        变形补码用于算术运算的ALU部件中，双符号位00表示正，11表示负，10和01表示溢出。
